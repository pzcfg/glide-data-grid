(self["webpackChunkroot"] = self["webpackChunkroot"] || []).push([[179],{

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cell.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".s1wvhs74{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1wvhs74 *,.s1wvhs74 *::before,.s1wvhs74 *::after{box-sizing:inherit;}\n.b16aqpip{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b16aqpip > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b16aqpip .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b16aqpip .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\n.d1npx1y{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGwuc3Rvcmllcy50c3giXSwibmFtZXMiOlsiLnMxd3Zoczc0IiwiLmIxNmFxcGlwIiwiLmQxbnB4MXkiXSwibWFwcGluZ3MiOiJBQThCc0JBO0FBaUNDQztBQW9FSEMiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jZWxscy9zcmMvY2VsbC5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgLy8gQHRzLW5vY2hlY2tcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIF9fU1RPUllfXyA9IFwiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcXFwiQGxpbmFyaWEvcmVhY3RcXFwiO1xcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5pbXBvcnQgeyBEYXRhRWRpdG9yLCBEYXRhRWRpdG9yUHJvcHMsIEdyaWRDZWxsS2luZCB9IGZyb20gXFxcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXFxcIjtcXG5pbXBvcnQgeyBEcm9wZG93bkNlbGwgYXMgRHJvcGRvd25SZW5kZXJlciwgdXNlRXh0cmFDZWxscyB9IGZyb20gXFxcIi5cXFwiO1xcbmltcG9ydCB0eXBlIHsgU3RhckNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL3N0YXItY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBTcGFya2xpbmVDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9zcGFya2xpbmUtY2VsbFxcXCI7XFxuaW1wb3J0IHJhbmdlIGZyb20gXFxcImxvZGFzaC9yYW5nZS5qc1xcXCI7XFxuaW1wb3J0IHVuaXEgZnJvbSBcXFwibG9kYXNoL3VuaXEuanNcXFwiO1xcbmltcG9ydCB0eXBlIHsgVGFnc0NlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL3RhZ3MtY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBVc2VyUHJvZmlsZUNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL3VzZXItcHJvZmlsZS1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IERyb3Bkb3duQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvZHJvcGRvd24tY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBBcnRpY2xlQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvYXJ0aWNsZS1jZWxsLXR5cGVzXFxcIjtcXG5pbXBvcnQgdHlwZSB7IFJhbmdlQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvcmFuZ2UtY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBTcGlubmVyQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvc3Bpbm5lci1jZWxsXFxcIjtcXG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXFxcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclxcXCI7XFxuXFxuaW1wb3J0IFxcXCJAdG9hc3QtdWkvZWRpdG9yL2Rpc3QvdG9hc3R1aS1lZGl0b3IuY3NzXFxcIjtcXG5pbXBvcnQgXFxcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvaW5kZXguY3NzXFxcIjtcXG5pbXBvcnQgdHlwZSB7IERhdGVQaWNrZXJDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9kYXRlLXBpY2tlci1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IExpbmtzQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvbGlua3MtY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBCdXR0b25DZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9idXR0b24tY2VsbFxcXCI7XFxuXFxuY29uc3QgU2ltcGxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcblxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcblxcbiAgICAqLFxcbiAgICAqOjpiZWZvcmUsXFxuICAgICo6OmFmdGVyIHtcXG4gICAgICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XFxuICAgIH1cXG5gO1xcblxcbmNvbnN0IFNpbXBsZVRoZW1lV3JhcHBlcjogUmVhY3QuRkMgPSBwID0+IHtcXG4gICAgcmV0dXJuIChcXG4gICAgICAgIDxTaW1wbGVXcmFwcGVyPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVxcXCJjb250ZW50XFxcIj57cC5jaGlsZHJlbn08L2Rpdj5cXG4gICAgICAgIDwvU2ltcGxlV3JhcHBlcj5cXG4gICAgKTtcXG59O1xcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gICAgdGl0bGU6IFxcXCJFeHRyYSBQYWNrYWdlcy9DZWxsc1xcXCIsXFxuXFxuICAgIGRlY29yYXRvcnM6IFtcXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxcbiAgICAgICAgICAgIDxTaW1wbGVUaGVtZVdyYXBwZXI+XFxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxcbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjMjc5MGI5LCAjMjA3MGE5KTtcXG4gICAgY29sb3I6IHdoaXRlO1xcblxcbiAgICBwYWRkaW5nOiAzMnB4IDQ4cHg7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGhlaWdodDogMTAwdmg7XFxuXFxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcblxcbiAgICAmID4gaDEge1xcbiAgICAgICAgZm9udC1zaXplOiA1MHB4O1xcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICAgICAgbWFyZ2luOiAwIDAgMTJweCAwO1xcbiAgICB9XFxuXFxuICAgIC5zaXplciB7XFxuICAgICAgICBmbGV4LWdyb3c6IDE7XFxuXFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG5cXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweCwgcmdiYSg5LCAzMCwgNjYsIDAuMDgpIDBweCAwcHggMHB4IDFweDtcXG5cXG4gICAgICAgIC5zaXplci1jbGlwIHtcXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xcblxcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgIH1cXG4gICAgfVxcbmA7XFxuXFxuaW50ZXJmYWNlIEJlYXV0aWZ1bFByb3BzIHtcXG4gICAgdGl0bGU6IHN0cmluZztcXG4gICAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGU7XFxufVxcblxcbmNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xcbiAgICBjb25zdCB7IHRpdGxlLCBjaGlsZHJlbiwgZGVzY3JpcHRpb24gfSA9IHA7XFxuXFxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxcbiAgICAgICAgICAgIDxoMT57dGl0bGV9PC9oMT5cXG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XFxcInNpemVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XFxcInNpemVyLWNsaXBcXFwiIHJlZj17cmVmfT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvQmVhdXRpZnVsU3R5bGU+XFxuICAgICk7XFxufTtcXG5cXG5jb25zdCBEZXNjcmlwdGlvbiA9IHN0eWxlZC5wYFxcbiAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XFxuYDtcXG5cXG5jb25zdCBkZWZhdWx0UHJvcHM6IFBhcnRpYWw8RGF0YUVkaXRvclByb3BzPiA9IHtcXG4gICAgc21vb3RoU2Nyb2xsWDogdHJ1ZSxcXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcXG4gICAgaXNEcmFnZ2FibGU6IGZhbHNlLFxcbiAgICByb3dNYXJrZXJzOiBcXFwibm9uZVxcXCIsXFxuICAgIHdpZHRoOiBcXFwiMTAwJVxcXCIsXFxufTtcXG5cXG5sZXQgbnVtOiBudW1iZXIgPSAxO1xcbmZ1bmN0aW9uIHJhbmQoKTogbnVtYmVyIHtcXG4gICAgcmV0dXJuIChudW0gPSAobnVtICogMTY4MDcpICUgMjE0NzQ4MzY0NykgLyAyMTQ3NDgzNjQ3O1xcbn1cXG5cXG5jb25zdCBwb3NzaWJsZVRhZ3MgPSBbXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkJ1Z1xcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiNmZjRkNGQzNVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkZlYXR1cmVcXFwiLFxcbiAgICAgICAgY29sb3I6IFxcXCIjMzVmOGZmMzVcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0YWc6IFxcXCJFbmhhbmNlbWVudFxcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiM0OGZmNTczNVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkZpcnN0IElzc3VlXFxcIixcXG4gICAgICAgIGNvbG9yOiBcXFwiIzQzNmZmZjM1XFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGFnOiBcXFwiUFJcXFwiLFxcbiAgICAgICAgY29sb3I6IFxcXCIjZTBmZjMyMzVcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0YWc6IFxcXCJBc3NpZ25lZFxcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiNmZjFlZWMzNVxcXCIsXFxuICAgIH0sXFxuXTtcXG5cXG5leHBvcnQgY29uc3QgQ3VzdG9tQ2VsbHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcXG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XFxcIkN1c3RvbSBjZWxsc1xcXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5Tb21lIG9mIG91ciBleHRlbnNpb24gY2VsbHMuPC9EZXNjcmlwdGlvbj59PlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XFxuICAgICAgICAgICAgICAgIHsuLi5jZWxsUHJvcHN9XFxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9eyguLi5hcmdzKSA9PiBjb25zb2xlLmxvZyhcXFwiRWRpdCBDZWxsXFxcIiwgLi4uYXJncyl9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtjZWxsID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjb2wsIHJvd10gPSBjZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcInN0YXItY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXFxcIlRlc3RcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW5nOiA0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgU3RhckNlbGw7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gcmFuZ2UoMCwgMTUpLm1hcCgoKSA9PiByYW5kKCkgKiAxMDAgLSA1MCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcInNwYXJrbGluZS1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZXM6IHZhbHVlcy5tYXAoeCA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKCkpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcXFwiIzc3YzRjNFxcXCIgOiBcXFwiI0Q5ODQ2NlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpczogWy01MCwgNTBdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgU3BhcmtsaW5lQ2VsbDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwic3BhcmtsaW5lLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByb3cgJSAyID09PSAwID8gXFxcIiM3N2M0YzRcXFwiIDogXFxcIiNEOTg0NjZcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhLaW5kOiBcXFwiYmFyXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzOiBbLTUwLCA1MF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJ0YWdzLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzOiBwb3NzaWJsZVRhZ3MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkb25seTogcm93ICUgMiA9PT0gMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHVuaXEoW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBUYWdzQ2VsbDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwidXNlci1wcm9maWxlLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHJvdyAlIDIgPyB1bmRlZmluZWQgOiBcXFwiaHR0cHM6Ly9pLnJlZGQuaXQvYXFjMWh3aGFsc3o3MS5qcGdcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbDogXFxcIkJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGludDogXFxcIiNGMUQ4NkVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93ICUgNSA/IHVuZGVmaW5lZCA6IFxcXCJCZWUgYmJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgVXNlclByb2ZpbGVDZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBEcm9wZG93bkNlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcImRyb3Bkb3duLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1xcXCJHb29kXFxcIiwgXFxcIkJldHRlclxcXCIsIFxcXCJCZXN0XFxcIl0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXFxcIkdvb2RcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogUmFuZ2VDZWxsID0ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJyYW5nZS1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMTAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IDMwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDEwICsgTWF0aC5yb3VuZCh2ICogMjApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogMSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBgJHtNYXRoLnJvdW5kKHYgKiAxMDApfSVgLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZUxhYmVsOiBcXFwiMTAwJVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA3KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogQXJ0aWNsZUNlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcImFydGljbGUtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bjogXFxcIiMjIFRoaXMgaXMgYSB0ZXN0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBTcGlubmVyQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwic3Bpbm5lci1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBEYXRlUGlja2VyQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiZGF0ZS1waWNrZXItY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogXFxcImRhdGVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMTApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBMaW5rc0NlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcImxpbmtzLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lT2Zmc2V0OiA2LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IFtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiTGlua3kgcGhvbmVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBhbGVydChcXFwiQ2xpY2sgMVxcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIkNsaWNrIHRoZSBsaW5reSBkaW5reVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGFsZXJ0KFxcXCJDbGljayAyXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IEJ1dHRvbkNlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogXFxcInBvaW50ZXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiYnV0dG9uLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXFxcInRyYW5zcGFyZW50XFxcIiwgXFxcIiM2NTcyZmZlZVxcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFtcXFwiYWNjZW50Q29sb3JcXFwiLCBcXFwiYWNjZW50RmdcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcXFwiIzY1NzJmZmEwXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogOSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiVmlldyBEZXRhaWxzXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHdpbmRvdy5hbGVydChcXFwiQnV0dG9uIGNsaWNrZWRcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWVPdmVycmlkZToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXFxcIjcwMCAxMnB4XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJGYWlsXFxcIik7XFxuICAgICAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e1tcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlN0YXJzXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlNwYXJrbGluZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJTcGFya2xpbmUgKGJhcnMpXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlRhZ3NcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiUHJvZmlsZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJEcm9wZG93blxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJSYW5nZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJBcnRpY2xlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlNwaW5uZXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiRGF0ZSBQaWNrZXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiTGlua3NcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiQnV0dG9uXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTIwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgXX1cXG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XFxuICAgICk7XFxufTtcXG4oQ3VzdG9tQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXFxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxFZGl0aW5nOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IGNlbGxQcm9wcyA9IHVzZUV4dHJhQ2VsbHMoKTtcXG5cXG4gICAgY29uc3QgZGF0YSA9IFJlYWN0LnVzZVJlZjxzdHJpbmdbXT4oW10pO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcXG4gICAgICAgICAgICB0aXRsZT1cXFwiQ3VzdG9tIGNlbGwgZWRpdGluZ1xcXCJcXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XFxuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgIENlbGxzIGNhbiBiZSBlZGl0ZWQgYW5kIHJlc3BvbmRpbmcgdG8gY29weS9wYXN0ZSB1c2luZyB0aGUgY29weURhdGEgYXR0cmlidXRlLlxcbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgIH0+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cXG4gICAgICAgICAgICAgICAgey4uLmNlbGxQcm9wc31cXG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoY2VsbCwgbmV3VmFsKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsLmtpbmQgIT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChEcm9wZG93blJlbmRlcmVyLmlzTWF0Y2gobmV3VmFsKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3VycmVudFtjZWxsWzFdXSA9IG5ld1ZhbC5kYXRhLnZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9fVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2NlbGwgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgcm93XSA9IGNlbGw7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkYXRhLmN1cnJlbnRbcm93XSA/PyBcXFwiQVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiB2YWwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiZHJvcGRvd24tY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcXFwiQVxcXCIsIFxcXCJCXFxcIiwgXFxcIkNcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbCxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBEcm9wZG93bkNlbGw7XFxuICAgICAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e1tcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIkRyb3Bkb3duXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgXX1cXG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XFxuICAgICk7XFxufTtcXG4oQ3VzdG9tQ2VsbEVkaXRpbmcgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX0xPQ0FUSU9OU19NQVBfXyA9IHtcIkN1c3RvbUNlbGxzXCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjozOCxcImxpbmVcIjoxNzB9LFwiZW5kTG9jXCI6e1wiY29sXCI6MSxcImxpbmVcIjo0MzN9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6MzgsXCJsaW5lXCI6MTcwfSxcImVuZEJvZHlcIjp7XCJjb2xcIjoxLFwibGluZVwiOjQzM319LFwiQ3VzdG9tQ2VsbEVkaXRpbmdcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjQ0LFwibGluZVwiOjQ0MH0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjQ4OH0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo0NCxcImxpbmVcIjo0NDB9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6NDg4fX19O1xuICAgIFxuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IsIERhdGFFZGl0b3JQcm9wcywgR3JpZENlbGxLaW5kIH0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgeyBEcm9wZG93bkNlbGwgYXMgRHJvcGRvd25SZW5kZXJlciwgdXNlRXh0cmFDZWxscyB9IGZyb20gXCIuXCI7XG5pbXBvcnQgdHlwZSB7IFN0YXJDZWxsIH0gZnJvbSBcIi4vY2VsbHMvc3Rhci1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IFNwYXJrbGluZUNlbGwgfSBmcm9tIFwiLi9jZWxscy9zcGFya2xpbmUtY2VsbFwiO1xuaW1wb3J0IHJhbmdlIGZyb20gXCJsb2Rhc2gvcmFuZ2UuanNcIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gvdW5pcS5qc1wiO1xuaW1wb3J0IHR5cGUgeyBUYWdzQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3RhZ3MtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBVc2VyUHJvZmlsZUNlbGwgfSBmcm9tIFwiLi9jZWxscy91c2VyLXByb2ZpbGUtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBEcm9wZG93bkNlbGwgfSBmcm9tIFwiLi9jZWxscy9kcm9wZG93bi1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IEFydGljbGVDZWxsIH0gZnJvbSBcIi4vY2VsbHMvYXJ0aWNsZS1jZWxsLXR5cGVzXCI7XG5pbXBvcnQgdHlwZSB7IFJhbmdlQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3JhbmdlLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgU3Bpbm5lckNlbGwgfSBmcm9tIFwiLi9jZWxscy9zcGlubmVyLWNlbGxcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclwiO1xuXG5pbXBvcnQgXCJAdG9hc3QtdWkvZWRpdG9yL2Rpc3QvdG9hc3R1aS1lZGl0b3IuY3NzXCI7XG5pbXBvcnQgXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2luZGV4LmNzc1wiO1xuaW1wb3J0IHR5cGUgeyBEYXRlUGlja2VyQ2VsbCB9IGZyb20gXCIuL2NlbGxzL2RhdGUtcGlja2VyLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgTGlua3NDZWxsIH0gZnJvbSBcIi4vY2VsbHMvbGlua3MtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBCdXR0b25DZWxsIH0gZnJvbSBcIi4vY2VsbHMvYnV0dG9uLWNlbGxcIjtcblxuY29uc3QgU2ltcGxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gICAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAqLFxuICAgICo6OmJlZm9yZSxcbiAgICAqOjphZnRlciB7XG4gICAgICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XG4gICAgfVxuYDtcblxuY29uc3QgU2ltcGxlVGhlbWVXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTaW1wbGVXcmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e3AuY2hpbGRyZW59PC9kaXY+XG4gICAgICAgIDwvU2ltcGxlV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge3BhcmFtZXRlcnM6IHtcInN0b3J5U291cmNlXCI6e1wic291cmNlXCI6XCJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFxcXCJAbGluYXJpYS9yZWFjdFxcXCI7XFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcXFwicmVhY3RcXFwiO1xcbmltcG9ydCB7IERhdGFFZGl0b3IsIERhdGFFZGl0b3JQcm9wcywgR3JpZENlbGxLaW5kIH0gZnJvbSBcXFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCB7IERyb3Bkb3duQ2VsbCBhcyBEcm9wZG93blJlbmRlcmVyLCB1c2VFeHRyYUNlbGxzIH0gZnJvbSBcXFwiLlxcXCI7XFxuaW1wb3J0IHR5cGUgeyBTdGFyQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvc3Rhci1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IFNwYXJrbGluZUNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL3NwYXJrbGluZS1jZWxsXFxcIjtcXG5pbXBvcnQgcmFuZ2UgZnJvbSBcXFwibG9kYXNoL3JhbmdlLmpzXFxcIjtcXG5pbXBvcnQgdW5pcSBmcm9tIFxcXCJsb2Rhc2gvdW5pcS5qc1xcXCI7XFxuaW1wb3J0IHR5cGUgeyBUYWdzQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvdGFncy1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IFVzZXJQcm9maWxlQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvdXNlci1wcm9maWxlLWNlbGxcXFwiO1xcbmltcG9ydCB0eXBlIHsgRHJvcGRvd25DZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9kcm9wZG93bi1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IEFydGljbGVDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9hcnRpY2xlLWNlbGwtdHlwZXNcXFwiO1xcbmltcG9ydCB0eXBlIHsgUmFuZ2VDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9yYW5nZS1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IFNwaW5uZXJDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9zcGlubmVyLWNlbGxcXFwiO1xcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcXFwicmVhY3QtcmVzaXplLWRldGVjdG9yXFxcIjtcXG5cXG5pbXBvcnQgXFxcIkB0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci5jc3NcXFwiO1xcbmltcG9ydCBcXFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9pbmRleC5jc3NcXFwiO1xcbmltcG9ydCB0eXBlIHsgRGF0ZVBpY2tlckNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL2RhdGUtcGlja2VyLWNlbGxcXFwiO1xcbmltcG9ydCB0eXBlIHsgTGlua3NDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9saW5rcy1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IEJ1dHRvbkNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL2J1dHRvbi1jZWxsXFxcIjtcXG5cXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcXG4gICAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuXFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuXFxuICAgICosXFxuICAgICo6OmJlZm9yZSxcXG4gICAgKjo6YWZ0ZXIge1xcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcXG4gICAgfVxcbmA7XFxuXFxuY29uc3QgU2ltcGxlVGhlbWVXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XFxcImNvbnRlbnRcXFwiPntwLmNoaWxkcmVufTwvZGl2PlxcbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxcbiAgICApO1xcbn07XFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICB0aXRsZTogXFxcIkV4dHJhIFBhY2thZ2VzL0NlbGxzXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XFxuICAgICAgICApLFxcbiAgICBdLFxcbn07XFxuXFxuY29uc3QgQmVhdXRpZnVsU3R5bGUgPSBzdHlsZWQuZGl2YFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xcbiAgICBjb2xvcjogd2hpdGU7XFxuXFxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG5cXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuXFxuICAgICYgPiBoMSB7XFxuICAgICAgICBmb250LXNpemU6IDUwcHg7XFxuICAgICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XFxuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XFxuICAgIH1cXG5cXG4gICAgLnNpemVyIHtcXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcXG5cXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcblxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xcblxcbiAgICAgICAgLnNpemVyLWNsaXAge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxuXFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuYDtcXG5cXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xcbiAgICB0aXRsZTogc3RyaW5nO1xcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcXG59XFxuXFxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XFxuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcXG5cXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XFxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxcbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXItY2xpcFxcXCIgcmVmPXtyZWZ9PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPz8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cXG4gICAgKTtcXG59O1xcblxcbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXFxuICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcXG5gO1xcblxcbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xcbiAgICBzbW9vdGhTY3JvbGxYOiB0cnVlLFxcbiAgICBzbW9vdGhTY3JvbGxZOiB0cnVlLFxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXFxuICAgIHJvd01hcmtlcnM6IFxcXCJub25lXFxcIixcXG4gICAgd2lkdGg6IFxcXCIxMDAlXFxcIixcXG59O1xcblxcbmxldCBudW06IG51bWJlciA9IDE7XFxuZnVuY3Rpb24gcmFuZCgpOiBudW1iZXIge1xcbiAgICByZXR1cm4gKG51bSA9IChudW0gKiAxNjgwNykgJSAyMTQ3NDgzNjQ3KSAvIDIxNDc0ODM2NDc7XFxufVxcblxcbmNvbnN0IHBvc3NpYmxlVGFncyA9IFtcXG4gICAge1xcbiAgICAgICAgdGFnOiBcXFwiQnVnXFxcIixcXG4gICAgICAgIGNvbG9yOiBcXFwiI2ZmNGQ0ZDM1XFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGFnOiBcXFwiRmVhdHVyZVxcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiMzNWY4ZmYzNVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkVuaGFuY2VtZW50XFxcIixcXG4gICAgICAgIGNvbG9yOiBcXFwiIzQ4ZmY1NzM1XFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGFnOiBcXFwiRmlyc3QgSXNzdWVcXFwiLFxcbiAgICAgICAgY29sb3I6IFxcXCIjNDM2ZmZmMzVcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0YWc6IFxcXCJQUlxcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiNlMGZmMzIzNVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkFzc2lnbmVkXFxcIixcXG4gICAgICAgIGNvbG9yOiBcXFwiI2ZmMWVlYzM1XFxcIixcXG4gICAgfSxcXG5dO1xcblxcbmV4cG9ydCBjb25zdCBDdXN0b21DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xcbiAgICBjb25zdCBjZWxsUHJvcHMgPSB1c2VFeHRyYUNlbGxzKCk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlciB0aXRsZT1cXFwiQ3VzdG9tIGNlbGxzXFxcIiBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPlNvbWUgb2Ygb3VyIGV4dGVuc2lvbiBjZWxscy48L0Rlc2NyaXB0aW9uPn0+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cXG4gICAgICAgICAgICAgICAgey4uLmNlbGxQcm9wc31cXG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17KC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKFxcXCJFZGl0IENlbGxcXFwiLCAuLi5hcmdzKX1cXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2NlbGwgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sID09PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwic3Rhci1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcXFwiVGVzdFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmc6IDQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTdGFyQ2VsbDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwic3BhcmtsaW5lLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlczogdmFsdWVzLm1hcCh4ID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoKSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcm93ICUgMiA9PT0gMCA/IFxcXCIjNzdjNGM0XFxcIiA6IFxcXCIjRDk4NDY2XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzOiBbLTUwLCA1MF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJzcGFya2xpbmUtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJhbmdlKDAsIDE1KS5tYXAoKCkgPT4gcmFuZCgpICogMTAwIC0gNTApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcXFwiIzc3YzRjNFxcXCIgOiBcXFwiI0Q5ODQ2NlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaEtpbmQ6IFxcXCJiYXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IFstNTAsIDUwXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFNwYXJrbGluZUNlbGw7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcInRhZ3MtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3M6IHBvc3NpYmxlVGFncyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiByb3cgJSAyID09PSAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogdW5pcShbXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFRhZ3NDZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJ1c2VyLXByb2ZpbGUtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogcm93ICUgMiA/IHVuZGVmaW5lZCA6IFxcXCJodHRwczovL2kucmVkZC5pdC9hcWMxaHdoYWxzejcxLmpwZ1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsOiBcXFwiQlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW50OiBcXFwiI0YxRDg2RVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByb3cgJSA1ID8gdW5kZWZpbmVkIDogXFxcIkJlZSBiYlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBVc2VyUHJvZmlsZUNlbGw7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERyb3Bkb3duQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiZHJvcGRvd24tY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBbXFxcIkdvb2RcXFwiLCBcXFwiQmV0dGVyXFxcIiwgXFxcIkJlc3RcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcXFwiR29vZFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA2KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBSYW5nZUNlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcInJhbmdlLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAxMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMzAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMTAgKyBNYXRoLnJvdW5kKHYgKiAyMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiAxLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGAke01hdGgucm91bmQodiAqIDEwMCl9JWAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlTGFiZWw6IFxcXCIxMDAlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBBcnRpY2xlQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiYXJ0aWNsZS1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duOiBcXFwiIyMgVGhpcyBpcyBhIHRlc3RcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IFNwaW5uZXJDZWxsID0ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJzcGlubmVyLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERhdGVQaWNrZXJDZWxsID0ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJkYXRlLXBpY2tlci1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcXFwiZGF0ZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IExpbmtzQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwibGlua3MtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmVPZmZzZXQ6IDYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rczogW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJMaW5reSBwaG9uZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGFsZXJ0KFxcXCJDbGljayAxXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiQ2xpY2sgdGhlIGxpbmt5IGRpbmt5XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoXFxcIkNsaWNrIDJcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDExKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogQnV0dG9uQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcXFwicG9pbnRlclxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJidXR0b24tY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcXFwidHJhbnNwYXJlbnRcXFwiLCBcXFwiIzY1NzJmZmVlXFxcIl0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogW1xcXCJhY2NlbnRDb2xvclxcXCIsIFxcXCJhY2NlbnRGZ1xcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFxcXCIjNjU3MmZmYTBcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJWaWV3IERldGFpbHNcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gd2luZG93LmFsZXJ0KFxcXCJCdXR0b24gY2xpY2tlZFxcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlRm9udFN0eWxlOiBcXFwiNzAwIDEycHhcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkZhaWxcXFwiKTtcXG4gICAgICAgICAgICAgICAgfX1cXG4gICAgICAgICAgICAgICAgY29sdW1ucz17W1xcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiU3RhcnNcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiU3BhcmtsaW5lXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlNwYXJrbGluZSAoYmFycylcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiVGFnc1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDI1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJQcm9maWxlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIkRyb3Bkb3duXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlJhbmdlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIkFydGljbGVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiU3Bpbm5lclxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJEYXRlIFBpY2tlclxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJMaW5rc1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJCdXR0b25cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBdfVxcbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XFxuICAgICAgICAgICAgLz5cXG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cXG4gICAgKTtcXG59O1xcbihDdXN0b21DZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXFxuICAgIH0sXFxufTtcXG5cXG5leHBvcnQgY29uc3QgQ3VzdG9tQ2VsbEVkaXRpbmc6IFJlYWN0LlZGQyA9ICgpID0+IHtcXG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xcblxcbiAgICBjb25zdCBkYXRhID0gUmVhY3QudXNlUmVmPHN0cmluZ1tdPihbXSk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxcbiAgICAgICAgICAgIHRpdGxlPVxcXCJDdXN0b20gY2VsbCBlZGl0aW5nXFxcIlxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcXG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgQ2VsbHMgY2FuIGJlIGVkaXRlZCBhbmQgcmVzcG9uZGluZyB0byBjb3B5L3Bhc3RlIHVzaW5nIHRoZSBjb3B5RGF0YSBhdHRyaWJ1dGUuXFxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XFxuICAgICAgICAgICAgfT5cXG4gICAgICAgICAgICA8RGF0YUVkaXRvclxcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxcbiAgICAgICAgICAgICAgICB7Li4uY2VsbFByb3BzfVxcbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxcbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9eyhjZWxsLCBuZXdWYWwpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwua2luZCAhPT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKERyb3Bkb3duUmVuZGVyZXIuaXNNYXRjaChuZXdWYWwpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jdXJyZW50W2NlbGxbMV1dID0gbmV3VmFsLmRhdGEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXt0cnVlfVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Y2VsbCA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCByb3ddID0gY2VsbDtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGRhdGEuY3VycmVudFtyb3ddID8/IFxcXCJBXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IHZhbCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJkcm9wZG93bi1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1xcXCJBXFxcIiwgXFxcIkJcXFwiLCBcXFwiQ1xcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB9IGFzIERyb3Bkb3duQ2VsbDtcXG4gICAgICAgICAgICAgICAgfX1cXG4gICAgICAgICAgICAgICAgY29sdW1ucz17W1xcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiRHJvcGRvd25cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBdfVxcbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XFxuICAgICAgICAgICAgLz5cXG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cXG4gICAgKTtcXG59O1xcbihDdXN0b21DZWxsRWRpdGluZyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXFxuICAgIH0sXFxufTtcXG5cIixcImxvY2F0aW9uc01hcFwiOntcImN1c3RvbS1jZWxsc1wiOntcInN0YXJ0TG9jXCI6e1wiY29sXCI6MzgsXCJsaW5lXCI6MTcwfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6NDMzfSxcInN0YXJ0Qm9keVwiOntcImNvbFwiOjM4LFwibGluZVwiOjE3MH0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjo0MzN9fSxcImN1c3RvbS1jZWxsLWVkaXRpbmdcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjQ0LFwibGluZVwiOjQ0MH0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjQ4OH0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo0NCxcImxpbmVcIjo0NDB9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6NDg4fX19fSx9LFxuICAgIHRpdGxlOiBcIkV4dHJhIFBhY2thZ2VzL0NlbGxzXCIsXG5cbiAgICBkZWNvcmF0b3JzOiBbXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8U3RvcnkgLz5cbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmID4gaDEge1xuICAgICAgICBmb250LXNpemU6IDUwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XG4gICAgfVxuXG4gICAgLnNpemVyIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxuICAgICAgICAgICAge2Rlc2NyaXB0aW9ufVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2l6ZXItY2xpcFwiIHJlZj17cmVmfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvQmVhdXRpZnVsU3R5bGU+XG4gICAgKTtcbn07XG5cbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcbmA7XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxubGV0IG51bTogbnVtYmVyID0gMTtcbmZ1bmN0aW9uIHJhbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKG51bSA9IChudW0gKiAxNjgwNykgJSAyMTQ3NDgzNjQ3KSAvIDIxNDc0ODM2NDc7XG59XG5cbmNvbnN0IHBvc3NpYmxlVGFncyA9IFtcbiAgICB7XG4gICAgICAgIHRhZzogXCJCdWdcIixcbiAgICAgICAgY29sb3I6IFwiI2ZmNGQ0ZDM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJGZWF0dXJlXCIsXG4gICAgICAgIGNvbG9yOiBcIiMzNWY4ZmYzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFwiRW5oYW5jZW1lbnRcIixcbiAgICAgICAgY29sb3I6IFwiIzQ4ZmY1NzM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJGaXJzdCBJc3N1ZVwiLFxuICAgICAgICBjb2xvcjogXCIjNDM2ZmZmMzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIlBSXCIsXG4gICAgICAgIGNvbG9yOiBcIiNlMGZmMzIzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFwiQXNzaWduZWRcIixcbiAgICAgICAgY29sb3I6IFwiI2ZmMWVlYzM1XCIsXG4gICAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBDdXN0b21DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IGNlbGxQcm9wcyA9IHVzZUV4dHJhQ2VsbHMoKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyIHRpdGxlPVwiQ3VzdG9tIGNlbGxzXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5Tb21lIG9mIG91ciBleHRlbnNpb24gY2VsbHMuPC9EZXNjcmlwdGlvbj59PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5jZWxsUHJvcHN9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17KC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKFwiRWRpdCBDZWxsXCIsIC4uLmFyZ3MpfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtjZWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2wgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzdGFyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiVGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmc6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgU3RhckNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gcmFuZ2UoMCwgMTUpLm1hcCgoKSA9PiByYW5kKCkgKiAxMDAgLSA1MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInNwYXJrbGluZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlczogdmFsdWVzLm1hcCh4ID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByb3cgJSAyID09PSAwID8gXCIjNzdjNGM0XCIgOiBcIiNEOTg0NjZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IFstNTAsIDUwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3BhcmtsaW5lLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcIiM3N2M0YzRcIiA6IFwiI0Q5ODQ2NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaEtpbmQ6IFwiYmFyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzOiBbLTUwLCA1MF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgU3BhcmtsaW5lQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidGFncy1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnczogcG9zc2libGVUYWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkb25seTogcm93ICUgMiA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogdW5pcShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3NbTWF0aC5yb3VuZChyYW5kKCkgKiAxMDAwKSAlIHBvc3NpYmxlVGFncy5sZW5ndGhdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3NbTWF0aC5yb3VuZChyYW5kKCkgKiAxMDAwKSAlIHBvc3NpYmxlVGFncy5sZW5ndGhdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgVGFnc0NlbGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInVzZXItcHJvZmlsZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiByb3cgJSAyID8gdW5kZWZpbmVkIDogXCJodHRwczovL2kucmVkZC5pdC9hcWMxaHdoYWxzejcxLmpwZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsOiBcIkJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGludDogXCIjRjFEODZFXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJvdyAlIDUgPyB1bmRlZmluZWQgOiBcIkJlZSBiYlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFVzZXJQcm9maWxlQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBEcm9wZG93bkNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJkcm9wZG93bi1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcIkdvb2RcIiwgXCJCZXR0ZXJcIiwgXCJCZXN0XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJHb29kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogUmFuZ2VDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwicmFuZ2UtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMTAgKyBNYXRoLnJvdW5kKHYgKiAyMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBgJHtNYXRoLnJvdW5kKHYgKiAxMDApfSVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlTGFiZWw6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogQXJ0aWNsZUNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJhcnRpY2xlLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd246IFwiIyMgVGhpcyBpcyBhIHRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IFNwaW5uZXJDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3Bpbm5lci1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBEYXRlUGlja2VyQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImRhdGUtcGlja2VyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBMaW5rc0NlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJsaW5rcy1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybGluZU9mZnNldDogNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJMaW5reSBwaG9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGFsZXJ0KFwiQ2xpY2sgMVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQ2xpY2sgdGhlIGxpbmt5IGRpbmt5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoXCJDbGljayAyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBCdXR0b25DZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJidXR0b24tY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcInRyYW5zcGFyZW50XCIsIFwiIzY1NzJmZmVlXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogW1wiYWNjZW50Q29sb3JcIiwgXCJhY2NlbnRGZ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzY1NzJmZmEwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogOSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiVmlldyBEZXRhaWxzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHdpbmRvdy5hbGVydChcIkJ1dHRvbiBjbGlja2VkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWVPdmVycmlkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlRm9udFN0eWxlOiBcIjcwMCAxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsXCIpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgY29sdW1ucz17W1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTdGFyc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiU3BhcmtsaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTcGFya2xpbmUgKGJhcnMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJUYWdzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJQcm9maWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJEcm9wZG93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiUmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkFydGljbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNwaW5uZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRhdGUgUGlja2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJMaW5rc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59OztcbihDdXN0b21DZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tQ2VsbEVkaXRpbmc6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCBjZWxsUHJvcHMgPSB1c2VFeHRyYUNlbGxzKCk7XG5cbiAgICBjb25zdCBkYXRhID0gUmVhY3QudXNlUmVmPHN0cmluZ1tdPihbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDdXN0b20gY2VsbCBlZGl0aW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENlbGxzIGNhbiBiZSBlZGl0ZWQgYW5kIHJlc3BvbmRpbmcgdG8gY29weS9wYXN0ZSB1c2luZyB0aGUgY29weURhdGEgYXR0cmlidXRlLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5jZWxsUHJvcHN9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9eyhjZWxsLCBuZXdWYWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbC5raW5kICE9PSBHcmlkQ2VsbEtpbmQuQ3VzdG9tKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChEcm9wZG93blJlbmRlcmVyLmlzTWF0Y2gobmV3VmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jdXJyZW50W2NlbGxbMV1dID0gbmV3VmFsLmRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXt0cnVlfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtjZWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGRhdGEuY3VycmVudFtyb3ddID8/IFwiQVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJkcm9wZG93bi1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1wiQVwiLCBcIkJcIiwgXCJDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9IGFzIERyb3Bkb3duQ2VsbDtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e1tcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRHJvcGRvd25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ3VzdG9tQ2VsbEVkaXRpbmcgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcbiJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/cells/src/cell.stories.tsx","webpack://./packages/cells/src/cell.stories.tsx"],"names":[".s1wvhs74",".b16aqpip",".d1npx1y"],"mappings":"AA8BsBA,UAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,mDAAAA,kBAAAA,CAAAA;AAiCCC,UAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,eAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,6BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA;AAoEHC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AChIpB,uu0EAAuu0E","sourcesContent":["\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\nimport { DataEditor, DataEditorProps, GridCellKind } from \\\"@glideapps/glide-data-grid\\\";\\nimport { DropdownCell as DropdownRenderer, useExtraCells } from \\\".\\\";\\nimport type { StarCell } from \\\"./cells/star-cell\\\";\\nimport type { SparklineCell } from \\\"./cells/sparkline-cell\\\";\\nimport range from \\\"lodash/range.js\\\";\\nimport uniq from \\\"lodash/uniq.js\\\";\\nimport type { TagsCell } from \\\"./cells/tags-cell\\\";\\nimport type { UserProfileCell } from \\\"./cells/user-profile-cell\\\";\\nimport type { DropdownCell } from \\\"./cells/dropdown-cell\\\";\\nimport type { ArticleCell } from \\\"./cells/article-cell-types\\\";\\nimport type { RangeCell } from \\\"./cells/range-cell\\\";\\nimport type { SpinnerCell } from \\\"./cells/spinner-cell\\\";\\nimport { useResizeDetector } from \\\"react-resize-detector\\\";\\n\\nimport \\\"@toast-ui/editor/dist/toastui-editor.css\\\";\\nimport \\\"@glideapps/glide-data-grid/dist/index.css\\\";\\nimport type { DatePickerCell } from \\\"./cells/date-picker-cell\\\";\\nimport type { LinksCell } from \\\"./cells/links-cell\\\";\\nimport type { ButtonCell } from \\\"./cells/button-cell\\\";\\n\\nconst SimpleWrapper = styled.div`\\n    text-rendering: optimizeLegibility;\\n    -webkit-font-smoothing: antialiased;\\n\\n    box-sizing: border-box;\\n\\n    *,\\n    *::before,\\n    *::after {\\n        box-sizing: inherit;\\n    }\\n`;\\n\\nconst SimpleThemeWrapper: React.FC = p => {\\n    return (\\n        <SimpleWrapper>\\n            <div className=\\\"content\\\">{p.children}</div>\\n        </SimpleWrapper>\\n    );\\n};\\n\\nexport default {\\n    title: \\\"Extra Packages/Cells\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <Story />\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst BeautifulStyle = styled.div`\\n    background-color: #2790b9;\\n    background: linear-gradient(90deg, #2790b9, #2070a9);\\n    color: white;\\n\\n    padding: 32px 48px;\\n\\n    display: flex;\\n    flex-direction: column;\\n    height: 100vh;\\n\\n    font-family: sans-serif;\\n\\n    & > h1 {\\n        font-size: 50px;\\n        font-weight: 600;\\n        flex-shrink: 0;\\n        margin: 0 0 12px 0;\\n    }\\n\\n    .sizer {\\n        flex-grow: 1;\\n\\n        background-color: white;\\n\\n        border-radius: 12px;\\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\\n\\n        .sizer-clip {\\n            border-radius: 12px;\\n            overflow: hidden;\\n            transform: translateZ(0);\\n\\n            height: 100%;\\n        }\\n    }\\n`;\\n\\ninterface BeautifulProps {\\n    title: string;\\n    description?: React.ReactNode;\\n}\\n\\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\\n    const { title, children, description } = p;\\n\\n    const { ref, width, height } = useResizeDetector();\\n\\n    return (\\n        <BeautifulStyle>\\n            <h1>{title}</h1>\\n            {description}\\n            <div className=\\\"sizer\\\">\\n                <div className=\\\"sizer-clip\\\" ref={ref}>\\n                    <div\\n                        style={{\\n                            position: \\\"relative\\\",\\n                            width: width ?? 100,\\n                            height: height ?? 100,\\n                        }}>\\n                        {children}\\n                    </div>\\n                </div>\\n            </div>\\n        </BeautifulStyle>\\n    );\\n};\\n\\nconst Description = styled.p`\\n    font-size: 18px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n`;\\n\\nconst defaultProps: Partial<DataEditorProps> = {\\n    smoothScrollX: true,\\n    smoothScrollY: true,\\n    isDraggable: false,\\n    rowMarkers: \\\"none\\\",\\n    width: \\\"100%\\\",\\n};\\n\\nlet num: number = 1;\\nfunction rand(): number {\\n    return (num = (num * 16807) % 2147483647) / 2147483647;\\n}\\n\\nconst possibleTags = [\\n    {\\n        tag: \\\"Bug\\\",\\n        color: \\\"#ff4d4d35\\\",\\n    },\\n    {\\n        tag: \\\"Feature\\\",\\n        color: \\\"#35f8ff35\\\",\\n    },\\n    {\\n        tag: \\\"Enhancement\\\",\\n        color: \\\"#48ff5735\\\",\\n    },\\n    {\\n        tag: \\\"First Issue\\\",\\n        color: \\\"#436fff35\\\",\\n    },\\n    {\\n        tag: \\\"PR\\\",\\n        color: \\\"#e0ff3235\\\",\\n    },\\n    {\\n        tag: \\\"Assigned\\\",\\n        color: \\\"#ff1eec35\\\",\\n    },\\n];\\n\\nexport const CustomCells: React.VFC = () => {\\n    const cellProps = useExtraCells();\\n\\n    return (\\n        <BeautifulWrapper title=\\\"Custom cells\\\" description={<Description>Some of our extension cells.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                {...cellProps}\\n                onPaste={true}\\n                \\n                onCellEdited={(...args) => console.log(\\\"Edit Cell\\\", ...args)}\\n                getCellContent={cell => {\\n                    const [col, row] = cell;\\n                    if (col === 0) {\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"star-cell\\\",\\n                                label: \\\"Test\\\",\\n                                rating: 4,\\n                            },\\n                        } as StarCell;\\n                    } else if (col === 1) {\\n                        num = row + 1;\\n                        const values = range(0, 15).map(() => rand() * 100 - 50);\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: false,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"sparkline-cell\\\",\\n                                values,\\n                                displayValues: values.map(x => Math.round(x).toString()),\\n                                color: row % 2 === 0 ? \\\"#77c4c4\\\" : \\\"#D98466\\\",\\n                                yAxis: [-50, 50],\\n                            },\\n                        } as SparklineCell;\\n                    } else if (col === 2) {\\n                        num = row + 1;\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: false,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"sparkline-cell\\\",\\n                                values: range(0, 15).map(() => rand() * 100 - 50),\\n                                color: row % 2 === 0 ? \\\"#77c4c4\\\" : \\\"#D98466\\\",\\n                                graphKind: \\\"bar\\\",\\n                                yAxis: [-50, 50],\\n                            },\\n                        } as SparklineCell;\\n                    } else if (col === 3) {\\n                        num = row + 1;\\n                        rand();\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"tags-cell\\\",\\n                                possibleTags: possibleTags,\\n                                readonly: row % 2 === 0,\\n                                tags: uniq([\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                ]),\\n                            },\\n                        } as TagsCell;\\n                    } else if (col === 4) {\\n                        num = row + 1;\\n                        rand();\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"user-profile-cell\\\",\\n                                image: row % 2 ? undefined : \\\"https://i.redd.it/aqc1hwhalsz71.jpg\\\",\\n                                initial: \\\"B\\\",\\n                                tint: \\\"#F1D86E\\\",\\n                                name: row % 5 ? undefined : \\\"Bee bb\\\",\\n                            },\\n                        } as UserProfileCell;\\n                    } else if (col === 5) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: DropdownCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"dropdown-cell\\\",\\n                                allowedValues: [\\\"Good\\\", \\\"Better\\\", \\\"Best\\\"],\\n                                value: \\\"Good\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 6) {\\n                        num = row + 1;\\n                        rand();\\n                        const v = rand();\\n                        const d: RangeCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"range-cell\\\",\\n                                min: 10,\\n                                max: 30,\\n                                value: 10 + Math.round(v * 20),\\n                                step: 1,\\n                                label: `${Math.round(v * 100)}%`,\\n                                measureLabel: \\\"100%\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 7) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: ArticleCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"article-cell\\\",\\n                                markdown: \\\"## This is a test\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 8) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: SpinnerCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"spinner-cell\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 9) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: DatePickerCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"date-picker-cell\\\",\\n                                date: new Date(),\\n                                displayDate: new Date().toISOString(),\\n                                format: \\\"date\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 10) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: LinksCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"links-cell\\\",\\n                                underlineOffset: 6,\\n                                links: [\\n                                    {\\n                                        title: \\\"Linky phone\\\",\\n                                        onClick: () => alert(\\\"Click 1\\\"),\\n                                    },\\n                                    {\\n                                        title: \\\"Click the linky dinky\\\",\\n                                        onClick: () => alert(\\\"Click 2\\\"),\\n                                    },\\n                                ],\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 11) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: ButtonCell = {\\n                            kind: GridCellKind.Custom,\\n                            cursor: \\\"pointer\\\",\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            readonly: true,\\n                            data: {\\n                                kind: \\\"button-cell\\\",\\n                                backgroundColor: [\\\"transparent\\\", \\\"#6572ffee\\\"],\\n                                color: [\\\"accentColor\\\", \\\"accentFg\\\"],\\n                                borderColor: \\\"#6572ffa0\\\",\\n                                borderRadius: 9,\\n                                title: \\\"View Details\\\",\\n                                onClick: () => window.alert(\\\"Button clicked\\\"),\\n                            },\\n                            themeOverride: {\\n                                baseFontStyle: \\\"700 12px\\\",\\n                            },\\n                        };\\n                        return d;\\n                    }\\n                    throw new Error(\\\"Fail\\\");\\n                }}\\n                columns={[\\n                    {\\n                        title: \\\"Stars\\\",\\n                        width: 200,\\n                    },\\n                    {\\n                        title: \\\"Sparkline\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Sparkline (bars)\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Tags\\\",\\n                        width: 250,\\n                    },\\n                    {\\n                        title: \\\"Profile\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Dropdown\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Range\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Article\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Spinner\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Date Picker\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Links\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Button\\\",\\n                        width: 120,\\n                    },\\n                ]}\\n                rows={500}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CustomCells as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const CustomCellEditing: React.VFC = () => {\\n    const cellProps = useExtraCells();\\n\\n    const data = React.useRef<string[]>([]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Custom cell editing\\\"\\n            description={\\n                <Description>\\n                    Cells can be edited and responding to copy/paste using the copyData attribute.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                {...cellProps}\\n                onPaste={true}\\n                onCellEdited={(cell, newVal) => {\\n                    if (newVal.kind !== GridCellKind.Custom) return;\\n                    if (DropdownRenderer.isMatch(newVal)) {\\n                        data.current[cell[1]] = newVal.data.value;\\n                    }\\n                }}\\n                getCellsForSelection={true}\\n                getCellContent={cell => {\\n                    const [, row] = cell;\\n                    const val = data.current[row] ?? \\\"A\\\";\\n                    return {\\n                        kind: GridCellKind.Custom,\\n                        allowOverlay: true,\\n                        copyData: val,\\n                        data: {\\n                            kind: \\\"dropdown-cell\\\",\\n                            allowedValues: [\\\"A\\\", \\\"B\\\", \\\"C\\\"],\\n                            value: val,\\n                        },\\n                    } as DropdownCell;\\n                }}\\n                columns={[\\n                    {\\n                        title: \\\"Dropdown\\\",\\n                        width: 200,\\n                    },\\n                ]}\\n                rows={500}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CustomCellEditing as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"CustomCells\":{\"startLoc\":{\"col\":38,\"line\":170},\"endLoc\":{\"col\":1,\"line\":433},\"startBody\":{\"col\":38,\"line\":170},\"endBody\":{\"col\":1,\"line\":433}},\"CustomCellEditing\":{\"startLoc\":{\"col\":44,\"line\":440},\"endLoc\":{\"col\":1,\"line\":488},\"startBody\":{\"col\":44,\"line\":440},\"endBody\":{\"col\":1,\"line\":488}}};\n    \nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { DataEditor, DataEditorProps, GridCellKind } from \"@glideapps/glide-data-grid\";\nimport { DropdownCell as DropdownRenderer, useExtraCells } from \".\";\nimport type { StarCell } from \"./cells/star-cell\";\nimport type { SparklineCell } from \"./cells/sparkline-cell\";\nimport range from \"lodash/range.js\";\nimport uniq from \"lodash/uniq.js\";\nimport type { TagsCell } from \"./cells/tags-cell\";\nimport type { UserProfileCell } from \"./cells/user-profile-cell\";\nimport type { DropdownCell } from \"./cells/dropdown-cell\";\nimport type { ArticleCell } from \"./cells/article-cell-types\";\nimport type { RangeCell } from \"./cells/range-cell\";\nimport type { SpinnerCell } from \"./cells/spinner-cell\";\nimport { useResizeDetector } from \"react-resize-detector\";\n\nimport \"@toast-ui/editor/dist/toastui-editor.css\";\nimport \"@glideapps/glide-data-grid/dist/index.css\";\nimport type { DatePickerCell } from \"./cells/date-picker-cell\";\nimport type { LinksCell } from \"./cells/links-cell\";\nimport type { ButtonCell } from \"./cells/button-cell\";\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {parameters: {\"storySource\":{\"source\":\"import { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\nimport { DataEditor, DataEditorProps, GridCellKind } from \\\"@glideapps/glide-data-grid\\\";\\nimport { DropdownCell as DropdownRenderer, useExtraCells } from \\\".\\\";\\nimport type { StarCell } from \\\"./cells/star-cell\\\";\\nimport type { SparklineCell } from \\\"./cells/sparkline-cell\\\";\\nimport range from \\\"lodash/range.js\\\";\\nimport uniq from \\\"lodash/uniq.js\\\";\\nimport type { TagsCell } from \\\"./cells/tags-cell\\\";\\nimport type { UserProfileCell } from \\\"./cells/user-profile-cell\\\";\\nimport type { DropdownCell } from \\\"./cells/dropdown-cell\\\";\\nimport type { ArticleCell } from \\\"./cells/article-cell-types\\\";\\nimport type { RangeCell } from \\\"./cells/range-cell\\\";\\nimport type { SpinnerCell } from \\\"./cells/spinner-cell\\\";\\nimport { useResizeDetector } from \\\"react-resize-detector\\\";\\n\\nimport \\\"@toast-ui/editor/dist/toastui-editor.css\\\";\\nimport \\\"@glideapps/glide-data-grid/dist/index.css\\\";\\nimport type { DatePickerCell } from \\\"./cells/date-picker-cell\\\";\\nimport type { LinksCell } from \\\"./cells/links-cell\\\";\\nimport type { ButtonCell } from \\\"./cells/button-cell\\\";\\n\\nconst SimpleWrapper = styled.div`\\n    text-rendering: optimizeLegibility;\\n    -webkit-font-smoothing: antialiased;\\n\\n    box-sizing: border-box;\\n\\n    *,\\n    *::before,\\n    *::after {\\n        box-sizing: inherit;\\n    }\\n`;\\n\\nconst SimpleThemeWrapper: React.FC = p => {\\n    return (\\n        <SimpleWrapper>\\n            <div className=\\\"content\\\">{p.children}</div>\\n        </SimpleWrapper>\\n    );\\n};\\n\\nexport default {\\n    title: \\\"Extra Packages/Cells\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <Story />\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst BeautifulStyle = styled.div`\\n    background-color: #2790b9;\\n    background: linear-gradient(90deg, #2790b9, #2070a9);\\n    color: white;\\n\\n    padding: 32px 48px;\\n\\n    display: flex;\\n    flex-direction: column;\\n    height: 100vh;\\n\\n    font-family: sans-serif;\\n\\n    & > h1 {\\n        font-size: 50px;\\n        font-weight: 600;\\n        flex-shrink: 0;\\n        margin: 0 0 12px 0;\\n    }\\n\\n    .sizer {\\n        flex-grow: 1;\\n\\n        background-color: white;\\n\\n        border-radius: 12px;\\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\\n\\n        .sizer-clip {\\n            border-radius: 12px;\\n            overflow: hidden;\\n            transform: translateZ(0);\\n\\n            height: 100%;\\n        }\\n    }\\n`;\\n\\ninterface BeautifulProps {\\n    title: string;\\n    description?: React.ReactNode;\\n}\\n\\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\\n    const { title, children, description } = p;\\n\\n    const { ref, width, height } = useResizeDetector();\\n\\n    return (\\n        <BeautifulStyle>\\n            <h1>{title}</h1>\\n            {description}\\n            <div className=\\\"sizer\\\">\\n                <div className=\\\"sizer-clip\\\" ref={ref}>\\n                    <div\\n                        style={{\\n                            position: \\\"relative\\\",\\n                            width: width ?? 100,\\n                            height: height ?? 100,\\n                        }}>\\n                        {children}\\n                    </div>\\n                </div>\\n            </div>\\n        </BeautifulStyle>\\n    );\\n};\\n\\nconst Description = styled.p`\\n    font-size: 18px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n`;\\n\\nconst defaultProps: Partial<DataEditorProps> = {\\n    smoothScrollX: true,\\n    smoothScrollY: true,\\n    isDraggable: false,\\n    rowMarkers: \\\"none\\\",\\n    width: \\\"100%\\\",\\n};\\n\\nlet num: number = 1;\\nfunction rand(): number {\\n    return (num = (num * 16807) % 2147483647) / 2147483647;\\n}\\n\\nconst possibleTags = [\\n    {\\n        tag: \\\"Bug\\\",\\n        color: \\\"#ff4d4d35\\\",\\n    },\\n    {\\n        tag: \\\"Feature\\\",\\n        color: \\\"#35f8ff35\\\",\\n    },\\n    {\\n        tag: \\\"Enhancement\\\",\\n        color: \\\"#48ff5735\\\",\\n    },\\n    {\\n        tag: \\\"First Issue\\\",\\n        color: \\\"#436fff35\\\",\\n    },\\n    {\\n        tag: \\\"PR\\\",\\n        color: \\\"#e0ff3235\\\",\\n    },\\n    {\\n        tag: \\\"Assigned\\\",\\n        color: \\\"#ff1eec35\\\",\\n    },\\n];\\n\\nexport const CustomCells: React.VFC = () => {\\n    const cellProps = useExtraCells();\\n\\n    return (\\n        <BeautifulWrapper title=\\\"Custom cells\\\" description={<Description>Some of our extension cells.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                {...cellProps}\\n                onPaste={true}\\n                \\n                onCellEdited={(...args) => console.log(\\\"Edit Cell\\\", ...args)}\\n                getCellContent={cell => {\\n                    const [col, row] = cell;\\n                    if (col === 0) {\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"star-cell\\\",\\n                                label: \\\"Test\\\",\\n                                rating: 4,\\n                            },\\n                        } as StarCell;\\n                    } else if (col === 1) {\\n                        num = row + 1;\\n                        const values = range(0, 15).map(() => rand() * 100 - 50);\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: false,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"sparkline-cell\\\",\\n                                values,\\n                                displayValues: values.map(x => Math.round(x).toString()),\\n                                color: row % 2 === 0 ? \\\"#77c4c4\\\" : \\\"#D98466\\\",\\n                                yAxis: [-50, 50],\\n                            },\\n                        } as SparklineCell;\\n                    } else if (col === 2) {\\n                        num = row + 1;\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: false,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"sparkline-cell\\\",\\n                                values: range(0, 15).map(() => rand() * 100 - 50),\\n                                color: row % 2 === 0 ? \\\"#77c4c4\\\" : \\\"#D98466\\\",\\n                                graphKind: \\\"bar\\\",\\n                                yAxis: [-50, 50],\\n                            },\\n                        } as SparklineCell;\\n                    } else if (col === 3) {\\n                        num = row + 1;\\n                        rand();\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"tags-cell\\\",\\n                                possibleTags: possibleTags,\\n                                readonly: row % 2 === 0,\\n                                tags: uniq([\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                ]),\\n                            },\\n                        } as TagsCell;\\n                    } else if (col === 4) {\\n                        num = row + 1;\\n                        rand();\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"user-profile-cell\\\",\\n                                image: row % 2 ? undefined : \\\"https://i.redd.it/aqc1hwhalsz71.jpg\\\",\\n                                initial: \\\"B\\\",\\n                                tint: \\\"#F1D86E\\\",\\n                                name: row % 5 ? undefined : \\\"Bee bb\\\",\\n                            },\\n                        } as UserProfileCell;\\n                    } else if (col === 5) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: DropdownCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"dropdown-cell\\\",\\n                                allowedValues: [\\\"Good\\\", \\\"Better\\\", \\\"Best\\\"],\\n                                value: \\\"Good\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 6) {\\n                        num = row + 1;\\n                        rand();\\n                        const v = rand();\\n                        const d: RangeCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"range-cell\\\",\\n                                min: 10,\\n                                max: 30,\\n                                value: 10 + Math.round(v * 20),\\n                                step: 1,\\n                                label: `${Math.round(v * 100)}%`,\\n                                measureLabel: \\\"100%\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 7) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: ArticleCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"article-cell\\\",\\n                                markdown: \\\"## This is a test\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 8) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: SpinnerCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"spinner-cell\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 9) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: DatePickerCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"date-picker-cell\\\",\\n                                date: new Date(),\\n                                displayDate: new Date().toISOString(),\\n                                format: \\\"date\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 10) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: LinksCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"links-cell\\\",\\n                                underlineOffset: 6,\\n                                links: [\\n                                    {\\n                                        title: \\\"Linky phone\\\",\\n                                        onClick: () => alert(\\\"Click 1\\\"),\\n                                    },\\n                                    {\\n                                        title: \\\"Click the linky dinky\\\",\\n                                        onClick: () => alert(\\\"Click 2\\\"),\\n                                    },\\n                                ],\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 11) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: ButtonCell = {\\n                            kind: GridCellKind.Custom,\\n                            cursor: \\\"pointer\\\",\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            readonly: true,\\n                            data: {\\n                                kind: \\\"button-cell\\\",\\n                                backgroundColor: [\\\"transparent\\\", \\\"#6572ffee\\\"],\\n                                color: [\\\"accentColor\\\", \\\"accentFg\\\"],\\n                                borderColor: \\\"#6572ffa0\\\",\\n                                borderRadius: 9,\\n                                title: \\\"View Details\\\",\\n                                onClick: () => window.alert(\\\"Button clicked\\\"),\\n                            },\\n                            themeOverride: {\\n                                baseFontStyle: \\\"700 12px\\\",\\n                            },\\n                        };\\n                        return d;\\n                    }\\n                    throw new Error(\\\"Fail\\\");\\n                }}\\n                columns={[\\n                    {\\n                        title: \\\"Stars\\\",\\n                        width: 200,\\n                    },\\n                    {\\n                        title: \\\"Sparkline\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Sparkline (bars)\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Tags\\\",\\n                        width: 250,\\n                    },\\n                    {\\n                        title: \\\"Profile\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Dropdown\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Range\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Article\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Spinner\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Date Picker\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Links\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Button\\\",\\n                        width: 120,\\n                    },\\n                ]}\\n                rows={500}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CustomCells as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const CustomCellEditing: React.VFC = () => {\\n    const cellProps = useExtraCells();\\n\\n    const data = React.useRef<string[]>([]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Custom cell editing\\\"\\n            description={\\n                <Description>\\n                    Cells can be edited and responding to copy/paste using the copyData attribute.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                {...cellProps}\\n                onPaste={true}\\n                onCellEdited={(cell, newVal) => {\\n                    if (newVal.kind !== GridCellKind.Custom) return;\\n                    if (DropdownRenderer.isMatch(newVal)) {\\n                        data.current[cell[1]] = newVal.data.value;\\n                    }\\n                }}\\n                getCellsForSelection={true}\\n                getCellContent={cell => {\\n                    const [, row] = cell;\\n                    const val = data.current[row] ?? \\\"A\\\";\\n                    return {\\n                        kind: GridCellKind.Custom,\\n                        allowOverlay: true,\\n                        copyData: val,\\n                        data: {\\n                            kind: \\\"dropdown-cell\\\",\\n                            allowedValues: [\\\"A\\\", \\\"B\\\", \\\"C\\\"],\\n                            value: val,\\n                        },\\n                    } as DropdownCell;\\n                }}\\n                columns={[\\n                    {\\n                        title: \\\"Dropdown\\\",\\n                        width: 200,\\n                    },\\n                ]}\\n                rows={500}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CustomCellEditing as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\",\"locationsMap\":{\"custom-cells\":{\"startLoc\":{\"col\":38,\"line\":170},\"endLoc\":{\"col\":1,\"line\":433},\"startBody\":{\"col\":38,\"line\":170},\"endBody\":{\"col\":1,\"line\":433}},\"custom-cell-editing\":{\"startLoc\":{\"col\":44,\"line\":440},\"endLoc\":{\"col\":1,\"line\":488},\"startBody\":{\"col\":44,\"line\":440},\"endBody\":{\"col\":1,\"line\":488}}}},},\n    title: \"Extra Packages/Cells\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16807) % 2147483647) / 2147483647;\n}\n\nconst possibleTags = [\n    {\n        tag: \"Bug\",\n        color: \"#ff4d4d35\",\n    },\n    {\n        tag: \"Feature\",\n        color: \"#35f8ff35\",\n    },\n    {\n        tag: \"Enhancement\",\n        color: \"#48ff5735\",\n    },\n    {\n        tag: \"First Issue\",\n        color: \"#436fff35\",\n    },\n    {\n        tag: \"PR\",\n        color: \"#e0ff3235\",\n    },\n    {\n        tag: \"Assigned\",\n        color: \"#ff1eec35\",\n    },\n];\n\nexport const CustomCells: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    return (\n        <BeautifulWrapper title=\"Custom cells\" description={<Description>Some of our extension cells.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                // eslint-disable-next-line no-console\n                onCellEdited={(...args) => console.log(\"Edit Cell\", ...args)}\n                getCellContent={cell => {\n                    const [col, row] = cell;\n                    if (col === 0) {\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"star-cell\",\n                                label: \"Test\",\n                                rating: 4,\n                            },\n                        } as StarCell;\n                    } else if (col === 1) {\n                        num = row + 1;\n                        const values = range(0, 15).map(() => rand() * 100 - 50);\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values,\n                                displayValues: values.map(x => Math.round(x).toString()),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 2) {\n                        num = row + 1;\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values: range(0, 15).map(() => rand() * 100 - 50),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                graphKind: \"bar\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 3) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"tags-cell\",\n                                possibleTags: possibleTags,\n                                readonly: row % 2 === 0,\n                                tags: uniq([\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                ]),\n                            },\n                        } as TagsCell;\n                    } else if (col === 4) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"user-profile-cell\",\n                                image: row % 2 ? undefined : \"https://i.redd.it/aqc1hwhalsz71.jpg\",\n                                initial: \"B\",\n                                tint: \"#F1D86E\",\n                                name: row % 5 ? undefined : \"Bee bb\",\n                            },\n                        } as UserProfileCell;\n                    } else if (col === 5) {\n                        num = row + 1;\n                        rand();\n                        const d: DropdownCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"dropdown-cell\",\n                                allowedValues: [\"Good\", \"Better\", \"Best\"],\n                                value: \"Good\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 6) {\n                        num = row + 1;\n                        rand();\n                        const v = rand();\n                        const d: RangeCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"range-cell\",\n                                min: 10,\n                                max: 30,\n                                value: 10 + Math.round(v * 20),\n                                step: 1,\n                                label: `${Math.round(v * 100)}%`,\n                                measureLabel: \"100%\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 7) {\n                        num = row + 1;\n                        rand();\n                        const d: ArticleCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"article-cell\",\n                                markdown: \"## This is a test\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 8) {\n                        num = row + 1;\n                        rand();\n                        const d: SpinnerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"spinner-cell\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 9) {\n                        num = row + 1;\n                        rand();\n                        const d: DatePickerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"date-picker-cell\",\n                                date: new Date(),\n                                displayDate: new Date().toISOString(),\n                                format: \"date\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 10) {\n                        num = row + 1;\n                        rand();\n                        const d: LinksCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"links-cell\",\n                                underlineOffset: 6,\n                                links: [\n                                    {\n                                        title: \"Linky phone\",\n                                        onClick: () => alert(\"Click 1\"),\n                                    },\n                                    {\n                                        title: \"Click the linky dinky\",\n                                        onClick: () => alert(\"Click 2\"),\n                                    },\n                                ],\n                            },\n                        };\n                        return d;\n                    } else if (col === 11) {\n                        num = row + 1;\n                        rand();\n                        const d: ButtonCell = {\n                            kind: GridCellKind.Custom,\n                            cursor: \"pointer\",\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            readonly: true,\n                            data: {\n                                kind: \"button-cell\",\n                                backgroundColor: [\"transparent\", \"#6572ffee\"],\n                                color: [\"accentColor\", \"accentFg\"],\n                                borderColor: \"#6572ffa0\",\n                                borderRadius: 9,\n                                title: \"View Details\",\n                                onClick: () => window.alert(\"Button clicked\"),\n                            },\n                            themeOverride: {\n                                baseFontStyle: \"700 12px\",\n                            },\n                        };\n                        return d;\n                    }\n                    throw new Error(\"Fail\");\n                }}\n                columns={[\n                    {\n                        title: \"Stars\",\n                        width: 200,\n                    },\n                    {\n                        title: \"Sparkline\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Sparkline (bars)\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Tags\",\n                        width: 250,\n                    },\n                    {\n                        title: \"Profile\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Dropdown\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Range\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Article\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Spinner\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Date Picker\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Links\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Button\",\n                        width: 120,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};;\n(CustomCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CustomCellEditing: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    const data = React.useRef<string[]>([]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Custom cell editing\"\n            description={\n                <Description>\n                    Cells can be edited and responding to copy/paste using the copyData attribute.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                onCellEdited={(cell, newVal) => {\n                    if (newVal.kind !== GridCellKind.Custom) return;\n                    if (DropdownRenderer.isMatch(newVal)) {\n                        data.current[cell[1]] = newVal.data.value;\n                    }\n                }}\n                getCellsForSelection={true}\n                getCellContent={cell => {\n                    const [, row] = cell;\n                    const val = data.current[row] ?? \"A\";\n                    return {\n                        kind: GridCellKind.Custom,\n                        allowOverlay: true,\n                        copyData: val,\n                        data: {\n                            kind: \"dropdown-cell\",\n                            allowedValues: [\"A\", \"B\", \"C\"],\n                            value: val,\n                        },\n                    } as DropdownCell;\n                }}\n                columns={[\n                    {\n                        title: \"Dropdown\",\n                        width: 200,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCellEditing as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n",".s1wvhs74{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1wvhs74 *,.s1wvhs74 *::before,.s1wvhs74 *::after{box-sizing:inherit;}\n.b16aqpip{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b16aqpip > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b16aqpip .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b16aqpip .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\n.d1npx1y{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGwuc3Rvcmllcy50c3giXSwibmFtZXMiOlsiLnMxd3Zoczc0IiwiLmIxNmFxcGlwIiwiLmQxbnB4MXkiXSwibWFwcGluZ3MiOiJBQThCc0JBO0FBaUNDQztBQW9FSEMiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jZWxscy9zcmMvY2VsbC5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgLy8gQHRzLW5vY2hlY2tcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIF9fU1RPUllfXyA9IFwiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcXFwiQGxpbmFyaWEvcmVhY3RcXFwiO1xcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5pbXBvcnQgeyBEYXRhRWRpdG9yLCBEYXRhRWRpdG9yUHJvcHMsIEdyaWRDZWxsS2luZCB9IGZyb20gXFxcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXFxcIjtcXG5pbXBvcnQgeyBEcm9wZG93bkNlbGwgYXMgRHJvcGRvd25SZW5kZXJlciwgdXNlRXh0cmFDZWxscyB9IGZyb20gXFxcIi5cXFwiO1xcbmltcG9ydCB0eXBlIHsgU3RhckNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL3N0YXItY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBTcGFya2xpbmVDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9zcGFya2xpbmUtY2VsbFxcXCI7XFxuaW1wb3J0IHJhbmdlIGZyb20gXFxcImxvZGFzaC9yYW5nZS5qc1xcXCI7XFxuaW1wb3J0IHVuaXEgZnJvbSBcXFwibG9kYXNoL3VuaXEuanNcXFwiO1xcbmltcG9ydCB0eXBlIHsgVGFnc0NlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL3RhZ3MtY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBVc2VyUHJvZmlsZUNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL3VzZXItcHJvZmlsZS1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IERyb3Bkb3duQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvZHJvcGRvd24tY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBBcnRpY2xlQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvYXJ0aWNsZS1jZWxsLXR5cGVzXFxcIjtcXG5pbXBvcnQgdHlwZSB7IFJhbmdlQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvcmFuZ2UtY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBTcGlubmVyQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvc3Bpbm5lci1jZWxsXFxcIjtcXG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXFxcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclxcXCI7XFxuXFxuaW1wb3J0IFxcXCJAdG9hc3QtdWkvZWRpdG9yL2Rpc3QvdG9hc3R1aS1lZGl0b3IuY3NzXFxcIjtcXG5pbXBvcnQgXFxcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvaW5kZXguY3NzXFxcIjtcXG5pbXBvcnQgdHlwZSB7IERhdGVQaWNrZXJDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9kYXRlLXBpY2tlci1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IExpbmtzQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvbGlua3MtY2VsbFxcXCI7XFxuaW1wb3J0IHR5cGUgeyBCdXR0b25DZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9idXR0b24tY2VsbFxcXCI7XFxuXFxuY29uc3QgU2ltcGxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcblxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcblxcbiAgICAqLFxcbiAgICAqOjpiZWZvcmUsXFxuICAgICo6OmFmdGVyIHtcXG4gICAgICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XFxuICAgIH1cXG5gO1xcblxcbmNvbnN0IFNpbXBsZVRoZW1lV3JhcHBlcjogUmVhY3QuRkMgPSBwID0+IHtcXG4gICAgcmV0dXJuIChcXG4gICAgICAgIDxTaW1wbGVXcmFwcGVyPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVxcXCJjb250ZW50XFxcIj57cC5jaGlsZHJlbn08L2Rpdj5cXG4gICAgICAgIDwvU2ltcGxlV3JhcHBlcj5cXG4gICAgKTtcXG59O1xcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gICAgdGl0bGU6IFxcXCJFeHRyYSBQYWNrYWdlcy9DZWxsc1xcXCIsXFxuXFxuICAgIGRlY29yYXRvcnM6IFtcXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxcbiAgICAgICAgICAgIDxTaW1wbGVUaGVtZVdyYXBwZXI+XFxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxcbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjMjc5MGI5LCAjMjA3MGE5KTtcXG4gICAgY29sb3I6IHdoaXRlO1xcblxcbiAgICBwYWRkaW5nOiAzMnB4IDQ4cHg7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGhlaWdodDogMTAwdmg7XFxuXFxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcblxcbiAgICAmID4gaDEge1xcbiAgICAgICAgZm9udC1zaXplOiA1MHB4O1xcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICAgICAgbWFyZ2luOiAwIDAgMTJweCAwO1xcbiAgICB9XFxuXFxuICAgIC5zaXplciB7XFxuICAgICAgICBmbGV4LWdyb3c6IDE7XFxuXFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG5cXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweCwgcmdiYSg5LCAzMCwgNjYsIDAuMDgpIDBweCAwcHggMHB4IDFweDtcXG5cXG4gICAgICAgIC5zaXplci1jbGlwIHtcXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xcblxcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgIH1cXG4gICAgfVxcbmA7XFxuXFxuaW50ZXJmYWNlIEJlYXV0aWZ1bFByb3BzIHtcXG4gICAgdGl0bGU6IHN0cmluZztcXG4gICAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGU7XFxufVxcblxcbmNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xcbiAgICBjb25zdCB7IHRpdGxlLCBjaGlsZHJlbiwgZGVzY3JpcHRpb24gfSA9IHA7XFxuXFxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxcbiAgICAgICAgICAgIDxoMT57dGl0bGV9PC9oMT5cXG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XFxcInNpemVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XFxcInNpemVyLWNsaXBcXFwiIHJlZj17cmVmfT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvQmVhdXRpZnVsU3R5bGU+XFxuICAgICk7XFxufTtcXG5cXG5jb25zdCBEZXNjcmlwdGlvbiA9IHN0eWxlZC5wYFxcbiAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XFxuYDtcXG5cXG5jb25zdCBkZWZhdWx0UHJvcHM6IFBhcnRpYWw8RGF0YUVkaXRvclByb3BzPiA9IHtcXG4gICAgc21vb3RoU2Nyb2xsWDogdHJ1ZSxcXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcXG4gICAgaXNEcmFnZ2FibGU6IGZhbHNlLFxcbiAgICByb3dNYXJrZXJzOiBcXFwibm9uZVxcXCIsXFxuICAgIHdpZHRoOiBcXFwiMTAwJVxcXCIsXFxufTtcXG5cXG5sZXQgbnVtOiBudW1iZXIgPSAxO1xcbmZ1bmN0aW9uIHJhbmQoKTogbnVtYmVyIHtcXG4gICAgcmV0dXJuIChudW0gPSAobnVtICogMTY4MDcpICUgMjE0NzQ4MzY0NykgLyAyMTQ3NDgzNjQ3O1xcbn1cXG5cXG5jb25zdCBwb3NzaWJsZVRhZ3MgPSBbXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkJ1Z1xcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiNmZjRkNGQzNVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkZlYXR1cmVcXFwiLFxcbiAgICAgICAgY29sb3I6IFxcXCIjMzVmOGZmMzVcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0YWc6IFxcXCJFbmhhbmNlbWVudFxcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiM0OGZmNTczNVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkZpcnN0IElzc3VlXFxcIixcXG4gICAgICAgIGNvbG9yOiBcXFwiIzQzNmZmZjM1XFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGFnOiBcXFwiUFJcXFwiLFxcbiAgICAgICAgY29sb3I6IFxcXCIjZTBmZjMyMzVcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0YWc6IFxcXCJBc3NpZ25lZFxcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiNmZjFlZWMzNVxcXCIsXFxuICAgIH0sXFxuXTtcXG5cXG5leHBvcnQgY29uc3QgQ3VzdG9tQ2VsbHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcXG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XFxcIkN1c3RvbSBjZWxsc1xcXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5Tb21lIG9mIG91ciBleHRlbnNpb24gY2VsbHMuPC9EZXNjcmlwdGlvbj59PlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XFxuICAgICAgICAgICAgICAgIHsuLi5jZWxsUHJvcHN9XFxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9eyguLi5hcmdzKSA9PiBjb25zb2xlLmxvZyhcXFwiRWRpdCBDZWxsXFxcIiwgLi4uYXJncyl9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtjZWxsID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjb2wsIHJvd10gPSBjZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcInN0YXItY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXFxcIlRlc3RcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW5nOiA0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgU3RhckNlbGw7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gcmFuZ2UoMCwgMTUpLm1hcCgoKSA9PiByYW5kKCkgKiAxMDAgLSA1MCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcInNwYXJrbGluZS1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZXM6IHZhbHVlcy5tYXAoeCA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKCkpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcXFwiIzc3YzRjNFxcXCIgOiBcXFwiI0Q5ODQ2NlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpczogWy01MCwgNTBdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgU3BhcmtsaW5lQ2VsbDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwic3BhcmtsaW5lLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByb3cgJSAyID09PSAwID8gXFxcIiM3N2M0YzRcXFwiIDogXFxcIiNEOTg0NjZcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhLaW5kOiBcXFwiYmFyXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzOiBbLTUwLCA1MF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJ0YWdzLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzOiBwb3NzaWJsZVRhZ3MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkb25seTogcm93ICUgMiA9PT0gMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHVuaXEoW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBUYWdzQ2VsbDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwidXNlci1wcm9maWxlLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHJvdyAlIDIgPyB1bmRlZmluZWQgOiBcXFwiaHR0cHM6Ly9pLnJlZGQuaXQvYXFjMWh3aGFsc3o3MS5qcGdcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbDogXFxcIkJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGludDogXFxcIiNGMUQ4NkVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93ICUgNSA/IHVuZGVmaW5lZCA6IFxcXCJCZWUgYmJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgVXNlclByb2ZpbGVDZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBEcm9wZG93bkNlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcImRyb3Bkb3duLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1xcXCJHb29kXFxcIiwgXFxcIkJldHRlclxcXCIsIFxcXCJCZXN0XFxcIl0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXFxcIkdvb2RcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogUmFuZ2VDZWxsID0ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJyYW5nZS1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMTAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IDMwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDEwICsgTWF0aC5yb3VuZCh2ICogMjApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogMSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBgJHtNYXRoLnJvdW5kKHYgKiAxMDApfSVgLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZUxhYmVsOiBcXFwiMTAwJVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA3KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogQXJ0aWNsZUNlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcImFydGljbGUtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bjogXFxcIiMjIFRoaXMgaXMgYSB0ZXN0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBTcGlubmVyQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwic3Bpbm5lci1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBEYXRlUGlja2VyQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiZGF0ZS1waWNrZXItY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogXFxcImRhdGVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMTApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBMaW5rc0NlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcImxpbmtzLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lT2Zmc2V0OiA2LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IFtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiTGlua3kgcGhvbmVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBhbGVydChcXFwiQ2xpY2sgMVxcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIkNsaWNrIHRoZSBsaW5reSBkaW5reVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGFsZXJ0KFxcXCJDbGljayAyXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IEJ1dHRvbkNlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogXFxcInBvaW50ZXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiYnV0dG9uLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXFxcInRyYW5zcGFyZW50XFxcIiwgXFxcIiM2NTcyZmZlZVxcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFtcXFwiYWNjZW50Q29sb3JcXFwiLCBcXFwiYWNjZW50RmdcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcXFwiIzY1NzJmZmEwXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogOSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiVmlldyBEZXRhaWxzXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHdpbmRvdy5hbGVydChcXFwiQnV0dG9uIGNsaWNrZWRcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWVPdmVycmlkZToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXFxcIjcwMCAxMnB4XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJGYWlsXFxcIik7XFxuICAgICAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e1tcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlN0YXJzXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlNwYXJrbGluZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJTcGFya2xpbmUgKGJhcnMpXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlRhZ3NcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiUHJvZmlsZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJEcm9wZG93blxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJSYW5nZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJBcnRpY2xlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlNwaW5uZXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiRGF0ZSBQaWNrZXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiTGlua3NcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiQnV0dG9uXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTIwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgXX1cXG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XFxuICAgICk7XFxufTtcXG4oQ3VzdG9tQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXFxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxFZGl0aW5nOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IGNlbGxQcm9wcyA9IHVzZUV4dHJhQ2VsbHMoKTtcXG5cXG4gICAgY29uc3QgZGF0YSA9IFJlYWN0LnVzZVJlZjxzdHJpbmdbXT4oW10pO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcXG4gICAgICAgICAgICB0aXRsZT1cXFwiQ3VzdG9tIGNlbGwgZWRpdGluZ1xcXCJcXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XFxuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgIENlbGxzIGNhbiBiZSBlZGl0ZWQgYW5kIHJlc3BvbmRpbmcgdG8gY29weS9wYXN0ZSB1c2luZyB0aGUgY29weURhdGEgYXR0cmlidXRlLlxcbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgIH0+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cXG4gICAgICAgICAgICAgICAgey4uLmNlbGxQcm9wc31cXG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoY2VsbCwgbmV3VmFsKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsLmtpbmQgIT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChEcm9wZG93blJlbmRlcmVyLmlzTWF0Y2gobmV3VmFsKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3VycmVudFtjZWxsWzFdXSA9IG5ld1ZhbC5kYXRhLnZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9fVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2NlbGwgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgcm93XSA9IGNlbGw7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkYXRhLmN1cnJlbnRbcm93XSA/PyBcXFwiQVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiB2YWwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiZHJvcGRvd24tY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcXFwiQVxcXCIsIFxcXCJCXFxcIiwgXFxcIkNcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbCxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBEcm9wZG93bkNlbGw7XFxuICAgICAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e1tcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIkRyb3Bkb3duXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgXX1cXG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XFxuICAgICk7XFxufTtcXG4oQ3VzdG9tQ2VsbEVkaXRpbmcgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX0xPQ0FUSU9OU19NQVBfXyA9IHtcIkN1c3RvbUNlbGxzXCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjozOCxcImxpbmVcIjoxNzB9LFwiZW5kTG9jXCI6e1wiY29sXCI6MSxcImxpbmVcIjo0MzN9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6MzgsXCJsaW5lXCI6MTcwfSxcImVuZEJvZHlcIjp7XCJjb2xcIjoxLFwibGluZVwiOjQzM319LFwiQ3VzdG9tQ2VsbEVkaXRpbmdcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjQ0LFwibGluZVwiOjQ0MH0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjQ4OH0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo0NCxcImxpbmVcIjo0NDB9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6NDg4fX19O1xuICAgIFxuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IsIERhdGFFZGl0b3JQcm9wcywgR3JpZENlbGxLaW5kIH0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgeyBEcm9wZG93bkNlbGwgYXMgRHJvcGRvd25SZW5kZXJlciwgdXNlRXh0cmFDZWxscyB9IGZyb20gXCIuXCI7XG5pbXBvcnQgdHlwZSB7IFN0YXJDZWxsIH0gZnJvbSBcIi4vY2VsbHMvc3Rhci1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IFNwYXJrbGluZUNlbGwgfSBmcm9tIFwiLi9jZWxscy9zcGFya2xpbmUtY2VsbFwiO1xuaW1wb3J0IHJhbmdlIGZyb20gXCJsb2Rhc2gvcmFuZ2UuanNcIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gvdW5pcS5qc1wiO1xuaW1wb3J0IHR5cGUgeyBUYWdzQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3RhZ3MtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBVc2VyUHJvZmlsZUNlbGwgfSBmcm9tIFwiLi9jZWxscy91c2VyLXByb2ZpbGUtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBEcm9wZG93bkNlbGwgfSBmcm9tIFwiLi9jZWxscy9kcm9wZG93bi1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IEFydGljbGVDZWxsIH0gZnJvbSBcIi4vY2VsbHMvYXJ0aWNsZS1jZWxsLXR5cGVzXCI7XG5pbXBvcnQgdHlwZSB7IFJhbmdlQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3JhbmdlLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgU3Bpbm5lckNlbGwgfSBmcm9tIFwiLi9jZWxscy9zcGlubmVyLWNlbGxcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclwiO1xuXG5pbXBvcnQgXCJAdG9hc3QtdWkvZWRpdG9yL2Rpc3QvdG9hc3R1aS1lZGl0b3IuY3NzXCI7XG5pbXBvcnQgXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2luZGV4LmNzc1wiO1xuaW1wb3J0IHR5cGUgeyBEYXRlUGlja2VyQ2VsbCB9IGZyb20gXCIuL2NlbGxzL2RhdGUtcGlja2VyLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgTGlua3NDZWxsIH0gZnJvbSBcIi4vY2VsbHMvbGlua3MtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBCdXR0b25DZWxsIH0gZnJvbSBcIi4vY2VsbHMvYnV0dG9uLWNlbGxcIjtcblxuY29uc3QgU2ltcGxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gICAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAqLFxuICAgICo6OmJlZm9yZSxcbiAgICAqOjphZnRlciB7XG4gICAgICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XG4gICAgfVxuYDtcblxuY29uc3QgU2ltcGxlVGhlbWVXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTaW1wbGVXcmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e3AuY2hpbGRyZW59PC9kaXY+XG4gICAgICAgIDwvU2ltcGxlV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge3BhcmFtZXRlcnM6IHtcInN0b3J5U291cmNlXCI6e1wic291cmNlXCI6XCJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFxcXCJAbGluYXJpYS9yZWFjdFxcXCI7XFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcXFwicmVhY3RcXFwiO1xcbmltcG9ydCB7IERhdGFFZGl0b3IsIERhdGFFZGl0b3JQcm9wcywgR3JpZENlbGxLaW5kIH0gZnJvbSBcXFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCB7IERyb3Bkb3duQ2VsbCBhcyBEcm9wZG93blJlbmRlcmVyLCB1c2VFeHRyYUNlbGxzIH0gZnJvbSBcXFwiLlxcXCI7XFxuaW1wb3J0IHR5cGUgeyBTdGFyQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvc3Rhci1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IFNwYXJrbGluZUNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL3NwYXJrbGluZS1jZWxsXFxcIjtcXG5pbXBvcnQgcmFuZ2UgZnJvbSBcXFwibG9kYXNoL3JhbmdlLmpzXFxcIjtcXG5pbXBvcnQgdW5pcSBmcm9tIFxcXCJsb2Rhc2gvdW5pcS5qc1xcXCI7XFxuaW1wb3J0IHR5cGUgeyBUYWdzQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvdGFncy1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IFVzZXJQcm9maWxlQ2VsbCB9IGZyb20gXFxcIi4vY2VsbHMvdXNlci1wcm9maWxlLWNlbGxcXFwiO1xcbmltcG9ydCB0eXBlIHsgRHJvcGRvd25DZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9kcm9wZG93bi1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IEFydGljbGVDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9hcnRpY2xlLWNlbGwtdHlwZXNcXFwiO1xcbmltcG9ydCB0eXBlIHsgUmFuZ2VDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9yYW5nZS1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IFNwaW5uZXJDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9zcGlubmVyLWNlbGxcXFwiO1xcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcXFwicmVhY3QtcmVzaXplLWRldGVjdG9yXFxcIjtcXG5cXG5pbXBvcnQgXFxcIkB0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci5jc3NcXFwiO1xcbmltcG9ydCBcXFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9pbmRleC5jc3NcXFwiO1xcbmltcG9ydCB0eXBlIHsgRGF0ZVBpY2tlckNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL2RhdGUtcGlja2VyLWNlbGxcXFwiO1xcbmltcG9ydCB0eXBlIHsgTGlua3NDZWxsIH0gZnJvbSBcXFwiLi9jZWxscy9saW5rcy1jZWxsXFxcIjtcXG5pbXBvcnQgdHlwZSB7IEJ1dHRvbkNlbGwgfSBmcm9tIFxcXCIuL2NlbGxzL2J1dHRvbi1jZWxsXFxcIjtcXG5cXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcXG4gICAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuXFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuXFxuICAgICosXFxuICAgICo6OmJlZm9yZSxcXG4gICAgKjo6YWZ0ZXIge1xcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcXG4gICAgfVxcbmA7XFxuXFxuY29uc3QgU2ltcGxlVGhlbWVXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XFxcImNvbnRlbnRcXFwiPntwLmNoaWxkcmVufTwvZGl2PlxcbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxcbiAgICApO1xcbn07XFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICB0aXRsZTogXFxcIkV4dHJhIFBhY2thZ2VzL0NlbGxzXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XFxuICAgICAgICApLFxcbiAgICBdLFxcbn07XFxuXFxuY29uc3QgQmVhdXRpZnVsU3R5bGUgPSBzdHlsZWQuZGl2YFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xcbiAgICBjb2xvcjogd2hpdGU7XFxuXFxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG5cXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuXFxuICAgICYgPiBoMSB7XFxuICAgICAgICBmb250LXNpemU6IDUwcHg7XFxuICAgICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XFxuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XFxuICAgIH1cXG5cXG4gICAgLnNpemVyIHtcXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcXG5cXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcblxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xcblxcbiAgICAgICAgLnNpemVyLWNsaXAge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxuXFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuYDtcXG5cXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xcbiAgICB0aXRsZTogc3RyaW5nO1xcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcXG59XFxuXFxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XFxuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcXG5cXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XFxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxcbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXItY2xpcFxcXCIgcmVmPXtyZWZ9PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPz8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cXG4gICAgKTtcXG59O1xcblxcbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXFxuICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcXG5gO1xcblxcbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xcbiAgICBzbW9vdGhTY3JvbGxYOiB0cnVlLFxcbiAgICBzbW9vdGhTY3JvbGxZOiB0cnVlLFxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXFxuICAgIHJvd01hcmtlcnM6IFxcXCJub25lXFxcIixcXG4gICAgd2lkdGg6IFxcXCIxMDAlXFxcIixcXG59O1xcblxcbmxldCBudW06IG51bWJlciA9IDE7XFxuZnVuY3Rpb24gcmFuZCgpOiBudW1iZXIge1xcbiAgICByZXR1cm4gKG51bSA9IChudW0gKiAxNjgwNykgJSAyMTQ3NDgzNjQ3KSAvIDIxNDc0ODM2NDc7XFxufVxcblxcbmNvbnN0IHBvc3NpYmxlVGFncyA9IFtcXG4gICAge1xcbiAgICAgICAgdGFnOiBcXFwiQnVnXFxcIixcXG4gICAgICAgIGNvbG9yOiBcXFwiI2ZmNGQ0ZDM1XFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGFnOiBcXFwiRmVhdHVyZVxcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiMzNWY4ZmYzNVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkVuaGFuY2VtZW50XFxcIixcXG4gICAgICAgIGNvbG9yOiBcXFwiIzQ4ZmY1NzM1XFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGFnOiBcXFwiRmlyc3QgSXNzdWVcXFwiLFxcbiAgICAgICAgY29sb3I6IFxcXCIjNDM2ZmZmMzVcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0YWc6IFxcXCJQUlxcXCIsXFxuICAgICAgICBjb2xvcjogXFxcIiNlMGZmMzIzNVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRhZzogXFxcIkFzc2lnbmVkXFxcIixcXG4gICAgICAgIGNvbG9yOiBcXFwiI2ZmMWVlYzM1XFxcIixcXG4gICAgfSxcXG5dO1xcblxcbmV4cG9ydCBjb25zdCBDdXN0b21DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xcbiAgICBjb25zdCBjZWxsUHJvcHMgPSB1c2VFeHRyYUNlbGxzKCk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlciB0aXRsZT1cXFwiQ3VzdG9tIGNlbGxzXFxcIiBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPlNvbWUgb2Ygb3VyIGV4dGVuc2lvbiBjZWxscy48L0Rlc2NyaXB0aW9uPn0+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cXG4gICAgICAgICAgICAgICAgey4uLmNlbGxQcm9wc31cXG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17KC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKFxcXCJFZGl0IENlbGxcXFwiLCAuLi5hcmdzKX1cXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2NlbGwgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sID09PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwic3Rhci1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcXFwiVGVzdFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmc6IDQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTdGFyQ2VsbDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwic3BhcmtsaW5lLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlczogdmFsdWVzLm1hcCh4ID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoKSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcm93ICUgMiA9PT0gMCA/IFxcXCIjNzdjNGM0XFxcIiA6IFxcXCIjRDk4NDY2XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzOiBbLTUwLCA1MF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJzcGFya2xpbmUtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJhbmdlKDAsIDE1KS5tYXAoKCkgPT4gcmFuZCgpICogMTAwIC0gNTApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcXFwiIzc3YzRjNFxcXCIgOiBcXFwiI0Q5ODQ2NlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaEtpbmQ6IFxcXCJiYXJcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IFstNTAsIDUwXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFNwYXJrbGluZUNlbGw7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcInRhZ3MtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3M6IHBvc3NpYmxlVGFncyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiByb3cgJSAyID09PSAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogdW5pcShbXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFRhZ3NDZWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJ1c2VyLXByb2ZpbGUtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogcm93ICUgMiA/IHVuZGVmaW5lZCA6IFxcXCJodHRwczovL2kucmVkZC5pdC9hcWMxaHdoYWxzejcxLmpwZ1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsOiBcXFwiQlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW50OiBcXFwiI0YxRDg2RVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByb3cgJSA1ID8gdW5kZWZpbmVkIDogXFxcIkJlZSBiYlxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBVc2VyUHJvZmlsZUNlbGw7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERyb3Bkb3duQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiZHJvcGRvd24tY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBbXFxcIkdvb2RcXFwiLCBcXFwiQmV0dGVyXFxcIiwgXFxcIkJlc3RcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcXFwiR29vZFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA2KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBSYW5nZUNlbGwgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXFxcInJhbmdlLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAxMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMzAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMTAgKyBNYXRoLnJvdW5kKHYgKiAyMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiAxLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGAke01hdGgucm91bmQodiAqIDEwMCl9JWAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlTGFiZWw6IFxcXCIxMDAlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBBcnRpY2xlQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiYXJ0aWNsZS1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duOiBcXFwiIyMgVGhpcyBpcyBhIHRlc3RcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IFNwaW5uZXJDZWxsID0ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJzcGlubmVyLWNlbGxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERhdGVQaWNrZXJDZWxsID0ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcXFwiNFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJkYXRlLXBpY2tlci1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcXFwiZGF0ZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IExpbmtzQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXFxcIjRcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwibGlua3MtY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmVPZmZzZXQ6IDYsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rczogW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJMaW5reSBwaG9uZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGFsZXJ0KFxcXCJDbGljayAxXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiQ2xpY2sgdGhlIGxpbmt5IGRpbmt5XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoXFxcIkNsaWNrIDJcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDExKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogQnV0dG9uQ2VsbCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcXFwicG9pbnRlclxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFxcXCI0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJidXR0b24tY2VsbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcXFwidHJhbnNwYXJlbnRcXFwiLCBcXFwiIzY1NzJmZmVlXFxcIl0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogW1xcXCJhY2NlbnRDb2xvclxcXCIsIFxcXCJhY2NlbnRGZ1xcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFxcXCIjNjU3MmZmYTBcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJWaWV3IERldGFpbHNcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gd2luZG93LmFsZXJ0KFxcXCJCdXR0b24gY2xpY2tlZFxcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlRm9udFN0eWxlOiBcXFwiNzAwIDEycHhcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkZhaWxcXFwiKTtcXG4gICAgICAgICAgICAgICAgfX1cXG4gICAgICAgICAgICAgICAgY29sdW1ucz17W1xcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiU3RhcnNcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiU3BhcmtsaW5lXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlNwYXJrbGluZSAoYmFycylcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiVGFnc1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDI1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJQcm9maWxlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIkRyb3Bkb3duXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIlJhbmdlXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIkFydGljbGVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiU3Bpbm5lclxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJEYXRlIFBpY2tlclxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJMaW5rc1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCJCdXR0b25cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBdfVxcbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XFxuICAgICAgICAgICAgLz5cXG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cXG4gICAgKTtcXG59O1xcbihDdXN0b21DZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXFxuICAgIH0sXFxufTtcXG5cXG5leHBvcnQgY29uc3QgQ3VzdG9tQ2VsbEVkaXRpbmc6IFJlYWN0LlZGQyA9ICgpID0+IHtcXG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xcblxcbiAgICBjb25zdCBkYXRhID0gUmVhY3QudXNlUmVmPHN0cmluZ1tdPihbXSk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxcbiAgICAgICAgICAgIHRpdGxlPVxcXCJDdXN0b20gY2VsbCBlZGl0aW5nXFxcIlxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcXG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgQ2VsbHMgY2FuIGJlIGVkaXRlZCBhbmQgcmVzcG9uZGluZyB0byBjb3B5L3Bhc3RlIHVzaW5nIHRoZSBjb3B5RGF0YSBhdHRyaWJ1dGUuXFxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XFxuICAgICAgICAgICAgfT5cXG4gICAgICAgICAgICA8RGF0YUVkaXRvclxcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxcbiAgICAgICAgICAgICAgICB7Li4uY2VsbFByb3BzfVxcbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxcbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9eyhjZWxsLCBuZXdWYWwpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwua2luZCAhPT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKERyb3Bkb3duUmVuZGVyZXIuaXNNYXRjaChuZXdWYWwpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jdXJyZW50W2NlbGxbMV1dID0gbmV3VmFsLmRhdGEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXt0cnVlfVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Y2VsbCA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCByb3ddID0gY2VsbDtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGRhdGEuY3VycmVudFtyb3ddID8/IFxcXCJBXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IHZhbCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFxcXCJkcm9wZG93bi1jZWxsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1xcXCJBXFxcIiwgXFxcIkJcXFwiLCBcXFwiQ1xcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICB9IGFzIERyb3Bkb3duQ2VsbDtcXG4gICAgICAgICAgICAgICAgfX1cXG4gICAgICAgICAgICAgICAgY29sdW1ucz17W1xcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwiRHJvcGRvd25cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAsXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBdfVxcbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XFxuICAgICAgICAgICAgLz5cXG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cXG4gICAgKTtcXG59O1xcbihDdXN0b21DZWxsRWRpdGluZyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXFxuICAgIH0sXFxufTtcXG5cIixcImxvY2F0aW9uc01hcFwiOntcImN1c3RvbS1jZWxsc1wiOntcInN0YXJ0TG9jXCI6e1wiY29sXCI6MzgsXCJsaW5lXCI6MTcwfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6NDMzfSxcInN0YXJ0Qm9keVwiOntcImNvbFwiOjM4LFwibGluZVwiOjE3MH0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjo0MzN9fSxcImN1c3RvbS1jZWxsLWVkaXRpbmdcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjQ0LFwibGluZVwiOjQ0MH0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjQ4OH0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo0NCxcImxpbmVcIjo0NDB9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6NDg4fX19fSx9LFxuICAgIHRpdGxlOiBcIkV4dHJhIFBhY2thZ2VzL0NlbGxzXCIsXG5cbiAgICBkZWNvcmF0b3JzOiBbXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8U3RvcnkgLz5cbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmID4gaDEge1xuICAgICAgICBmb250LXNpemU6IDUwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XG4gICAgfVxuXG4gICAgLnNpemVyIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxuICAgICAgICAgICAge2Rlc2NyaXB0aW9ufVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2l6ZXItY2xpcFwiIHJlZj17cmVmfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvQmVhdXRpZnVsU3R5bGU+XG4gICAgKTtcbn07XG5cbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcbmA7XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxubGV0IG51bTogbnVtYmVyID0gMTtcbmZ1bmN0aW9uIHJhbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKG51bSA9IChudW0gKiAxNjgwNykgJSAyMTQ3NDgzNjQ3KSAvIDIxNDc0ODM2NDc7XG59XG5cbmNvbnN0IHBvc3NpYmxlVGFncyA9IFtcbiAgICB7XG4gICAgICAgIHRhZzogXCJCdWdcIixcbiAgICAgICAgY29sb3I6IFwiI2ZmNGQ0ZDM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJGZWF0dXJlXCIsXG4gICAgICAgIGNvbG9yOiBcIiMzNWY4ZmYzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFwiRW5oYW5jZW1lbnRcIixcbiAgICAgICAgY29sb3I6IFwiIzQ4ZmY1NzM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJGaXJzdCBJc3N1ZVwiLFxuICAgICAgICBjb2xvcjogXCIjNDM2ZmZmMzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIlBSXCIsXG4gICAgICAgIGNvbG9yOiBcIiNlMGZmMzIzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFwiQXNzaWduZWRcIixcbiAgICAgICAgY29sb3I6IFwiI2ZmMWVlYzM1XCIsXG4gICAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBDdXN0b21DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IGNlbGxQcm9wcyA9IHVzZUV4dHJhQ2VsbHMoKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyIHRpdGxlPVwiQ3VzdG9tIGNlbGxzXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5Tb21lIG9mIG91ciBleHRlbnNpb24gY2VsbHMuPC9EZXNjcmlwdGlvbj59PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5jZWxsUHJvcHN9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17KC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKFwiRWRpdCBDZWxsXCIsIC4uLmFyZ3MpfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtjZWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2wgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzdGFyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiVGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmc6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgU3RhckNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gcmFuZ2UoMCwgMTUpLm1hcCgoKSA9PiByYW5kKCkgKiAxMDAgLSA1MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInNwYXJrbGluZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlczogdmFsdWVzLm1hcCh4ID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByb3cgJSAyID09PSAwID8gXCIjNzdjNGM0XCIgOiBcIiNEOTg0NjZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IFstNTAsIDUwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3BhcmtsaW5lLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcIiM3N2M0YzRcIiA6IFwiI0Q5ODQ2NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaEtpbmQ6IFwiYmFyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzOiBbLTUwLCA1MF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgU3BhcmtsaW5lQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidGFncy1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnczogcG9zc2libGVUYWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkb25seTogcm93ICUgMiA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogdW5pcShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3NbTWF0aC5yb3VuZChyYW5kKCkgKiAxMDAwKSAlIHBvc3NpYmxlVGFncy5sZW5ndGhdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3NbTWF0aC5yb3VuZChyYW5kKCkgKiAxMDAwKSAlIHBvc3NpYmxlVGFncy5sZW5ndGhdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgVGFnc0NlbGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInVzZXItcHJvZmlsZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiByb3cgJSAyID8gdW5kZWZpbmVkIDogXCJodHRwczovL2kucmVkZC5pdC9hcWMxaHdoYWxzejcxLmpwZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsOiBcIkJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGludDogXCIjRjFEODZFXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJvdyAlIDUgPyB1bmRlZmluZWQgOiBcIkJlZSBiYlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFVzZXJQcm9maWxlQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBEcm9wZG93bkNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJkcm9wZG93bi1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcIkdvb2RcIiwgXCJCZXR0ZXJcIiwgXCJCZXN0XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJHb29kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogUmFuZ2VDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwicmFuZ2UtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMTAgKyBNYXRoLnJvdW5kKHYgKiAyMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBgJHtNYXRoLnJvdW5kKHYgKiAxMDApfSVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlTGFiZWw6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogQXJ0aWNsZUNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJhcnRpY2xlLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd246IFwiIyMgVGhpcyBpcyBhIHRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IFNwaW5uZXJDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3Bpbm5lci1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBEYXRlUGlja2VyQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImRhdGUtcGlja2VyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBMaW5rc0NlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJsaW5rcy1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybGluZU9mZnNldDogNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJMaW5reSBwaG9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGFsZXJ0KFwiQ2xpY2sgMVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQ2xpY2sgdGhlIGxpbmt5IGRpbmt5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoXCJDbGljayAyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBCdXR0b25DZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJidXR0b24tY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcInRyYW5zcGFyZW50XCIsIFwiIzY1NzJmZmVlXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogW1wiYWNjZW50Q29sb3JcIiwgXCJhY2NlbnRGZ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzY1NzJmZmEwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogOSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiVmlldyBEZXRhaWxzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHdpbmRvdy5hbGVydChcIkJ1dHRvbiBjbGlja2VkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWVPdmVycmlkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlRm9udFN0eWxlOiBcIjcwMCAxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsXCIpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgY29sdW1ucz17W1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTdGFyc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiU3BhcmtsaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTcGFya2xpbmUgKGJhcnMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJUYWdzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJQcm9maWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJEcm9wZG93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiUmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkFydGljbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNwaW5uZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRhdGUgUGlja2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJMaW5rc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59OztcbihDdXN0b21DZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tQ2VsbEVkaXRpbmc6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCBjZWxsUHJvcHMgPSB1c2VFeHRyYUNlbGxzKCk7XG5cbiAgICBjb25zdCBkYXRhID0gUmVhY3QudXNlUmVmPHN0cmluZ1tdPihbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDdXN0b20gY2VsbCBlZGl0aW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENlbGxzIGNhbiBiZSBlZGl0ZWQgYW5kIHJlc3BvbmRpbmcgdG8gY29weS9wYXN0ZSB1c2luZyB0aGUgY29weURhdGEgYXR0cmlidXRlLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5jZWxsUHJvcHN9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9eyhjZWxsLCBuZXdWYWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbC5raW5kICE9PSBHcmlkQ2VsbEtpbmQuQ3VzdG9tKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChEcm9wZG93blJlbmRlcmVyLmlzTWF0Y2gobmV3VmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jdXJyZW50W2NlbGxbMV1dID0gbmV3VmFsLmRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXt0cnVlfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtjZWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGRhdGEuY3VycmVudFtyb3ddID8/IFwiQVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJkcm9wZG93bi1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1wiQVwiLCBcIkJcIiwgXCJDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9IGFzIERyb3Bkb3duQ2VsbDtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e1tcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRHJvcGRvd25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ3VzdG9tQ2VsbEVkaXRpbmcgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/dropdown-cell.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".wg6ppx4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}.wg6ppx4 .glide-select{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);}\n.p7jnwoo{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);color:var(--gdg-text-dark);}.p7jnwoo > div{border-radius:4px;border:1px solid var(--gdg-border-color);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL2Ryb3Bkb3duLWNlbGwudHN4Il0sIm5hbWVzIjpbIi53ZzZwcHg0IiwiLnA3am53b28iXSwibWFwcGluZ3MiOiJBQTZCYUE7QUFXTUMiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvZHJvcGRvd24tY2VsbC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEN1c3RvbUNlbGwsXG4gICAgUHJvdmlkZUVkaXRvckNhbGxiYWNrLFxuICAgIEN1c3RvbVJlbmRlcmVyLFxuICAgIGdldE1pZGRsZUNlbnRlckJpYXMsXG4gICAgdXNlVGhlbWUsXG4gICAgR3JpZENlbGxLaW5kLFxufSBmcm9tIFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgU2VsZWN0LCB7IE1lbnVQcm9wcywgY29tcG9uZW50cyB9IGZyb20gXCJyZWFjdC1zZWxlY3RcIjtcblxuaW50ZXJmYWNlIEN1c3RvbU1lbnVQcm9wcyBleHRlbmRzIE1lbnVQcm9wczxhbnk+IHt9XG5cbmNvbnN0IEN1c3RvbU1lbnU6IFJlYWN0LkZDPEN1c3RvbU1lbnVQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IE1lbnUgfSA9IGNvbXBvbmVudHM7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gcDtcbiAgICByZXR1cm4gPE1lbnUgey4uLnJlc3R9PntjaGlsZHJlbn08L01lbnU+O1xufTtcblxuaW50ZXJmYWNlIERyb3Bkb3duQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcImRyb3Bkb3duLWNlbGxcIjtcbiAgICByZWFkb25seSB2YWx1ZTogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGFsbG93ZWRWYWx1ZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICAgIHJlYWRvbmx5IHJlYWRvbmx5PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgRHJvcGRvd25DZWxsID0gQ3VzdG9tQ2VsbDxEcm9wZG93bkNlbGxQcm9wcz47XG5cbmNvbnN0IFdyYXAgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcblxuICAgIC5nbGlkZS1zZWxlY3Qge1xuICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICAgICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgfVxuYDtcblxuY29uc3QgUG9ydGFsV3JhcCA9IHN0eWxlZC5kaXZgXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgPiBkaXYge1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIH1cbmA7XG5cbmNvbnN0IEVkaXRvcjogUmV0dXJuVHlwZTxQcm92aWRlRWRpdG9yQ2FsbGJhY2s8RHJvcGRvd25DZWxsPj4gPSBwID0+IHtcbiAgICBjb25zdCB7IHZhbHVlOiBjZWxsLCBvbkZpbmlzaGVkRWRpdGluZywgaW5pdGlhbFZhbHVlIH0gPSBwO1xuICAgIGNvbnN0IHsgYWxsb3dlZFZhbHVlcywgdmFsdWU6IHZhbHVlSW4gfSA9IGNlbGwuZGF0YTtcblxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUodmFsdWVJbik7XG4gICAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbFZhbHVlID8/IFwiXCIpO1xuXG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuXG4gICAgY29uc3QgdmFsdWVzID0gUmVhY3QudXNlTWVtbyhcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXMubWFwKHggPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgICAgICAgICBsYWJlbDogeCxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgW2FsbG93ZWRWYWx1ZXNdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxXcmFwPlxuICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdsaWRlLXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZT17aW5wdXRWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbklucHV0Q2hhbmdlPXtzZXRJbnB1dFZhbHVlfVxuICAgICAgICAgICAgICAgIG1lbnVQbGFjZW1lbnQ9e1wiYXV0b1wifVxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZXMuZmluZCh4ID0+IHgudmFsdWUgPT09IHZhbHVlKX1cbiAgICAgICAgICAgICAgICBzdHlsZXM9e3tcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogYmFzZSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgdGhlbWU9e3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnQuY29sb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwwOiB0aGVtZS5iZ0NlbGwsIC8vIHRoaXMgaXMgYm90aCB0aGUgYmFja2dyb3VuZCBjb2xvciBBTkQgdGhlIGZnIGNvbG9yIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGl0ZW0gYmVjYXVzZSBvZiBjb3Vyc2UgaXQgaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDU6IHRoZW1lLmJnQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsMTA6IHRoZW1lLmJnQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsMjA6IHRoZW1lLmJnQ2VsbE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsMzA6IHRoZW1lLmJnQ2VsbE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNDA6IHRoZW1lLmJnQ2VsbE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNTA6IHRoZW1lLnRleHRMaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNjA6IHRoZW1lLnRleHRNZWRpdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDcwOiB0aGVtZS50ZXh0TWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw4MDogdGhlbWUudGV4dERhcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDkwOiB0aGVtZS50ZXh0RGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsMTAwOiB0aGVtZS50ZXh0RGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5OiB0aGVtZS5hY2NlbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5NzU6IHRoZW1lLmFjY2VudENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk1MDogdGhlbWUuYWNjZW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTI1OiB0aGVtZS5hY2NlbnRMaWdodCwgLy8gcHJlbGlnaHQgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBtZW51UG9ydGFsVGFyZ2V0PXtkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBvcnRhbFwiKX1cbiAgICAgICAgICAgICAgICBhdXRvRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAgICAgb3Blbk1lbnVPbkZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM9e3tcbiAgICAgICAgICAgICAgICAgICAgRHJvcGRvd25JbmRpY2F0b3I6ICgpID0+IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIEluZGljYXRvclNlcGFyYXRvcjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgTWVudTogcHJvcHMgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPFBvcnRhbFdyYXA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEN1c3RvbU1lbnUgY2xhc3NOYW1lPXtcImNsaWNrLW91dHNpZGUtaWdub3JlXCJ9IHsuLi5wcm9wc30gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvUG9ydGFsV3JhcD5cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e3ZhbHVlc31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17YXN5bmMgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocikpO1xuICAgICAgICAgICAgICAgICAgICBvbkZpbmlzaGVkRWRpdGluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNlbGwuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L1dyYXA+XG4gICAgKTtcbn07XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxEcm9wZG93bkNlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIERyb3Bkb3duQ2VsbCA9PiAoYy5kYXRhIGFzIGFueSkua2luZCA9PT0gXCJkcm9wZG93bi1jZWxsXCIsXG4gICAgZHJhdzogKGFyZ3MsIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHRoZW1lLCByZWN0IH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBjZWxsLmRhdGE7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByZWN0LnggKyB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmcsXG4gICAgICAgICAgICByZWN0LnkgKyByZWN0LmhlaWdodCAvIDIgKyBnZXRNaWRkbGVDZW50ZXJCaWFzKGN0eCwgdGhlbWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiAoe1xuICAgICAgICBlZGl0b3I6IEVkaXRvcixcbiAgICAgICAgZGlzYWJsZVBhZGRpbmc6IHRydWUsXG4gICAgICAgIGRlbGV0ZWRWYWx1ZTogdiA9PiAoe1xuICAgICAgICAgICAgLi4udixcbiAgICAgICAgICAgIGNvcHlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLnYuZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgIH0pLFxuICAgIG9uUGFzdGU6ICh2LCBkKSA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICB2YWx1ZTogZC5hbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHYpID8gdiA6IGQudmFsdWUsXG4gICAgfSksXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJlcjtcbiJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/cells/src/cells/dropdown-cell.tsx","webpack://./packages/cells/src/cells/dropdown-cell.tsx"],"names":[".wg6ppx4",".p7jnwoo"],"mappings":"AA6BaA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,uBAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA;AAWMC,SAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,eAAAA,iBAAAA,CAAAA,wCAAAA,CAAAA;ACtCnB,m5PAAm5P","sourcesContent":["import {\n    CustomCell,\n    ProvideEditorCallback,\n    CustomRenderer,\n    getMiddleCenterBias,\n    useTheme,\n    GridCellKind,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport Select, { MenuProps, components } from \"react-select\";\n\ninterface CustomMenuProps extends MenuProps<any> {}\n\nconst CustomMenu: React.FC<CustomMenuProps> = p => {\n    const { Menu } = components;\n    const { children, ...rest } = p;\n    return <Menu {...rest}>{children}</Menu>;\n};\n\ninterface DropdownCellProps {\n    readonly kind: \"dropdown-cell\";\n    readonly value: string;\n    readonly allowedValues: readonly string[];\n    readonly readonly?: boolean;\n}\n\nexport type DropdownCell = CustomCell<DropdownCellProps>;\n\nconst Wrap = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n\n    .glide-select {\n        font-family: var(--gdg-font-family);\n        font-size: var(--gdg-editor-font-size);\n    }\n`;\n\nconst PortalWrap = styled.div`\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n    color: var(--gdg-text-dark);\n\n    > div {\n        border-radius: 4px;\n        border: 1px solid var(--gdg-border-color);\n    }\n`;\n\nconst Editor: ReturnType<ProvideEditorCallback<DropdownCell>> = p => {\n    const { value: cell, onFinishedEditing, initialValue } = p;\n    const { allowedValues, value: valueIn } = cell.data;\n\n    const [value, setValue] = React.useState(valueIn);\n    const [inputValue, setInputValue] = React.useState(initialValue ?? \"\");\n\n    const theme = useTheme();\n\n    const values = React.useMemo(\n        () =>\n            allowedValues.map(x => ({\n                value: x,\n                label: x,\n            })),\n        [allowedValues]\n    );\n\n    return (\n        <Wrap>\n            <Select\n                className=\"glide-select\"\n                inputValue={inputValue}\n                onInputChange={setInputValue}\n                menuPlacement={\"auto\"}\n                value={values.find(x => x.value === value)}\n                styles={{\n                    control: base => ({\n                        ...base,\n                        border: 0,\n                        boxShadow: \"none\",\n                    }),\n                }}\n                theme={t => {\n                    return {\n                        ...t,\n                        colors: {\n                            ...t.colors,\n                            neutral0: theme.bgCell, // this is both the background color AND the fg color of\n                            // the selected item because of course it is.\n                            neutral5: theme.bgCell,\n                            neutral10: theme.bgCell,\n                            neutral20: theme.bgCellMedium,\n                            neutral30: theme.bgCellMedium,\n                            neutral40: theme.bgCellMedium,\n                            neutral50: theme.textLight,\n                            neutral60: theme.textMedium,\n                            neutral70: theme.textMedium,\n                            neutral80: theme.textDark,\n                            neutral90: theme.textDark,\n                            neutral100: theme.textDark,\n                            primary: theme.accentColor,\n                            primary75: theme.accentColor,\n                            primary50: theme.accentColor,\n                            primary25: theme.accentLight, // prelight color\n                        },\n                    };\n                }}\n                menuPortalTarget={document.getElementById(\"portal\")}\n                autoFocus={true}\n                openMenuOnFocus={true}\n                components={{\n                    DropdownIndicator: () => null,\n                    IndicatorSeparator: () => null,\n                    Menu: props => (\n                        <PortalWrap>\n                            <CustomMenu className={\"click-outside-ignore\"} {...props} />\n                        </PortalWrap>\n                    ),\n                }}\n                options={values}\n                onChange={async e => {\n                    if (e === null) return;\n                    setValue(e.value);\n                    await new Promise(r => window.requestAnimationFrame(r));\n                    onFinishedEditing({\n                        ...cell,\n                        data: {\n                            ...cell.data,\n                            value: e.value,\n                        },\n                    });\n                }}\n            />\n        </Wrap>\n    );\n};\n\nconst renderer: CustomRenderer<DropdownCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is DropdownCell => (c.data as any).kind === \"dropdown-cell\",\n    draw: (args, cell) => {\n        const { ctx, theme, rect } = args;\n        const { value } = cell.data;\n        ctx.fillStyle = theme.textDark;\n        ctx.fillText(\n            value,\n            rect.x + theme.cellHorizontalPadding,\n            rect.y + rect.height / 2 + getMiddleCenterBias(ctx, theme)\n        );\n\n        return true;\n    },\n    provideEditor: () => ({\n        editor: Editor,\n        disablePadding: true,\n        deletedValue: v => ({\n            ...v,\n            copyData: \"\",\n            data: {\n                ...v.data,\n                value: \"\",\n            },\n        }),\n    }),\n    onPaste: (v, d) => ({\n        ...d,\n        value: d.allowedValues.includes(v) ? v : d.value,\n    }),\n};\n\nexport default renderer;\n",".wg6ppx4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}.wg6ppx4 .glide-select{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);}\n.p7jnwoo{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);color:var(--gdg-text-dark);}.p7jnwoo > div{border-radius:4px;border:1px solid var(--gdg-border-color);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL2Ryb3Bkb3duLWNlbGwudHN4Il0sIm5hbWVzIjpbIi53ZzZwcHg0IiwiLnA3am53b28iXSwibWFwcGluZ3MiOiJBQTZCYUE7QUFXTUMiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvZHJvcGRvd24tY2VsbC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEN1c3RvbUNlbGwsXG4gICAgUHJvdmlkZUVkaXRvckNhbGxiYWNrLFxuICAgIEN1c3RvbVJlbmRlcmVyLFxuICAgIGdldE1pZGRsZUNlbnRlckJpYXMsXG4gICAgdXNlVGhlbWUsXG4gICAgR3JpZENlbGxLaW5kLFxufSBmcm9tIFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgU2VsZWN0LCB7IE1lbnVQcm9wcywgY29tcG9uZW50cyB9IGZyb20gXCJyZWFjdC1zZWxlY3RcIjtcblxuaW50ZXJmYWNlIEN1c3RvbU1lbnVQcm9wcyBleHRlbmRzIE1lbnVQcm9wczxhbnk+IHt9XG5cbmNvbnN0IEN1c3RvbU1lbnU6IFJlYWN0LkZDPEN1c3RvbU1lbnVQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IE1lbnUgfSA9IGNvbXBvbmVudHM7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gcDtcbiAgICByZXR1cm4gPE1lbnUgey4uLnJlc3R9PntjaGlsZHJlbn08L01lbnU+O1xufTtcblxuaW50ZXJmYWNlIERyb3Bkb3duQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcImRyb3Bkb3duLWNlbGxcIjtcbiAgICByZWFkb25seSB2YWx1ZTogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGFsbG93ZWRWYWx1ZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICAgIHJlYWRvbmx5IHJlYWRvbmx5PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgRHJvcGRvd25DZWxsID0gQ3VzdG9tQ2VsbDxEcm9wZG93bkNlbGxQcm9wcz47XG5cbmNvbnN0IFdyYXAgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcblxuICAgIC5nbGlkZS1zZWxlY3Qge1xuICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICAgICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgfVxuYDtcblxuY29uc3QgUG9ydGFsV3JhcCA9IHN0eWxlZC5kaXZgXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgPiBkaXYge1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIH1cbmA7XG5cbmNvbnN0IEVkaXRvcjogUmV0dXJuVHlwZTxQcm92aWRlRWRpdG9yQ2FsbGJhY2s8RHJvcGRvd25DZWxsPj4gPSBwID0+IHtcbiAgICBjb25zdCB7IHZhbHVlOiBjZWxsLCBvbkZpbmlzaGVkRWRpdGluZywgaW5pdGlhbFZhbHVlIH0gPSBwO1xuICAgIGNvbnN0IHsgYWxsb3dlZFZhbHVlcywgdmFsdWU6IHZhbHVlSW4gfSA9IGNlbGwuZGF0YTtcblxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUodmFsdWVJbik7XG4gICAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbFZhbHVlID8/IFwiXCIpO1xuXG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuXG4gICAgY29uc3QgdmFsdWVzID0gUmVhY3QudXNlTWVtbyhcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXMubWFwKHggPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgICAgICAgICBsYWJlbDogeCxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgW2FsbG93ZWRWYWx1ZXNdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxXcmFwPlxuICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdsaWRlLXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZT17aW5wdXRWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbklucHV0Q2hhbmdlPXtzZXRJbnB1dFZhbHVlfVxuICAgICAgICAgICAgICAgIG1lbnVQbGFjZW1lbnQ9e1wiYXV0b1wifVxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZXMuZmluZCh4ID0+IHgudmFsdWUgPT09IHZhbHVlKX1cbiAgICAgICAgICAgICAgICBzdHlsZXM9e3tcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogYmFzZSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgdGhlbWU9e3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnQuY29sb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwwOiB0aGVtZS5iZ0NlbGwsIC8vIHRoaXMgaXMgYm90aCB0aGUgYmFja2dyb3VuZCBjb2xvciBBTkQgdGhlIGZnIGNvbG9yIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGl0ZW0gYmVjYXVzZSBvZiBjb3Vyc2UgaXQgaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDU6IHRoZW1lLmJnQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsMTA6IHRoZW1lLmJnQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsMjA6IHRoZW1lLmJnQ2VsbE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsMzA6IHRoZW1lLmJnQ2VsbE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNDA6IHRoZW1lLmJnQ2VsbE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNTA6IHRoZW1lLnRleHRMaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNjA6IHRoZW1lLnRleHRNZWRpdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDcwOiB0aGVtZS50ZXh0TWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw4MDogdGhlbWUudGV4dERhcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDkwOiB0aGVtZS50ZXh0RGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsMTAwOiB0aGVtZS50ZXh0RGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5OiB0aGVtZS5hY2NlbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5NzU6IHRoZW1lLmFjY2VudENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk1MDogdGhlbWUuYWNjZW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTI1OiB0aGVtZS5hY2NlbnRMaWdodCwgLy8gcHJlbGlnaHQgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBtZW51UG9ydGFsVGFyZ2V0PXtkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBvcnRhbFwiKX1cbiAgICAgICAgICAgICAgICBhdXRvRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAgICAgb3Blbk1lbnVPbkZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM9e3tcbiAgICAgICAgICAgICAgICAgICAgRHJvcGRvd25JbmRpY2F0b3I6ICgpID0+IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIEluZGljYXRvclNlcGFyYXRvcjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgTWVudTogcHJvcHMgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPFBvcnRhbFdyYXA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEN1c3RvbU1lbnUgY2xhc3NOYW1lPXtcImNsaWNrLW91dHNpZGUtaWdub3JlXCJ9IHsuLi5wcm9wc30gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvUG9ydGFsV3JhcD5cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e3ZhbHVlc31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17YXN5bmMgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocikpO1xuICAgICAgICAgICAgICAgICAgICBvbkZpbmlzaGVkRWRpdGluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNlbGwuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L1dyYXA+XG4gICAgKTtcbn07XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxEcm9wZG93bkNlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIERyb3Bkb3duQ2VsbCA9PiAoYy5kYXRhIGFzIGFueSkua2luZCA9PT0gXCJkcm9wZG93bi1jZWxsXCIsXG4gICAgZHJhdzogKGFyZ3MsIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHRoZW1lLCByZWN0IH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBjZWxsLmRhdGE7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByZWN0LnggKyB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmcsXG4gICAgICAgICAgICByZWN0LnkgKyByZWN0LmhlaWdodCAvIDIgKyBnZXRNaWRkbGVDZW50ZXJCaWFzKGN0eCwgdGhlbWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiAoe1xuICAgICAgICBlZGl0b3I6IEVkaXRvcixcbiAgICAgICAgZGlzYWJsZVBhZGRpbmc6IHRydWUsXG4gICAgICAgIGRlbGV0ZWRWYWx1ZTogdiA9PiAoe1xuICAgICAgICAgICAgLi4udixcbiAgICAgICAgICAgIGNvcHlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLnYuZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgIH0pLFxuICAgIG9uUGFzdGU6ICh2LCBkKSA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICB2YWx1ZTogZC5hbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHYpID8gdiA6IGQudmFsdWUsXG4gICAgfSksXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJlcjtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/links-cell.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".lld219p{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;margin:4px 0;}.lld219p > button{color:var(--gdg-accent-color);font-weight:600;-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;border:none;outline:none;background-color:transparent;-webkit-transition:background-color 200ms;transition:background-color 200ms;border-radius:4px;padding:6px 8px;cursor:pointer;}.lld219p > button:hover,.lld219p > button:focus-visible{background-color:var(--gdg-accent-light);}.lld219p > button:disabled{opacity:0.4;pointer-events:none;}.lld219p .gdg-link-title-editor{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-width:250px;}.lld219p .gdg-link-title-editor > input{outline:none;border:1px solid var(--gdg-border-color);border-radius:4px;box-shadow:none;padding:6px 8px;min-width:0;width:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-transition:border 200ms;transition:border 200ms;}.lld219p .gdg-link-title-editor > input:not(:last-child){margin-right:4px;}.lld219p .gdg-link-title-editor > input:focus{border:1px solid var(--gdg-accent-color);}.lld219p .gdg-link-title-editor:not(:last-child){margin-bottom:4px;}.lld219p .gdg-link-title-editor > button{border:none;outline:none;border-radius:4px;background-color:transparent;cursor:pointer;-webkit-transition:background-color 200ms,color 200ms;transition:background-color 200ms,color 200ms;color:var(--gdg-text-medium);}.lld219p .gdg-link-title-editor > button:hover,.lld219p .gdg-link-title-editor > button:focus-visible{background-color:var(--gdg-accent-light);color:var(--gdg-text-dark);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL2xpbmtzLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5sbGQyMTlwIl0sIm1hcHBpbmdzIjoiQUF1TTZCQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9saW5rcy1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBtZWFzdXJlVGV4dENhY2hlZCxcbiAgICBDdXN0b21SZW5kZXJlcixcbiAgICBnZXRNaWRkbGVDZW50ZXJCaWFzLFxuICAgIEdyaWRDZWxsS2luZCxcbiAgICBibGVuZCxcbn0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgTGlua3NDZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwibGlua3MtY2VsbFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gaGFuZCB0dW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgdW5kZXJsaW5lIGFzIHRoaXMgaXMgbm90IGEgbmF0aXZlIGNhbnZhcyBjYXBhYmlsaXR5LCBpdCBjYW4gbmVlZCB0d2Vha2luZ1xuICAgICAqIGZvciBkaWZmZXJlbnQgZm9udHMuXG4gICAgICovXG4gICAgcmVhZG9ubHkgdW5kZXJsaW5lT2Zmc2V0PzogbnVtYmVyO1xuICAgIHJlYWRvbmx5IG1heExpbmtzPzogbnVtYmVyO1xuICAgIHJlYWRvbmx5IG5hdmlnYXRlT24/OiBcImNsaWNrXCIgfCBcImNvbnRyb2wtY2xpY2tcIjtcbiAgICByZWFkb25seSBsaW5rczogcmVhZG9ubHkge1xuICAgICAgICByZWFkb25seSB0aXRsZTogc3RyaW5nO1xuICAgICAgICByZWFkb25seSBocmVmPzogc3RyaW5nO1xuICAgICAgICByZWFkb25seSBvbkNsaWNrPzogKCkgPT4gdm9pZDtcbiAgICB9W107XG59XG5cbmV4cG9ydCB0eXBlIExpbmtzQ2VsbCA9IEN1c3RvbUNlbGw8TGlua3NDZWxsUHJvcHM+O1xuXG5mdW5jdGlvbiBvbkNsaWNrU2VsZWN0KGU6IFBhcmFtZXRlcnM8Tm9uTnVsbGFibGU8Q3VzdG9tUmVuZGVyZXI8TGlua3NDZWxsPltcIm9uU2VsZWN0XCJdPj5bMF0pIHtcbiAgICBjb25zdCB1c2VDdHJsID0gZS5jZWxsLmRhdGEubmF2aWdhdGVPbiAhPT0gXCJjbGlja1wiO1xuICAgIGlmICh1c2VDdHJsICE9PSBlLmN0cmxLZXkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHsgYWxwaGE6IGZhbHNlIH0pO1xuICAgIGlmIChjdHggPT09IG51bGwpIHJldHVybjtcblxuICAgIGNvbnN0IHsgcG9zWDogaG92ZXJYLCBib3VuZHM6IHJlY3QsIGNlbGwsIHRoZW1lIH0gPSBlO1xuICAgIGNvbnN0IGZvbnQgPSBgJHt0aGVtZS5iYXNlRm9udFN0eWxlfSAke3RoZW1lLmZvbnRGYW1pbHl9YDtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG5cbiAgICBjb25zdCB7IGxpbmtzIH0gPSBjZWxsLmRhdGE7XG5cbiAgICBjb25zdCB4UGFkID0gdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuXG4gICAgbGV0IGRyYXdYID0gcmVjdC54ICsgeFBhZDtcblxuICAgIGNvbnN0IHJlY3RIb3ZlclggPSByZWN0LnggKyBob3Zlclg7XG5cbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgbF0gb2YgbGlua3MuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IG5lZWRzQ29tbWEgPSBpbmRleCA8IGxpbmtzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dENhY2hlZChsLnRpdGxlLCBjdHgpO1xuICAgICAgICBjb25zdCBjb21tYU1ldHJpY3MgPSBuZWVkc0NvbW1hID8gbWVhc3VyZVRleHRDYWNoZWQobC50aXRsZSArIFwiLFwiLCBjdHgsIGZvbnQpIDogbWV0cmljcztcblxuICAgICAgICBjb25zdCBpc0hvdmVyZWQgPSByZWN0SG92ZXJYID4gZHJhd1ggJiYgcmVjdEhvdmVyWCA8IGRyYXdYICsgbWV0cmljcy53aWR0aDtcblxuICAgICAgICBpZiAoaXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXdYICs9IGNvbW1hTWV0cmljcy53aWR0aCArIDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgcmVuZGVyZXI6IEN1c3RvbVJlbmRlcmVyPExpbmtzQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBuZWVkc0hvdmVyOiB0cnVlLFxuICAgIG5lZWRzSG92ZXJQb3NpdGlvbjogdHJ1ZSxcbiAgICBpc01hdGNoOiAoYyk6IGMgaXMgTGlua3NDZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcImxpbmtzLWNlbGxcIixcbiAgICBvblNlbGVjdDogZSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrU2VsZWN0KGUpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25DbGljazogZSA9PiB7XG4gICAgICAgIGNvbnN0IGhvdmVyZWQgPSBvbkNsaWNrU2VsZWN0KGUpO1xuICAgICAgICBpZiAoaG92ZXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBob3ZlcmVkLm9uQ2xpY2s/LigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgcmVjdCwgdGhlbWUsIGhvdmVyWCA9IC0xMDAsIGhpZ2hsaWdodGVkIH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IGxpbmtzLCB1bmRlcmxpbmVPZmZzZXQgPSA1IH0gPSBjZWxsLmRhdGE7XG5cbiAgICAgICAgY29uc3QgeFBhZCA9IHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZztcblxuICAgICAgICBsZXQgZHJhd1ggPSByZWN0LnggKyB4UGFkO1xuXG4gICAgICAgIGNvbnN0IHJlY3RIb3ZlclggPSByZWN0LnggKyBob3Zlclg7XG5cbiAgICAgICAgY29uc3QgZm9udCA9IGAke3RoZW1lLmJhc2VGb250U3R5bGV9ICR7dGhlbWUuZm9udEZhbWlseX1gO1xuXG4gICAgICAgIGNvbnN0IG1pZGRsZUNlbnRlckJpYXMgPSBnZXRNaWRkbGVDZW50ZXJCaWFzKGN0eCwgZm9udCk7XG4gICAgICAgIGNvbnN0IGRyYXdZID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyICsgbWlkZGxlQ2VudGVyQmlhcztcblxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgbF0gb2YgbGlua3MuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBuZWVkc0NvbW1hID0gaW5kZXggPCBsaW5rcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUsIGN0eCwgZm9udCk7XG4gICAgICAgICAgICBjb25zdCBjb21tYU1ldHJpY3MgPSBuZWVkc0NvbW1hID8gbWVhc3VyZVRleHRDYWNoZWQobC50aXRsZSArIFwiLFwiLCBjdHgsIGZvbnQpIDogbWV0cmljcztcblxuICAgICAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gcmVjdEhvdmVyWCA+IGRyYXdYICYmIHJlY3RIb3ZlclggPCBkcmF3WCArIG1ldHJpY3Mud2lkdGg7XG5cbiAgICAgICAgICAgIGlmIChpc0hvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGRyYXdYLCBNYXRoLmZsb29yKGRyYXdZICsgdW5kZXJsaW5lT2Zmc2V0KSArIDAuNSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhkcmF3WCArIG1ldHJpY3Mud2lkdGgsIE1hdGguZmxvb3IoZHJhd1kgKyB1bmRlcmxpbmVPZmZzZXQpICsgMC41KTtcblxuICAgICAgICAgICAgICAgIC8vIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lLnRleHREYXJrO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBoaWdobGlnaHRlZCA/IGJsZW5kKHRoZW1lLmFjY2VudExpZ2h0LCB0aGVtZS5iZ0NlbGwpIDogdGhlbWUuYmdDZWxsO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggLSAxLCBkcmF3WSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG5lZWRzQ29tbWEgPyBsLnRpdGxlICsgXCIsXCIgOiBsLnRpdGxlLCBkcmF3WCArIDEsIGRyYXdZKTtcblxuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggLSAyLCBkcmF3WSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG5lZWRzQ29tbWEgPyBsLnRpdGxlICsgXCIsXCIgOiBsLnRpdGxlLCBkcmF3WCArIDIsIGRyYXdZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1gsIGRyYXdZKTtcblxuICAgICAgICAgICAgZHJhd1ggKz0gY29tbWFNZXRyaWNzLndpZHRoICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+IHAgPT4ge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBvbkNoYW5nZSB9ID0gcDtcbiAgICAgICAgY29uc3QgeyBsaW5rcywgbWF4TGlua3MgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB9ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxMaW5rc0NlbGxFZGl0b3JTdHlsZSBvbktleURvd249e2lnbm9yZVRhYn0+XG4gICAgICAgICAgICAgICAge2xpbmtzLm1hcCgobCwgaSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8TGlua1RpdGxlRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rPXtsLmhyZWYgPz8gXCJcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtsLnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM9e2kgPT09IDB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TGlua3MgPSBbLi4ubGlua3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMaW5rcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IG5ld0xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhsaW5rLCB0aXRsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMaW5rc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IG5ld0xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtsaW5rcy5sZW5ndGggPj0gbWF4TGlua3N9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFkZC1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TGlua3MgPSBbLi4ubGlua3MsIHsgdGl0bGU6IFwiXCIgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rczogbmV3TGlua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgQWRkIGxpbmtcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvTGlua3NDZWxsRWRpdG9yU3R5bGU+XG4gICAgICAgICk7XG4gICAgfSxcbiAgICBvblBhc3RlOiAodiwgZCkgPT4ge1xuICAgICAgICBjb25zdCBzcGxpdCA9IHYuc3BsaXQoXCIsXCIpO1xuICAgICAgICBpZiAoZC5saW5rcy5zb21lKChsLCBpKSA9PiBzcGxpdFtpXSAhPT0gbC50aXRsZSkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgbGlua3M6IHNwbGl0Lm1hcChsID0+ICh7IHRpdGxlOiBsIH0pKSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuY29uc3QgTGlua3NDZWxsRWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICAgIG1hcmdpbjogNHB4IDA7XG5cbiAgICA+IGJ1dHRvbiB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAyMDBtcztcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuXG4gICAgICAgIHBhZGRpbmc6IDZweCA4cHg7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICA6aG92ZXIsXG4gICAgICAgIDpmb2N1cy12aXNpYmxlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtbGlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgOmRpc2FibGVkIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmdkZy1saW5rLXRpdGxlLWVkaXRvciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICAgICAgbWluLXdpZHRoOiAyNTBweDtcblxuICAgICAgICA+IGlucHV0IHtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKTtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggOHB4O1xuICAgICAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgICAgICAgICAgd2lkdGg6IDA7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICAgICAgICAgICY6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAyMDBtcztcblxuICAgICAgICAgICAgJjpmb2N1cyB7XG4gICAgICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgPiBidXR0b24ge1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcblxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAyMDBtcywgY29sb3IgMjAwbXM7XG5cbiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1tZWRpdW0pO1xuXG4gICAgICAgICAgICA6aG92ZXIsXG4gICAgICAgICAgICA6Zm9jdXMtdmlzaWJsZSB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1saWdodCk7XG4gICAgICAgICAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuYDtcblxuaW50ZXJmYWNlIExpbmtUaXRsZUVkaXRvclByb3BzIHtcbiAgICByZWFkb25seSBsaW5rOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcbiAgICByZWFkb25seSBvbkNoYW5nZTogKGxpbms6IHN0cmluZywgdGl0bGU6IHN0cmluZykgPT4gdm9pZDtcbiAgICByZWFkb25seSBvbkRlbGV0ZT86ICgpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgZm9jdXM6IGJvb2xlYW47XG59XG5cbmZ1bmN0aW9uIGlnbm9yZVRhYihlOiBSZWFjdC5LZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGUua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxufVxuXG5jb25zdCBMaW5rVGl0bGVFZGl0b3I6IFJlYWN0LlZGQzxMaW5rVGl0bGVFZGl0b3JQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGxpbmssIG9uQ2hhbmdlLCB0aXRsZSwgb25EZWxldGUsIGZvY3VzIH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2RnLWxpbmstdGl0bGUtZWRpdG9yXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZGctdGl0bGUtaW5wdXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aXRsZX1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlRpdGxlXCJcbiAgICAgICAgICAgICAgICBhdXRvRm9jdXM9e2ZvY3VzfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobGluaywgZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLWxpbmstaW5wdXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtsaW5rfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVVJMXCJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlLCB0aXRsZSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7b25EZWxldGUgIT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvbkRlbGV0ZX0+XG4gICAgICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXsxNn1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17MTZ9XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwiaWNvbi1pbXBvcnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTMgNkw1IDZMMjEgNlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD1cIjFweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNMTcuOTAxOSA2QzE4LjQ5MSA2IDE4Ljk1MjUgNi41MDY3NiAxOC44OTc1IDcuMDkzMzRMMTcuNjcgMjAuMTg2N0MxNy41NzM2IDIxLjIxNDQgMTYuNzExIDIyIDE1LjY3ODcgMjJIOC4zMjEyN0M3LjI4OTAyIDIyIDYuNDI2MzUgMjEuMjE0NCA2LjMzIDIwLjE4NjdMNS4xMDI1IDcuMDkzMzRDNS4wNDc1MSA2LjUwNjc2IDUuNTA4OTggNiA2LjA5ODEzIDZIMTcuOTAxOVpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTE0LjQ0OTkgMTAuMjExTDEzLjk5NDkgMTdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTkuNTU0OTkgMTAuMjExTDEwLjAwNDkgMTdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTcuNSAyLjI1SDE2LjVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJlcjtcbiJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/cells/src/cells/links-cell.tsx","webpack://./packages/cells/src/cells/links-cell.tsx"],"names":[".lld219p"],"mappings":"AAuM6BA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,CAAAA,kBAAAA,6BAAAA,CAAAA,eAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,4BAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,wDAAAA,wCAAAA,CAAAA,CAAAA,2BAAAA,WAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,gCAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,eAAAA,CAAAA,CAAAA,wCAAAA,YAAAA,CAAAA,wCAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,OAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,+BAAAA,CAAAA,uBAAAA,CAAAA,CAAAA,yDAAAA,gBAAAA,CAAAA,CAAAA,8CAAAA,wCAAAA,CAAAA,CAAAA,iDAAAA,iBAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,YAAAA,CAAAA,iBAAAA,CAAAA,4BAAAA,CAAAA,cAAAA,CAAAA,qDAAAA,CAAAA,6CAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,sGAAAA,wCAAAA,CAAAA,0BAAAA,CAAAA;ACtM7B,mphBAAmphB","sourcesContent":["import {\n    CustomCell,\n    measureTextCached,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n    blend,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\n\ninterface LinksCellProps {\n    readonly kind: \"links-cell\";\n    /**\n     * Used to hand tune the position of the underline as this is not a native canvas capability, it can need tweaking\n     * for different fonts.\n     */\n    readonly underlineOffset?: number;\n    readonly maxLinks?: number;\n    readonly navigateOn?: \"click\" | \"control-click\";\n    readonly links: readonly {\n        readonly title: string;\n        readonly href?: string;\n        readonly onClick?: () => void;\n    }[];\n}\n\nexport type LinksCell = CustomCell<LinksCellProps>;\n\nfunction onClickSelect(e: Parameters<NonNullable<CustomRenderer<LinksCell>[\"onSelect\"]>>[0]) {\n    const useCtrl = e.cell.data.navigateOn !== \"click\";\n    if (useCtrl !== e.ctrlKey) return undefined;\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\", { alpha: false });\n    if (ctx === null) return;\n\n    const { posX: hoverX, bounds: rect, cell, theme } = e;\n    const font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n    ctx.font = font;\n\n    const { links } = cell.data;\n\n    const xPad = theme.cellHorizontalPadding;\n\n    let drawX = rect.x + xPad;\n\n    const rectHoverX = rect.x + hoverX;\n\n    for (const [index, l] of links.entries()) {\n        const needsComma = index < links.length - 1;\n        const metrics = measureTextCached(l.title, ctx);\n        const commaMetrics = needsComma ? measureTextCached(l.title + \",\", ctx, font) : metrics;\n\n        const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;\n\n        if (isHovered) {\n            return l;\n        }\n\n        drawX += commaMetrics.width + 4;\n    }\n\n    return undefined;\n}\n\nconst renderer: CustomRenderer<LinksCell> = {\n    kind: GridCellKind.Custom,\n    needsHover: true,\n    needsHoverPosition: true,\n    isMatch: (c): c is LinksCell => (c.data as any).kind === \"links-cell\",\n    onSelect: e => {\n        if (onClickSelect(e) !== undefined) {\n            e.preventDefault();\n        }\n    },\n    onClick: e => {\n        const hovered = onClickSelect(e);\n        if (hovered !== undefined) {\n            hovered.onClick?.();\n            e.preventDefault();\n        }\n        return undefined;\n    },\n    draw: (args, cell) => {\n        const { ctx, rect, theme, hoverX = -100, highlighted } = args;\n        const { links, underlineOffset = 5 } = cell.data;\n\n        const xPad = theme.cellHorizontalPadding;\n\n        let drawX = rect.x + xPad;\n\n        const rectHoverX = rect.x + hoverX;\n\n        const font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n\n        const middleCenterBias = getMiddleCenterBias(ctx, font);\n        const drawY = rect.y + rect.height / 2 + middleCenterBias;\n\n        for (const [index, l] of links.entries()) {\n            const needsComma = index < links.length - 1;\n            const metrics = measureTextCached(l.title, ctx, font);\n            const commaMetrics = needsComma ? measureTextCached(l.title + \",\", ctx, font) : metrics;\n\n            const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;\n\n            if (isHovered) {\n                ctx.moveTo(drawX, Math.floor(drawY + underlineOffset) + 0.5);\n                ctx.lineTo(drawX + metrics.width, Math.floor(drawY + underlineOffset) + 0.5);\n\n                // ctx.lineWidth = 1;\n                ctx.strokeStyle = theme.textDark;\n                ctx.stroke();\n\n                ctx.fillStyle = highlighted ? blend(theme.accentLight, theme.bgCell) : theme.bgCell;\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX - 1, drawY);\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX + 1, drawY);\n\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX - 2, drawY);\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX + 2, drawY);\n            }\n            ctx.fillStyle = theme.textDark;\n            ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX, drawY);\n\n            drawX += commaMetrics.width + 4;\n        }\n\n        return true;\n    },\n    // eslint-disable-next-line react/display-name\n    provideEditor: () => p => {\n        const { value, onChange } = p;\n        const { links, maxLinks = Number.MAX_SAFE_INTEGER } = value.data;\n        return (\n            <LinksCellEditorStyle onKeyDown={ignoreTab}>\n                {links.map((l, i) => (\n                    <LinkTitleEditor\n                        key={i}\n                        link={l.href ?? \"\"}\n                        title={l.title}\n                        focus={i === 0}\n                        onDelete={\n                            links.length > 1\n                                ? () => {\n                                      const newLinks = [...links];\n                                      newLinks.splice(i, 1);\n                                      onChange({\n                                          ...value,\n                                          data: {\n                                              ...value.data,\n                                              links: newLinks,\n                                          },\n                                      });\n                                  }\n                                : undefined\n                        }\n                        onChange={(link, title) => {\n                            const newLinks = [...links];\n                            newLinks[i] = {\n                                href: link,\n                                title,\n                            };\n                            onChange({\n                                ...value,\n                                data: {\n                                    ...value.data,\n                                    links: newLinks,\n                                },\n                            });\n                        }}\n                    />\n                ))}\n                <button\n                    disabled={links.length >= maxLinks}\n                    className=\"add-link\"\n                    onClick={() => {\n                        const newLinks = [...links, { title: \"\" }];\n                        onChange({\n                            ...value,\n                            data: {\n                                ...value.data,\n                                links: newLinks,\n                            },\n                        });\n                    }}>\n                    Add link\n                </button>\n            </LinksCellEditorStyle>\n        );\n    },\n    onPaste: (v, d) => {\n        const split = v.split(\",\");\n        if (d.links.some((l, i) => split[i] !== l.title)) return undefined;\n        return {\n            ...d,\n            links: split.map(l => ({ title: l })),\n        };\n    },\n};\n\nconst LinksCellEditorStyle = styled.div`\n    display: flex;\n    flex-direction: column;\n\n    margin: 4px 0;\n\n    > button {\n        color: var(--gdg-accent-color);\n        font-weight: 600;\n        align-self: flex-end;\n        border: none;\n        outline: none;\n        background-color: transparent;\n\n        transition: background-color 200ms;\n        border-radius: 4px;\n\n        padding: 6px 8px;\n        cursor: pointer;\n\n        :hover,\n        :focus-visible {\n            background-color: var(--gdg-accent-light);\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n\n    .gdg-link-title-editor {\n        display: flex;\n\n        min-width: 250px;\n\n        > input {\n            outline: none;\n            border: 1px solid var(--gdg-border-color);\n            border-radius: 4px;\n            box-shadow: none;\n            padding: 6px 8px;\n            min-width: 0;\n            width: 0;\n            flex-grow: 1;\n\n            &:not(:last-child) {\n                margin-right: 4px;\n            }\n\n            transition: border 200ms;\n\n            &:focus {\n                border: 1px solid var(--gdg-accent-color);\n            }\n        }\n\n        &:not(:last-child) {\n            margin-bottom: 4px;\n        }\n\n        > button {\n            border: none;\n            outline: none;\n            border-radius: 4px;\n\n            background-color: transparent;\n\n            cursor: pointer;\n\n            transition: background-color 200ms, color 200ms;\n\n            color: var(--gdg-text-medium);\n\n            :hover,\n            :focus-visible {\n                background-color: var(--gdg-accent-light);\n                color: var(--gdg-text-dark);\n            }\n        }\n    }\n`;\n\ninterface LinkTitleEditorProps {\n    readonly link: string;\n    readonly title: string;\n    readonly onChange: (link: string, title: string) => void;\n    readonly onDelete?: () => void;\n    readonly focus: boolean;\n}\n\nfunction ignoreTab(e: React.KeyboardEvent) {\n    if (e.key === \"Tab\") {\n        e.stopPropagation();\n    }\n}\n\nconst LinkTitleEditor: React.VFC<LinkTitleEditorProps> = p => {\n    const { link, onChange, title, onDelete, focus } = p;\n    return (\n        <div className=\"gdg-link-title-editor\">\n            <input\n                className=\"gdg-title-input\"\n                value={title}\n                placeholder=\"Title\"\n                autoFocus={focus}\n                onChange={e => {\n                    onChange(link, e.target.value);\n                }}\n            />\n            <input\n                className=\"gdg-link-input\"\n                value={link}\n                placeholder=\"URL\"\n                onChange={e => {\n                    onChange(e.target.value, title);\n                }}\n            />\n            {onDelete !== undefined && (\n                <button onClick={onDelete}>\n                    <svg\n                        width={16}\n                        height={16}\n                        viewBox=\"0 0 24 24\"\n                        fill=\"none\"\n                        id=\"icon-import\"\n                        xmlns=\"http://www.w3.org/2000/svg\">\n                        <path\n                            d=\"M3 6L5 6L21 6\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M17.9019 6C18.491 6 18.9525 6.50676 18.8975 7.09334L17.67 20.1867C17.5736 21.2144 16.711 22 15.6787 22H8.32127C7.28902 22 6.42635 21.2144 6.33 20.1867L5.1025 7.09334C5.04751 6.50676 5.50898 6 6.09813 6H17.9019Z\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M14.4499 10.211L13.9949 17\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M9.55499 10.211L10.0049 17\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M7.5 2.25H16.5\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                    </svg>\n                </button>\n            )}\n        </div>\n    );\n};\n\nexport default renderer;\n",".lld219p{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;margin:4px 0;}.lld219p > button{color:var(--gdg-accent-color);font-weight:600;-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;border:none;outline:none;background-color:transparent;-webkit-transition:background-color 200ms;transition:background-color 200ms;border-radius:4px;padding:6px 8px;cursor:pointer;}.lld219p > button:hover,.lld219p > button:focus-visible{background-color:var(--gdg-accent-light);}.lld219p > button:disabled{opacity:0.4;pointer-events:none;}.lld219p .gdg-link-title-editor{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-width:250px;}.lld219p .gdg-link-title-editor > input{outline:none;border:1px solid var(--gdg-border-color);border-radius:4px;box-shadow:none;padding:6px 8px;min-width:0;width:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-transition:border 200ms;transition:border 200ms;}.lld219p .gdg-link-title-editor > input:not(:last-child){margin-right:4px;}.lld219p .gdg-link-title-editor > input:focus{border:1px solid var(--gdg-accent-color);}.lld219p .gdg-link-title-editor:not(:last-child){margin-bottom:4px;}.lld219p .gdg-link-title-editor > button{border:none;outline:none;border-radius:4px;background-color:transparent;cursor:pointer;-webkit-transition:background-color 200ms,color 200ms;transition:background-color 200ms,color 200ms;color:var(--gdg-text-medium);}.lld219p .gdg-link-title-editor > button:hover,.lld219p .gdg-link-title-editor > button:focus-visible{background-color:var(--gdg-accent-light);color:var(--gdg-text-dark);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL2xpbmtzLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5sbGQyMTlwIl0sIm1hcHBpbmdzIjoiQUF1TTZCQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9saW5rcy1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBtZWFzdXJlVGV4dENhY2hlZCxcbiAgICBDdXN0b21SZW5kZXJlcixcbiAgICBnZXRNaWRkbGVDZW50ZXJCaWFzLFxuICAgIEdyaWRDZWxsS2luZCxcbiAgICBibGVuZCxcbn0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgTGlua3NDZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwibGlua3MtY2VsbFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gaGFuZCB0dW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgdW5kZXJsaW5lIGFzIHRoaXMgaXMgbm90IGEgbmF0aXZlIGNhbnZhcyBjYXBhYmlsaXR5LCBpdCBjYW4gbmVlZCB0d2Vha2luZ1xuICAgICAqIGZvciBkaWZmZXJlbnQgZm9udHMuXG4gICAgICovXG4gICAgcmVhZG9ubHkgdW5kZXJsaW5lT2Zmc2V0PzogbnVtYmVyO1xuICAgIHJlYWRvbmx5IG1heExpbmtzPzogbnVtYmVyO1xuICAgIHJlYWRvbmx5IG5hdmlnYXRlT24/OiBcImNsaWNrXCIgfCBcImNvbnRyb2wtY2xpY2tcIjtcbiAgICByZWFkb25seSBsaW5rczogcmVhZG9ubHkge1xuICAgICAgICByZWFkb25seSB0aXRsZTogc3RyaW5nO1xuICAgICAgICByZWFkb25seSBocmVmPzogc3RyaW5nO1xuICAgICAgICByZWFkb25seSBvbkNsaWNrPzogKCkgPT4gdm9pZDtcbiAgICB9W107XG59XG5cbmV4cG9ydCB0eXBlIExpbmtzQ2VsbCA9IEN1c3RvbUNlbGw8TGlua3NDZWxsUHJvcHM+O1xuXG5mdW5jdGlvbiBvbkNsaWNrU2VsZWN0KGU6IFBhcmFtZXRlcnM8Tm9uTnVsbGFibGU8Q3VzdG9tUmVuZGVyZXI8TGlua3NDZWxsPltcIm9uU2VsZWN0XCJdPj5bMF0pIHtcbiAgICBjb25zdCB1c2VDdHJsID0gZS5jZWxsLmRhdGEubmF2aWdhdGVPbiAhPT0gXCJjbGlja1wiO1xuICAgIGlmICh1c2VDdHJsICE9PSBlLmN0cmxLZXkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHsgYWxwaGE6IGZhbHNlIH0pO1xuICAgIGlmIChjdHggPT09IG51bGwpIHJldHVybjtcblxuICAgIGNvbnN0IHsgcG9zWDogaG92ZXJYLCBib3VuZHM6IHJlY3QsIGNlbGwsIHRoZW1lIH0gPSBlO1xuICAgIGNvbnN0IGZvbnQgPSBgJHt0aGVtZS5iYXNlRm9udFN0eWxlfSAke3RoZW1lLmZvbnRGYW1pbHl9YDtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG5cbiAgICBjb25zdCB7IGxpbmtzIH0gPSBjZWxsLmRhdGE7XG5cbiAgICBjb25zdCB4UGFkID0gdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuXG4gICAgbGV0IGRyYXdYID0gcmVjdC54ICsgeFBhZDtcblxuICAgIGNvbnN0IHJlY3RIb3ZlclggPSByZWN0LnggKyBob3Zlclg7XG5cbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgbF0gb2YgbGlua3MuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IG5lZWRzQ29tbWEgPSBpbmRleCA8IGxpbmtzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dENhY2hlZChsLnRpdGxlLCBjdHgpO1xuICAgICAgICBjb25zdCBjb21tYU1ldHJpY3MgPSBuZWVkc0NvbW1hID8gbWVhc3VyZVRleHRDYWNoZWQobC50aXRsZSArIFwiLFwiLCBjdHgsIGZvbnQpIDogbWV0cmljcztcblxuICAgICAgICBjb25zdCBpc0hvdmVyZWQgPSByZWN0SG92ZXJYID4gZHJhd1ggJiYgcmVjdEhvdmVyWCA8IGRyYXdYICsgbWV0cmljcy53aWR0aDtcblxuICAgICAgICBpZiAoaXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXdYICs9IGNvbW1hTWV0cmljcy53aWR0aCArIDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgcmVuZGVyZXI6IEN1c3RvbVJlbmRlcmVyPExpbmtzQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBuZWVkc0hvdmVyOiB0cnVlLFxuICAgIG5lZWRzSG92ZXJQb3NpdGlvbjogdHJ1ZSxcbiAgICBpc01hdGNoOiAoYyk6IGMgaXMgTGlua3NDZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcImxpbmtzLWNlbGxcIixcbiAgICBvblNlbGVjdDogZSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrU2VsZWN0KGUpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25DbGljazogZSA9PiB7XG4gICAgICAgIGNvbnN0IGhvdmVyZWQgPSBvbkNsaWNrU2VsZWN0KGUpO1xuICAgICAgICBpZiAoaG92ZXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBob3ZlcmVkLm9uQ2xpY2s/LigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgcmVjdCwgdGhlbWUsIGhvdmVyWCA9IC0xMDAsIGhpZ2hsaWdodGVkIH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IGxpbmtzLCB1bmRlcmxpbmVPZmZzZXQgPSA1IH0gPSBjZWxsLmRhdGE7XG5cbiAgICAgICAgY29uc3QgeFBhZCA9IHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZztcblxuICAgICAgICBsZXQgZHJhd1ggPSByZWN0LnggKyB4UGFkO1xuXG4gICAgICAgIGNvbnN0IHJlY3RIb3ZlclggPSByZWN0LnggKyBob3Zlclg7XG5cbiAgICAgICAgY29uc3QgZm9udCA9IGAke3RoZW1lLmJhc2VGb250U3R5bGV9ICR7dGhlbWUuZm9udEZhbWlseX1gO1xuXG4gICAgICAgIGNvbnN0IG1pZGRsZUNlbnRlckJpYXMgPSBnZXRNaWRkbGVDZW50ZXJCaWFzKGN0eCwgZm9udCk7XG4gICAgICAgIGNvbnN0IGRyYXdZID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyICsgbWlkZGxlQ2VudGVyQmlhcztcblxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgbF0gb2YgbGlua3MuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBuZWVkc0NvbW1hID0gaW5kZXggPCBsaW5rcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUsIGN0eCwgZm9udCk7XG4gICAgICAgICAgICBjb25zdCBjb21tYU1ldHJpY3MgPSBuZWVkc0NvbW1hID8gbWVhc3VyZVRleHRDYWNoZWQobC50aXRsZSArIFwiLFwiLCBjdHgsIGZvbnQpIDogbWV0cmljcztcblxuICAgICAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gcmVjdEhvdmVyWCA+IGRyYXdYICYmIHJlY3RIb3ZlclggPCBkcmF3WCArIG1ldHJpY3Mud2lkdGg7XG5cbiAgICAgICAgICAgIGlmIChpc0hvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGRyYXdYLCBNYXRoLmZsb29yKGRyYXdZICsgdW5kZXJsaW5lT2Zmc2V0KSArIDAuNSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhkcmF3WCArIG1ldHJpY3Mud2lkdGgsIE1hdGguZmxvb3IoZHJhd1kgKyB1bmRlcmxpbmVPZmZzZXQpICsgMC41KTtcblxuICAgICAgICAgICAgICAgIC8vIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lLnRleHREYXJrO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBoaWdobGlnaHRlZCA/IGJsZW5kKHRoZW1lLmFjY2VudExpZ2h0LCB0aGVtZS5iZ0NlbGwpIDogdGhlbWUuYmdDZWxsO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggLSAxLCBkcmF3WSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG5lZWRzQ29tbWEgPyBsLnRpdGxlICsgXCIsXCIgOiBsLnRpdGxlLCBkcmF3WCArIDEsIGRyYXdZKTtcblxuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggLSAyLCBkcmF3WSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG5lZWRzQ29tbWEgPyBsLnRpdGxlICsgXCIsXCIgOiBsLnRpdGxlLCBkcmF3WCArIDIsIGRyYXdZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1gsIGRyYXdZKTtcblxuICAgICAgICAgICAgZHJhd1ggKz0gY29tbWFNZXRyaWNzLndpZHRoICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+IHAgPT4ge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBvbkNoYW5nZSB9ID0gcDtcbiAgICAgICAgY29uc3QgeyBsaW5rcywgbWF4TGlua3MgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB9ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxMaW5rc0NlbGxFZGl0b3JTdHlsZSBvbktleURvd249e2lnbm9yZVRhYn0+XG4gICAgICAgICAgICAgICAge2xpbmtzLm1hcCgobCwgaSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8TGlua1RpdGxlRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rPXtsLmhyZWYgPz8gXCJcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtsLnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM9e2kgPT09IDB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TGlua3MgPSBbLi4ubGlua3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMaW5rcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IG5ld0xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhsaW5rLCB0aXRsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMaW5rc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IG5ld0xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtsaW5rcy5sZW5ndGggPj0gbWF4TGlua3N9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFkZC1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TGlua3MgPSBbLi4ubGlua3MsIHsgdGl0bGU6IFwiXCIgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rczogbmV3TGlua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgQWRkIGxpbmtcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvTGlua3NDZWxsRWRpdG9yU3R5bGU+XG4gICAgICAgICk7XG4gICAgfSxcbiAgICBvblBhc3RlOiAodiwgZCkgPT4ge1xuICAgICAgICBjb25zdCBzcGxpdCA9IHYuc3BsaXQoXCIsXCIpO1xuICAgICAgICBpZiAoZC5saW5rcy5zb21lKChsLCBpKSA9PiBzcGxpdFtpXSAhPT0gbC50aXRsZSkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgbGlua3M6IHNwbGl0Lm1hcChsID0+ICh7IHRpdGxlOiBsIH0pKSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuY29uc3QgTGlua3NDZWxsRWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICAgIG1hcmdpbjogNHB4IDA7XG5cbiAgICA+IGJ1dHRvbiB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAyMDBtcztcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuXG4gICAgICAgIHBhZGRpbmc6IDZweCA4cHg7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICA6aG92ZXIsXG4gICAgICAgIDpmb2N1cy12aXNpYmxlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtbGlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgOmRpc2FibGVkIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmdkZy1saW5rLXRpdGxlLWVkaXRvciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICAgICAgbWluLXdpZHRoOiAyNTBweDtcblxuICAgICAgICA+IGlucHV0IHtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKTtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggOHB4O1xuICAgICAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgICAgICAgICAgd2lkdGg6IDA7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICAgICAgICAgICY6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJvcmRlciAyMDBtcztcblxuICAgICAgICAgICAgJjpmb2N1cyB7XG4gICAgICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAmOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgPiBidXR0b24ge1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcblxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAyMDBtcywgY29sb3IgMjAwbXM7XG5cbiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1tZWRpdW0pO1xuXG4gICAgICAgICAgICA6aG92ZXIsXG4gICAgICAgICAgICA6Zm9jdXMtdmlzaWJsZSB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1saWdodCk7XG4gICAgICAgICAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuYDtcblxuaW50ZXJmYWNlIExpbmtUaXRsZUVkaXRvclByb3BzIHtcbiAgICByZWFkb25seSBsaW5rOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcbiAgICByZWFkb25seSBvbkNoYW5nZTogKGxpbms6IHN0cmluZywgdGl0bGU6IHN0cmluZykgPT4gdm9pZDtcbiAgICByZWFkb25seSBvbkRlbGV0ZT86ICgpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgZm9jdXM6IGJvb2xlYW47XG59XG5cbmZ1bmN0aW9uIGlnbm9yZVRhYihlOiBSZWFjdC5LZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGUua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxufVxuXG5jb25zdCBMaW5rVGl0bGVFZGl0b3I6IFJlYWN0LlZGQzxMaW5rVGl0bGVFZGl0b3JQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGxpbmssIG9uQ2hhbmdlLCB0aXRsZSwgb25EZWxldGUsIGZvY3VzIH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2RnLWxpbmstdGl0bGUtZWRpdG9yXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZGctdGl0bGUtaW5wdXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aXRsZX1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlRpdGxlXCJcbiAgICAgICAgICAgICAgICBhdXRvRm9jdXM9e2ZvY3VzfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobGluaywgZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLWxpbmstaW5wdXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtsaW5rfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVVJMXCJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlLCB0aXRsZSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7b25EZWxldGUgIT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvbkRlbGV0ZX0+XG4gICAgICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXsxNn1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD17MTZ9XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwiaWNvbi1pbXBvcnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTMgNkw1IDZMMjEgNlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD1cIjFweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNMTcuOTAxOSA2QzE4LjQ5MSA2IDE4Ljk1MjUgNi41MDY3NiAxOC44OTc1IDcuMDkzMzRMMTcuNjcgMjAuMTg2N0MxNy41NzM2IDIxLjIxNDQgMTYuNzExIDIyIDE1LjY3ODcgMjJIOC4zMjEyN0M3LjI4OTAyIDIyIDYuNDI2MzUgMjEuMjE0NCA2LjMzIDIwLjE4NjdMNS4xMDI1IDcuMDkzMzRDNS4wNDc1MSA2LjUwNjc2IDUuNTA4OTggNiA2LjA5ODEzIDZIMTcuOTAxOVpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTE0LjQ0OTkgMTAuMjExTDEzLjk5NDkgMTdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTkuNTU0OTkgMTAuMjExTDEwLjAwNDkgMTdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTcuNSAyLjI1SDE2LjVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJlcjtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/star-cell.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".e8nv6xj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:6px 0;color:var(--gdg-text-light);}.e8nv6xj .active{color:var(--gdg-text-dark);}.e8nv6xj > *{position:relative;width:16px;height:16px;cursor:pointer;margin-right:2px;}.e8nv6xj > * svg{width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL3N0YXItY2VsbC50c3giXSwibmFtZXMiOlsiLmU4bnY2eGoiXSwibWFwcGluZ3MiOiJBQWtEbUJBIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL3N0YXItY2VsbC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDdXN0b21DZWxsLCBJdGVtLCBDdXN0b21SZW5kZXJlciwgR3JpZENlbGxLaW5kIH0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5pbnRlcmZhY2UgU3RhckNlbGxQcm9wcyB7XG4gICAgcmVhZG9ubHkga2luZDogXCJzdGFyLWNlbGxcIjtcbiAgICByZWFkb25seSByYXRpbmc6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgU3RhckNlbGwgPSBDdXN0b21DZWxsPFN0YXJDZWxsUHJvcHM+O1xuXG5jb25zdCBzdGFyUG9pbnRzID0gW1xuICAgIFs1MCwgNV0sXG4gICAgWzYxLjIzLCAzOS41NV0sXG4gICAgWzk3LjU1LCAzOS41NV0sXG4gICAgWzY4LjE2LCA2MC45XSxcbiAgICBbNzkuMzksIDk1LjQ1XSxcbiAgICBbNTAsIDc0LjFdLFxuICAgIFsyMC42MSwgOTUuNDVdLFxuICAgIFszMS44NCwgNjAuOV0sXG4gICAgWzIuNDUsIDM5LjU1XSxcbiAgICBbMzguNzcsIDM5LjU1XSxcbl07XG5cbmZ1bmN0aW9uIHBhdGhTdGFyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjZW50ZXI6IEl0ZW0sIHNpemU6IG51bWJlcikge1xuICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcCBvZiBzdGFyUG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHggPSAocFswXSAtIDUwKSAqIChzaXplIC8gMTAwKSArIGNlbnRlclswXTtcbiAgICAgICAgY29uc3QgeSA9IChwWzFdIC0gNTApICogKHNpemUgLyAxMDApICsgY2VudGVyWzFdO1xuXG4gICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG59XG5cbmNvbnN0IFN0YXJTVkcgPSAoKSA9PiAoXG4gICAgPHN2ZyB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgICAgZD1cIk00Ny4xNDY4IDEzLjc4MTFDNDguMDQ0OSAxMS4wMTcyIDUxLjk1NTEgMTEuMDE3MiA1Mi44NTMyIDEzLjc4MTJMNjAuNTUyMiAzNy40NzYyQzYwLjk1MzggMzguNzEyMyA2Mi4xMDU2IDM5LjU0OTEgNjMuNDA1MyAzOS41NDkxSDg4LjMxOThDOTEuMjI2IDM5LjU0OTEgOTIuNDM0MyA0My4yNjggOTAuMDgzMSA0NC45NzYyTDY5LjkyNjkgNTkuNjIwNUM2OC44NzU1IDYwLjM4NDUgNjguNDM1NSA2MS43Mzg2IDY4LjgzNzEgNjIuOTc0Nkw3Ni41MzYxIDg2LjY2OTdDNzcuNDM0MiA4OS40MzM2IDc0LjI3MDcgOTEuNzMyIDcxLjkxOTYgOTAuMDIzOEw1MS43NjM0IDc1LjM3OTRDNTAuNzExOSA3NC42MTU1IDQ5LjI4ODEgNzQuNjE1NSA0OC4yMzY2IDc1LjM3OTVMMjguMDgwNCA5MC4wMjM4QzI1LjcyOTMgOTEuNzMyIDIyLjU2NTkgODkuNDMzNiAyMy40NjM5IDg2LjY2OTdMMzEuMTYyOSA2Mi45NzQ2QzMxLjU2NDUgNjEuNzM4NiAzMS4xMjQ1IDYwLjM4NDUgMzAuMDczMSA1OS42MjA1TDkuOTE2ODYgNDQuOTc2MkM3LjU2NTcyIDQzLjI2OCA4Ljc3NDA1IDM5LjU0OTEgMTEuNjgwMiAzOS41NDkxSDM2LjU5NDdDMzcuODk0NCAzOS41NDkxIDM5LjA0NjIgMzguNzEyMyAzOS40NDc4IDM3LjQ3NjJMNDcuMTQ2OCAxMy43ODExWlwiXG4gICAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgLz5cbiAgICA8L3N2Zz5cbik7XG5cbmNvbnN0IEVkaXRvcldyYXAgPSBzdHlsZWQuZGl2YFxuICAgIC5hY3RpdmUge1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgfVxuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDZweCAwO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1saWdodCk7XG5cbiAgICA+ICoge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAycHg7XG5cbiAgICAgICAgc3ZnIHtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuYDtcblxuY29uc3QgcmVuZGVyZXI6IEN1c3RvbVJlbmRlcmVyPFN0YXJDZWxsPiA9IHtcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgIGlzTWF0Y2g6IChjZWxsOiBDdXN0b21DZWxsKTogY2VsbCBpcyBTdGFyQ2VsbCA9PiAoY2VsbC5kYXRhIGFzIGFueSkua2luZCA9PT0gXCJzdGFyLWNlbGxcIixcbiAgICBuZWVkc0hvdmVyOiB0cnVlLFxuICAgIGRyYXc6IChhcmdzLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCB0aGVtZSwgcmVjdCwgaG92ZXJBbW91bnQgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHsgcmF0aW5nIH0gPSBjZWxsLmRhdGE7XG4gICAgICAgIGNvbnN0IHBhZFggPSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgICAgIGxldCBkcmF3WCA9IHJlY3QueCArIHBhZFg7XG4gICAgICAgIGNvbnN0IHN0YXJzID0gTWF0aC5taW4oNSwgTWF0aC5jZWlsKHJhdGluZykpO1xuICAgICAgICBkcmF3WCArPSA4O1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnM7IGkrKykge1xuICAgICAgICAgICAgcGF0aFN0YXIoY3R4LCBbZHJhd1gsIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMl0sIDE2KTtcbiAgICAgICAgICAgIGRyYXdYICs9IDE4O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42ICsgMC40ICogaG92ZXJBbW91bnQ7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJvdmlkZUVkaXRvcjogKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgICAgIHJldHVybiBwID0+IChcbiAgICAgICAgICAgIDxFZGl0b3JXcmFwPlxuICAgICAgICAgICAgICAgIHtbMCwgMSwgMiwgMywgNF0ubWFwKGluZGV4ID0+IChcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cC52YWx1ZS5kYXRhLnJhdGluZyA8IGluZGV4ICsgMSA/IFwiaW5hY3RpdmVcIiA6IFwiYWN0aXZlXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAudmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGluZzogaW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3RhclNWRyAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvRWRpdG9yV3JhcD5cbiAgICAgICAgKTtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICh2YWwsIGQpID0+IHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlSW50KHZhbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgcmF0aW5nOiBOdW1iZXIuaXNOYU4obnVtKSA/IDAgOiBudW0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/cells/src/cells/star-cell.tsx","webpack://./packages/cells/src/cells/star-cell.tsx"],"names":[".e8nv6xj"],"mappings":"AAkDmBA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,aAAAA,CAAAA,2BAAAA,CAAAA,CAAAA,iBAAAA,0BAAAA,CAAAA,CAAAA,aAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,iBAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACjDnB,u3LAAu3L","sourcesContent":["import { CustomCell, Item, CustomRenderer, GridCellKind } from \"@glideapps/glide-data-grid\";\nimport * as React from \"react\";\nimport { styled } from \"@linaria/react\";\n\ninterface StarCellProps {\n    readonly kind: \"star-cell\";\n    readonly rating: number;\n}\n\nexport type StarCell = CustomCell<StarCellProps>;\n\nconst starPoints = [\n    [50, 5],\n    [61.23, 39.55],\n    [97.55, 39.55],\n    [68.16, 60.9],\n    [79.39, 95.45],\n    [50, 74.1],\n    [20.61, 95.45],\n    [31.84, 60.9],\n    [2.45, 39.55],\n    [38.77, 39.55],\n];\n\nfunction pathStar(ctx: CanvasRenderingContext2D, center: Item, size: number) {\n    let moved = false;\n    for (const p of starPoints) {\n        const x = (p[0] - 50) * (size / 100) + center[0];\n        const y = (p[1] - 50) * (size / 100) + center[1];\n\n        if (moved) {\n            ctx.lineTo(x, y);\n        } else {\n            ctx.moveTo(x, y);\n            moved = true;\n        }\n    }\n\n    ctx.closePath();\n}\n\nconst StarSVG = () => (\n    <svg width=\"100\" height=\"100\" viewBox=\"0 0 100 100\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path\n            d=\"M47.1468 13.7811C48.0449 11.0172 51.9551 11.0172 52.8532 13.7812L60.5522 37.4762C60.9538 38.7123 62.1056 39.5491 63.4053 39.5491H88.3198C91.226 39.5491 92.4343 43.268 90.0831 44.9762L69.9269 59.6205C68.8755 60.3845 68.4355 61.7386 68.8371 62.9746L76.5361 86.6697C77.4342 89.4336 74.2707 91.732 71.9196 90.0238L51.7634 75.3794C50.7119 74.6155 49.2881 74.6155 48.2366 75.3795L28.0804 90.0238C25.7293 91.732 22.5659 89.4336 23.4639 86.6697L31.1629 62.9746C31.5645 61.7386 31.1245 60.3845 30.0731 59.6205L9.91686 44.9762C7.56572 43.268 8.77405 39.5491 11.6802 39.5491H36.5947C37.8944 39.5491 39.0462 38.7123 39.4478 37.4762L47.1468 13.7811Z\"\n            fill=\"currentColor\"\n        />\n    </svg>\n);\n\nconst EditorWrap = styled.div`\n    .active {\n        color: var(--gdg-text-dark);\n    }\n\n    display: flex;\n    align-items: center;\n    padding: 6px 0;\n    color: var(--gdg-text-light);\n\n    > * {\n        position: relative;\n        width: 16px;\n        height: 16px;\n        cursor: pointer;\n        margin-right: 2px;\n\n        svg {\n            width: 100%;\n            height: 100%;\n        }\n    }\n`;\n\nconst renderer: CustomRenderer<StarCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (cell: CustomCell): cell is StarCell => (cell.data as any).kind === \"star-cell\",\n    needsHover: true,\n    draw: (args, cell) => {\n        const { ctx, theme, rect, hoverAmount } = args;\n        const { rating } = cell.data;\n        const padX = theme.cellHorizontalPadding;\n        let drawX = rect.x + padX;\n        const stars = Math.min(5, Math.ceil(rating));\n        drawX += 8;\n        ctx.beginPath();\n        for (let i = 0; i < stars; i++) {\n            pathStar(ctx, [drawX, rect.y + rect.height / 2], 16);\n            drawX += 18;\n        }\n        ctx.fillStyle = theme.textDark;\n        ctx.globalAlpha = 0.6 + 0.4 * hoverAmount;\n        ctx.fill();\n        ctx.globalAlpha = 1;\n        return true;\n    },\n    provideEditor: () => {\n        // eslint-disable-next-line react/display-name\n        return p => (\n            <EditorWrap>\n                {[0, 1, 2, 3, 4].map(index => (\n                    <div\n                        key={index}\n                        className={p.value.data.rating < index + 1 ? \"inactive\" : \"active\"}\n                        onClick={() => {\n                            p.onChange({\n                                ...p.value,\n                                data: {\n                                    ...p.value.data,\n                                    rating: index + 1,\n                                },\n                            });\n                        }}>\n                        <StarSVG />\n                    </div>\n                ))}\n            </EditorWrap>\n        );\n    },\n    onPaste: (val, d) => {\n        const num = Number.parseInt(val);\n        return {\n            ...d,\n            rating: Number.isNaN(num) ? 0 : num,\n        };\n    },\n};\n\nexport default renderer;\n",".e8nv6xj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:6px 0;color:var(--gdg-text-light);}.e8nv6xj .active{color:var(--gdg-text-dark);}.e8nv6xj > *{position:relative;width:16px;height:16px;cursor:pointer;margin-right:2px;}.e8nv6xj > * svg{width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL3N0YXItY2VsbC50c3giXSwibmFtZXMiOlsiLmU4bnY2eGoiXSwibWFwcGluZ3MiOiJBQWtEbUJBIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL3N0YXItY2VsbC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDdXN0b21DZWxsLCBJdGVtLCBDdXN0b21SZW5kZXJlciwgR3JpZENlbGxLaW5kIH0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5pbnRlcmZhY2UgU3RhckNlbGxQcm9wcyB7XG4gICAgcmVhZG9ubHkga2luZDogXCJzdGFyLWNlbGxcIjtcbiAgICByZWFkb25seSByYXRpbmc6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgU3RhckNlbGwgPSBDdXN0b21DZWxsPFN0YXJDZWxsUHJvcHM+O1xuXG5jb25zdCBzdGFyUG9pbnRzID0gW1xuICAgIFs1MCwgNV0sXG4gICAgWzYxLjIzLCAzOS41NV0sXG4gICAgWzk3LjU1LCAzOS41NV0sXG4gICAgWzY4LjE2LCA2MC45XSxcbiAgICBbNzkuMzksIDk1LjQ1XSxcbiAgICBbNTAsIDc0LjFdLFxuICAgIFsyMC42MSwgOTUuNDVdLFxuICAgIFszMS44NCwgNjAuOV0sXG4gICAgWzIuNDUsIDM5LjU1XSxcbiAgICBbMzguNzcsIDM5LjU1XSxcbl07XG5cbmZ1bmN0aW9uIHBhdGhTdGFyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjZW50ZXI6IEl0ZW0sIHNpemU6IG51bWJlcikge1xuICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcCBvZiBzdGFyUG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHggPSAocFswXSAtIDUwKSAqIChzaXplIC8gMTAwKSArIGNlbnRlclswXTtcbiAgICAgICAgY29uc3QgeSA9IChwWzFdIC0gNTApICogKHNpemUgLyAxMDApICsgY2VudGVyWzFdO1xuXG4gICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG59XG5cbmNvbnN0IFN0YXJTVkcgPSAoKSA9PiAoXG4gICAgPHN2ZyB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgICAgZD1cIk00Ny4xNDY4IDEzLjc4MTFDNDguMDQ0OSAxMS4wMTcyIDUxLjk1NTEgMTEuMDE3MiA1Mi44NTMyIDEzLjc4MTJMNjAuNTUyMiAzNy40NzYyQzYwLjk1MzggMzguNzEyMyA2Mi4xMDU2IDM5LjU0OTEgNjMuNDA1MyAzOS41NDkxSDg4LjMxOThDOTEuMjI2IDM5LjU0OTEgOTIuNDM0MyA0My4yNjggOTAuMDgzMSA0NC45NzYyTDY5LjkyNjkgNTkuNjIwNUM2OC44NzU1IDYwLjM4NDUgNjguNDM1NSA2MS43Mzg2IDY4LjgzNzEgNjIuOTc0Nkw3Ni41MzYxIDg2LjY2OTdDNzcuNDM0MiA4OS40MzM2IDc0LjI3MDcgOTEuNzMyIDcxLjkxOTYgOTAuMDIzOEw1MS43NjM0IDc1LjM3OTRDNTAuNzExOSA3NC42MTU1IDQ5LjI4ODEgNzQuNjE1NSA0OC4yMzY2IDc1LjM3OTVMMjguMDgwNCA5MC4wMjM4QzI1LjcyOTMgOTEuNzMyIDIyLjU2NTkgODkuNDMzNiAyMy40NjM5IDg2LjY2OTdMMzEuMTYyOSA2Mi45NzQ2QzMxLjU2NDUgNjEuNzM4NiAzMS4xMjQ1IDYwLjM4NDUgMzAuMDczMSA1OS42MjA1TDkuOTE2ODYgNDQuOTc2MkM3LjU2NTcyIDQzLjI2OCA4Ljc3NDA1IDM5LjU0OTEgMTEuNjgwMiAzOS41NDkxSDM2LjU5NDdDMzcuODk0NCAzOS41NDkxIDM5LjA0NjIgMzguNzEyMyAzOS40NDc4IDM3LjQ3NjJMNDcuMTQ2OCAxMy43ODExWlwiXG4gICAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgLz5cbiAgICA8L3N2Zz5cbik7XG5cbmNvbnN0IEVkaXRvcldyYXAgPSBzdHlsZWQuZGl2YFxuICAgIC5hY3RpdmUge1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgfVxuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDZweCAwO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1saWdodCk7XG5cbiAgICA+ICoge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAycHg7XG5cbiAgICAgICAgc3ZnIHtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuYDtcblxuY29uc3QgcmVuZGVyZXI6IEN1c3RvbVJlbmRlcmVyPFN0YXJDZWxsPiA9IHtcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgIGlzTWF0Y2g6IChjZWxsOiBDdXN0b21DZWxsKTogY2VsbCBpcyBTdGFyQ2VsbCA9PiAoY2VsbC5kYXRhIGFzIGFueSkua2luZCA9PT0gXCJzdGFyLWNlbGxcIixcbiAgICBuZWVkc0hvdmVyOiB0cnVlLFxuICAgIGRyYXc6IChhcmdzLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCB0aGVtZSwgcmVjdCwgaG92ZXJBbW91bnQgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHsgcmF0aW5nIH0gPSBjZWxsLmRhdGE7XG4gICAgICAgIGNvbnN0IHBhZFggPSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgICAgIGxldCBkcmF3WCA9IHJlY3QueCArIHBhZFg7XG4gICAgICAgIGNvbnN0IHN0YXJzID0gTWF0aC5taW4oNSwgTWF0aC5jZWlsKHJhdGluZykpO1xuICAgICAgICBkcmF3WCArPSA4O1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnM7IGkrKykge1xuICAgICAgICAgICAgcGF0aFN0YXIoY3R4LCBbZHJhd1gsIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMl0sIDE2KTtcbiAgICAgICAgICAgIGRyYXdYICs9IDE4O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42ICsgMC40ICogaG92ZXJBbW91bnQ7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJvdmlkZUVkaXRvcjogKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgICAgIHJldHVybiBwID0+IChcbiAgICAgICAgICAgIDxFZGl0b3JXcmFwPlxuICAgICAgICAgICAgICAgIHtbMCwgMSwgMiwgMywgNF0ubWFwKGluZGV4ID0+IChcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17cC52YWx1ZS5kYXRhLnJhdGluZyA8IGluZGV4ICsgMSA/IFwiaW5hY3RpdmVcIiA6IFwiYWN0aXZlXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAudmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGluZzogaW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3RhclNWRyAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvRWRpdG9yV3JhcD5cbiAgICAgICAgKTtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICh2YWwsIGQpID0+IHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlSW50KHZhbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgcmF0aW5nOiBOdW1iZXIuaXNOYU4obnVtKSA/IDAgOiBudW0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/tags-cell.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".e14vzbfa{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;padding-top:6px;color:var(--gdg-text-dark);box-sizing:border-box;}.e14vzbfa *{box-sizing:border-box;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;cursor:pointer;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label input{cursor:pointer;width:auto;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill{margin-left:8px;margin-right:6px;margin-bottom:6px;border-radius:var(--e14vzbfa-0);min-height:var(--e14vzbfa-1);padding:2px var(--e14vzbfa-2);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font:12px var(--gdg-font-family);background-color:var(--gdg-bg-bubble);-webkit-transition:box-shadow 150ms;transition:box-shadow 150ms;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill.unselected{opacity:0.8;}.e14vzbfa label:hover .pill{box-shadow:0 1px 4px rgba(0,0,0,0.15);}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label{cursor:default;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label .pill{box-shadow:none !important;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL3RhZ3MtY2VsbC50c3giXSwibmFtZXMiOlsiLmUxNHZ6YmZhIl0sIm1hcHBpbmdzIjoiQUEyQm1CQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy90YWdzLWNlbGwudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDdXN0b21DZWxsLFxuICAgIFJlY3RhbmdsZSxcbiAgICBtZWFzdXJlVGV4dENhY2hlZCxcbiAgICBDdXN0b21SZW5kZXJlcixcbiAgICBnZXRNaWRkbGVDZW50ZXJCaWFzLFxuICAgIEdyaWRDZWxsS2luZCxcbn0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgcm91bmRlZFJlY3QgfSBmcm9tIFwiLi4vZHJhdy1mbnNcIjtcblxuaW50ZXJmYWNlIFRhZ3NDZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwidGFncy1jZWxsXCI7XG4gICAgcmVhZG9ubHkgdGFnczogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgcmVhZG9ubHkgcmVhZG9ubHk/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHBvc3NpYmxlVGFnczogcmVhZG9ubHkge1xuICAgICAgICB0YWc6IHN0cmluZztcbiAgICAgICAgY29sb3I6IHN0cmluZztcbiAgICB9W107XG59XG5cbmV4cG9ydCB0eXBlIFRhZ3NDZWxsID0gQ3VzdG9tQ2VsbDxUYWdzQ2VsbFByb3BzPjtcblxuY29uc3QgdGFnSGVpZ2h0ID0gMjA7XG5jb25zdCBpbm5lclBhZCA9IDY7XG5cbmNvbnN0IEVkaXRvcldyYXAgPSBzdHlsZWQuZGl2PHsgdGFnSGVpZ2h0OiBudW1iZXI7IGlubmVyUGFkOiBudW1iZXIgfT5gXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIHBhZGRpbmctdG9wOiA2cHg7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICoge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cblxuICAgICYmJiYgbGFiZWwge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgaW5wdXQge1xuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIH1cblxuICAgICAgICAucGlsbCB7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogOHB4O1xuICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA2cHg7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA2cHg7XG5cbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6ICR7cCA9PiBwLnRhZ0hlaWdodCAvIDJ9cHg7XG4gICAgICAgICAgICBtaW4taGVpZ2h0OiAke3AgPT4gcC50YWdIZWlnaHR9cHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAycHggJHtwID0+IHAuaW5uZXJQYWR9cHg7XG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICAgICAgZm9udDogMTJweCB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctYnViYmxlKTtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYm94LXNoYWRvdyAxNTBtcztcblxuICAgICAgICAgICAgJi51bnNlbGVjdGVkIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGFiZWw6aG92ZXIgLnBpbGwge1xuICAgICAgICBib3gtc2hhZG93OiAwIDFweCA0cHggcmdiYSgwLCAwLCAwLCAwLjE1KTtcbiAgICB9XG5cbiAgICAmJiYmLnJlYWRvbmx5IGxhYmVsIHtcbiAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuXG4gICAgICAgIC5waWxsIHtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxUYWdzQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoYyk6IGMgaXMgVGFnc0NlbGwgPT4gKGMuZGF0YSBhcyBhbnkpLmtpbmQgPT09IFwidGFncy1jZWxsXCIsXG4gICAgZHJhdzogKGFyZ3MsIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHRoZW1lLCByZWN0IH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IHBvc3NpYmxlVGFncywgdGFncyB9ID0gY2VsbC5kYXRhO1xuXG4gICAgICAgIGNvbnN0IGRyYXdBcmVhOiBSZWN0YW5nbGUgPSB7XG4gICAgICAgICAgICB4OiByZWN0LnggKyB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmcsXG4gICAgICAgICAgICB5OiByZWN0LnkgKyB0aGVtZS5jZWxsVmVydGljYWxQYWRkaW5nLFxuICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLSAyICogdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAtIDIgKiB0aGVtZS5jZWxsVmVydGljYWxQYWRkaW5nLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3dzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihkcmF3QXJlYS5oZWlnaHQgLyAodGFnSGVpZ2h0ICsgaW5uZXJQYWQpKSk7XG5cbiAgICAgICAgbGV0IHggPSBkcmF3QXJlYS54O1xuICAgICAgICBsZXQgcm93ID0gMTtcbiAgICAgICAgbGV0IHkgPSBkcmF3QXJlYS55ICsgKGRyYXdBcmVhLmhlaWdodCAtIHJvd3MgKiB0YWdIZWlnaHQgLSAocm93cyAtIDEpICogaW5uZXJQYWQpIC8gMjtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwb3NzaWJsZVRhZ3MuZmluZCh0ID0+IHQudGFnID09PSB0YWcpPy5jb2xvciA/PyB0aGVtZS5iZ0J1YmJsZTtcblxuICAgICAgICAgICAgY3R4LmZvbnQgPSBgMTJweCAke3RoZW1lLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dENhY2hlZCh0YWcsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1ldHJpY3Mud2lkdGggKyBpbm5lclBhZCAqIDI7XG4gICAgICAgICAgICBjb25zdCB0ZXh0WSA9IHRhZ0hlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIGlmICh4ICE9PSBkcmF3QXJlYS54ICYmIHggKyB3aWR0aCA+IGRyYXdBcmVhLnggKyBkcmF3QXJlYS53aWR0aCAmJiByb3cgPCByb3dzKSB7XG4gICAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICAgICAgeSArPSB0YWdIZWlnaHQgKyBpbm5lclBhZDtcbiAgICAgICAgICAgICAgICB4ID0gZHJhd0FyZWEueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgcm91bmRlZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgdGFnSGVpZ2h0LCB0YWdIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0YWcsIHggKyBpbm5lclBhZCwgeSArIHRleHRZICsgZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIGAxMnB4ICR7dGhlbWUuZm9udEZhbWlseX1gKSk7XG5cbiAgICAgICAgICAgIHggKz0gd2lkdGggKyA4O1xuICAgICAgICAgICAgaWYgKHggPiBkcmF3QXJlYS54ICsgZHJhd0FyZWEud2lkdGggJiYgcm93ID49IHJvd3MpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICAgICAgcmV0dXJuIHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkNoYW5nZSwgdmFsdWUgfSA9IHA7XG4gICAgICAgICAgICBjb25zdCB7IHBvc3NpYmxlVGFncywgdGFncywgcmVhZG9ubHkgPSBmYWxzZSB9ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEVkaXRvcldyYXAgdGFnSGVpZ2h0PXt0YWdIZWlnaHR9IGlubmVyUGFkPXtpbm5lclBhZH0gY2xhc3NOYW1lPXtyZWFkb25seSA/IFwicmVhZG9ubHlcIiA6IFwiXCJ9PlxuICAgICAgICAgICAgICAgICAgICB7cG9zc2libGVUYWdzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdGFncy5pbmRleE9mKHQudGFnKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBrZXk9e3QudGFnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyFyZWFkb25seSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZGctaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17c2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VGFncyA9IHNlbGVjdGVkID8gdGFncy5maWx0ZXIoeCA9PiB4ICE9PSB0LnRhZykgOiBbLi4udGFncywgdC50YWddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogbmV3VGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1wicGlsbCBcIiArIChzZWxlY3RlZCA/IFwic2VsZWN0ZWRcIiA6IFwidW5zZWxlY3RlZFwiKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0ZWQgPyB0LmNvbG9yIDogdW5kZWZpbmVkIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3QudGFnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPC9FZGl0b3JXcmFwPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICh2LCBkKSA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICB0YWdzOiBkLnBvc3NpYmxlVGFnc1xuICAgICAgICAgICAgLm1hcCh4ID0+IHgudGFnKVxuICAgICAgICAgICAgLmZpbHRlcih4ID0+XG4gICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocyA9PiBzLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKHgpXG4gICAgICAgICAgICApLFxuICAgIH0pLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyZXI7XG4iXX0=*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/cells/src/cells/tags-cell.tsx","webpack://./packages/cells/src/cells/tags-cell.tsx"],"names":[".e14vzbfa"],"mappings":"AA2BmBA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,mBAAAA,CAAAA,eAAAA,CAAAA,0BAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,YAAAA,qBAAAA,CAAAA,CAAAA,2CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,cAAAA,CAAAA,CAAAA,iDAAAA,cAAAA,CAAAA,UAAAA,CAAAA,CAAAA,iDAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,+BAAAA,CAAAA,4BAAAA,CAAAA,6BAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,gCAAAA,CAAAA,qCAAAA,CAAAA,mCAAAA,CAAAA,2BAAAA,CAAAA,CAAAA,4DAAAA,WAAAA,CAAAA,CAAAA,4BAAAA,qCAAAA,CAAAA,CAAAA,oDAAAA,cAAAA,CAAAA,CAAAA,0DAAAA,0BAAAA,CAAAA;AC1BnB,uyQAAuyQ","sourcesContent":["import {\n    CustomCell,\n    Rectangle,\n    measureTextCached,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { roundedRect } from \"../draw-fns\";\n\ninterface TagsCellProps {\n    readonly kind: \"tags-cell\";\n    readonly tags: readonly string[];\n    readonly readonly?: boolean;\n    readonly possibleTags: readonly {\n        tag: string;\n        color: string;\n    }[];\n}\n\nexport type TagsCell = CustomCell<TagsCellProps>;\n\nconst tagHeight = 20;\nconst innerPad = 6;\n\nconst EditorWrap = styled.div<{ tagHeight: number; innerPad: number }>`\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    padding-top: 6px;\n    color: var(--gdg-text-dark);\n\n    box-sizing: border-box;\n\n    * {\n        box-sizing: border-box;\n    }\n\n    &&&& label {\n        display: flex;\n        cursor: pointer;\n\n        input {\n            cursor: pointer;\n            width: auto;\n        }\n\n        .pill {\n            margin-left: 8px;\n            margin-right: 6px;\n            margin-bottom: 6px;\n\n            border-radius: ${p => p.tagHeight / 2}px;\n            min-height: ${p => p.tagHeight}px;\n            padding: 2px ${p => p.innerPad}px;\n            display: flex;\n            align-items: center;\n\n            font: 12px var(--gdg-font-family);\n\n            background-color: var(--gdg-bg-bubble);\n\n            transition: box-shadow 150ms;\n\n            &.unselected {\n                opacity: 0.8;\n            }\n        }\n    }\n    label:hover .pill {\n        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);\n    }\n\n    &&&&.readonly label {\n        cursor: default;\n\n        .pill {\n            box-shadow: none !important;\n        }\n    }\n`;\n\nconst renderer: CustomRenderer<TagsCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is TagsCell => (c.data as any).kind === \"tags-cell\",\n    draw: (args, cell) => {\n        const { ctx, theme, rect } = args;\n        const { possibleTags, tags } = cell.data;\n\n        const drawArea: Rectangle = {\n            x: rect.x + theme.cellHorizontalPadding,\n            y: rect.y + theme.cellVerticalPadding,\n            width: rect.width - 2 * theme.cellHorizontalPadding,\n            height: rect.height - 2 * theme.cellVerticalPadding,\n        };\n        const rows = Math.max(1, Math.floor(drawArea.height / (tagHeight + innerPad)));\n\n        let x = drawArea.x;\n        let row = 1;\n        let y = drawArea.y + (drawArea.height - rows * tagHeight - (rows - 1) * innerPad) / 2;\n        for (const tag of tags) {\n            const color = possibleTags.find(t => t.tag === tag)?.color ?? theme.bgBubble;\n\n            ctx.font = `12px ${theme.fontFamily}`;\n            const metrics = measureTextCached(tag, ctx);\n            const width = metrics.width + innerPad * 2;\n            const textY = tagHeight / 2;\n\n            if (x !== drawArea.x && x + width > drawArea.x + drawArea.width && row < rows) {\n                row++;\n                y += tagHeight + innerPad;\n                x = drawArea.x;\n            }\n\n            ctx.fillStyle = color;\n            ctx.beginPath();\n            roundedRect(ctx, x, y, width, tagHeight, tagHeight / 2);\n            ctx.fill();\n\n            ctx.fillStyle = theme.textDark;\n            ctx.fillText(tag, x + innerPad, y + textY + getMiddleCenterBias(ctx, `12px ${theme.fontFamily}`));\n\n            x += width + 8;\n            if (x > drawArea.x + drawArea.width && row >= rows) break;\n        }\n\n        return true;\n    },\n    provideEditor: () => {\n        // eslint-disable-next-line react/display-name\n        return p => {\n            const { onChange, value } = p;\n            const { possibleTags, tags, readonly = false } = value.data;\n            return (\n                <EditorWrap tagHeight={tagHeight} innerPad={innerPad} className={readonly ? \"readonly\" : \"\"}>\n                    {possibleTags.map(t => {\n                        const selected = tags.indexOf(t.tag) !== -1;\n                        return (\n                            <label key={t.tag}>\n                                {!readonly && (\n                                    <input\n                                        className=\"gdg-input\"\n                                        type=\"checkbox\"\n                                        checked={selected}\n                                        onChange={() => {\n                                            const newTags = selected ? tags.filter(x => x !== t.tag) : [...tags, t.tag];\n                                            onChange({\n                                                ...p.value,\n                                                data: {\n                                                    ...value.data,\n                                                    tags: newTags,\n                                                },\n                                            });\n                                        }}\n                                    />\n                                )}\n                                <div\n                                    className={\"pill \" + (selected ? \"selected\" : \"unselected\")}\n                                    style={{ backgroundColor: selected ? t.color : undefined }}>\n                                    {t.tag}\n                                </div>\n                            </label>\n                        );\n                    })}\n                </EditorWrap>\n            );\n        };\n    },\n    onPaste: (v, d) => ({\n        ...d,\n        tags: d.possibleTags\n            .map(x => x.tag)\n            .filter(x =>\n                v\n                    .split(\",\")\n                    .map(s => s.trim())\n                    .includes(x)\n            ),\n    }),\n};\n\nexport default renderer;\n",".e14vzbfa{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;padding-top:6px;color:var(--gdg-text-dark);box-sizing:border-box;}.e14vzbfa *{box-sizing:border-box;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;cursor:pointer;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label input{cursor:pointer;width:auto;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill{margin-left:8px;margin-right:6px;margin-bottom:6px;border-radius:var(--e14vzbfa-0);min-height:var(--e14vzbfa-1);padding:2px var(--e14vzbfa-2);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font:12px var(--gdg-font-family);background-color:var(--gdg-bg-bubble);-webkit-transition:box-shadow 150ms;transition:box-shadow 150ms;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill.unselected{opacity:0.8;}.e14vzbfa label:hover .pill{box-shadow:0 1px 4px rgba(0,0,0,0.15);}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label{cursor:default;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label .pill{box-shadow:none !important;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY2VsbHMvc3JjL2NlbGxzL3RhZ3MtY2VsbC50c3giXSwibmFtZXMiOlsiLmUxNHZ6YmZhIl0sIm1hcHBpbmdzIjoiQUEyQm1CQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy90YWdzLWNlbGwudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDdXN0b21DZWxsLFxuICAgIFJlY3RhbmdsZSxcbiAgICBtZWFzdXJlVGV4dENhY2hlZCxcbiAgICBDdXN0b21SZW5kZXJlcixcbiAgICBnZXRNaWRkbGVDZW50ZXJCaWFzLFxuICAgIEdyaWRDZWxsS2luZCxcbn0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgcm91bmRlZFJlY3QgfSBmcm9tIFwiLi4vZHJhdy1mbnNcIjtcblxuaW50ZXJmYWNlIFRhZ3NDZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwidGFncy1jZWxsXCI7XG4gICAgcmVhZG9ubHkgdGFnczogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgcmVhZG9ubHkgcmVhZG9ubHk/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHBvc3NpYmxlVGFnczogcmVhZG9ubHkge1xuICAgICAgICB0YWc6IHN0cmluZztcbiAgICAgICAgY29sb3I6IHN0cmluZztcbiAgICB9W107XG59XG5cbmV4cG9ydCB0eXBlIFRhZ3NDZWxsID0gQ3VzdG9tQ2VsbDxUYWdzQ2VsbFByb3BzPjtcblxuY29uc3QgdGFnSGVpZ2h0ID0gMjA7XG5jb25zdCBpbm5lclBhZCA9IDY7XG5cbmNvbnN0IEVkaXRvcldyYXAgPSBzdHlsZWQuZGl2PHsgdGFnSGVpZ2h0OiBudW1iZXI7IGlubmVyUGFkOiBudW1iZXIgfT5gXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIHBhZGRpbmctdG9wOiA2cHg7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICoge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cblxuICAgICYmJiYgbGFiZWwge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgaW5wdXQge1xuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIH1cblxuICAgICAgICAucGlsbCB7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogOHB4O1xuICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA2cHg7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA2cHg7XG5cbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6ICR7cCA9PiBwLnRhZ0hlaWdodCAvIDJ9cHg7XG4gICAgICAgICAgICBtaW4taGVpZ2h0OiAke3AgPT4gcC50YWdIZWlnaHR9cHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAycHggJHtwID0+IHAuaW5uZXJQYWR9cHg7XG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICAgICAgZm9udDogMTJweCB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctYnViYmxlKTtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYm94LXNoYWRvdyAxNTBtcztcblxuICAgICAgICAgICAgJi51bnNlbGVjdGVkIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGFiZWw6aG92ZXIgLnBpbGwge1xuICAgICAgICBib3gtc2hhZG93OiAwIDFweCA0cHggcmdiYSgwLCAwLCAwLCAwLjE1KTtcbiAgICB9XG5cbiAgICAmJiYmLnJlYWRvbmx5IGxhYmVsIHtcbiAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuXG4gICAgICAgIC5waWxsIHtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxUYWdzQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoYyk6IGMgaXMgVGFnc0NlbGwgPT4gKGMuZGF0YSBhcyBhbnkpLmtpbmQgPT09IFwidGFncy1jZWxsXCIsXG4gICAgZHJhdzogKGFyZ3MsIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHRoZW1lLCByZWN0IH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IHBvc3NpYmxlVGFncywgdGFncyB9ID0gY2VsbC5kYXRhO1xuXG4gICAgICAgIGNvbnN0IGRyYXdBcmVhOiBSZWN0YW5nbGUgPSB7XG4gICAgICAgICAgICB4OiByZWN0LnggKyB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmcsXG4gICAgICAgICAgICB5OiByZWN0LnkgKyB0aGVtZS5jZWxsVmVydGljYWxQYWRkaW5nLFxuICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLSAyICogdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAtIDIgKiB0aGVtZS5jZWxsVmVydGljYWxQYWRkaW5nLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3dzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihkcmF3QXJlYS5oZWlnaHQgLyAodGFnSGVpZ2h0ICsgaW5uZXJQYWQpKSk7XG5cbiAgICAgICAgbGV0IHggPSBkcmF3QXJlYS54O1xuICAgICAgICBsZXQgcm93ID0gMTtcbiAgICAgICAgbGV0IHkgPSBkcmF3QXJlYS55ICsgKGRyYXdBcmVhLmhlaWdodCAtIHJvd3MgKiB0YWdIZWlnaHQgLSAocm93cyAtIDEpICogaW5uZXJQYWQpIC8gMjtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwb3NzaWJsZVRhZ3MuZmluZCh0ID0+IHQudGFnID09PSB0YWcpPy5jb2xvciA/PyB0aGVtZS5iZ0J1YmJsZTtcblxuICAgICAgICAgICAgY3R4LmZvbnQgPSBgMTJweCAke3RoZW1lLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dENhY2hlZCh0YWcsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1ldHJpY3Mud2lkdGggKyBpbm5lclBhZCAqIDI7XG4gICAgICAgICAgICBjb25zdCB0ZXh0WSA9IHRhZ0hlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIGlmICh4ICE9PSBkcmF3QXJlYS54ICYmIHggKyB3aWR0aCA+IGRyYXdBcmVhLnggKyBkcmF3QXJlYS53aWR0aCAmJiByb3cgPCByb3dzKSB7XG4gICAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICAgICAgeSArPSB0YWdIZWlnaHQgKyBpbm5lclBhZDtcbiAgICAgICAgICAgICAgICB4ID0gZHJhd0FyZWEueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgcm91bmRlZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgdGFnSGVpZ2h0LCB0YWdIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0YWcsIHggKyBpbm5lclBhZCwgeSArIHRleHRZICsgZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIGAxMnB4ICR7dGhlbWUuZm9udEZhbWlseX1gKSk7XG5cbiAgICAgICAgICAgIHggKz0gd2lkdGggKyA4O1xuICAgICAgICAgICAgaWYgKHggPiBkcmF3QXJlYS54ICsgZHJhd0FyZWEud2lkdGggJiYgcm93ID49IHJvd3MpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICAgICAgcmV0dXJuIHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkNoYW5nZSwgdmFsdWUgfSA9IHA7XG4gICAgICAgICAgICBjb25zdCB7IHBvc3NpYmxlVGFncywgdGFncywgcmVhZG9ubHkgPSBmYWxzZSB9ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEVkaXRvcldyYXAgdGFnSGVpZ2h0PXt0YWdIZWlnaHR9IGlubmVyUGFkPXtpbm5lclBhZH0gY2xhc3NOYW1lPXtyZWFkb25seSA/IFwicmVhZG9ubHlcIiA6IFwiXCJ9PlxuICAgICAgICAgICAgICAgICAgICB7cG9zc2libGVUYWdzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdGFncy5pbmRleE9mKHQudGFnKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBrZXk9e3QudGFnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyFyZWFkb25seSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZGctaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17c2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VGFncyA9IHNlbGVjdGVkID8gdGFncy5maWx0ZXIoeCA9PiB4ICE9PSB0LnRhZykgOiBbLi4udGFncywgdC50YWddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogbmV3VGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1wicGlsbCBcIiArIChzZWxlY3RlZCA/IFwic2VsZWN0ZWRcIiA6IFwidW5zZWxlY3RlZFwiKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0ZWQgPyB0LmNvbG9yIDogdW5kZWZpbmVkIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3QudGFnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPC9FZGl0b3JXcmFwPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICh2LCBkKSA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICB0YWdzOiBkLnBvc3NpYmxlVGFnc1xuICAgICAgICAgICAgLm1hcCh4ID0+IHgudGFnKVxuICAgICAgICAgICAgLmZpbHRlcih4ID0+XG4gICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocyA9PiBzLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKHgpXG4gICAgICAgICAgICApLFxuICAgIH0pLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyZXI7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor-container/data-grid-container.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".wo9gtxb{position:relative;min-width:10px;min-height:10px;max-width:100%;max-height:100%;width:var(--wo9gtxb-0);height:var(--wo9gtxb-1);overflow:hidden;overflow:clip;contain:strict;}.wo9gtxb > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3ItY29udGFpbmVyL2RhdGEtZ3JpZC1jb250YWluZXIudHN4Il0sIm5hbWVzIjpbIi53bzlndHhiIl0sIm1hcHBpbmdzIjoiQUFhZ0JBIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3ItY29udGFpbmVyL2RhdGEtZ3JpZC1jb250YWluZXIudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIFdyYXBwZXJQcm9wcyB7XG4gICAgaW5XaWR0aDogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGluSGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHRvQ3NzKHg6IG51bWJlciB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHg7XG4gICAgcmV0dXJuIGAke3h9cHhgO1xufVxuXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLmRpdjx7IGlubmVyV2lkdGg6IHN0cmluZzsgaW5uZXJIZWlnaHQ6IHN0cmluZyB9PmBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICBtaW4td2lkdGg6IDEwcHg7XG4gICAgbWluLWhlaWdodDogMTBweDtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgbWF4LWhlaWdodDogMTAwJTtcblxuICAgIHdpZHRoOiAke3AgPT4gcC5pbm5lcldpZHRofTtcbiAgICBoZWlnaHQ6ICR7cCA9PiBwLmlubmVySGVpZ2h0fTtcblxuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgb3ZlcmZsb3c6IGNsaXA7XG5cbiAgICBjb250YWluOiBzdHJpY3Q7XG5cbiAgICA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBQcm9wcyBleHRlbmRzIFdyYXBwZXJQcm9wcywgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+IHt9XG5cbmV4cG9ydCBjb25zdCBEYXRhRWRpdG9yQ29udGFpbmVyOiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxQcm9wcz4+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBpbldpZHRoLCBpbkhlaWdodCwgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IHA7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFdyYXBwZXIgaW5uZXJIZWlnaHQ9e3RvQ3NzKGluSGVpZ2h0KX0gaW5uZXJXaWR0aD17dG9Dc3MoaW5XaWR0aCl9IHsuLi5yZXN0fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9XcmFwcGVyPlxuICAgICk7XG59O1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor-container/data-grid-container.tsx","webpack://./packages/core/src/data-editor-container/data-grid-container.tsx"],"names":[".wo9gtxb"],"mappings":"AAagBA,SAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,sBAAAA,CAAAA,uBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA,cAAAA,CAAAA,CAAAA,wBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACZhB,++DAA++D","sourcesContent":["import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\n\ninterface WrapperProps {\n    inWidth: number | string;\n    inHeight: number | string;\n}\n\nfunction toCss(x: number | string) {\n    if (typeof x === \"string\") return x;\n    return `${x}px`;\n}\n\nconst Wrapper = styled.div<{ innerWidth: string; innerHeight: string }>`\n    position: relative;\n\n    min-width: 10px;\n    min-height: 10px;\n    max-width: 100%;\n    max-height: 100%;\n\n    width: ${p => p.innerWidth};\n    height: ${p => p.innerHeight};\n\n    overflow: hidden;\n    overflow: clip;\n\n    contain: strict;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\ninterface Props extends WrapperProps, React.HTMLAttributes<HTMLDivElement> {}\n\nexport const DataEditorContainer: React.FunctionComponent<React.PropsWithChildren<Props>> = p => {\n    const { inWidth, inHeight, children, ...rest } = p;\n    return (\n        <Wrapper innerHeight={toCss(inHeight)} innerWidth={toCss(inWidth)} {...rest}>\n            {children}\n        </Wrapper>\n    );\n};\n",".wo9gtxb{position:relative;min-width:10px;min-height:10px;max-width:100%;max-height:100%;width:var(--wo9gtxb-0);height:var(--wo9gtxb-1);overflow:hidden;overflow:clip;contain:strict;}.wo9gtxb > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3ItY29udGFpbmVyL2RhdGEtZ3JpZC1jb250YWluZXIudHN4Il0sIm5hbWVzIjpbIi53bzlndHhiIl0sIm1hcHBpbmdzIjoiQUFhZ0JBIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3ItY29udGFpbmVyL2RhdGEtZ3JpZC1jb250YWluZXIudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIFdyYXBwZXJQcm9wcyB7XG4gICAgaW5XaWR0aDogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGluSGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHRvQ3NzKHg6IG51bWJlciB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHg7XG4gICAgcmV0dXJuIGAke3h9cHhgO1xufVxuXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLmRpdjx7IGlubmVyV2lkdGg6IHN0cmluZzsgaW5uZXJIZWlnaHQ6IHN0cmluZyB9PmBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICBtaW4td2lkdGg6IDEwcHg7XG4gICAgbWluLWhlaWdodDogMTBweDtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgbWF4LWhlaWdodDogMTAwJTtcblxuICAgIHdpZHRoOiAke3AgPT4gcC5pbm5lcldpZHRofTtcbiAgICBoZWlnaHQ6ICR7cCA9PiBwLmlubmVySGVpZ2h0fTtcblxuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgb3ZlcmZsb3c6IGNsaXA7XG5cbiAgICBjb250YWluOiBzdHJpY3Q7XG5cbiAgICA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBQcm9wcyBleHRlbmRzIFdyYXBwZXJQcm9wcywgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+IHt9XG5cbmV4cG9ydCBjb25zdCBEYXRhRWRpdG9yQ29udGFpbmVyOiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxQcm9wcz4+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBpbldpZHRoLCBpbkhlaWdodCwgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IHA7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFdyYXBwZXIgaW5uZXJIZWlnaHQ9e3RvQ3NzKGluSGVpZ2h0KX0gaW5uZXJXaWR0aD17dG9Dc3MoaW5XaWR0aCl9IHsuLi5yZXN0fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9XcmFwcGVyPlxuICAgICk7XG59O1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/group-rename.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".r1fzhvm4{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;border:none;outline:none;background-color:var(--gdg-bg-header-has-focus);border-radius:9px;padding:0 8px;box-shadow:0 0 0 1px var(--gdg-border-color);color:var(--gdg-text-group-header);min-height:var(--r1fzhvm4-0);font:var(--gdg-header-font-style) var(--gdg-font-family);}\n.c181oggi{padding:0 8px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:var(--gdg-bg-header);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3IvZ3JvdXAtcmVuYW1lLnRzeCJdLCJuYW1lcyI6WyIucjFmemh2bTQiLCIuYzE4MW9nZ2kiXSwibWFwcGluZ3MiOiJBQWNvQkE7QUEyQkdDIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3IvZ3JvdXAtcmVuYW1lLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSBcIkBsaW5hcmlhL2NvcmVcIjtcbmltcG9ydCBDbGlja091dHNpZGVDb250YWluZXIgZnJvbSBcIi4uL2NsaWNrLW91dHNpZGUtY29udGFpbmVyL2NsaWNrLW91dHNpZGUtY29udGFpbmVyXCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHkgYm91bmRzOiBSZWN0YW5nbGU7XG4gICAgcmVhZG9ubHkgZ3JvdXA6IHN0cmluZztcbiAgICByZWFkb25seSBvbkNsb3NlOiAoKSA9PiB2b2lkO1xuICAgIHJlYWRvbmx5IG9uRmluaXNoOiAobmV3VmFsOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgY2FudmFzQm91bmRzOiBET01SZWN0O1xufVxuXG5jb25zdCBSZW5hbWVJbnB1dCA9IHN0eWxlZC5pbnB1dDx7IHRhcmdldEhlaWdodDogbnVtYmVyIH0+YFxuICAgIGZsZXgtZ3JvdzogMTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctaGVhZGVyLWhhcy1mb2N1cyk7XG4gICAgYm9yZGVyLXJhZGl1czogOXB4O1xuICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZ3JvdXAtaGVhZGVyKTtcbiAgICBtaW4taGVpZ2h0OiAke3AgPT4gTWF0aC5tYXgoMTYsIHAudGFyZ2V0SGVpZ2h0IC0gMTApfXB4O1xuICAgIGZvbnQ6IHZhcigtLWdkZy1oZWFkZXItZm9udC1zdHlsZSkgdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbmA7XG5cbmV4cG9ydCBjb25zdCBHcm91cFJlbmFtZTogUmVhY3QuVkZDPFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgYm91bmRzLCBncm91cCwgb25DbG9zZSwgY2FudmFzQm91bmRzLCBvbkZpbmlzaCB9ID0gcDtcblxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoZ3JvdXApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPENsaWNrT3V0c2lkZUNvbnRhaW5lclxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy54IC0gY2FudmFzQm91bmRzLmxlZnQgKyAxLFxuICAgICAgICAgICAgICAgIHRvcDogYm91bmRzLnkgLSBjYW52YXNCb3VuZHMudG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGggLSAyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBjbGFzc05hbWU9e2Nzc2BcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWhlYWRlcik7XG4gICAgICAgICAgICBgfVxuICAgICAgICAgICAgb25DbGlja091dHNpZGU9e29uQ2xvc2V9PlxuICAgICAgICAgICAgPFJlbmFtZUlucHV0XG4gICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0PXtib3VuZHMuaGVpZ2h0fVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwiZ3JvdXAtcmVuYW1lLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgb25CbHVyPXtvbkNsb3NlfVxuICAgICAgICAgICAgICAgIG9uRm9jdXM9e2UgPT4gZS50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgdmFsdWUubGVuZ3RoKX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiBzZXRWYWx1ZShlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRmluaXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBhdXRvRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0NsaWNrT3V0c2lkZUNvbnRhaW5lcj5cbiAgICApO1xufTtcbiJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/group-rename.tsx","webpack://./packages/core/src/data-editor/group-rename.tsx"],"names":[".r1fzhvm4",".c181oggi"],"mappings":"AAcoBA,UAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,+CAAAA,CAAAA,iBAAAA,CAAAA,aAAAA,CAAAA,4CAAAA,CAAAA,kCAAAA,CAAAA,4BAAAA,CAAAA,wDAAAA,CAAAA;AA2BGC,UAAAA,aAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,qCAAAA,CAAAA;ACvCvB,2gHAA2gH","sourcesContent":["import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { css } from \"@linaria/core\";\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container\";\nimport type { Rectangle } from \"../data-grid/data-grid-types\";\n\ninterface Props {\n    readonly bounds: Rectangle;\n    readonly group: string;\n    readonly onClose: () => void;\n    readonly onFinish: (newVal: string) => void;\n    readonly canvasBounds: DOMRect;\n}\n\nconst RenameInput = styled.input<{ targetHeight: number }>`\n    flex-grow: 1;\n    border: none;\n    outline: none;\n    background-color: var(--gdg-bg-header-has-focus);\n    border-radius: 9px;\n    padding: 0 8px;\n    box-shadow: 0 0 0 1px var(--gdg-border-color);\n    color: var(--gdg-text-group-header);\n    min-height: ${p => Math.max(16, p.targetHeight - 10)}px;\n    font: var(--gdg-header-font-style) var(--gdg-font-family);\n`;\n\nexport const GroupRename: React.VFC<Props> = p => {\n    const { bounds, group, onClose, canvasBounds, onFinish } = p;\n\n    const [value, setValue] = React.useState(group);\n\n    return (\n        <ClickOutsideContainer\n            style={{\n                position: \"absolute\",\n                left: bounds.x - canvasBounds.left + 1,\n                top: bounds.y - canvasBounds.top,\n                width: bounds.width - 2,\n                height: bounds.height,\n            }}\n            className={css`\n                padding: 0 8px;\n                display: flex;\n                align-items: center;\n                background-color: var(--gdg-bg-header);\n            `}\n            onClickOutside={onClose}>\n            <RenameInput\n                targetHeight={bounds.height}\n                data-testid=\"group-rename-input\"\n                value={value}\n                onBlur={onClose}\n                onFocus={e => e.target.setSelectionRange(0, value.length)}\n                onChange={e => setValue(e.target.value)}\n                onKeyDown={e => {\n                    if (e.key === \"Enter\") {\n                        onFinish(value);\n                    } else if (e.key === \"Escape\") {\n                        onClose();\n                    }\n                }}\n                autoFocus={true}\n            />\n        </ClickOutsideContainer>\n    );\n};\n",".r1fzhvm4{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;border:none;outline:none;background-color:var(--gdg-bg-header-has-focus);border-radius:9px;padding:0 8px;box-shadow:0 0 0 1px var(--gdg-border-color);color:var(--gdg-text-group-header);min-height:var(--r1fzhvm4-0);font:var(--gdg-header-font-style) var(--gdg-font-family);}\n.c181oggi{padding:0 8px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:var(--gdg-bg-header);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3IvZ3JvdXAtcmVuYW1lLnRzeCJdLCJuYW1lcyI6WyIucjFmemh2bTQiLCIuYzE4MW9nZ2kiXSwibWFwcGluZ3MiOiJBQWNvQkE7QUEyQkdDIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3IvZ3JvdXAtcmVuYW1lLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSBcIkBsaW5hcmlhL2NvcmVcIjtcbmltcG9ydCBDbGlja091dHNpZGVDb250YWluZXIgZnJvbSBcIi4uL2NsaWNrLW91dHNpZGUtY29udGFpbmVyL2NsaWNrLW91dHNpZGUtY29udGFpbmVyXCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHkgYm91bmRzOiBSZWN0YW5nbGU7XG4gICAgcmVhZG9ubHkgZ3JvdXA6IHN0cmluZztcbiAgICByZWFkb25seSBvbkNsb3NlOiAoKSA9PiB2b2lkO1xuICAgIHJlYWRvbmx5IG9uRmluaXNoOiAobmV3VmFsOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgY2FudmFzQm91bmRzOiBET01SZWN0O1xufVxuXG5jb25zdCBSZW5hbWVJbnB1dCA9IHN0eWxlZC5pbnB1dDx7IHRhcmdldEhlaWdodDogbnVtYmVyIH0+YFxuICAgIGZsZXgtZ3JvdzogMTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctaGVhZGVyLWhhcy1mb2N1cyk7XG4gICAgYm9yZGVyLXJhZGl1czogOXB4O1xuICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZ3JvdXAtaGVhZGVyKTtcbiAgICBtaW4taGVpZ2h0OiAke3AgPT4gTWF0aC5tYXgoMTYsIHAudGFyZ2V0SGVpZ2h0IC0gMTApfXB4O1xuICAgIGZvbnQ6IHZhcigtLWdkZy1oZWFkZXItZm9udC1zdHlsZSkgdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbmA7XG5cbmV4cG9ydCBjb25zdCBHcm91cFJlbmFtZTogUmVhY3QuVkZDPFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgYm91bmRzLCBncm91cCwgb25DbG9zZSwgY2FudmFzQm91bmRzLCBvbkZpbmlzaCB9ID0gcDtcblxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoZ3JvdXApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPENsaWNrT3V0c2lkZUNvbnRhaW5lclxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy54IC0gY2FudmFzQm91bmRzLmxlZnQgKyAxLFxuICAgICAgICAgICAgICAgIHRvcDogYm91bmRzLnkgLSBjYW52YXNCb3VuZHMudG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGggLSAyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBjbGFzc05hbWU9e2Nzc2BcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWhlYWRlcik7XG4gICAgICAgICAgICBgfVxuICAgICAgICAgICAgb25DbGlja091dHNpZGU9e29uQ2xvc2V9PlxuICAgICAgICAgICAgPFJlbmFtZUlucHV0XG4gICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0PXtib3VuZHMuaGVpZ2h0fVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwiZ3JvdXAtcmVuYW1lLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgb25CbHVyPXtvbkNsb3NlfVxuICAgICAgICAgICAgICAgIG9uRm9jdXM9e2UgPT4gZS50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgdmFsdWUubGVuZ3RoKX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiBzZXRWYWx1ZShlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRmluaXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBhdXRvRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0NsaWNrT3V0c2lkZUNvbnRhaW5lcj5cbiAgICApO1xufTtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".b1nvh7n2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.b1nvh7n2 > a{margin-bottom:20px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3Ivc3Rvcmllcy9kYXRhLWVkaXRvci1yZXByb3Muc3Rvcmllcy50c3giXSwibmFtZXMiOlsiLmIxbnZoN24yIl0sIm1hcHBpbmdzIjoiQUFzQ21CQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItcmVwcm9zLnN0b3JpZXMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAvLyBAdHMtbm9jaGVja1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgX19TVE9SWV9fID0gXCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFxcXCJyZWFjdFxcXCI7XFxuXFxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZU1lbW8gfSBmcm9tIFxcXCJAc3Rvcnlib29rL2FkZG9uc1xcXCI7XFxuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXFxcIi4uLy4uL3N0b3JpZXMvc3RvcnktdXRpbHNcXFwiO1xcblxcbmltcG9ydCB7IEdyaWRDZWxsLCBHcmlkQ2VsbEtpbmQsIEl0ZW0gfSBmcm9tIFxcXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBEYXRhRWRpdG9yIH0gZnJvbSBcXFwiLi4vZGF0YS1lZGl0b3JcXFwiO1xcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXFxcIkBsaW5hcmlhL3JlYWN0XFxcIjtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiVGVzdHMvVGVzdENhc2VzL0J1Z3NcXFwiLFxcblxcbiAgICBkZWNvcmF0b3JzOiBbXFxuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcXG4gICAgICAgICAgICA8QnVpbGRlclRoZW1lV3JhcHBlciB3aWR0aD17MTAwMH0gaGVpZ2h0PXs4MDB9PlxcbiAgICAgICAgICAgICAgICA8U3RvcnkgLz5cXG4gICAgICAgICAgICA8L0J1aWxkZXJUaGVtZVdyYXBwZXI+XFxuICAgICAgICApLFxcbiAgICBdLFxcbn07XFxuXFxuY29uc3QgYnVnNzBHZW4gPSAoWywgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XFxuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcXG4gICAgZGF0YTogcm93LFxcbiAgICBkaXNwbGF5RGF0YTogcm93LnRvU3RyaW5nKCksXFxufSk7XFxuXFxuY29uc3QgaWdub3JlID0gKCkgPT4gdW5kZWZpbmVkO1xcblxcbmNvbnN0IEJ1ZzcwU3R5bGUgPSBzdHlsZWQuZGl2YFxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcblxcbiAgICA+IGEge1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG4gICAgfVxcbmA7XFxuXFxuZXhwb3J0IGZ1bmN0aW9uIEJ1ZzcwKCkge1xcbiAgICBjb25zdCBjb2xzID0gW1xcbiAgICAgICAgeyB0aXRsZTogXFxcIkNvbDFcXFwiLCB3aWR0aDogMTAwIH0sXFxuICAgICAgICB7IHRpdGxlOiBcXFwiQ29sMlxcXCIsIHdpZHRoOiAxMDAgfSxcXG4gICAgXTtcXG5cXG4gICAgcmV0dXJuIChcXG4gICAgICAgIDxCdWc3MFN0eWxlIGNsYXNzTmFtZT1cXFwiQXBwXFxcIj5cXG4gICAgICAgICAgICA8cD5UbyBjYXVzZSBlcnJvcjogc2Nyb2xsIGRvd24gYXQgbGVhc3Qgb25lIHJvdywgZWRpdCBhIGNlbGwgaW4gQ29sMiwgYW5kIGhpdCBUYWI8L3A+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2dsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvaXNzdWVzLzcwXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgcmVsPVxcXCJub3JlZmVycmVyXFxcIj5cXG4gICAgICAgICAgICAgICAgT3JpZ2luYWwgcmVwb3J0XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHdpZHRoPXs1MDB9XFxuICAgICAgICAgICAgICAgIGhlaWdodD17NTAwfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtidWc3MEdlbn1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtpZ25vcmV9XFxuICAgICAgICAgICAgLz5cXG4gICAgICAgIDwvQnVnNzBTdHlsZT5cXG4gICAgKTtcXG59XFxuXFxuY29uc3QgZmlsdGVyQ29sdW1uc0dlbiA9IChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4gKHtcXG4gICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcXG4gICAgZGF0YTogYCR7Y29sfSAtICR7cm93fWAsXFxuICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9IC0gJHtyb3d9YCxcXG59KTtcXG5cXG5jb25zdCBmaWx0ZXJpbmdDb2x1bW5zID0gW1xcbiAgICB7IHRpdGxlOiBcXFwiQ29sIEFBQUFcXFwiLCB3aWR0aDogMTIwIH0sXFxuICAgIHsgdGl0bGU6IFxcXCJDb2wgQUFBXFxcIiwgd2lkdGg6IDEyMCB9LFxcbiAgICB7IHRpdGxlOiBcXFwiQ29sIEFBXFxcIiwgd2lkdGg6IDEyMCB9LFxcbiAgICB7IHRpdGxlOiBcXFwiQ29sIEFcXFwiLCB3aWR0aDogMTIwIH0sXFxuICAgIHsgdGl0bGU6IFxcXCJDb2xcXFwiLCB3aWR0aDogMTIwIH0sXFxuXTtcXG5cXG5leHBvcnQgZnVuY3Rpb24gRmlsdGVyQ29sdW1ucygpIHtcXG4gICAgY29uc3QgW3NlYXJjaFRleHQsIHNldFNlYXJjaFRleHRdID0gdXNlU3RhdGUoXFxcIlxcXCIpO1xcblxcbiAgICBjb25zdCBjb2xzID0gdXNlTWVtbygoKSA9PiB7XFxuICAgICAgICBpZiAoc2VhcmNoVGV4dCA9PT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBmaWx0ZXJpbmdDb2x1bW5zLmZpbHRlcihjID0+IGMudGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXh0LnRvTG93ZXJDYXNlKCkpKTtcXG4gICAgfSwgW3NlYXJjaFRleHRdKTtcXG5cXG4gICAgY29uc3Qgb25JbnB1dENoYW5nZSA9IChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xcbiAgICAgICAgc2V0U2VhcmNoVGV4dChlLnRhcmdldC52YWx1ZSk7XFxuICAgIH07XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT17c2VhcmNoVGV4dH0gb25DaGFuZ2U9e29uSW5wdXRDaGFuZ2V9IC8+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgd2lkdGg9ezEwMDB9XFxuICAgICAgICAgICAgICAgIGhlaWdodD17NTAwfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtmaWx0ZXJDb2x1bW5zR2VufVxcbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxYPXt0cnVlfVxcbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxZPXt0cnVlfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgKTtcXG59XFxuXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX0xPQ0FUSU9OU19NQVBfXyA9IHtcIkJ1ZzcwXCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjo3LFwibGluZVwiOjQwfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6NjJ9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6NyxcImxpbmVcIjo0MH0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjo2Mn19LFwiRmlsdGVyQ29sdW1uc1wiOntcInN0YXJ0TG9jXCI6e1wiY29sXCI6NyxcImxpbmVcIjo3OX0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjEwOH0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo3LFwibGluZVwiOjc5fSxcImVuZEJvZHlcIjp7XCJjb2xcIjoxLFwibGluZVwiOjEwOH19fTtcbiAgICBcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gXCJAc3Rvcnlib29rL2FkZG9uc1wiO1xuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5cbmltcG9ydCB7IEdyaWRDZWxsLCBHcmlkQ2VsbEtpbmQsIEl0ZW0gfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtwYXJhbWV0ZXJzOiB7XCJzdG9yeVNvdXJjZVwiOntcInNvdXJjZVwiOlwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcXFwicmVhY3RcXFwiO1xcblxcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VNZW1vIH0gZnJvbSBcXFwiQHN0b3J5Ym9vay9hZGRvbnNcXFwiO1xcbmltcG9ydCB7IEJ1aWxkZXJUaGVtZVdyYXBwZXIgfSBmcm9tIFxcXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXFxcIjtcXG5cXG5pbXBvcnQgeyBHcmlkQ2VsbCwgR3JpZENlbGxLaW5kLCBJdGVtIH0gZnJvbSBcXFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1xcXCI7XFxuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXFxcIi4uL2RhdGEtZWRpdG9yXFxcIjtcXG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFxcXCJAbGluYXJpYS9yZWFjdFxcXCI7XFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICB0aXRsZTogXFxcIlRlc3RzL1Rlc3RDYXNlcy9CdWdzXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPEJ1aWxkZXJUaGVtZVdyYXBwZXIgd2lkdGg9ezEwMDB9IGhlaWdodD17ODAwfT5cXG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgPC9CdWlsZGVyVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmNvbnN0IGJ1ZzcwR2VuID0gKFssIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xcbiAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5OdW1iZXIsXFxuICAgIGRhdGE6IHJvdyxcXG4gICAgZGlzcGxheURhdGE6IHJvdy50b1N0cmluZygpLFxcbn0pO1xcblxcbmNvbnN0IGlnbm9yZSA9ICgpID0+IHVuZGVmaW5lZDtcXG5cXG5jb25zdCBCdWc3MFN0eWxlID0gc3R5bGVkLmRpdmBcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG5cXG4gICAgPiBhIHtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XFxuICAgIH1cXG5gO1xcblxcbmV4cG9ydCBmdW5jdGlvbiBCdWc3MCgpIHtcXG4gICAgY29uc3QgY29scyA9IFtcXG4gICAgICAgIHsgdGl0bGU6IFxcXCJDb2wxXFxcIiwgd2lkdGg6IDEwMCB9LFxcbiAgICAgICAgeyB0aXRsZTogXFxcIkNvbDJcXFwiLCB3aWR0aDogMTAwIH0sXFxuICAgIF07XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QnVnNzBTdHlsZSBjbGFzc05hbWU9XFxcIkFwcFxcXCI+XFxuICAgICAgICAgICAgPHA+VG8gY2F1c2UgZXJyb3I6IHNjcm9sbCBkb3duIGF0IGxlYXN0IG9uZSByb3csIGVkaXQgYSBjZWxsIGluIENvbDIsIGFuZCBoaXQgVGFiPC9wPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9nbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2lzc3Vlcy83MFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIHJlbD1cXFwibm9yZWZlcnJlclxcXCI+XFxuICAgICAgICAgICAgICAgIE9yaWdpbmFsIHJlcG9ydFxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8RGF0YUVkaXRvclxcbiAgICAgICAgICAgICAgICB3aWR0aD17NTAwfVxcbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezUwMH1cXG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17YnVnNzBHZW59XFxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17aWdub3JlfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0J1ZzcwU3R5bGU+XFxuICAgICk7XFxufVxcblxcbmNvbnN0IGZpbHRlckNvbHVtbnNHZW4gPSAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XFxuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXFxuICAgIGRhdGE6IGAke2NvbH0gLSAke3Jvd31gLFxcbiAgICBkaXNwbGF5RGF0YTogYCR7Y29sfSAtICR7cm93fWAsXFxufSk7XFxuXFxuY29uc3QgZmlsdGVyaW5nQ29sdW1ucyA9IFtcXG4gICAgeyB0aXRsZTogXFxcIkNvbCBBQUFBXFxcIiwgd2lkdGg6IDEyMCB9LFxcbiAgICB7IHRpdGxlOiBcXFwiQ29sIEFBQVxcXCIsIHdpZHRoOiAxMjAgfSxcXG4gICAgeyB0aXRsZTogXFxcIkNvbCBBQVxcXCIsIHdpZHRoOiAxMjAgfSxcXG4gICAgeyB0aXRsZTogXFxcIkNvbCBBXFxcIiwgd2lkdGg6IDEyMCB9LFxcbiAgICB7IHRpdGxlOiBcXFwiQ29sXFxcIiwgd2lkdGg6IDEyMCB9LFxcbl07XFxuXFxuZXhwb3J0IGZ1bmN0aW9uIEZpbHRlckNvbHVtbnMoKSB7XFxuICAgIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKFxcXCJcXFwiKTtcXG5cXG4gICAgY29uc3QgY29scyA9IHVzZU1lbW8oKCkgPT4ge1xcbiAgICAgICAgaWYgKHNlYXJjaFRleHQgPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmluZ0NvbHVtbnM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucy5maWx0ZXIoYyA9PiBjLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpKSk7XFxuICAgIH0sIFtzZWFyY2hUZXh0XSk7XFxuXFxuICAgIGNvbnN0IG9uSW5wdXRDaGFuZ2UgPSAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcXG4gICAgICAgIHNldFNlYXJjaFRleHQoZS50YXJnZXQudmFsdWUpO1xcbiAgICB9O1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9e3NlYXJjaFRleHR9IG9uQ2hhbmdlPXtvbklucHV0Q2hhbmdlfSAvPlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHdpZHRoPXsxMDAwfVxcbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezUwMH1cXG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17ZmlsdGVyQ29sdW1uc0dlbn1cXG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17dHJ1ZX1cXG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17dHJ1ZX1cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICk7XFxufVxcblwiLFwibG9jYXRpb25zTWFwXCI6e1wiYnVnLTcwXCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjo3LFwibGluZVwiOjQwfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6NjJ9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6NyxcImxpbmVcIjo0MH0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjo2Mn19LFwiZmlsdGVyLWNvbHVtbnNcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjcsXCJsaW5lXCI6Nzl9LFwiZW5kTG9jXCI6e1wiY29sXCI6MSxcImxpbmVcIjoxMDh9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6NyxcImxpbmVcIjo3OX0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjoxMDh9fX19LH0sXG4gICAgdGl0bGU6IFwiVGVzdHMvVGVzdENhc2VzL0J1Z3NcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8QnVpbGRlclRoZW1lV3JhcHBlciB3aWR0aD17MTAwMH0gaGVpZ2h0PXs4MDB9PlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9CdWlsZGVyVGhlbWVXcmFwcGVyPlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5jb25zdCBidWc3MEdlbiA9IChbLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4gKHtcbiAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICBkYXRhOiByb3csXG4gICAgZGlzcGxheURhdGE6IHJvdy50b1N0cmluZygpLFxufSk7XG5cbmNvbnN0IGlnbm9yZSA9ICgpID0+IHVuZGVmaW5lZDtcblxuY29uc3QgQnVnNzBTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXG4gICAgPiBhIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgQnVnNzAgPSBmdW5jdGlvbiBCdWc3MCgpIHtcbiAgICBjb25zdCBjb2xzID0gW1xuICAgICAgICB7IHRpdGxlOiBcIkNvbDFcIiwgd2lkdGg6IDEwMCB9LFxuICAgICAgICB7IHRpdGxlOiBcIkNvbDJcIiwgd2lkdGg6IDEwMCB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QnVnNzBTdHlsZSBjbGFzc05hbWU9XCJBcHBcIj5cbiAgICAgICAgICAgIDxwPlRvIGNhdXNlIGVycm9yOiBzY3JvbGwgZG93biBhdCBsZWFzdCBvbmUgcm93LCBlZGl0IGEgY2VsbCBpbiBDb2wyLCBhbmQgaGl0IFRhYjwvcD5cbiAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9pc3N1ZXMvNzBcIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyXCI+XG4gICAgICAgICAgICAgICAgT3JpZ2luYWwgcmVwb3J0XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHdpZHRoPXs1MDB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXs1MDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2J1ZzcwR2VufVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17aWdub3JlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CdWc3MFN0eWxlPlxuICAgICk7XG59O1xuXG5jb25zdCBmaWx0ZXJDb2x1bW5zR2VuID0gKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICBkYXRhOiBgJHtjb2x9IC0gJHtyb3d9YCxcbiAgICBkaXNwbGF5RGF0YTogYCR7Y29sfSAtICR7cm93fWAsXG59KTtcblxuY29uc3QgZmlsdGVyaW5nQ29sdW1ucyA9IFtcbiAgICB7IHRpdGxlOiBcIkNvbCBBQUFBXCIsIHdpZHRoOiAxMjAgfSxcbiAgICB7IHRpdGxlOiBcIkNvbCBBQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFBXCIsIHdpZHRoOiAxMjAgfSxcbiAgICB7IHRpdGxlOiBcIkNvbCBBXCIsIHdpZHRoOiAxMjAgfSxcbiAgICB7IHRpdGxlOiBcIkNvbFwiLCB3aWR0aDogMTIwIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgRmlsdGVyQ29sdW1ucyA9IGZ1bmN0aW9uIEZpbHRlckNvbHVtbnMoKSB7XG4gICAgY29uc3QgW3NlYXJjaFRleHQsIHNldFNlYXJjaFRleHRdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgICBjb25zdCBjb2xzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzZWFyY2hUZXh0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXJpbmdDb2x1bW5zLmZpbHRlcihjID0+IGMudGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXh0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICB9LCBbc2VhcmNoVGV4dF0pO1xuXG4gICAgY29uc3Qgb25JbnB1dENoYW5nZSA9IChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgICAgICBzZXRTZWFyY2hUZXh0KGUudGFyZ2V0LnZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT17c2VhcmNoVGV4dH0gb25DaGFuZ2U9e29uSW5wdXRDaGFuZ2V9IC8+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHdpZHRoPXsxMDAwfVxuICAgICAgICAgICAgICAgIGhlaWdodD17NTAwfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtmaWx0ZXJDb2x1bW5zR2VufVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3RydWV9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17dHJ1ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59OyJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/stories/data-editor-repros.stories.tsx","webpack://./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx"],"names":[".b1nvh7n2"],"mappings":"AAsCmBA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,cAAAA,kBAAAA,CAAAA;ACrCnB,m2bAAm2b","sourcesContent":["\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import * as React from \\\"react\\\";\\n\\nimport { useState, useMemo } from \\\"@storybook/addons\\\";\\nimport { BuilderThemeWrapper } from \\\"../../stories/story-utils\\\";\\n\\nimport { GridCell, GridCellKind, Item } from \\\"../../data-grid/data-grid-types\\\";\\nimport { DataEditor } from \\\"../data-editor\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\n\\nexport default {\\n    title: \\\"Tests/TestCases/Bugs\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <BuilderThemeWrapper width={1000} height={800}>\\n                <Story />\\n            </BuilderThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst bug70Gen = ([, row]: Item): GridCell => ({\\n    allowOverlay: true,\\n    kind: GridCellKind.Number,\\n    data: row,\\n    displayData: row.toString(),\\n});\\n\\nconst ignore = () => undefined;\\n\\nconst Bug70Style = styled.div`\\n    display: flex;\\n    flex-direction: column;\\n\\n    > a {\\n        margin-bottom: 20px;\\n    }\\n`;\\n\\nexport function Bug70() {\\n    const cols = [\\n        { title: \\\"Col1\\\", width: 100 },\\n        { title: \\\"Col2\\\", width: 100 },\\n    ];\\n\\n    return (\\n        <Bug70Style className=\\\"App\\\">\\n            <p>To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab</p>\\n            <a href=\\\"https://github.com/glideapps/glide-data-grid/issues/70\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">\\n                Original report\\n            </a>\\n            <DataEditor\\n                width={500}\\n                height={500}\\n                rows={100}\\n                columns={cols}\\n                getCellContent={bug70Gen}\\n                onCellEdited={ignore}\\n            />\\n        </Bug70Style>\\n    );\\n}\\n\\nconst filterColumnsGen = ([col, row]: Item): GridCell => ({\\n    allowOverlay: true,\\n    kind: GridCellKind.Text,\\n    data: `${col} - ${row}`,\\n    displayData: `${col} - ${row}`,\\n});\\n\\nconst filteringColumns = [\\n    { title: \\\"Col AAAA\\\", width: 120 },\\n    { title: \\\"Col AAA\\\", width: 120 },\\n    { title: \\\"Col AA\\\", width: 120 },\\n    { title: \\\"Col A\\\", width: 120 },\\n    { title: \\\"Col\\\", width: 120 },\\n];\\n\\nexport function FilterColumns() {\\n    const [searchText, setSearchText] = useState(\\\"\\\");\\n\\n    const cols = useMemo(() => {\\n        if (searchText === \\\"\\\") {\\n            return filteringColumns;\\n        }\\n\\n        return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));\\n    }, [searchText]);\\n\\n    const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n        setSearchText(e.target.value);\\n    };\\n\\n    return (\\n        <div>\\n            <input value={searchText} onChange={onInputChange} />\\n            <DataEditor\\n                width={1000}\\n                height={500}\\n                rows={100}\\n                columns={cols}\\n                getCellContent={filterColumnsGen}\\n                smoothScrollX={true}\\n                smoothScrollY={true}\\n            />\\n        </div>\\n    );\\n}\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Bug70\":{\"startLoc\":{\"col\":7,\"line\":40},\"endLoc\":{\"col\":1,\"line\":62},\"startBody\":{\"col\":7,\"line\":40},\"endBody\":{\"col\":1,\"line\":62}},\"FilterColumns\":{\"startLoc\":{\"col\":7,\"line\":79},\"endLoc\":{\"col\":1,\"line\":108},\"startBody\":{\"col\":7,\"line\":79},\"endBody\":{\"col\":1,\"line\":108}}};\n    \nimport * as React from \"react\";\n\nimport { useState, useMemo } from \"@storybook/addons\";\nimport { BuilderThemeWrapper } from \"../../stories/story-utils\";\n\nimport { GridCell, GridCellKind, Item } from \"../../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor\";\nimport { styled } from \"@linaria/react\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"import * as React from \\\"react\\\";\\n\\nimport { useState, useMemo } from \\\"@storybook/addons\\\";\\nimport { BuilderThemeWrapper } from \\\"../../stories/story-utils\\\";\\n\\nimport { GridCell, GridCellKind, Item } from \\\"../../data-grid/data-grid-types\\\";\\nimport { DataEditor } from \\\"../data-editor\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\n\\nexport default {\\n    title: \\\"Tests/TestCases/Bugs\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <BuilderThemeWrapper width={1000} height={800}>\\n                <Story />\\n            </BuilderThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst bug70Gen = ([, row]: Item): GridCell => ({\\n    allowOverlay: true,\\n    kind: GridCellKind.Number,\\n    data: row,\\n    displayData: row.toString(),\\n});\\n\\nconst ignore = () => undefined;\\n\\nconst Bug70Style = styled.div`\\n    display: flex;\\n    flex-direction: column;\\n\\n    > a {\\n        margin-bottom: 20px;\\n    }\\n`;\\n\\nexport function Bug70() {\\n    const cols = [\\n        { title: \\\"Col1\\\", width: 100 },\\n        { title: \\\"Col2\\\", width: 100 },\\n    ];\\n\\n    return (\\n        <Bug70Style className=\\\"App\\\">\\n            <p>To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab</p>\\n            <a href=\\\"https://github.com/glideapps/glide-data-grid/issues/70\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">\\n                Original report\\n            </a>\\n            <DataEditor\\n                width={500}\\n                height={500}\\n                rows={100}\\n                columns={cols}\\n                getCellContent={bug70Gen}\\n                onCellEdited={ignore}\\n            />\\n        </Bug70Style>\\n    );\\n}\\n\\nconst filterColumnsGen = ([col, row]: Item): GridCell => ({\\n    allowOverlay: true,\\n    kind: GridCellKind.Text,\\n    data: `${col} - ${row}`,\\n    displayData: `${col} - ${row}`,\\n});\\n\\nconst filteringColumns = [\\n    { title: \\\"Col AAAA\\\", width: 120 },\\n    { title: \\\"Col AAA\\\", width: 120 },\\n    { title: \\\"Col AA\\\", width: 120 },\\n    { title: \\\"Col A\\\", width: 120 },\\n    { title: \\\"Col\\\", width: 120 },\\n];\\n\\nexport function FilterColumns() {\\n    const [searchText, setSearchText] = useState(\\\"\\\");\\n\\n    const cols = useMemo(() => {\\n        if (searchText === \\\"\\\") {\\n            return filteringColumns;\\n        }\\n\\n        return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));\\n    }, [searchText]);\\n\\n    const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n        setSearchText(e.target.value);\\n    };\\n\\n    return (\\n        <div>\\n            <input value={searchText} onChange={onInputChange} />\\n            <DataEditor\\n                width={1000}\\n                height={500}\\n                rows={100}\\n                columns={cols}\\n                getCellContent={filterColumnsGen}\\n                smoothScrollX={true}\\n                smoothScrollY={true}\\n            />\\n        </div>\\n    );\\n}\\n\",\"locationsMap\":{\"bug-70\":{\"startLoc\":{\"col\":7,\"line\":40},\"endLoc\":{\"col\":1,\"line\":62},\"startBody\":{\"col\":7,\"line\":40},\"endBody\":{\"col\":1,\"line\":62}},\"filter-columns\":{\"startLoc\":{\"col\":7,\"line\":79},\"endLoc\":{\"col\":1,\"line\":108},\"startBody\":{\"col\":7,\"line\":79},\"endBody\":{\"col\":1,\"line\":108}}}},},\n    title: \"Tests/TestCases/Bugs\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <BuilderThemeWrapper width={1000} height={800}>\n                <Story />\n            </BuilderThemeWrapper>\n        ),\n    ],\n};\n\nconst bug70Gen = ([, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Number,\n    data: row,\n    displayData: row.toString(),\n});\n\nconst ignore = () => undefined;\n\nconst Bug70Style = styled.div`\n    display: flex;\n    flex-direction: column;\n\n    > a {\n        margin-bottom: 20px;\n    }\n`;\n\nexport const Bug70 = function Bug70() {\n    const cols = [\n        { title: \"Col1\", width: 100 },\n        { title: \"Col2\", width: 100 },\n    ];\n\n    return (\n        <Bug70Style className=\"App\">\n            <p>To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab</p>\n            <a href=\"https://github.com/glideapps/glide-data-grid/issues/70\" target=\"_blank\" rel=\"noreferrer\">\n                Original report\n            </a>\n            <DataEditor\n                width={500}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={bug70Gen}\n                onCellEdited={ignore}\n            />\n        </Bug70Style>\n    );\n};\n\nconst filterColumnsGen = ([col, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Text,\n    data: `${col} - ${row}`,\n    displayData: `${col} - ${row}`,\n});\n\nconst filteringColumns = [\n    { title: \"Col AAAA\", width: 120 },\n    { title: \"Col AAA\", width: 120 },\n    { title: \"Col AA\", width: 120 },\n    { title: \"Col A\", width: 120 },\n    { title: \"Col\", width: 120 },\n];\n\nexport const FilterColumns = function FilterColumns() {\n    const [searchText, setSearchText] = useState(\"\");\n\n    const cols = useMemo(() => {\n        if (searchText === \"\") {\n            return filteringColumns;\n        }\n\n        return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));\n    }, [searchText]);\n\n    const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        setSearchText(e.target.value);\n    };\n\n    return (\n        <div>\n            <input value={searchText} onChange={onInputChange} />\n            <DataEditor\n                width={1000}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={filterColumnsGen}\n                smoothScrollX={true}\n                smoothScrollY={true}\n            />\n        </div>\n    );\n};",".b1nvh7n2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.b1nvh7n2 > a{margin-bottom:20px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3Ivc3Rvcmllcy9kYXRhLWVkaXRvci1yZXByb3Muc3Rvcmllcy50c3giXSwibmFtZXMiOlsiLmIxbnZoN24yIl0sIm1hcHBpbmdzIjoiQUFzQ21CQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItcmVwcm9zLnN0b3JpZXMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAvLyBAdHMtbm9jaGVja1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgX19TVE9SWV9fID0gXCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFxcXCJyZWFjdFxcXCI7XFxuXFxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZU1lbW8gfSBmcm9tIFxcXCJAc3Rvcnlib29rL2FkZG9uc1xcXCI7XFxuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXFxcIi4uLy4uL3N0b3JpZXMvc3RvcnktdXRpbHNcXFwiO1xcblxcbmltcG9ydCB7IEdyaWRDZWxsLCBHcmlkQ2VsbEtpbmQsIEl0ZW0gfSBmcm9tIFxcXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBEYXRhRWRpdG9yIH0gZnJvbSBcXFwiLi4vZGF0YS1lZGl0b3JcXFwiO1xcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXFxcIkBsaW5hcmlhL3JlYWN0XFxcIjtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiVGVzdHMvVGVzdENhc2VzL0J1Z3NcXFwiLFxcblxcbiAgICBkZWNvcmF0b3JzOiBbXFxuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcXG4gICAgICAgICAgICA8QnVpbGRlclRoZW1lV3JhcHBlciB3aWR0aD17MTAwMH0gaGVpZ2h0PXs4MDB9PlxcbiAgICAgICAgICAgICAgICA8U3RvcnkgLz5cXG4gICAgICAgICAgICA8L0J1aWxkZXJUaGVtZVdyYXBwZXI+XFxuICAgICAgICApLFxcbiAgICBdLFxcbn07XFxuXFxuY29uc3QgYnVnNzBHZW4gPSAoWywgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XFxuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcXG4gICAgZGF0YTogcm93LFxcbiAgICBkaXNwbGF5RGF0YTogcm93LnRvU3RyaW5nKCksXFxufSk7XFxuXFxuY29uc3QgaWdub3JlID0gKCkgPT4gdW5kZWZpbmVkO1xcblxcbmNvbnN0IEJ1ZzcwU3R5bGUgPSBzdHlsZWQuZGl2YFxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcblxcbiAgICA+IGEge1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG4gICAgfVxcbmA7XFxuXFxuZXhwb3J0IGZ1bmN0aW9uIEJ1ZzcwKCkge1xcbiAgICBjb25zdCBjb2xzID0gW1xcbiAgICAgICAgeyB0aXRsZTogXFxcIkNvbDFcXFwiLCB3aWR0aDogMTAwIH0sXFxuICAgICAgICB7IHRpdGxlOiBcXFwiQ29sMlxcXCIsIHdpZHRoOiAxMDAgfSxcXG4gICAgXTtcXG5cXG4gICAgcmV0dXJuIChcXG4gICAgICAgIDxCdWc3MFN0eWxlIGNsYXNzTmFtZT1cXFwiQXBwXFxcIj5cXG4gICAgICAgICAgICA8cD5UbyBjYXVzZSBlcnJvcjogc2Nyb2xsIGRvd24gYXQgbGVhc3Qgb25lIHJvdywgZWRpdCBhIGNlbGwgaW4gQ29sMiwgYW5kIGhpdCBUYWI8L3A+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2dsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvaXNzdWVzLzcwXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgcmVsPVxcXCJub3JlZmVycmVyXFxcIj5cXG4gICAgICAgICAgICAgICAgT3JpZ2luYWwgcmVwb3J0XFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHdpZHRoPXs1MDB9XFxuICAgICAgICAgICAgICAgIGhlaWdodD17NTAwfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtidWc3MEdlbn1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtpZ25vcmV9XFxuICAgICAgICAgICAgLz5cXG4gICAgICAgIDwvQnVnNzBTdHlsZT5cXG4gICAgKTtcXG59XFxuXFxuY29uc3QgZmlsdGVyQ29sdW1uc0dlbiA9IChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4gKHtcXG4gICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcXG4gICAgZGF0YTogYCR7Y29sfSAtICR7cm93fWAsXFxuICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9IC0gJHtyb3d9YCxcXG59KTtcXG5cXG5jb25zdCBmaWx0ZXJpbmdDb2x1bW5zID0gW1xcbiAgICB7IHRpdGxlOiBcXFwiQ29sIEFBQUFcXFwiLCB3aWR0aDogMTIwIH0sXFxuICAgIHsgdGl0bGU6IFxcXCJDb2wgQUFBXFxcIiwgd2lkdGg6IDEyMCB9LFxcbiAgICB7IHRpdGxlOiBcXFwiQ29sIEFBXFxcIiwgd2lkdGg6IDEyMCB9LFxcbiAgICB7IHRpdGxlOiBcXFwiQ29sIEFcXFwiLCB3aWR0aDogMTIwIH0sXFxuICAgIHsgdGl0bGU6IFxcXCJDb2xcXFwiLCB3aWR0aDogMTIwIH0sXFxuXTtcXG5cXG5leHBvcnQgZnVuY3Rpb24gRmlsdGVyQ29sdW1ucygpIHtcXG4gICAgY29uc3QgW3NlYXJjaFRleHQsIHNldFNlYXJjaFRleHRdID0gdXNlU3RhdGUoXFxcIlxcXCIpO1xcblxcbiAgICBjb25zdCBjb2xzID0gdXNlTWVtbygoKSA9PiB7XFxuICAgICAgICBpZiAoc2VhcmNoVGV4dCA9PT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBmaWx0ZXJpbmdDb2x1bW5zLmZpbHRlcihjID0+IGMudGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXh0LnRvTG93ZXJDYXNlKCkpKTtcXG4gICAgfSwgW3NlYXJjaFRleHRdKTtcXG5cXG4gICAgY29uc3Qgb25JbnB1dENoYW5nZSA9IChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xcbiAgICAgICAgc2V0U2VhcmNoVGV4dChlLnRhcmdldC52YWx1ZSk7XFxuICAgIH07XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT17c2VhcmNoVGV4dH0gb25DaGFuZ2U9e29uSW5wdXRDaGFuZ2V9IC8+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgd2lkdGg9ezEwMDB9XFxuICAgICAgICAgICAgICAgIGhlaWdodD17NTAwfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtmaWx0ZXJDb2x1bW5zR2VufVxcbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxYPXt0cnVlfVxcbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxZPXt0cnVlfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgKTtcXG59XFxuXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX0xPQ0FUSU9OU19NQVBfXyA9IHtcIkJ1ZzcwXCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjo3LFwibGluZVwiOjQwfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6NjJ9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6NyxcImxpbmVcIjo0MH0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjo2Mn19LFwiRmlsdGVyQ29sdW1uc1wiOntcInN0YXJ0TG9jXCI6e1wiY29sXCI6NyxcImxpbmVcIjo3OX0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjEwOH0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo3LFwibGluZVwiOjc5fSxcImVuZEJvZHlcIjp7XCJjb2xcIjoxLFwibGluZVwiOjEwOH19fTtcbiAgICBcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gXCJAc3Rvcnlib29rL2FkZG9uc1wiO1xuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5cbmltcG9ydCB7IEdyaWRDZWxsLCBHcmlkQ2VsbEtpbmQsIEl0ZW0gfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtwYXJhbWV0ZXJzOiB7XCJzdG9yeVNvdXJjZVwiOntcInNvdXJjZVwiOlwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcXFwicmVhY3RcXFwiO1xcblxcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VNZW1vIH0gZnJvbSBcXFwiQHN0b3J5Ym9vay9hZGRvbnNcXFwiO1xcbmltcG9ydCB7IEJ1aWxkZXJUaGVtZVdyYXBwZXIgfSBmcm9tIFxcXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXFxcIjtcXG5cXG5pbXBvcnQgeyBHcmlkQ2VsbCwgR3JpZENlbGxLaW5kLCBJdGVtIH0gZnJvbSBcXFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1xcXCI7XFxuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXFxcIi4uL2RhdGEtZWRpdG9yXFxcIjtcXG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFxcXCJAbGluYXJpYS9yZWFjdFxcXCI7XFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICB0aXRsZTogXFxcIlRlc3RzL1Rlc3RDYXNlcy9CdWdzXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPEJ1aWxkZXJUaGVtZVdyYXBwZXIgd2lkdGg9ezEwMDB9IGhlaWdodD17ODAwfT5cXG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgPC9CdWlsZGVyVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmNvbnN0IGJ1ZzcwR2VuID0gKFssIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xcbiAgICBhbGxvd092ZXJsYXk6IHRydWUsXFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5OdW1iZXIsXFxuICAgIGRhdGE6IHJvdyxcXG4gICAgZGlzcGxheURhdGE6IHJvdy50b1N0cmluZygpLFxcbn0pO1xcblxcbmNvbnN0IGlnbm9yZSA9ICgpID0+IHVuZGVmaW5lZDtcXG5cXG5jb25zdCBCdWc3MFN0eWxlID0gc3R5bGVkLmRpdmBcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG5cXG4gICAgPiBhIHtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XFxuICAgIH1cXG5gO1xcblxcbmV4cG9ydCBmdW5jdGlvbiBCdWc3MCgpIHtcXG4gICAgY29uc3QgY29scyA9IFtcXG4gICAgICAgIHsgdGl0bGU6IFxcXCJDb2wxXFxcIiwgd2lkdGg6IDEwMCB9LFxcbiAgICAgICAgeyB0aXRsZTogXFxcIkNvbDJcXFwiLCB3aWR0aDogMTAwIH0sXFxuICAgIF07XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QnVnNzBTdHlsZSBjbGFzc05hbWU9XFxcIkFwcFxcXCI+XFxuICAgICAgICAgICAgPHA+VG8gY2F1c2UgZXJyb3I6IHNjcm9sbCBkb3duIGF0IGxlYXN0IG9uZSByb3csIGVkaXQgYSBjZWxsIGluIENvbDIsIGFuZCBoaXQgVGFiPC9wPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9nbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2lzc3Vlcy83MFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIHJlbD1cXFwibm9yZWZlcnJlclxcXCI+XFxuICAgICAgICAgICAgICAgIE9yaWdpbmFsIHJlcG9ydFxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8RGF0YUVkaXRvclxcbiAgICAgICAgICAgICAgICB3aWR0aD17NTAwfVxcbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezUwMH1cXG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17YnVnNzBHZW59XFxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17aWdub3JlfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0J1ZzcwU3R5bGU+XFxuICAgICk7XFxufVxcblxcbmNvbnN0IGZpbHRlckNvbHVtbnNHZW4gPSAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XFxuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXFxuICAgIGRhdGE6IGAke2NvbH0gLSAke3Jvd31gLFxcbiAgICBkaXNwbGF5RGF0YTogYCR7Y29sfSAtICR7cm93fWAsXFxufSk7XFxuXFxuY29uc3QgZmlsdGVyaW5nQ29sdW1ucyA9IFtcXG4gICAgeyB0aXRsZTogXFxcIkNvbCBBQUFBXFxcIiwgd2lkdGg6IDEyMCB9LFxcbiAgICB7IHRpdGxlOiBcXFwiQ29sIEFBQVxcXCIsIHdpZHRoOiAxMjAgfSxcXG4gICAgeyB0aXRsZTogXFxcIkNvbCBBQVxcXCIsIHdpZHRoOiAxMjAgfSxcXG4gICAgeyB0aXRsZTogXFxcIkNvbCBBXFxcIiwgd2lkdGg6IDEyMCB9LFxcbiAgICB7IHRpdGxlOiBcXFwiQ29sXFxcIiwgd2lkdGg6IDEyMCB9LFxcbl07XFxuXFxuZXhwb3J0IGZ1bmN0aW9uIEZpbHRlckNvbHVtbnMoKSB7XFxuICAgIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKFxcXCJcXFwiKTtcXG5cXG4gICAgY29uc3QgY29scyA9IHVzZU1lbW8oKCkgPT4ge1xcbiAgICAgICAgaWYgKHNlYXJjaFRleHQgPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmluZ0NvbHVtbnM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucy5maWx0ZXIoYyA9PiBjLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpKSk7XFxuICAgIH0sIFtzZWFyY2hUZXh0XSk7XFxuXFxuICAgIGNvbnN0IG9uSW5wdXRDaGFuZ2UgPSAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcXG4gICAgICAgIHNldFNlYXJjaFRleHQoZS50YXJnZXQudmFsdWUpO1xcbiAgICB9O1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9e3NlYXJjaFRleHR9IG9uQ2hhbmdlPXtvbklucHV0Q2hhbmdlfSAvPlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHdpZHRoPXsxMDAwfVxcbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezUwMH1cXG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17ZmlsdGVyQ29sdW1uc0dlbn1cXG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17dHJ1ZX1cXG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17dHJ1ZX1cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICk7XFxufVxcblwiLFwibG9jYXRpb25zTWFwXCI6e1wiYnVnLTcwXCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjo3LFwibGluZVwiOjQwfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6NjJ9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6NyxcImxpbmVcIjo0MH0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjo2Mn19LFwiZmlsdGVyLWNvbHVtbnNcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjcsXCJsaW5lXCI6Nzl9LFwiZW5kTG9jXCI6e1wiY29sXCI6MSxcImxpbmVcIjoxMDh9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6NyxcImxpbmVcIjo3OX0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjoxMDh9fX19LH0sXG4gICAgdGl0bGU6IFwiVGVzdHMvVGVzdENhc2VzL0J1Z3NcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8QnVpbGRlclRoZW1lV3JhcHBlciB3aWR0aD17MTAwMH0gaGVpZ2h0PXs4MDB9PlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9CdWlsZGVyVGhlbWVXcmFwcGVyPlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5jb25zdCBidWc3MEdlbiA9IChbLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4gKHtcbiAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICBkYXRhOiByb3csXG4gICAgZGlzcGxheURhdGE6IHJvdy50b1N0cmluZygpLFxufSk7XG5cbmNvbnN0IGlnbm9yZSA9ICgpID0+IHVuZGVmaW5lZDtcblxuY29uc3QgQnVnNzBTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXG4gICAgPiBhIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgQnVnNzAgPSBmdW5jdGlvbiBCdWc3MCgpIHtcbiAgICBjb25zdCBjb2xzID0gW1xuICAgICAgICB7IHRpdGxlOiBcIkNvbDFcIiwgd2lkdGg6IDEwMCB9LFxuICAgICAgICB7IHRpdGxlOiBcIkNvbDJcIiwgd2lkdGg6IDEwMCB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QnVnNzBTdHlsZSBjbGFzc05hbWU9XCJBcHBcIj5cbiAgICAgICAgICAgIDxwPlRvIGNhdXNlIGVycm9yOiBzY3JvbGwgZG93biBhdCBsZWFzdCBvbmUgcm93LCBlZGl0IGEgY2VsbCBpbiBDb2wyLCBhbmQgaGl0IFRhYjwvcD5cbiAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9pc3N1ZXMvNzBcIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyXCI+XG4gICAgICAgICAgICAgICAgT3JpZ2luYWwgcmVwb3J0XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHdpZHRoPXs1MDB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXs1MDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2J1ZzcwR2VufVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17aWdub3JlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CdWc3MFN0eWxlPlxuICAgICk7XG59O1xuXG5jb25zdCBmaWx0ZXJDb2x1bW5zR2VuID0gKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICBkYXRhOiBgJHtjb2x9IC0gJHtyb3d9YCxcbiAgICBkaXNwbGF5RGF0YTogYCR7Y29sfSAtICR7cm93fWAsXG59KTtcblxuY29uc3QgZmlsdGVyaW5nQ29sdW1ucyA9IFtcbiAgICB7IHRpdGxlOiBcIkNvbCBBQUFBXCIsIHdpZHRoOiAxMjAgfSxcbiAgICB7IHRpdGxlOiBcIkNvbCBBQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFBXCIsIHdpZHRoOiAxMjAgfSxcbiAgICB7IHRpdGxlOiBcIkNvbCBBXCIsIHdpZHRoOiAxMjAgfSxcbiAgICB7IHRpdGxlOiBcIkNvbFwiLCB3aWR0aDogMTIwIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgRmlsdGVyQ29sdW1ucyA9IGZ1bmN0aW9uIEZpbHRlckNvbHVtbnMoKSB7XG4gICAgY29uc3QgW3NlYXJjaFRleHQsIHNldFNlYXJjaFRleHRdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgICBjb25zdCBjb2xzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzZWFyY2hUZXh0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXJpbmdDb2x1bW5zLmZpbHRlcihjID0+IGMudGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXh0LnRvTG93ZXJDYXNlKCkpKTtcbiAgICB9LCBbc2VhcmNoVGV4dF0pO1xuXG4gICAgY29uc3Qgb25JbnB1dENoYW5nZSA9IChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgICAgICBzZXRTZWFyY2hUZXh0KGUudGFyZ2V0LnZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT17c2VhcmNoVGV4dH0gb25DaGFuZ2U9e29uSW5wdXRDaGFuZ2V9IC8+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHdpZHRoPXsxMDAwfVxuICAgICAgICAgICAgICAgIGhlaWdodD17NTAwfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtmaWx0ZXJDb2x1bW5zR2VufVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3RydWV9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17dHJ1ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59OyJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/utils.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".c4uqbye{width:120px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:#f1f1f1;height:100%;}.c4uqbye button{border:none;outline:none;height:37px;width:120px;font-size:20px;background-color:#f7f7f8;color:#000000dd;border-bottom:1px solid #e1e2e5;-webkit-transition:background-color 200ms;transition:background-color 200ms;cursor:pointer;}.c4uqbye button:hover{background-color:#efeff1;}\n.b1bsqg7n{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b1bsqg7n.double{height:200vh;}.b1bsqg7n > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b1bsqg7n .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b1bsqg7n .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}.b1bsqg7n.firefox .sizer{border-radius:0;box-shadow:unset;}.b1bsqg7n.firefox .sizer .sizer-clip{border-radius:0;}.b1bsqg7n .white{background-color:white;}\n.piiq54i{font-family:monospace;font-weight:500;color:#ffe394;}\n.d1k3yj19{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.m1j0dy02{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.m1j0dy02 button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n.kcvwzr4{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3Ivc3Rvcmllcy91dGlscy50c3giXSwibmFtZXMiOlsiLmM0dXFieWUiLCIuYjFic3FnN24iLCIucGlpcTU0aSIsIi5kMWszeWoxOSIsIi5tMWowZHkwMiIsIi5rY3Z3enI0Il0sIm1hcHBpbmdzIjoiQUF5SCtCQTtBQXlCREM7QUF1RE5DO0FBTUdDO0FBTUhDO0FBNFJEQyIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1pZGVudGljYWwtZnVuY3Rpb25zICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgICBFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEdyaWRDZWxsLFxuICAgIEdyaWRDZWxsS2luZCxcbiAgICBHcmlkQ29sdW1uLFxuICAgIEdyaWRDb2x1bW5JY29uLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBpc1RleHRFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEl0ZW0sXG59IGZyb20gXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXCI7XG5cbmltcG9ydCBmYWtlciBmcm9tIFwiZmFrZXJcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSBcImxvZGFzaC9pc0FycmF5LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnROZXZlciB9IGZyb20gXCIuLi8uLi9jb21tb24vc3VwcG9ydFwiO1xuaW1wb3J0IHsgYnJvd3NlcklzRmlyZWZveCB9IGZyb20gXCIuLi8uLi9jb21tb24vYnJvd3Nlci1kZXRlY3RcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclwiO1xuaW1wb3J0IHR5cGUgeyBEYXRhRWRpdG9yUHJvcHMgfSBmcm9tIFwiLi4vZGF0YS1lZGl0b3JcIjtcbmltcG9ydCBub29wIGZyb20gXCJsb2Rhc2gvbm9vcC5qc1wiO1xuXG5mYWtlci5zZWVkKDEzMzcpO1xuXG5mdW5jdGlvbiBpc1RydXRoeSh4OiBhbnkpOiBib29sZWFuIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgcmV0dXJuIHggPyB0cnVlIDogZmFsc2U7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gY29weSBkYXRhIGJldHdlZW4gZ3JpZCBjZWxscyBvZiBhbnkga2luZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvc3N5Q29weURhdGE8VCBleHRlbmRzIEVkaXRhYmxlR3JpZENlbGw+KHNvdXJjZTogRWRpdGFibGVHcmlkQ2VsbCwgdGFyZ2V0OiBUKTogRWRpdGFibGVHcmlkQ2VsbCB7XG4gICAgY29uc3Qgc291cmNlRGF0YSA9IHNvdXJjZS5kYXRhO1xuICAgIGlmICh0eXBlb2Ygc291cmNlRGF0YSA9PT0gdHlwZW9mIHRhcmdldC5kYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhIGFzIGFueSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgICAgc3dpdGNoICh0YXJnZXQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVXJpOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGFbMF0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlRGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5Cb29sZWFuOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGFbMF0gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5raW5kID09PSBHcmlkQ2VsbEtpbmQuQm9vbGVhbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaXNUcnV0aHkoc291cmNlRGF0YSkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkltYWdlOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtzb3VyY2VEYXRhWzBdXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbc291cmNlRGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTnVtYmVyOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5UZXh0OlxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTWFya2Rvd246IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShzb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlRGF0YVswXS50b1N0cmluZygpID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2UuZGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5DdXN0b206IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gZGVmYXVsdFxuICAgICAgICB9XG4gICAgYXNzZXJ0TmV2ZXIodGFyZ2V0KTtcbn1cblxuZXhwb3J0IHR5cGUgR3JpZENvbHVtbldpdGhNb2NraW5nSW5mbyA9IEdyaWRDb2x1bW4gJiB7XG4gICAgZ2V0Q29udGVudCgpOiBHcmlkQ2VsbDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcmlkQ29sdW1uKGNvbHVtbldpdGhNb2NrOiBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvKTogR3JpZENvbHVtbiB7XG4gICAgY29uc3QgeyBnZXRDb250ZW50LCAuLi5yZXN0IH0gPSBjb2x1bW5XaXRoTW9jaztcblxuICAgIHJldHVybiByZXN0O1xufVxuXG5leHBvcnQgY29uc3QgQ29sdW1uQWRkQnV0dG9uID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogMTIwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmMWYxZjE7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgaGVpZ2h0OiAzN3B4O1xuICAgICAgICB3aWR0aDogMTIwcHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmODtcbiAgICAgICAgY29sb3I6ICMwMDAwMDBkZDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlMWUyZTU7XG5cbiAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAyMDBtcztcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZlZmYxO1xuICAgICAgICB9XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzI3OTBiOSwgIzIwNzBhOSk7XG4gICAgY29sb3I6IHdoaXRlO1xuXG4gICAgcGFkZGluZzogMzJweCA0OHB4O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGhlaWdodDogMTAwdmg7XG5cbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcblxuICAgICYuZG91YmxlIHtcbiAgICAgICAgaGVpZ2h0OiAyMDB2aDtcbiAgICB9XG5cbiAgICAmID4gaDEge1xuICAgICAgICBmb250LXNpemU6IDUwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XG4gICAgfVxuXG4gICAgLnNpemVyIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmZpcmVmb3ggLnNpemVyIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICAgICAgYm94LXNoYWRvdzogdW5zZXQ7XG5cbiAgICAgICAgLnNpemVyLWNsaXAge1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC53aGl0ZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcm9wTmFtZSA9IHN0eWxlZC5zcGFuYFxuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBjb2xvcjogI2ZmZTM5NDtcbmA7XG5cbmV4cG9ydCBjb25zdCBEZXNjcmlwdGlvbiA9IHN0eWxlZC5wYFxuICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICBmbGV4LXNocmluazogMDtcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgTW9yZUluZm8gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XG4gICAgICAgIHBhZGRpbmc6IDJweCA2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuYDtcblxuaW50ZXJmYWNlIEJlYXV0aWZ1bFByb3BzIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNsYXNzTmFtZT86IHN0cmluZztcbiAgICBzY2FsZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiwgY2xhc3NOYW1lLCBzY2FsZSB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlIGNsYXNzTmFtZT17Y2xhc3NOYW1lICsgKGJyb3dzZXJJc0ZpcmVmb3gudmFsdWUgPyBcIiBmaXJlZm94XCIgOiBcIlwiKX0+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHNjYWxlIH19IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dENvbHVtbkluZm8oaW5kZXg6IG51bWJlciwgZ3JvdXA6IGJvb2xlYW4pOiBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogYENvbHVtbiAke2luZGV4fWAsXG4gICAgICAgIGlkOiBgQ29sdW1uICR7aW5kZXh9YCxcbiAgICAgICAgZ3JvdXA6IGdyb3VwID8gYEdyb3VwICR7TWF0aC5yb3VuZChpbmRleCAvIDMpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBmYWtlci5sb3JlbS53b3JkKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6YWJsZUNvbHVtbnMoYW1vdW50OiBudW1iZXIsIGdyb3VwOiBib29sZWFuKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICBjb25zdCBkZWZhdWx0Q29sdW1uczogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIk5hbWVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TmFtZSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTGFzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJMYXN0IG5hbWVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiTmFtZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGFzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkF2YXRhclwiLFxuICAgICAgICAgICAgaWQ6IFwiQXZhdGFyXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYGh0dHBzOi8vcGljc3VtLnBob3Rvcy9pZC8ke259LzkwMC85MDBgXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFtgaHR0cHM6Ly9waWNzdW0ucGhvdG9zL2lkLyR7bn0vNDAvNDBgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0FkZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJFbWFpbFwiLFxuICAgICAgICAgICAgaWQ6IFwiRW1haWxcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSBmYWtlci5pbnRlcm5ldC5lbWFpbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJUaXRsZVwiLFxuICAgICAgICAgICAgaWQ6IFwiVGl0bGVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFueSA9IGZha2VyLm5hbWUuam9iVGl0bGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1vcmUgSW5mb1wiLFxuICAgICAgICAgICAgaWQ6IFwiTW9yZSBJbmZvXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclVyaSxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGZha2VyLmludGVybmV0LnVybCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5VcmksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgaWYgKGFtb3VudCA8IGRlZmF1bHRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdENvbHVtbnMuc2xpY2UoMCwgYW1vdW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRyYUNvbHVtbnNBbW91bnQgPSBhbW91bnQgLSBkZWZhdWx0Q29sdW1ucy5sZW5ndGg7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1uZXctYXJyYXlcbiAgICBjb25zdCBleHRyYUNvbHVtbnMgPSBbLi4ubmV3IEFycmF5KGV4dHJhQ29sdW1uc0Ftb3VudCldLm1hcCgoXywgaW5kZXgpID0+XG4gICAgICAgIGNyZWF0ZVRleHRDb2x1bW5JbmZvKGluZGV4ICsgZGVmYXVsdENvbHVtbnMubGVuZ3RoLCBncm91cClcbiAgICApO1xuXG4gICAgcmV0dXJuIFsuLi5kZWZhdWx0Q29sdW1ucywgLi4uZXh0cmFDb2x1bW5zXTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnRlbnRDYWNoZSB7XG4gICAgLy8gY29sdW1uIC0+IHJvdyAtPiB2YWx1ZVxuICAgIHByaXZhdGUgY2FjaGVkQ29udGVudDogTWFwPG51bWJlciwgTWFwPG51bWJlciwgR3JpZENlbGw+PiA9IG5ldyBNYXAoKTtcblxuICAgIGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY29sQ2FjaGUgPSB0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCk7XG5cbiAgICAgICAgaWYgKGNvbENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sQ2FjaGUuZ2V0KHJvdyk7XG4gICAgfVxuXG4gICAgc2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IEdyaWRDZWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRDb250ZW50LnNldChjb2wsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3dDYWNoZSA9IHRoaXMuY2FjaGVkQ29udGVudC5nZXQoY29sKSBhcyBNYXA8bnVtYmVyLCBHcmlkQ2VsbD47XG4gICAgICAgIHJvd0NhY2hlLnNldChyb3csIHZhbHVlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb2NrRGF0YUdlbmVyYXRvcihudW1Db2xzOiBudW1iZXIsIHJlYWRvbmx5OiBib29sZWFuID0gdHJ1ZSwgZ3JvdXA6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGdldFJlc2l6YWJsZUNvbHVtbnMobnVtQ29scywgZ3JvdXApKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldENvbHNNYXAoZ2V0UmVzaXphYmxlQ29sdW1ucyhudW1Db2xzLCBncm91cCkpO1xuICAgIH0sIFtncm91cCwgbnVtQ29sc10pO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgY29sc01hcFJlZiA9IFJlYWN0LnVzZVJlZihjb2xzTWFwKTtcbiAgICBjb2xzTWFwUmVmLmN1cnJlbnQgPSBjb2xzTWFwO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGNvbHNNYXBSZWYuY3VycmVudFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRvbmx5ICYmIGlzVGV4dEVkaXRhYmxlR3JpZENlbGwodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB7IC4uLnZhbCwgcmVhZG9ubHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbcmVhZG9ubHldXG4gICAgKTtcblxuICAgIGNvbnN0IHNldENlbGxWYWx1ZVJhdyA9IFJlYWN0LnVzZUNhbGxiYWNrKChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsKTogdm9pZCA9PiB7XG4gICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNvbCwgcm93LCB2YWwpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldENlbGxWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSwgdmFsOiBHcmlkQ2VsbCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBjYWNoZS5jdXJyZW50LmdldChjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvbHNNYXBbY29sXS5nZXRDb250ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNFZGl0YWJsZUdyaWRDZWxsKHZhbCkgJiYgaXNFZGl0YWJsZUdyaWRDZWxsKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29waWVkID0gbG9zc3lDb3B5RGF0YSh2YWwsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNvbCwgcm93LCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvcGllZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IHR5cGVvZiBjb3BpZWQuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGNvcGllZC5kYXRhIDogKGNvcGllZCBhcyBhbnkpLmRpc3BsYXlEYXRhLFxuICAgICAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbY29sc01hcF1cbiAgICApO1xuXG4gICAgcmV0dXJuIHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUsIHNldENlbGxWYWx1ZVJhdyB9O1xufVxuXG5leHBvcnQgY29uc3QgS2V5TmFtZSA9IHN0eWxlZC5rYmRgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICBjb2xvcjogIzJiMmIyYjtcbiAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgbWFyZ2luOiAwIDAuMWVtO1xuYDtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbjogdHJ1ZSxcbiAgICB3aWR0aDogXCIxMDAlXCIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDZWxsKGNlbGw6IEdyaWRDZWxsKTogR3JpZENlbGwge1xuICAgIHN3aXRjaCAoY2VsbC5raW5kKSB7XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkJvb2xlYW46IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuSW1hZ2U6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkRyaWxsZG93bjpcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQnViYmxlOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlVyaTpcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTWFya2Rvd246IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5UZXh0OiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgZGF0YTogXCJcIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTnVtYmVyOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgZGF0YTogMCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG59XG5cbmZ1bmN0aW9uIGdldENvbHVtbnNGb3JDZWxsVHlwZXMoKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJSb3cgSURcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJSb3dJRCxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5Sb3dJRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFrZXIuZGF0YXR5cGUudXVpZCgpLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIlByb3RlY3RlZFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuUHJvdGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmYWtlci5maW5hbmNlLmJpdGNvaW5BZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkxvYWRpbmdcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJTdHJpbmcsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVGV4dFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZmFrZXIubmFtZS5maXJzdE5hbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTnVtYmVyXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gZmFrZXIuZGF0YXR5cGUubnVtYmVyKDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYWdlLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7YWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckJvb2xlYW4sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb2xsID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcm9sbCA8IDAuMSA/IHVuZGVmaW5lZCA6IHJvbGwgPCAwLjIgPyBudWxsIDogcm9sbCA8IDAuNjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIGVkaXRhYmxlLiBVWCBsb29rcyBiYWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJJbWFnZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYCR7ZmFrZXIuaW1hZ2UuYW5pbWFscyg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVXJpXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyVXJpLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZmFrZXIuaW50ZXJuZXQudXJsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlVyaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1hcmtkb3duXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTWFya2Rvd24sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZG93biA9IGAjIFRpdGxlXG5IZWxsbyBteSBuYW1lIGlzICoke2Zha2VyLm5hbWUuZmlyc3ROYW1lKCl9KlxuXG4jIyBUT0RPOlxuVHJ5IG91dCBbR2xpZGVdKGh0dHBzOi8vd3d3LmdsaWRlYXBwcy5jb20vKVxuYDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTWFya2Rvd24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1hcmtkb3duLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkJ1YmJsZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2Zha2VyLmxvcmVtLndvcmQoKSwgZmFrZXIubG9yZW0ud29yZCgpLCBmYWtlci5sb3JlbS53b3JkKCldLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkRyaWxsZG93blwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkRyaWxsZG93bixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZha2VyLmFkZHJlc3MuY2l0eU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6IGAke2Zha2VyLmltYWdlLm5hdHVyZSg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmFrZXIuYWRkcmVzcy5jaXR5TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogYCR7ZmFrZXIuaW1hZ2UubmF0dXJlKDQwLCA0MCl9P3JhbmRvbT0ke2Zha2VyLmRhdGF0eXBlLm51bWJlcigxMDBfMDAwKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbGxNb2NrZWRLaW5kcygpIHtcbiAgICBjb25zdCBjYWNoZSA9IFJlYWN0LnVzZVJlZjxDb250ZW50Q2FjaGU+KG5ldyBDb250ZW50Q2FjaGUoKSk7XG5cbiAgICBjb25zdCBbY29sc01hcCwgc2V0Q29sc01hcF0gPSBSZWFjdC51c2VTdGF0ZShnZXRDb2x1bW5zRm9yQ2VsbFR5cGVzKTtcblxuICAgIGNvbnN0IG9uQ29sdW1uUmVzaXplID0gUmVhY3QudXNlQ2FsbGJhY2soKGNvbHVtbjogR3JpZENvbHVtbiwgbmV3U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldENvbHNNYXAocHJldkNvbHNNYXAgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmV2Q29sc01hcC5maW5kSW5kZXgoY2kgPT4gY2kudGl0bGUgPT09IGNvbHVtbi50aXRsZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5wcmV2Q29sc01hcF07XG4gICAgICAgICAgICBuZXdBcnJheS5zcGxpY2UoaW5kZXgsIDEsIHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2Q29sc01hcFtpbmRleF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5ld1NpemUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29scyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY29sc01hcC5tYXAoZ2V0R3JpZENvbHVtbik7XG4gICAgfSwgW2NvbHNNYXBdKTtcblxuICAgIGNvbnN0IFt1cGRhdGVWZXJzaW9uLCBzZXRVcGRhdGVWZXJzaW9uXSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4ge1xuICAgICAgICAgICAgLy8gVGVycmlibGUgaGFjayB0byBmb3JjZSB1cGRhdGUgd2hlbiBzZXRDZWxsVmFsdWUgcmVxdWVzdHMgaXRcbiAgICAgICAgICAgIG5vb3AodXBkYXRlVmVyc2lvbik7XG4gICAgICAgICAgICBsZXQgdmFsID0gY2FjaGUuY3VycmVudC5nZXQoY29sLCByb3cpO1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gY29sc01hcFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBjYWNoZS5jdXJyZW50LnNldChjb2wsIHJvdywgdmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNNYXAsIHVwZGF0ZVZlcnNpb25dXG4gICAgKTtcblxuICAgIGNvbnN0IHNldENlbGxWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSwgdmFsOiBHcmlkQ2VsbCwgbm9EaXNwbGF5PzogYm9vbGVhbiwgZm9yY2VVcGRhdGU/OiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29sc01hcFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlR3JpZENlbGwodmFsKSAmJiBpc0VkaXRhYmxlR3JpZENlbGwoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3BpZWQgPSBsb3NzeUNvcHlEYXRhKHZhbCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29waWVkLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogbm9EaXNwbGF5ID09PSB0cnVlID8gdW5kZWZpbmVkIDogY29waWVkLmRhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZm9yY2VVcGRhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VXBkYXRlVmVyc2lvbih2ID0+IHYgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtjb2xzTWFwXVxuICAgICk7XG5cbiAgICByZXR1cm4geyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSB9O1xufVxuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/stories/utils.tsx","webpack://./packages/core/src/data-editor/stories/utils.tsx"],"names":[".c4uqbye",".b1bsqg7n",".piiq54i",".d1k3yj19",".m1j0dy02",".kcvwzr4"],"mappings":"AAyH+BA,SAAAA,WAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,wBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,gBAAAA,WAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,wBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,cAAAA,CAAAA,CAAAA,sBAAAA,wBAAAA,CAAAA;AAyBDC,UAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iBAAAA,YAAAA,CAAAA,CAAAA,eAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,6BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yBAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,qCAAAA,eAAAA,CAAAA,CAAAA,iBAAAA,sBAAAA,CAAAA;AAuDNC,SAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA;AAMGC,UAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AAMHC,UAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA;AA4RDC,SAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA;AC3evB,+ggCAA+ggC","sourcesContent":["/* eslint-disable sonarjs/no-identical-functions */\nimport * as React from \"react\";\n\nimport {\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    GridColumnIcon,\n    isEditableGridCell,\n    isTextEditableGridCell,\n    Item,\n} from \"../../data-grid/data-grid-types\";\n\nimport faker from \"faker\";\nimport { styled } from \"@linaria/react\";\nimport isArray from \"lodash/isArray.js\";\nimport { assertNever } from \"../../common/support\";\nimport { browserIsFirefox } from \"../../common/browser-detect\";\nimport { useResizeDetector } from \"react-resize-detector\";\nimport type { DataEditorProps } from \"../data-editor\";\nimport noop from \"lodash/noop.js\";\n\nfaker.seed(1337);\n\nfunction isTruthy(x: any): boolean {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    return x ? true : false;\n}\n\n/**\n * Attempts to copy data between grid cells of any kind.\n */\nexport function lossyCopyData<T extends EditableGridCell>(source: EditableGridCell, target: T): EditableGridCell {\n    const sourceData = source.data;\n    if (typeof sourceData === typeof target.data) {\n        return {\n            ...target,\n            data: sourceData as any,\n        };\n    } else\n        switch (target.kind) {\n            case GridCellKind.Uri: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0],\n                    };\n                }\n                return {\n                    ...target,\n                    data: sourceData?.toString() ?? \"\",\n                };\n            }\n            case GridCellKind.Boolean: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0] !== undefined,\n                    };\n                } else if (source.kind === GridCellKind.Boolean) {\n                    return {\n                        ...target,\n                        data: source.data,\n                    };\n                }\n                return {\n                    ...target,\n                    data: isTruthy(sourceData) ? true : false,\n                };\n            }\n            case GridCellKind.Image: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: [sourceData[0]],\n                    };\n                }\n                return {\n                    ...target,\n                    data: [sourceData?.toString() ?? \"\"],\n                };\n            }\n            case GridCellKind.Number: {\n                return {\n                    ...target,\n                    data: 0,\n                };\n            }\n            case GridCellKind.Text:\n            case GridCellKind.Markdown: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0].toString() ?? \"\",\n                    };\n                }\n\n                return {\n                    ...target,\n                    data: source.data?.toString() ?? \"\",\n                };\n            }\n            case GridCellKind.Custom: {\n                return target;\n            }\n            // No default\n        }\n    assertNever(target);\n}\n\nexport type GridColumnWithMockingInfo = GridColumn & {\n    getContent(): GridCell;\n};\n\nexport function getGridColumn(columnWithMock: GridColumnWithMockingInfo): GridColumn {\n    const { getContent, ...rest } = columnWithMock;\n\n    return rest;\n}\n\nexport const ColumnAddButton = styled.div`\n    width: 120px;\n    display: flex;\n    flex-direction: column;\n    background-color: #f1f1f1;\n    height: 100%;\n    button {\n        border: none;\n        outline: none;\n        height: 37px;\n        width: 120px;\n        font-size: 20px;\n        background-color: #f7f7f8;\n        color: #000000dd;\n        border-bottom: 1px solid #e1e2e5;\n\n        transition: background-color 200ms;\n\n        cursor: pointer;\n        :hover {\n            background-color: #efeff1;\n        }\n    }\n`;\n\nexport const BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    &.double {\n        height: 200vh;\n    }\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n\n    &.firefox .sizer {\n        border-radius: 0;\n        box-shadow: unset;\n\n        .sizer-clip {\n            border-radius: 0;\n        }\n    }\n\n    .white {\n        background-color: white;\n    }\n`;\n\nexport const PropName = styled.span`\n    font-family: monospace;\n    font-weight: 500;\n    color: #ffe394;\n`;\n\nexport const Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n    className?: string;\n    scale?: string;\n}\n\nexport const BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description, className, scale } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle className={className + (browserIsFirefox.value ? \" firefox\" : \"\")}>\n            <h1>{title}</h1>\n            {description}\n            <div style={{ scale }} className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nfunction createTextColumnInfo(index: number, group: boolean): GridColumnWithMockingInfo {\n    return {\n        title: `Column ${index}`,\n        id: `Column ${index}`,\n        group: group ? `Group ${Math.round(index / 3)}` : undefined,\n        icon: GridColumnIcon.HeaderString,\n        hasMenu: false,\n        getContent: () => {\n            const text = faker.lorem.word();\n\n            return {\n                kind: GridCellKind.Text,\n                data: text,\n                displayData: text,\n                allowOverlay: true,\n                readonly: true,\n            };\n        },\n    };\n}\n\nfunction getResizableColumns(amount: number, group: boolean): GridColumnWithMockingInfo[] {\n    const defaultColumns: GridColumnWithMockingInfo[] = [\n        {\n            title: \"First name\",\n            id: \"First name\",\n            group: group ? \"Name\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const firstName = faker.name.firstName();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: firstName,\n                    data: firstName,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Last name\",\n            id: \"Last name\",\n            group: group ? \"Name\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const lastName = faker.name.lastName();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: lastName,\n                    data: lastName,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Avatar\",\n            id: \"Avatar\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderImage,\n            hasMenu: false,\n            getContent: () => {\n                const n = Math.round(Math.random() * 100);\n                return {\n                    kind: GridCellKind.Image,\n                    data: [`https://picsum.photos/id/${n}/900/900`],\n                    displayData: [`https://picsum.photos/id/${n}/40/40`],\n                    allowOverlay: true,\n                    allowAdd: false,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Email\",\n            id: \"Email\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const email = faker.internet.email();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: email,\n                    data: email,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Title\",\n            id: \"Title\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const company = faker.name.jobTitle();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: company,\n                    data: company,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"More Info\",\n            id: \"More Info\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderUri,\n            hasMenu: false,\n            getContent: () => {\n                const url = faker.internet.url();\n                return {\n                    kind: GridCellKind.Uri,\n                    displayData: url,\n                    data: url,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n    ];\n\n    if (amount < defaultColumns.length) {\n        return defaultColumns.slice(0, amount);\n    }\n\n    const extraColumnsAmount = amount - defaultColumns.length;\n\n    // eslint-disable-next-line unicorn/no-new-array\n    const extraColumns = [...new Array(extraColumnsAmount)].map((_, index) =>\n        createTextColumnInfo(index + defaultColumns.length, group)\n    );\n\n    return [...defaultColumns, ...extraColumns];\n}\n\nexport class ContentCache {\n    // column -> row -> value\n    private cachedContent: Map<number, Map<number, GridCell>> = new Map();\n\n    get(col: number, row: number) {\n        const colCache = this.cachedContent.get(col);\n\n        if (colCache === undefined) {\n            return undefined;\n        }\n\n        return colCache.get(row);\n    }\n\n    set(col: number, row: number, value: GridCell) {\n        if (this.cachedContent.get(col) === undefined) {\n            this.cachedContent.set(col, new Map());\n        }\n\n        const rowCache = this.cachedContent.get(col) as Map<number, GridCell>;\n        rowCache.set(row, value);\n    }\n}\n\nexport function useMockDataGenerator(numCols: number, readonly: boolean = true, group: boolean = false) {\n    const cache = React.useRef<ContentCache>(new ContentCache());\n\n    const [colsMap, setColsMap] = React.useState(() => getResizableColumns(numCols, group));\n\n    React.useEffect(() => {\n        setColsMap(getResizableColumns(numCols, group));\n    }, [group, numCols]);\n\n    const onColumnResize = React.useCallback((column: GridColumn, newSize: number) => {\n        setColsMap(prevColsMap => {\n            const index = prevColsMap.findIndex(ci => ci.title === column.title);\n            const newArray = [...prevColsMap];\n            newArray.splice(index, 1, {\n                ...prevColsMap[index],\n                width: newSize,\n            });\n            return newArray;\n        });\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return colsMap.map(getGridColumn);\n    }, [colsMap]);\n\n    const colsMapRef = React.useRef(colsMap);\n    colsMapRef.current = colsMap;\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            let val = cache.current.get(col, row);\n            if (val === undefined) {\n                val = colsMapRef.current[col].getContent();\n                if (!readonly && isTextEditableGridCell(val)) {\n                    val = { ...val, readonly };\n                }\n                cache.current.set(col, row, val);\n            }\n            return val;\n        },\n        [readonly]\n    );\n\n    const setCellValueRaw = React.useCallback(([col, row]: Item, val: GridCell): void => {\n        cache.current.set(col, row, val);\n    }, []);\n\n    const setCellValue = React.useCallback(\n        ([col, row]: Item, val: GridCell): void => {\n            let current = cache.current.get(col, row);\n            if (current === undefined) {\n                current = colsMap[col].getContent();\n            }\n            if (isEditableGridCell(val) && isEditableGridCell(current)) {\n                const copied = lossyCopyData(val, current);\n                cache.current.set(col, row, {\n                    ...copied,\n                    displayData: typeof copied.data === \"string\" ? copied.data : (copied as any).displayData,\n                    lastUpdated: performance.now(),\n                } as any);\n            }\n        },\n        [colsMap]\n    );\n\n    return { cols, getCellContent, onColumnResize, setCellValue, setCellValueRaw };\n}\n\nexport const KeyName = styled.kbd`\n    background-color: #f4f4f4;\n    color: #2b2b2b;\n    padding: 2px 6px;\n    font-family: monospace;\n    font-size: 14px;\n    border-radius: 4px;\n    box-shadow: 0px 1px 2px #00000040;\n    margin: 0 0.1em;\n`;\n\nexport const defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    getCellsForSelection: true,\n    width: \"100%\",\n};\n\nexport function clearCell(cell: GridCell): GridCell {\n    switch (cell.kind) {\n        case GridCellKind.Boolean: {\n            return {\n                ...cell,\n                data: false,\n            };\n        }\n        case GridCellKind.Image: {\n            return {\n                ...cell,\n                data: [],\n                displayData: [],\n            };\n        }\n        case GridCellKind.Drilldown:\n        case GridCellKind.Bubble: {\n            return {\n                ...cell,\n                data: [],\n            };\n        }\n        case GridCellKind.Uri:\n        case GridCellKind.Markdown: {\n            return {\n                ...cell,\n                data: \"\",\n            };\n        }\n        case GridCellKind.Text: {\n            return {\n                ...cell,\n                data: \"\",\n                displayData: \"\",\n            };\n        }\n        case GridCellKind.Number: {\n            return {\n                ...cell,\n                data: 0,\n                displayData: \"\",\n            };\n        }\n    }\n    return cell;\n}\n\nfunction getColumnsForCellTypes(): GridColumnWithMockingInfo[] {\n    return [\n        {\n            title: \"Row ID\",\n            width: 120,\n            icon: GridColumnIcon.HeaderRowID,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.RowID,\n                    data: faker.datatype.uuid(),\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Protected\",\n            width: 120,\n            icon: GridColumnIcon.HeaderCode,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Protected,\n                    data: faker.finance.bitcoinAddress(),\n                    allowOverlay: false,\n                };\n            },\n        },\n        {\n            title: \"Loading\",\n            width: 120,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Loading,\n                    allowOverlay: false,\n                };\n            },\n        },\n        {\n            title: \"Text\",\n            width: 120,\n            icon: GridColumnIcon.HeaderCode,\n            hasMenu: false,\n            getContent: () => {\n                const name = faker.name.firstName();\n                return {\n                    kind: GridCellKind.Text,\n                    data: name,\n                    displayData: name,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Number\",\n            width: 120,\n            icon: GridColumnIcon.HeaderNumber,\n            hasMenu: false,\n            getContent: () => {\n                const age = faker.datatype.number(100);\n                return {\n                    kind: GridCellKind.Number,\n                    data: age,\n                    displayData: `${age}`,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Boolean\",\n            width: 120,\n            icon: GridColumnIcon.HeaderBoolean,\n            hasMenu: false,\n            getContent: () => {\n                const roll = Math.random();\n                const checked = roll < 0.1 ? undefined : roll < 0.2 ? null : roll < 0.6;\n                // TODO: Make editable. UX looks bad by default.\n                return {\n                    kind: GridCellKind.Boolean,\n                    data: checked,\n                    allowOverlay: false,\n                    readonly: false,\n                };\n            },\n        },\n        {\n            title: \"Image\",\n            width: 120,\n            icon: GridColumnIcon.HeaderImage,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Image,\n                    data: [`${faker.image.animals(40, 40)}?random=${faker.datatype.number(100_000)}`],\n                    allowOverlay: true,\n                    allowAdd: false,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Uri\",\n            width: 120,\n            icon: GridColumnIcon.HeaderUri,\n            hasMenu: false,\n            getContent: () => {\n                const url = faker.internet.url();\n                return {\n                    kind: GridCellKind.Uri,\n                    data: url,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Markdown\",\n            width: 120,\n            icon: GridColumnIcon.HeaderMarkdown,\n            hasMenu: false,\n            getContent: () => {\n                const markdown = `# Title\nHello my name is *${faker.name.firstName()}*\n\n## TODO:\nTry out [Glide](https://www.glideapps.com/)\n`;\n                return {\n                    kind: GridCellKind.Markdown,\n                    data: markdown,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Bubble\",\n            width: 120,\n            icon: GridColumnIcon.HeaderArray,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Bubble,\n                    data: [faker.lorem.word(), faker.lorem.word(), faker.lorem.word()],\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Drilldown\",\n            width: 120,\n            icon: GridColumnIcon.HeaderArray,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Drilldown,\n                    data: [\n                        {\n                            text: faker.address.cityName(),\n                            img: `${faker.image.nature(40, 40)}?random=${faker.datatype.number(100_000)}`,\n                        },\n                        {\n                            text: faker.address.cityName(),\n                            img: `${faker.image.nature(40, 40)}?random=${faker.datatype.number(100_000)}`,\n                        },\n                    ],\n                    allowOverlay: true,\n                };\n            },\n        },\n    ];\n}\n\nexport function useAllMockedKinds() {\n    const cache = React.useRef<ContentCache>(new ContentCache());\n\n    const [colsMap, setColsMap] = React.useState(getColumnsForCellTypes);\n\n    const onColumnResize = React.useCallback((column: GridColumn, newSize: number) => {\n        setColsMap(prevColsMap => {\n            const index = prevColsMap.findIndex(ci => ci.title === column.title);\n            const newArray = [...prevColsMap];\n            newArray.splice(index, 1, {\n                ...prevColsMap[index],\n                width: newSize,\n            });\n            return newArray;\n        });\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return colsMap.map(getGridColumn);\n    }, [colsMap]);\n\n    const [updateVersion, setUpdateVersion] = React.useState(0);\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            // Terrible hack to force update when setCellValue requests it\n            noop(updateVersion);\n            let val = cache.current.get(col, row);\n            if (val === undefined) {\n                val = colsMap[col].getContent();\n                cache.current.set(col, row, val);\n            }\n\n            return val;\n        },\n        [colsMap, updateVersion]\n    );\n\n    const setCellValue = React.useCallback(\n        ([col, row]: Item, val: GridCell, noDisplay?: boolean, forceUpdate?: boolean): void => {\n            let current = cache.current.get(col, row);\n            if (current === undefined) {\n                current = colsMap[col].getContent();\n            }\n            if (isEditableGridCell(val) && isEditableGridCell(current)) {\n                const copied = lossyCopyData(val, current);\n                cache.current.set(col, row, {\n                    ...copied,\n                    displayData: noDisplay === true ? undefined : copied.data?.toString() ?? \"\",\n                } as any);\n\n                if (forceUpdate === true) {\n                    setUpdateVersion(v => v + 1);\n                }\n            }\n        },\n        [colsMap]\n    );\n\n    return { cols, getCellContent, onColumnResize, setCellValue };\n}\n",".c4uqbye{width:120px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:#f1f1f1;height:100%;}.c4uqbye button{border:none;outline:none;height:37px;width:120px;font-size:20px;background-color:#f7f7f8;color:#000000dd;border-bottom:1px solid #e1e2e5;-webkit-transition:background-color 200ms;transition:background-color 200ms;cursor:pointer;}.c4uqbye button:hover{background-color:#efeff1;}\n.b1bsqg7n{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b1bsqg7n.double{height:200vh;}.b1bsqg7n > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b1bsqg7n .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b1bsqg7n .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}.b1bsqg7n.firefox .sizer{border-radius:0;box-shadow:unset;}.b1bsqg7n.firefox .sizer .sizer-clip{border-radius:0;}.b1bsqg7n .white{background-color:white;}\n.piiq54i{font-family:monospace;font-weight:500;color:#ffe394;}\n.d1k3yj19{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.m1j0dy02{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.m1j0dy02 button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n.kcvwzr4{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1lZGl0b3Ivc3Rvcmllcy91dGlscy50c3giXSwibmFtZXMiOlsiLmM0dXFieWUiLCIuYjFic3FnN24iLCIucGlpcTU0aSIsIi5kMWszeWoxOSIsIi5tMWowZHkwMiIsIi5rY3Z3enI0Il0sIm1hcHBpbmdzIjoiQUF5SCtCQTtBQXlCREM7QUF1RE5DO0FBTUdDO0FBTUhDO0FBNFJEQyIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1pZGVudGljYWwtZnVuY3Rpb25zICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgICBFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEdyaWRDZWxsLFxuICAgIEdyaWRDZWxsS2luZCxcbiAgICBHcmlkQ29sdW1uLFxuICAgIEdyaWRDb2x1bW5JY29uLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBpc1RleHRFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEl0ZW0sXG59IGZyb20gXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXCI7XG5cbmltcG9ydCBmYWtlciBmcm9tIFwiZmFrZXJcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSBcImxvZGFzaC9pc0FycmF5LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnROZXZlciB9IGZyb20gXCIuLi8uLi9jb21tb24vc3VwcG9ydFwiO1xuaW1wb3J0IHsgYnJvd3NlcklzRmlyZWZveCB9IGZyb20gXCIuLi8uLi9jb21tb24vYnJvd3Nlci1kZXRlY3RcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclwiO1xuaW1wb3J0IHR5cGUgeyBEYXRhRWRpdG9yUHJvcHMgfSBmcm9tIFwiLi4vZGF0YS1lZGl0b3JcIjtcbmltcG9ydCBub29wIGZyb20gXCJsb2Rhc2gvbm9vcC5qc1wiO1xuXG5mYWtlci5zZWVkKDEzMzcpO1xuXG5mdW5jdGlvbiBpc1RydXRoeSh4OiBhbnkpOiBib29sZWFuIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgcmV0dXJuIHggPyB0cnVlIDogZmFsc2U7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gY29weSBkYXRhIGJldHdlZW4gZ3JpZCBjZWxscyBvZiBhbnkga2luZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvc3N5Q29weURhdGE8VCBleHRlbmRzIEVkaXRhYmxlR3JpZENlbGw+KHNvdXJjZTogRWRpdGFibGVHcmlkQ2VsbCwgdGFyZ2V0OiBUKTogRWRpdGFibGVHcmlkQ2VsbCB7XG4gICAgY29uc3Qgc291cmNlRGF0YSA9IHNvdXJjZS5kYXRhO1xuICAgIGlmICh0eXBlb2Ygc291cmNlRGF0YSA9PT0gdHlwZW9mIHRhcmdldC5kYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhIGFzIGFueSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgICAgc3dpdGNoICh0YXJnZXQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVXJpOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGFbMF0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlRGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5Cb29sZWFuOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGFbMF0gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5raW5kID09PSBHcmlkQ2VsbEtpbmQuQm9vbGVhbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaXNUcnV0aHkoc291cmNlRGF0YSkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkltYWdlOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtzb3VyY2VEYXRhWzBdXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbc291cmNlRGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTnVtYmVyOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5UZXh0OlxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTWFya2Rvd246IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShzb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlRGF0YVswXS50b1N0cmluZygpID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2UuZGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5DdXN0b206IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gZGVmYXVsdFxuICAgICAgICB9XG4gICAgYXNzZXJ0TmV2ZXIodGFyZ2V0KTtcbn1cblxuZXhwb3J0IHR5cGUgR3JpZENvbHVtbldpdGhNb2NraW5nSW5mbyA9IEdyaWRDb2x1bW4gJiB7XG4gICAgZ2V0Q29udGVudCgpOiBHcmlkQ2VsbDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcmlkQ29sdW1uKGNvbHVtbldpdGhNb2NrOiBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvKTogR3JpZENvbHVtbiB7XG4gICAgY29uc3QgeyBnZXRDb250ZW50LCAuLi5yZXN0IH0gPSBjb2x1bW5XaXRoTW9jaztcblxuICAgIHJldHVybiByZXN0O1xufVxuXG5leHBvcnQgY29uc3QgQ29sdW1uQWRkQnV0dG9uID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogMTIwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmMWYxZjE7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgaGVpZ2h0OiAzN3B4O1xuICAgICAgICB3aWR0aDogMTIwcHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmODtcbiAgICAgICAgY29sb3I6ICMwMDAwMDBkZDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlMWUyZTU7XG5cbiAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAyMDBtcztcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZlZmYxO1xuICAgICAgICB9XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzI3OTBiOSwgIzIwNzBhOSk7XG4gICAgY29sb3I6IHdoaXRlO1xuXG4gICAgcGFkZGluZzogMzJweCA0OHB4O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGhlaWdodDogMTAwdmg7XG5cbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcblxuICAgICYuZG91YmxlIHtcbiAgICAgICAgaGVpZ2h0OiAyMDB2aDtcbiAgICB9XG5cbiAgICAmID4gaDEge1xuICAgICAgICBmb250LXNpemU6IDUwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XG4gICAgfVxuXG4gICAgLnNpemVyIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmZpcmVmb3ggLnNpemVyIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICAgICAgYm94LXNoYWRvdzogdW5zZXQ7XG5cbiAgICAgICAgLnNpemVyLWNsaXAge1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC53aGl0ZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcm9wTmFtZSA9IHN0eWxlZC5zcGFuYFxuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBjb2xvcjogI2ZmZTM5NDtcbmA7XG5cbmV4cG9ydCBjb25zdCBEZXNjcmlwdGlvbiA9IHN0eWxlZC5wYFxuICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICBmbGV4LXNocmluazogMDtcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgTW9yZUluZm8gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XG4gICAgICAgIHBhZGRpbmc6IDJweCA2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuYDtcblxuaW50ZXJmYWNlIEJlYXV0aWZ1bFByb3BzIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIGNsYXNzTmFtZT86IHN0cmluZztcbiAgICBzY2FsZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiwgY2xhc3NOYW1lLCBzY2FsZSB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlIGNsYXNzTmFtZT17Y2xhc3NOYW1lICsgKGJyb3dzZXJJc0ZpcmVmb3gudmFsdWUgPyBcIiBmaXJlZm94XCIgOiBcIlwiKX0+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHNjYWxlIH19IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dENvbHVtbkluZm8oaW5kZXg6IG51bWJlciwgZ3JvdXA6IGJvb2xlYW4pOiBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogYENvbHVtbiAke2luZGV4fWAsXG4gICAgICAgIGlkOiBgQ29sdW1uICR7aW5kZXh9YCxcbiAgICAgICAgZ3JvdXA6IGdyb3VwID8gYEdyb3VwICR7TWF0aC5yb3VuZChpbmRleCAvIDMpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBmYWtlci5sb3JlbS53b3JkKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6YWJsZUNvbHVtbnMoYW1vdW50OiBudW1iZXIsIGdyb3VwOiBib29sZWFuKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICBjb25zdCBkZWZhdWx0Q29sdW1uczogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIk5hbWVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TmFtZSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTGFzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJMYXN0IG5hbWVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiTmFtZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGFzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkF2YXRhclwiLFxuICAgICAgICAgICAgaWQ6IFwiQXZhdGFyXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYGh0dHBzOi8vcGljc3VtLnBob3Rvcy9pZC8ke259LzkwMC85MDBgXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFtgaHR0cHM6Ly9waWNzdW0ucGhvdG9zL2lkLyR7bn0vNDAvNDBgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0FkZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJFbWFpbFwiLFxuICAgICAgICAgICAgaWQ6IFwiRW1haWxcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSBmYWtlci5pbnRlcm5ldC5lbWFpbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJUaXRsZVwiLFxuICAgICAgICAgICAgaWQ6IFwiVGl0bGVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFueSA9IGZha2VyLm5hbWUuam9iVGl0bGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1vcmUgSW5mb1wiLFxuICAgICAgICAgICAgaWQ6IFwiTW9yZSBJbmZvXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclVyaSxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGZha2VyLmludGVybmV0LnVybCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5VcmksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgaWYgKGFtb3VudCA8IGRlZmF1bHRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdENvbHVtbnMuc2xpY2UoMCwgYW1vdW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRyYUNvbHVtbnNBbW91bnQgPSBhbW91bnQgLSBkZWZhdWx0Q29sdW1ucy5sZW5ndGg7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1uZXctYXJyYXlcbiAgICBjb25zdCBleHRyYUNvbHVtbnMgPSBbLi4ubmV3IEFycmF5KGV4dHJhQ29sdW1uc0Ftb3VudCldLm1hcCgoXywgaW5kZXgpID0+XG4gICAgICAgIGNyZWF0ZVRleHRDb2x1bW5JbmZvKGluZGV4ICsgZGVmYXVsdENvbHVtbnMubGVuZ3RoLCBncm91cClcbiAgICApO1xuXG4gICAgcmV0dXJuIFsuLi5kZWZhdWx0Q29sdW1ucywgLi4uZXh0cmFDb2x1bW5zXTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnRlbnRDYWNoZSB7XG4gICAgLy8gY29sdW1uIC0+IHJvdyAtPiB2YWx1ZVxuICAgIHByaXZhdGUgY2FjaGVkQ29udGVudDogTWFwPG51bWJlciwgTWFwPG51bWJlciwgR3JpZENlbGw+PiA9IG5ldyBNYXAoKTtcblxuICAgIGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY29sQ2FjaGUgPSB0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCk7XG5cbiAgICAgICAgaWYgKGNvbENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sQ2FjaGUuZ2V0KHJvdyk7XG4gICAgfVxuXG4gICAgc2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IEdyaWRDZWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRDb250ZW50LnNldChjb2wsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3dDYWNoZSA9IHRoaXMuY2FjaGVkQ29udGVudC5nZXQoY29sKSBhcyBNYXA8bnVtYmVyLCBHcmlkQ2VsbD47XG4gICAgICAgIHJvd0NhY2hlLnNldChyb3csIHZhbHVlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb2NrRGF0YUdlbmVyYXRvcihudW1Db2xzOiBudW1iZXIsIHJlYWRvbmx5OiBib29sZWFuID0gdHJ1ZSwgZ3JvdXA6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGdldFJlc2l6YWJsZUNvbHVtbnMobnVtQ29scywgZ3JvdXApKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldENvbHNNYXAoZ2V0UmVzaXphYmxlQ29sdW1ucyhudW1Db2xzLCBncm91cCkpO1xuICAgIH0sIFtncm91cCwgbnVtQ29sc10pO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgY29sc01hcFJlZiA9IFJlYWN0LnVzZVJlZihjb2xzTWFwKTtcbiAgICBjb2xzTWFwUmVmLmN1cnJlbnQgPSBjb2xzTWFwO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGNvbHNNYXBSZWYuY3VycmVudFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRvbmx5ICYmIGlzVGV4dEVkaXRhYmxlR3JpZENlbGwodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB7IC4uLnZhbCwgcmVhZG9ubHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbcmVhZG9ubHldXG4gICAgKTtcblxuICAgIGNvbnN0IHNldENlbGxWYWx1ZVJhdyA9IFJlYWN0LnVzZUNhbGxiYWNrKChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsKTogdm9pZCA9PiB7XG4gICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNvbCwgcm93LCB2YWwpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNldENlbGxWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSwgdmFsOiBHcmlkQ2VsbCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBjYWNoZS5jdXJyZW50LmdldChjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvbHNNYXBbY29sXS5nZXRDb250ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNFZGl0YWJsZUdyaWRDZWxsKHZhbCkgJiYgaXNFZGl0YWJsZUdyaWRDZWxsKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29waWVkID0gbG9zc3lDb3B5RGF0YSh2YWwsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNvbCwgcm93LCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvcGllZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IHR5cGVvZiBjb3BpZWQuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGNvcGllZC5kYXRhIDogKGNvcGllZCBhcyBhbnkpLmRpc3BsYXlEYXRhLFxuICAgICAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbY29sc01hcF1cbiAgICApO1xuXG4gICAgcmV0dXJuIHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUsIHNldENlbGxWYWx1ZVJhdyB9O1xufVxuXG5leHBvcnQgY29uc3QgS2V5TmFtZSA9IHN0eWxlZC5rYmRgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICBjb2xvcjogIzJiMmIyYjtcbiAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgbWFyZ2luOiAwIDAuMWVtO1xuYDtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbjogdHJ1ZSxcbiAgICB3aWR0aDogXCIxMDAlXCIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDZWxsKGNlbGw6IEdyaWRDZWxsKTogR3JpZENlbGwge1xuICAgIHN3aXRjaCAoY2VsbC5raW5kKSB7XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkJvb2xlYW46IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuSW1hZ2U6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkRyaWxsZG93bjpcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQnViYmxlOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlVyaTpcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTWFya2Rvd246IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5UZXh0OiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgZGF0YTogXCJcIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTnVtYmVyOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgZGF0YTogMCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG59XG5cbmZ1bmN0aW9uIGdldENvbHVtbnNGb3JDZWxsVHlwZXMoKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJSb3cgSURcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJSb3dJRCxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5Sb3dJRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFrZXIuZGF0YXR5cGUudXVpZCgpLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIlByb3RlY3RlZFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuUHJvdGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmYWtlci5maW5hbmNlLmJpdGNvaW5BZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkxvYWRpbmdcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJTdHJpbmcsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVGV4dFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZmFrZXIubmFtZS5maXJzdE5hbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTnVtYmVyXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gZmFrZXIuZGF0YXR5cGUubnVtYmVyKDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYWdlLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7YWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckJvb2xlYW4sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb2xsID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcm9sbCA8IDAuMSA/IHVuZGVmaW5lZCA6IHJvbGwgPCAwLjIgPyBudWxsIDogcm9sbCA8IDAuNjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIGVkaXRhYmxlLiBVWCBsb29rcyBiYWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJJbWFnZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYCR7ZmFrZXIuaW1hZ2UuYW5pbWFscyg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVXJpXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyVXJpLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZmFrZXIuaW50ZXJuZXQudXJsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlVyaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1hcmtkb3duXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTWFya2Rvd24sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZG93biA9IGAjIFRpdGxlXG5IZWxsbyBteSBuYW1lIGlzICoke2Zha2VyLm5hbWUuZmlyc3ROYW1lKCl9KlxuXG4jIyBUT0RPOlxuVHJ5IG91dCBbR2xpZGVdKGh0dHBzOi8vd3d3LmdsaWRlYXBwcy5jb20vKVxuYDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTWFya2Rvd24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1hcmtkb3duLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkJ1YmJsZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2Zha2VyLmxvcmVtLndvcmQoKSwgZmFrZXIubG9yZW0ud29yZCgpLCBmYWtlci5sb3JlbS53b3JkKCldLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkRyaWxsZG93blwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkRyaWxsZG93bixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZha2VyLmFkZHJlc3MuY2l0eU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6IGAke2Zha2VyLmltYWdlLm5hdHVyZSg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmFrZXIuYWRkcmVzcy5jaXR5TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogYCR7ZmFrZXIuaW1hZ2UubmF0dXJlKDQwLCA0MCl9P3JhbmRvbT0ke2Zha2VyLmRhdGF0eXBlLm51bWJlcigxMDBfMDAwKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbGxNb2NrZWRLaW5kcygpIHtcbiAgICBjb25zdCBjYWNoZSA9IFJlYWN0LnVzZVJlZjxDb250ZW50Q2FjaGU+KG5ldyBDb250ZW50Q2FjaGUoKSk7XG5cbiAgICBjb25zdCBbY29sc01hcCwgc2V0Q29sc01hcF0gPSBSZWFjdC51c2VTdGF0ZShnZXRDb2x1bW5zRm9yQ2VsbFR5cGVzKTtcblxuICAgIGNvbnN0IG9uQ29sdW1uUmVzaXplID0gUmVhY3QudXNlQ2FsbGJhY2soKGNvbHVtbjogR3JpZENvbHVtbiwgbmV3U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldENvbHNNYXAocHJldkNvbHNNYXAgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmV2Q29sc01hcC5maW5kSW5kZXgoY2kgPT4gY2kudGl0bGUgPT09IGNvbHVtbi50aXRsZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5wcmV2Q29sc01hcF07XG4gICAgICAgICAgICBuZXdBcnJheS5zcGxpY2UoaW5kZXgsIDEsIHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2Q29sc01hcFtpbmRleF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5ld1NpemUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29scyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY29sc01hcC5tYXAoZ2V0R3JpZENvbHVtbik7XG4gICAgfSwgW2NvbHNNYXBdKTtcblxuICAgIGNvbnN0IFt1cGRhdGVWZXJzaW9uLCBzZXRVcGRhdGVWZXJzaW9uXSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4ge1xuICAgICAgICAgICAgLy8gVGVycmlibGUgaGFjayB0byBmb3JjZSB1cGRhdGUgd2hlbiBzZXRDZWxsVmFsdWUgcmVxdWVzdHMgaXRcbiAgICAgICAgICAgIG5vb3AodXBkYXRlVmVyc2lvbik7XG4gICAgICAgICAgICBsZXQgdmFsID0gY2FjaGUuY3VycmVudC5nZXQoY29sLCByb3cpO1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gY29sc01hcFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBjYWNoZS5jdXJyZW50LnNldChjb2wsIHJvdywgdmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNNYXAsIHVwZGF0ZVZlcnNpb25dXG4gICAgKTtcblxuICAgIGNvbnN0IHNldENlbGxWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSwgdmFsOiBHcmlkQ2VsbCwgbm9EaXNwbGF5PzogYm9vbGVhbiwgZm9yY2VVcGRhdGU/OiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29sc01hcFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlR3JpZENlbGwodmFsKSAmJiBpc0VkaXRhYmxlR3JpZENlbGwoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3BpZWQgPSBsb3NzeUNvcHlEYXRhKHZhbCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29waWVkLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogbm9EaXNwbGF5ID09PSB0cnVlID8gdW5kZWZpbmVkIDogY29waWVkLmRhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZm9yY2VVcGRhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VXBkYXRlVmVyc2lvbih2ID0+IHYgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtjb2xzTWFwXVxuICAgICk7XG5cbiAgICByZXR1cm4geyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSB9O1xufVxuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".dpsd959{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:hidden;box-sizing:border-box;--overlay-top:var(--dpsd959-0);left:var(--dpsd959-1);top:var(--dpsd959-2);min-width:var(--dpsd959-3);min-height:var(--dpsd959-4);width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:400px;max-height:calc(100vh - var(--dpsd959-5));font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);text-align:start;}@-webkit-keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}@keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}.dpsd959.gdg-style{border-radius:2px;background-color:var(--gdg-bg-cell);box-shadow:0 0 0 1px var(--gdg-accent-color),0px 0px 1px rgba(62,65,86,0.4), 0px 6px 12px rgba(62,65,86,0.15);-webkit-animation:glide_fade_in-dpsd959 60ms 1;animation:glide_fade_in-dpsd959 60ms 1;}.dpsd959.pad{padding:var(--dpsd959-6) 8.5px 3px;}.dpsd959 .clip-region{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow-y:auto;overflow-x:hidden;border-radius:2px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.dpsd959 .clip-region .gdg-growing-entry{height:100%;}.dpsd959 .clip-region input.gdg-input{width:100%;border:none;border-width:0;outline:none;}.dpsd959 .clip-region textarea.gdg-input{border:none;border-width:0;outline:none;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwibmFtZXMiOlsiLmRwc2Q5NTkiXSwibWFwcGluZ3MiOiJBQVEwQ0EiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHRhcmdldFg6IG51bWJlcjtcbiAgICB0YXJnZXRZOiBudW1iZXI7XG4gICAgdGFyZ2V0V2lkdGg6IG51bWJlcjtcbiAgICB0YXJnZXRIZWlnaHQ6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBEYXRhR3JpZE92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXY8UHJvcHM+YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAtLW92ZXJsYXktdG9wOiAke3AgPT4gcC50YXJnZXRZfXB4O1xuXG4gICAgbGVmdDogJHtwID0+IHAudGFyZ2V0WCAtIDF9cHg7XG4gICAgdG9wOiAke3AgPT4gcC50YXJnZXRZIC0gMX1weDtcbiAgICBtaW4td2lkdGg6ICR7cCA9PiBwLnRhcmdldFdpZHRoICsgMn1weDtcbiAgICBtaW4taGVpZ2h0OiAke3AgPT4gcC50YXJnZXRIZWlnaHQgKyAyfXB4O1xuICAgIHdpZHRoOiBtYXgtY29udGVudDtcbiAgICBtYXgtd2lkdGg6IDQwMHB4O1xuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwdmggLSAke3AgPT4gcC50YXJnZXRZICsgMTB9cHgpO1xuXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG5cbiAgICBAa2V5ZnJhbWVzIGdsaWRlX2ZhZGVfaW4ge1xuICAgICAgICBmcm9tIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAlO1xuICAgICAgICB9XG5cbiAgICAgICAgdG8ge1xuICAgICAgICAgICAgb3BhY2l0eTogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuZ2RnLXN0eWxlIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG5cbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpLCAwcHggMHB4IDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNCksXG4gICAgICAgICAgICAwcHggNnB4IDEycHggcmdiYSg2MiwgNjUsIDg2LCAwLjE1KTtcblxuICAgICAgICBhbmltYXRpb246IGdsaWRlX2ZhZGVfaW4gNjBtcyAxO1xuICAgIH1cblxuICAgICYucGFkIHtcbiAgICAgICAgcGFkZGluZzogJHtwID0+IE1hdGgubWF4KDAsIChwLnRhcmdldEhlaWdodCAtIDI4KSAvIDIpfXB4IDguNXB4IDNweDtcbiAgICB9XG5cbiAgICAuY2xpcC1yZWdpb24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIC5nZGctZ3Jvd2luZy1lbnRyeSB7XG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cblxuICAgICAgICAmIGlucHV0LmdkZy1pbnB1dCB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICAgIGJvcmRlci13aWR0aDogMDtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICAmIHRleHRhcmVhLmdkZy1pbnB1dCB7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItd2lkdGg6IDA7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dC1hbGlnbjogc3RhcnQ7XG5gO1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx"],"names":[".dpsd959"],"mappings":"AAQ0CA,SAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,8BAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,0BAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,yCAAAA,CAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,yCAAAA,KAAAA,UAAAA,CAAAA,CAAAA,GAAAA,YAAAA,CAAAA,CAAAA,CAAAA,iCAAAA,KAAAA,UAAAA,CAAAA,CAAAA,GAAAA,YAAAA,CAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,mCAAAA,CAAAA,6GAAAA,CAAAA,8CAAAA,CAAAA,sCAAAA,CAAAA,CAAAA,aAAAA,kCAAAA,CAAAA,CAAAA,sBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,CAAAA,sCAAAA,UAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA;ACP1C,+8FAA+8F","sourcesContent":["import { styled } from \"@linaria/react\";\n\ninterface Props {\n    targetX: number;\n    targetY: number;\n    targetWidth: number;\n    targetHeight: number;\n}\nexport const DataGridOverlayEditorStyle = styled.div<Props>`\n    position: absolute;\n\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    box-sizing: border-box;\n\n    --overlay-top: ${p => p.targetY}px;\n\n    left: ${p => p.targetX - 1}px;\n    top: ${p => p.targetY - 1}px;\n    min-width: ${p => p.targetWidth + 2}px;\n    min-height: ${p => p.targetHeight + 2}px;\n    width: max-content;\n    max-width: 400px;\n    max-height: calc(100vh - ${p => p.targetY + 10}px);\n\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n\n    @keyframes glide_fade_in {\n        from {\n            opacity: 0%;\n        }\n\n        to {\n            opacity: 100%;\n        }\n    }\n\n    &.gdg-style {\n        border-radius: 2px;\n        background-color: var(--gdg-bg-cell);\n\n        box-shadow: 0 0 0 1px var(--gdg-accent-color), 0px 0px 1px rgba(62, 65, 86, 0.4),\n            0px 6px 12px rgba(62, 65, 86, 0.15);\n\n        animation: glide_fade_in 60ms 1;\n    }\n\n    &.pad {\n        padding: ${p => Math.max(0, (p.targetHeight - 28) / 2)}px 8.5px 3px;\n    }\n\n    .clip-region {\n        display: flex;\n        flex-direction: column;\n        overflow-y: auto;\n        overflow-x: hidden;\n        border-radius: 2px;\n        flex-grow: 1;\n\n        .gdg-growing-entry {\n            height: 100%;\n        }\n\n        & input.gdg-input {\n            width: 100%;\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n\n        & textarea.gdg-input {\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n    }\n\n    text-align: start;\n`;\n",".dpsd959{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:hidden;box-sizing:border-box;--overlay-top:var(--dpsd959-0);left:var(--dpsd959-1);top:var(--dpsd959-2);min-width:var(--dpsd959-3);min-height:var(--dpsd959-4);width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:400px;max-height:calc(100vh - var(--dpsd959-5));font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);text-align:start;}@-webkit-keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}@keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}.dpsd959.gdg-style{border-radius:2px;background-color:var(--gdg-bg-cell);box-shadow:0 0 0 1px var(--gdg-accent-color),0px 0px 1px rgba(62,65,86,0.4), 0px 6px 12px rgba(62,65,86,0.15);-webkit-animation:glide_fade_in-dpsd959 60ms 1;animation:glide_fade_in-dpsd959 60ms 1;}.dpsd959.pad{padding:var(--dpsd959-6) 8.5px 3px;}.dpsd959 .clip-region{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow-y:auto;overflow-x:hidden;border-radius:2px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.dpsd959 .clip-region .gdg-growing-entry{height:100%;}.dpsd959 .clip-region input.gdg-input{width:100%;border:none;border-width:0;outline:none;}.dpsd959 .clip-region textarea.gdg-input{border:none;border-width:0;outline:none;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwibmFtZXMiOlsiLmRwc2Q5NTkiXSwibWFwcGluZ3MiOiJBQVEwQ0EiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHRhcmdldFg6IG51bWJlcjtcbiAgICB0YXJnZXRZOiBudW1iZXI7XG4gICAgdGFyZ2V0V2lkdGg6IG51bWJlcjtcbiAgICB0YXJnZXRIZWlnaHQ6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBEYXRhR3JpZE92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXY8UHJvcHM+YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAtLW92ZXJsYXktdG9wOiAke3AgPT4gcC50YXJnZXRZfXB4O1xuXG4gICAgbGVmdDogJHtwID0+IHAudGFyZ2V0WCAtIDF9cHg7XG4gICAgdG9wOiAke3AgPT4gcC50YXJnZXRZIC0gMX1weDtcbiAgICBtaW4td2lkdGg6ICR7cCA9PiBwLnRhcmdldFdpZHRoICsgMn1weDtcbiAgICBtaW4taGVpZ2h0OiAke3AgPT4gcC50YXJnZXRIZWlnaHQgKyAyfXB4O1xuICAgIHdpZHRoOiBtYXgtY29udGVudDtcbiAgICBtYXgtd2lkdGg6IDQwMHB4O1xuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwdmggLSAke3AgPT4gcC50YXJnZXRZICsgMTB9cHgpO1xuXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG5cbiAgICBAa2V5ZnJhbWVzIGdsaWRlX2ZhZGVfaW4ge1xuICAgICAgICBmcm9tIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAlO1xuICAgICAgICB9XG5cbiAgICAgICAgdG8ge1xuICAgICAgICAgICAgb3BhY2l0eTogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICYuZ2RnLXN0eWxlIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG5cbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpLCAwcHggMHB4IDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNCksXG4gICAgICAgICAgICAwcHggNnB4IDEycHggcmdiYSg2MiwgNjUsIDg2LCAwLjE1KTtcblxuICAgICAgICBhbmltYXRpb246IGdsaWRlX2ZhZGVfaW4gNjBtcyAxO1xuICAgIH1cblxuICAgICYucGFkIHtcbiAgICAgICAgcGFkZGluZzogJHtwID0+IE1hdGgubWF4KDAsIChwLnRhcmdldEhlaWdodCAtIDI4KSAvIDIpfXB4IDguNXB4IDNweDtcbiAgICB9XG5cbiAgICAuY2xpcC1yZWdpb24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIC5nZGctZ3Jvd2luZy1lbnRyeSB7XG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cblxuICAgICAgICAmIGlucHV0LmdkZy1pbnB1dCB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICAgIGJvcmRlci13aWR0aDogMDtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICAmIHRleHRhcmVhLmdkZy1pbnB1dCB7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItd2lkdGg6IDA7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dC1hbGlnbjogc3RhcnQ7XG5gO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".bvh4xn4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.bvh4xn4 .boe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:20px;background-color:var(--gdg-bg-bubble);color:var(--gdg-text-dark);margin:2px;}.bvh4xn4 textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwibmFtZXMiOlsiLmJ2aDR4bjQiXSwibWFwcGluZ3MiOiJBQUV5Q0EiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9idWJibGVzLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgQnViYmxlc092ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG5cbiAgICAuYm9lLWJ1YmJsZSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xuXG4gICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgICAgICBoZWlnaHQ6IDIwcHg7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWJ1YmJsZSk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgbWFyZ2luOiAycHg7XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx"],"names":[".bvh4xn4"],"mappings":"AAEyCA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,qCAAAA,CAAAA,0BAAAA,CAAAA,UAAAA,CAAAA,CAAAA,kBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDzC,m1CAAm1C","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const BubblesOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .boe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 20px;\n\n        background-color: var(--gdg-bg-bubble);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n",".bvh4xn4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.bvh4xn4 .boe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:20px;background-color:var(--gdg-bg-bubble);color:var(--gdg-text-dark);margin:2px;}.bvh4xn4 textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwibmFtZXMiOlsiLmJ2aDR4bjQiXSwibWFwcGluZ3MiOiJBQUV5Q0EiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9idWJibGVzLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgQnViYmxlc092ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG5cbiAgICAuYm9lLWJ1YmJsZSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xuXG4gICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgICAgICBoZWlnaHQ6IDIwcHg7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWJ1YmJsZSk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgbWFyZ2luOiAycHg7XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".d11gcyta{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.d11gcyta .doe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:24px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);margin:2px;border-radius:6px;box-shadow:0 0 1px rgba(62,65,86,0.4),0 1px 3px rgba(62,65,86,0.4);}.d11gcyta .doe-bubble img{height:16px;object-fit:contain;margin-right:4px;}.d11gcyta textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvZHJpbGxkb3duLW92ZXJsYXktZWRpdG9yLnRzeCJdLCJuYW1lcyI6WyIuZDExZ2N5dGEiXSwibWFwcGluZ3MiOiJBQUlvQ0EiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9kcmlsbGRvd24tb3ZlcmxheS1lZGl0b3IudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBEcmlsbGRvd25DZWxsRGF0YSB9IGZyb20gXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5jb25zdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuXG4gICAgLmRvZS1idWJibGUge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDBweDtcblxuICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICBtYXJnaW46IDJweDtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNCksIDAgMXB4IDNweCByZ2JhKDYyLCA2NSwgODYsIDAuNCk7XG5cbiAgICAgICAgaW1nIHtcbiAgICAgICAgICAgIGhlaWdodDogMTZweDtcbiAgICAgICAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG5cbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICByZWFkb25seSBkcmlsbGRvd25zOiByZWFkb25seSBEcmlsbGRvd25DZWxsRGF0YVtdO1xufVxuXG5jb25zdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yOiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGRyaWxsZG93bnMgfSA9IHA7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPERyaWxsZG93bk92ZXJsYXlFZGl0b3JTdHlsZT5cbiAgICAgICAgICAgIHtkcmlsbGRvd25zLm1hcCgoZCwgaSkgPT4gKFxuICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJkb2UtYnViYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgIHtkLmltZyAhPT0gdW5kZWZpbmVkICYmIDxpbWcgc3JjPXtkLmltZ30gLz59XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+e2QudGV4dH08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICA8L0RyaWxsZG93bk92ZXJsYXlFZGl0b3JTdHlsZT5cbiAgICApO1xufTtcbmV4cG9ydCBkZWZhdWx0IERyaWxsZG93bk92ZXJsYXlFZGl0b3I7XG4iXX0=*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx"],"names":[".d11gcyta"],"mappings":"AAIoCA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,CAAAA,sBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,mCAAAA,CAAAA,0BAAAA,CAAAA,UAAAA,CAAAA,iBAAAA,CAAAA,kEAAAA,CAAAA,CAAAA,0BAAAA,WAAAA,CAAAA,kBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACHpC,mhFAAmhF","sourcesContent":["import type { DrilldownCellData } from \"../../data-grid/data-grid-types\";\nimport * as React from \"react\";\nimport { styled } from \"@linaria/react\";\n\nconst DrilldownOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .doe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 24px;\n\n        background-color: var(--gdg-bg-cell);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n\n        border-radius: 6px;\n\n        box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n\n        img {\n            height: 16px;\n            object-fit: contain;\n\n            margin-right: 4px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n\ninterface Props {\n    readonly drilldowns: readonly DrilldownCellData[];\n}\n\nconst DrilldownOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { drilldowns } = p;\n    return (\n        <DrilldownOverlayEditorStyle>\n            {drilldowns.map((d, i) => (\n                <div key={i} className=\"doe-bubble\">\n                    {d.img !== undefined && <img src={d.img} />}\n                    <div>{d.text}</div>\n                </div>\n            ))}\n        </DrilldownOverlayEditorStyle>\n    );\n};\nexport default DrilldownOverlayEditor;\n",".d11gcyta{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.d11gcyta .doe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:24px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);margin:2px;border-radius:6px;box-shadow:0 0 1px rgba(62,65,86,0.4),0 1px 3px rgba(62,65,86,0.4);}.d11gcyta .doe-bubble img{height:16px;object-fit:contain;margin-right:4px;}.d11gcyta textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvZHJpbGxkb3duLW92ZXJsYXktZWRpdG9yLnRzeCJdLCJuYW1lcyI6WyIuZDExZ2N5dGEiXSwibWFwcGluZ3MiOiJBQUlvQ0EiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9kcmlsbGRvd24tb3ZlcmxheS1lZGl0b3IudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBEcmlsbGRvd25DZWxsRGF0YSB9IGZyb20gXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5jb25zdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuXG4gICAgLmRvZS1idWJibGUge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDBweDtcblxuICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICBtYXJnaW46IDJweDtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNCksIDAgMXB4IDNweCByZ2JhKDYyLCA2NSwgODYsIDAuNCk7XG5cbiAgICAgICAgaW1nIHtcbiAgICAgICAgICAgIGhlaWdodDogMTZweDtcbiAgICAgICAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG5cbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICByZWFkb25seSBkcmlsbGRvd25zOiByZWFkb25seSBEcmlsbGRvd25DZWxsRGF0YVtdO1xufVxuXG5jb25zdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yOiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGRyaWxsZG93bnMgfSA9IHA7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPERyaWxsZG93bk92ZXJsYXlFZGl0b3JTdHlsZT5cbiAgICAgICAgICAgIHtkcmlsbGRvd25zLm1hcCgoZCwgaSkgPT4gKFxuICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpfSBjbGFzc05hbWU9XCJkb2UtYnViYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgIHtkLmltZyAhPT0gdW5kZWZpbmVkICYmIDxpbWcgc3JjPXtkLmltZ30gLz59XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+e2QudGV4dH08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICA8L0RyaWxsZG93bk92ZXJsYXlFZGl0b3JTdHlsZT5cbiAgICApO1xufTtcbmV4cG9ydCBkZWZhdWx0IERyaWxsZG93bk92ZXJsYXlFZGl0b3I7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".i1v3763o{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100%;}.i1v3763o .centering-container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;}.i1v3763o .centering-container img,.i1v3763o .centering-container canvas{max-height:calc(100vh - var(--overlay-top) - 20px);object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.i1v3763o .centering-container canvas{max-width:380px;}.i1v3763o .edit-icon{position:absolute;top:12px;right:0;width:48px;height:48px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.i1v3763o .edit-icon > *{width:24px;height:24px;}.i1v3763o textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvaW1hZ2Utb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5pMXYzNzYzbyJdLCJtYXBwaW5ncyI6IkFBRXVDQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2ltYWdlLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgSW1hZ2VPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAuY2VudGVyaW5nLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGhlaWdodDogMTAwJTtcblxuICAgICAgICBpbWcsXG4gICAgICAgIGNhbnZhcyB7XG4gICAgICAgICAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0tb3ZlcmxheS10b3ApIC0gMjBweCk7XG4gICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXMge1xuICAgICAgICAgICAgbWF4LXdpZHRoOiAzODBweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMTJweDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx"],"names":[".i1v3763o"],"mappings":"AAEuCA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,CAAAA,+BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yEAAAA,kDAAAA,CAAAA,kBAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,qBAAAA,iBAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,CAAAA,yBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDvC,+6DAA+6D","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const ImageOverlayEditorStyle = styled.div`\n    display: flex;\n\n    height: 100%;\n\n    .centering-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        height: 100%;\n\n        img,\n        canvas {\n            max-height: calc(100vh - var(--overlay-top) - 20px);\n            object-fit: contain;\n            user-select: none;\n        }\n\n        canvas {\n            max-width: 380px;\n        }\n    }\n\n    .edit-icon {\n        position: absolute;\n        top: 12px;\n        right: 0;\n        width: 48px;\n        height: 48px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n",".i1v3763o{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100%;}.i1v3763o .centering-container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;}.i1v3763o .centering-container img,.i1v3763o .centering-container canvas{max-height:calc(100vh - var(--overlay-top) - 20px);object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.i1v3763o .centering-container canvas{max-width:380px;}.i1v3763o .edit-icon{position:absolute;top:12px;right:0;width:48px;height:48px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.i1v3763o .edit-icon > *{width:24px;height:24px;}.i1v3763o textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvaW1hZ2Utb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5pMXYzNzYzbyJdLCJtYXBwaW5ncyI6IkFBRXVDQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2ltYWdlLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgSW1hZ2VPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAuY2VudGVyaW5nLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGhlaWdodDogMTAwJTtcblxuICAgICAgICBpbWcsXG4gICAgICAgIGNhbnZhcyB7XG4gICAgICAgICAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0tb3ZlcmxheS10b3ApIC0gMjBweCk7XG4gICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXMge1xuICAgICAgICAgICAgbWF4LXdpZHRoOiAzODBweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMTJweDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".m1bd3197{min-width:var(--m1bd3197-0);width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;position:relative;color:var(--gdg-text-dark);}.m1bd3197 .gecuh31{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;min-width:0;}.m1bd3197 .spacer{-webkit-flex:1;-ms-flex:1;flex:1;}.m1bd3197 .edit-icon{position:relative;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--gdg-accent-color);padding:0;height:24px;width:24px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:all \"0.125s ease\";transition:all \"0.125s ease\";border-radius:6px;}.m1bd3197 .edit-icon > *{width:16px;height:16px;}.m1bd3197 .edit-hover:hover{background-color:var(--gdg-accent-light);-webkit-transition:background-color 150ms;transition:background-color 150ms;}.m1bd3197 .checkmark-hover:hover{color:#ffffff;background-color:var(--gdg-accent-color);}.m1bd3197 .md-edit-textarea{position:relative;top:0px;left:0px;width:0px;height:0px;margin-top:25px;opacity:0;padding:0;}.m1bd3197 .ml-6{margin-left:6px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvbWFya2Rvd24tb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5tMWJkMzE5NyJdLCJtYXBwaW5ncyI6IkFBTzBDQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL21hcmtkb3duLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdyb3dpbmdFbnRyeVN0eWxlIH0gZnJvbSBcIi4uLy4uL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZVwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgdGFyZ2V0V2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdjxQcm9wcz5gXG4gICAgbWluLXdpZHRoOiAke3AgPT4gcC50YXJnZXRXaWR0aH1weDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgJHtHcm93aW5nRW50cnlTdHlsZX0ge1xuICAgICAgICBmbGV4LXNocmluazogMTtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgIH1cblxuICAgIC5zcGFjZXIge1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgcGFkZGluZzogMDtcblxuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBmbGV4LXNocmluazogMDtcblxuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgXCIwLjEyNXMgZWFzZVwiO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcblxuICAgICAgICA+ICoge1xuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZWRpdC1ob3ZlciB7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTUwbXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuY2hlY2ttYXJrLWhvdmVyIHtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiAjZmZmZmZmO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubWQtZWRpdC10ZXh0YXJlYSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAwcHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDI1cHg7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgfVxuXG4gICAgLm1sLTYge1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgIH1cbmA7XG4iXX0=*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx"],"names":[".m1bd3197"],"mappings":"AAO0CA,UAAAA,2BAAAA,CAAAA,UAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,8BAAAA,CAAAA,4BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,wBAAAA,CAAAA,qCAAAA,CAAAA,qBAAAA,CAAAA,6BAAAA,CAAAA,iBAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,mBAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,CAAAA,kBAAAA,cAAAA,CAAAA,UAAAA,CAAAA,MAAAA,CAAAA,CAAAA,qBAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,6BAAAA,CAAAA,SAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,oCAAAA,CAAAA,4BAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,yBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,4BAAAA,wCAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,CAAAA,iCAAAA,aAAAA,CAAAA,wCAAAA,CAAAA,CAAAA,4BAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,SAAAA,CAAAA,SAAAA,CAAAA,CAAAA,gBAAAA,eAAAA,CAAAA;ACN1C,uoFAAuoF","sourcesContent":["import { GrowingEntryStyle } from \"../../growing-entry/growing-entry-style\";\nimport { styled } from \"@linaria/react\";\n\ninterface Props {\n    targetWidth: number;\n}\n\nexport const MarkdownOverlayEditorStyle = styled.div<Props>`\n    min-width: ${p => p.targetWidth}px;\n    width: 100%;\n    display: flex;\n    align-items: flex-start;\n    justify-content: space-between;\n    position: relative;\n    color: var(--gdg-text-dark);\n\n    ${GrowingEntryStyle} {\n        flex-shrink: 1;\n        min-width: 0;\n    }\n\n    .spacer {\n        flex: 1;\n    }\n\n    .edit-icon {\n        position: relative;\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        color: var(--gdg-accent-color);\n\n        padding: 0;\n\n        height: 24px;\n        width: 24px;\n        flex-shrink: 0;\n\n        transition: all \"0.125s ease\";\n\n        border-radius: 6px;\n\n        > * {\n            width: 16px;\n            height: 16px;\n        }\n    }\n\n    .edit-hover {\n        :hover {\n            background-color: var(--gdg-accent-light);\n            transition: background-color 150ms;\n        }\n    }\n\n    .checkmark-hover {\n        :hover {\n            color: #ffffff;\n            background-color: var(--gdg-accent-color);\n        }\n    }\n\n    .md-edit-textarea {\n        position: relative;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n        margin-top: 25px;\n        opacity: 0;\n        padding: 0;\n    }\n\n    .ml-6 {\n        margin-left: 6px;\n    }\n`;\n",".m1bd3197{min-width:var(--m1bd3197-0);width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;position:relative;color:var(--gdg-text-dark);}.m1bd3197 .gecuh31{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;min-width:0;}.m1bd3197 .spacer{-webkit-flex:1;-ms-flex:1;flex:1;}.m1bd3197 .edit-icon{position:relative;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--gdg-accent-color);padding:0;height:24px;width:24px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:all \"0.125s ease\";transition:all \"0.125s ease\";border-radius:6px;}.m1bd3197 .edit-icon > *{width:16px;height:16px;}.m1bd3197 .edit-hover:hover{background-color:var(--gdg-accent-light);-webkit-transition:background-color 150ms;transition:background-color 150ms;}.m1bd3197 .checkmark-hover:hover{color:#ffffff;background-color:var(--gdg-accent-color);}.m1bd3197 .md-edit-textarea{position:relative;top:0px;left:0px;width:0px;height:0px;margin-top:25px;opacity:0;padding:0;}.m1bd3197 .ml-6{margin-left:6px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvbWFya2Rvd24tb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5tMWJkMzE5NyJdLCJtYXBwaW5ncyI6IkFBTzBDQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL21hcmtkb3duLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdyb3dpbmdFbnRyeVN0eWxlIH0gZnJvbSBcIi4uLy4uL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZVwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgdGFyZ2V0V2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdjxQcm9wcz5gXG4gICAgbWluLXdpZHRoOiAke3AgPT4gcC50YXJnZXRXaWR0aH1weDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgJHtHcm93aW5nRW50cnlTdHlsZX0ge1xuICAgICAgICBmbGV4LXNocmluazogMTtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgIH1cblxuICAgIC5zcGFjZXIge1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgcGFkZGluZzogMDtcblxuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBmbGV4LXNocmluazogMDtcblxuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgXCIwLjEyNXMgZWFzZVwiO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcblxuICAgICAgICA+ICoge1xuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZWRpdC1ob3ZlciB7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTUwbXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuY2hlY2ttYXJrLWhvdmVyIHtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiAjZmZmZmZmO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubWQtZWRpdC10ZXh0YXJlYSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAwcHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDI1cHg7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgfVxuXG4gICAgLm1sLTYge1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgIH1cbmA7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".uvnt6gu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:21px;}.uvnt6gu .link-area{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;cursor:pointer;margin-right:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--gdg-link-color);-webkit-text-decoration:underline !important;text-decoration:underline !important;}.uvnt6gu .edit-icon{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:32px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.uvnt6gu .edit-icon > *{width:24px;height:24px;}.uvnt6gu textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvdXJpLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIudXZudDZndSJdLCJtYXBwaW5ncyI6IkFBRXFDQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL3VyaS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IFVyaU92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcblxuICAgIGZsZXgtZ3JvdzogMTtcblxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICBtaW4taGVpZ2h0OiAyMXB4O1xuXG4gICAgLmxpbmstYXJlYSB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcblxuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWxpbmstY29sb3IpO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx"],"names":[".uvnt6gu"],"mappings":"AAEqCA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,eAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,2BAAAA,CAAAA,4CAAAA,CAAAA,oCAAAA,CAAAA,CAAAA,oBAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,CAAAA,wBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,kBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDrC,+yDAA+yD","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const UriOverlayEditorStyle = styled.div`\n    display: flex;\n\n    flex-grow: 1;\n\n    align-items: center;\n\n    min-height: 21px;\n\n    .link-area {\n        flex-grow: 1;\n        flex-shrink: 1;\n\n        cursor: pointer;\n\n        margin-right: 8px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n\n        color: var(--gdg-link-color);\n        text-decoration: underline !important;\n    }\n\n    .edit-icon {\n        flex-shrink: 0;\n        width: 32px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n",".uvnt6gu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:21px;}.uvnt6gu .link-area{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;cursor:pointer;margin-right:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--gdg-link-color);-webkit-text-decoration:underline !important;text-decoration:underline !important;}.uvnt6gu .edit-icon{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:32px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.uvnt6gu .edit-icon > *{width:24px;height:24px;}.uvnt6gu textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvdXJpLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIudXZudDZndSJdLCJtYXBwaW5ncyI6IkFBRXFDQSIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL3VyaS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IFVyaU92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcblxuICAgIGZsZXgtZ3JvdzogMTtcblxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICBtaW4taGVpZ2h0OiAyMXB4O1xuXG4gICAgLmxpbmstYXJlYSB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcblxuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWxpbmstY29sb3IpO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-search/data-grid-search-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".s11k75lr{position:absolute;top:4px;right:20px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);padding:8px;border:1px solid var(--gdg-border-color);border-radius:6px;font-size:var(--gdg-editor-font-size);-webkit-transform:translateX(var(--s11k75lr-0));-ms-transform:translateX(var(--s11k75lr-0));transform:translateX(var(--s11k75lr-0));-webkit-transition:-webkit-transform 0.15s;-webkit-transition:transform 0.15s;transition:transform 0.15s;}.s11k75lr .search-bar-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.s11k75lr .search-status{padding-top:4px;font-size:11px;}.s11k75lr .search-progress{position:absolute;height:4px;left:0;bottom:0;background-color:var(--gdg-text-light);}.s11k75lr input{width:220px;color:var(--gdg-textDark);background-color:var(--gdg-bg-cell);border:none;border-width:0;outline:none;}.s11k75lr button{width:24px;height:24px;padding:0;border:none;outline:none;background:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;color:var(--gdg-text-medium);}.s11k75lr button:hover{color:var(--gdg-text-dark);}.s11k75lr button .button-icon{width:16px;height:16px;}.s11k75lr button:disabled{opacity:0.4;pointer-events:none;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIuczExazc1bHIiXSwibWFwcGluZ3MiOiJBQUU2QkEiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtc2VhcmNoL2RhdGEtZ3JpZC1zZWFyY2gtc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBTZWFyY2hXcmFwcGVyID0gc3R5bGVkLmRpdjx7IHNob3dTZWFyY2g6IGJvb2xlYW4gfT5gXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNHB4O1xuICAgIHJpZ2h0OiAyMHB4O1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgIHBhZGRpbmc6IDhweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKTtcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcblxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgke3AgPT4gKHAuc2hvd1NlYXJjaCA/IDAgOiA0MDApfXB4KTtcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xNXM7XG5cbiAgICAuc2VhcmNoLWJhci1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuXG4gICAgLnNlYXJjaC1zdGF0dXMge1xuICAgICAgICBwYWRkaW5nLXRvcDogNHB4O1xuICAgICAgICBmb250LXNpemU6IDExcHg7XG4gICAgfVxuXG4gICAgLnNlYXJjaC1wcm9ncmVzcyB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgaGVpZ2h0OiA0cHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctdGV4dC1saWdodCk7XG4gICAgfVxuXG4gICAgaW5wdXQge1xuICAgICAgICB3aWR0aDogMjIwcHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dERhcmspO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgIH1cblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIHBhZGRpbmc6IDA7XG5cbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBiYWNrZ3JvdW5kOiBub25lO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1tZWRpdW0pO1xuXG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIH1cblxuICAgICAgICAuYnV0dG9uLWljb24ge1xuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIH1cblxuICAgICAgICA6ZGlzYWJsZWQge1xuICAgICAgICAgICAgb3BhY2l0eTogMC40O1xuICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-search/data-grid-search-style.tsx","webpack://./packages/core/src/data-grid-search/data-grid-search-style.tsx"],"names":[".s11k75lr"],"mappings":"AAE6BA,UAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,UAAAA,CAAAA,mCAAAA,CAAAA,0BAAAA,CAAAA,WAAAA,CAAAA,wCAAAA,CAAAA,iBAAAA,CAAAA,qCAAAA,CAAAA,+CAAAA,CAAAA,2CAAAA,CAAAA,uCAAAA,CAAAA,0CAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,4BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,CAAAA,yBAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,2BAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,sCAAAA,CAAAA,CAAAA,gBAAAA,WAAAA,CAAAA,yBAAAA,CAAAA,mCAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA,CAAAA,iBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,SAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,eAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,uBAAAA,0BAAAA,CAAAA,CAAAA,8BAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,0BAAAA,WAAAA,CAAAA,mBAAAA,CAAAA;ACD7B,+iFAA+iF","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const SearchWrapper = styled.div<{ showSearch: boolean }>`\n    position: absolute;\n    top: 4px;\n    right: 20px;\n\n    background-color: var(--gdg-bg-cell);\n    color: var(--gdg-text-dark);\n\n    padding: 8px;\n    border: 1px solid var(--gdg-border-color);\n    border-radius: 6px;\n\n    font-size: var(--gdg-editor-font-size);\n\n    transform: translateX(${p => (p.showSearch ? 0 : 400)}px);\n    transition: transform 0.15s;\n\n    .search-bar-inner {\n        display: flex;\n    }\n\n    .search-status {\n        padding-top: 4px;\n        font-size: 11px;\n    }\n\n    .search-progress {\n        position: absolute;\n        height: 4px;\n        left: 0;\n        bottom: 0;\n\n        background-color: var(--gdg-text-light);\n    }\n\n    input {\n        width: 220px;\n        color: var(--gdg-textDark);\n        background-color: var(--gdg-bg-cell);\n        border: none;\n        border-width: 0;\n        outline: none;\n    }\n\n    button {\n        width: 24px;\n        height: 24px;\n        padding: 0;\n\n        border: none;\n        outline: none;\n        background: none;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        cursor: pointer;\n        color: var(--gdg-text-medium);\n\n        :hover {\n            color: var(--gdg-text-dark);\n        }\n\n        .button-icon {\n            width: 16px;\n            height: 16px;\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n`;\n",".s11k75lr{position:absolute;top:4px;right:20px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);padding:8px;border:1px solid var(--gdg-border-color);border-radius:6px;font-size:var(--gdg-editor-font-size);-webkit-transform:translateX(var(--s11k75lr-0));-ms-transform:translateX(var(--s11k75lr-0));transform:translateX(var(--s11k75lr-0));-webkit-transition:-webkit-transform 0.15s;-webkit-transition:transform 0.15s;transition:transform 0.15s;}.s11k75lr .search-bar-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.s11k75lr .search-status{padding-top:4px;font-size:11px;}.s11k75lr .search-progress{position:absolute;height:4px;left:0;bottom:0;background-color:var(--gdg-text-light);}.s11k75lr input{width:220px;color:var(--gdg-textDark);background-color:var(--gdg-bg-cell);border:none;border-width:0;outline:none;}.s11k75lr button{width:24px;height:24px;padding:0;border:none;outline:none;background:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;color:var(--gdg-text-medium);}.s11k75lr button:hover{color:var(--gdg-text-dark);}.s11k75lr button .button-icon{width:16px;height:16px;}.s11k75lr button:disabled{opacity:0.4;pointer-events:none;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIuczExazc1bHIiXSwibWFwcGluZ3MiOiJBQUU2QkEiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtc2VhcmNoL2RhdGEtZ3JpZC1zZWFyY2gtc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBTZWFyY2hXcmFwcGVyID0gc3R5bGVkLmRpdjx7IHNob3dTZWFyY2g6IGJvb2xlYW4gfT5gXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNHB4O1xuICAgIHJpZ2h0OiAyMHB4O1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgIHBhZGRpbmc6IDhweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKTtcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcblxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgke3AgPT4gKHAuc2hvd1NlYXJjaCA/IDAgOiA0MDApfXB4KTtcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xNXM7XG5cbiAgICAuc2VhcmNoLWJhci1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuXG4gICAgLnNlYXJjaC1zdGF0dXMge1xuICAgICAgICBwYWRkaW5nLXRvcDogNHB4O1xuICAgICAgICBmb250LXNpemU6IDExcHg7XG4gICAgfVxuXG4gICAgLnNlYXJjaC1wcm9ncmVzcyB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgaGVpZ2h0OiA0cHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctdGV4dC1saWdodCk7XG4gICAgfVxuXG4gICAgaW5wdXQge1xuICAgICAgICB3aWR0aDogMjIwcHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dERhcmspO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgIH1cblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIHBhZGRpbmc6IDA7XG5cbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBiYWNrZ3JvdW5kOiBub25lO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1tZWRpdW0pO1xuXG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIH1cblxuICAgICAgICAuYnV0dG9uLWljb24ge1xuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIH1cblxuICAgICAgICA6ZGlzYWJsZWQge1xuICAgICAgICAgICAgb3BhY2l0eTogMC40O1xuICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/doc-wrapper.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".w1gh5fuv{overflow:hidden;position:relative;border-radius:12px;box-shadow:0 2px 5px rgba(0,0,0,0.2),0 0 1px rgba(0,0,0,0.4);width:100%;height:var(--w1gh5fuv-0);margin:24px 0;}.w1gh5fuv > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\n.b1bk6rj1{background:white;color:#222222;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;font-family:sans-serif;}.b1bk6rj1 .inner{position:relative;width:900px;}.b1bk6rj1 .inner > pre{font-size:14px;border-radius:9px;}.b1bk6rj1 .marked{font-family:Helvetica,arial,sans-serif;font-size:18px;line-height:1.6;}.b1bk6rj1 .marked > *:first-child{margin-top:0 !important;}.b1bk6rj1 .marked > *:last-child{margin-bottom:0 !important;}.b1bk6rj1 .marked a{color:#4183c4;}.b1bk6rj1 .marked a.absent{color:#cc0000;}.b1bk6rj1 .marked a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0;}.b1bk6rj1 .marked h1,.b1bk6rj1 .marked h2,.b1bk6rj1 .marked h3,.b1bk6rj1 .marked h4,.b1bk6rj1 .marked h5,.b1bk6rj1 .marked h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased;cursor:text;position:relative;}.b1bk6rj1 .marked h1:hover a.anchor,.b1bk6rj1 .marked h2:hover a.anchor,.b1bk6rj1 .marked h3:hover a.anchor,.b1bk6rj1 .marked h4:hover a.anchor,.b1bk6rj1 .marked h5:hover a.anchor,.b1bk6rj1 .marked h6:hover a.anchor{-webkit-text-decoration:none;text-decoration:none;}.b1bk6rj1 .marked h1 tt,.b1bk6rj1 .marked h1 code{font-size:inherit;}.b1bk6rj1 .marked h2 tt,.b1bk6rj1 .marked h2 code{font-size:inherit;}.b1bk6rj1 .marked h3 tt,.b1bk6rj1 .marked h3 code{font-size:inherit;}.b1bk6rj1 .marked h4 tt,.b1bk6rj1 .marked h4 code{font-size:inherit;}.b1bk6rj1 .marked h5 tt,.b1bk6rj1 .marked h5 code{font-size:inherit;}.b1bk6rj1 .marked h6 tt,.b1bk6rj1 .marked h6 code{font-size:inherit;}.b1bk6rj1 .marked h1{font-size:32px;color:black;}.b1bk6rj1 .marked h2{font-size:28px;border-bottom:1px solid #cccccc;color:black;}.b1bk6rj1 .marked h3{font-size:22px;}.b1bk6rj1 .marked h4{font-size:20px;}.b1bk6rj1 .marked h5{font-size:18px;}.b1bk6rj1 .marked h6{color:#777777;font-size:18px;}.b1bk6rj1 .marked p,.b1bk6rj1 .marked blockquote,.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol,.b1bk6rj1 .marked dl,.b1bk6rj1 .marked li,.b1bk6rj1 .marked table,.b1bk6rj1 .marked pre{margin:20px 0;}.b1bk6rj1 .marked hr{border:0 none;color:#cccccc;height:4px;padding:0;}.b1bk6rj1 .marked > h2:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child + h2{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h3:first-child,.b1bk6rj1 .marked > h4:first-child,.b1bk6rj1 .marked > h5:first-child,.b1bk6rj1 .marked > h6:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked a:first-child h1,.b1bk6rj1 .marked a:first-child h2,.b1bk6rj1 .marked a:first-child h3,.b1bk6rj1 .marked a:first-child h4,.b1bk6rj1 .marked a:first-child h5,.b1bk6rj1 .marked a:first-child h6{margin-top:0;padding-top:0;}.b1bk6rj1 .marked h1 p,.b1bk6rj1 .marked h2 p,.b1bk6rj1 .marked h3 p,.b1bk6rj1 .marked h4 p,.b1bk6rj1 .marked h5 p,.b1bk6rj1 .marked h6 p{margin-top:0;}.b1bk6rj1 .marked li p.first{display:inline-block;}.b1bk6rj1 .marked li{margin:0;}.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol{padding-left:30px;}.b1bk6rj1 .marked ul :first-child,.b1bk6rj1 .marked ol :first-child{margin-top:0;}.b1bk6rj1 .marked dl{padding:0;}.b1bk6rj1 .marked dl dt{font-size:18px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px;}.b1bk6rj1 .marked dl dt:first-child{padding:0;}.b1bk6rj1 .marked dl dt > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dt > :last-child{margin-bottom:0;}.b1bk6rj1 .marked dl dd{margin:0 0 15px;padding:0 15px;}.b1bk6rj1 .marked dl dd > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dd > :last-child{margin-bottom:0;}.b1bk6rj1 .marked blockquote{border-left:4px solid #dddddd;padding:0 15px;color:#777777;}.b1bk6rj1 .marked blockquote > :first-child{margin-top:0;}.b1bk6rj1 .marked blockquote > :last-child{margin-bottom:0;}.b1bk6rj1 .marked table{font-size:14px;padding:0;border-collapse:collapse;}.b1bk6rj1 .marked table tr{border-top:1px solid #cccccc;background-color:white;margin:0;padding:0;}.b1bk6rj1 .marked table tr:nth-child(2n){background-color:#f8f8f8;}.b1bk6rj1 .marked table tr th{font-weight:bold;border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr td{border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr th :first-child,.b1bk6rj1 .marked table tr td :first-child{margin-top:0;}.b1bk6rj1 .marked table tr th :last-child,.b1bk6rj1 .marked table tr td :last-child{margin-bottom:0;}.b1bk6rj1 .marked img{max-width:100%;}.b1bk6rj1 .marked span.frame{display:block;overflow:hidden;}.b1bk6rj1 .marked span.frame > span{border:1px solid #dddddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto;}.b1bk6rj1 .marked span.frame span img{display:block;float:left;}.b1bk6rj1 .marked span.frame span span{clear:both;color:#333333;display:block;padding:5px 0 0;}.b1bk6rj1 .marked span.align-center{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center;}.b1bk6rj1 .marked span.align-center span img{margin:0 auto;text-align:center;}.b1bk6rj1 .marked span.align-right{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right;}.b1bk6rj1 .marked span.align-right span img{margin:0;text-align:right;}.b1bk6rj1 .marked span.float-left{display:block;margin-right:13px;overflow:hidden;float:left;}.b1bk6rj1 .marked span.float-left span{margin:13px 0 0;}.b1bk6rj1 .marked span.float-right{display:block;margin-left:13px;overflow:hidden;float:right;}.b1bk6rj1 .marked span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right;}.b1bk6rj1 .marked code,.b1bk6rj1 .marked tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px;}.b1bk6rj1 .marked pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent;}.b1bk6rj1 .marked .highlight pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre code,.b1bk6rj1 .marked pre tt{background-color:transparent;border:none;}.b1bk6rj1 .marked sup{font-size:0.83em;vertical-align:super;line-height:0;}.b1bk6rj1 .marked *{-webkit-print-color-adjust:exact;}\n.p65g85a{font-family:monospace;font-weight:500;color:#ffe394;}\n.d2b9oy3{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.mnvl60p{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.mnvl60p button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZG9jcy9kb2Mtd3JhcHBlci50c3giXSwibmFtZXMiOlsiLncxZ2g1ZnV2IiwiLmIxYms2cmoxIiwiLnA2NWc4NWEiLCIuZDJiOW95MyIsIi5tbnZsNjBwIl0sIm1hcHBpbmdzIjoiQUFVdUJBO0FBNkNBQztBQStaQ0M7QUFNR0M7QUFNSEMiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kb2NzL2RvYy13cmFwcGVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgbWFya2VkIH0gZnJvbSBcIm1hcmtlZFwiO1xuaW1wb3J0IFN5bnRheEhpZ2hsaWdodGVyIGZyb20gXCJyZWFjdC1zeW50YXgtaGlnaGxpZ2h0ZXJcIjtcbmltcG9ydCBoaWdobGlnaHRTdHlsZSBmcm9tIFwicmVhY3Qtc3ludGF4LWhpZ2hsaWdodGVyL2Rpc3QvZXNtL3N0eWxlcy9obGpzL2dpdGh1YlwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdyYXBwZXJQcm9wcyB7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBXcmFwcGVyID0gc3R5bGVkLmRpdjxXcmFwcGVyUHJvcHM+YFxuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcblxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAke3AgPT4gcC5oZWlnaHR9cHg7XG5cbiAgICBtYXJnaW46IDI0cHggMDtcblxuICAgID4gOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IEhpZ2hsaWdodDogUmVhY3QuVkZDPHsgY2hpbGRyZW46IHN0cmluZyB9PiA9IHAgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTeW50YXhIaWdobGlnaHRlclxuICAgICAgICAgICAgc3R5bGU9e2hpZ2hsaWdodFN0eWxlfVxuICAgICAgICAgICAgc2hvd0xpbmVOdW1iZXJzPXt0cnVlfVxuICAgICAgICAgICAgbGluZU51bWJlclN0eWxlPXt7IG9wYWNpdHk6IDAuNSB9fVxuICAgICAgICAgICAgbGFuZ3VhZ2U9XCJ0eXBlc2NyaXB0XCI+XG4gICAgICAgICAgICB7cC5jaGlsZHJlbi50cmltKCl9XG4gICAgICAgIDwvU3ludGF4SGlnaGxpZ2h0ZXI+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBNYXJrZWQ6IFJlYWN0LlZGQzx7IGNoaWxkcmVuOiBzdHJpbmcgfT4gPSBwID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtYXJrZWRcIlxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tcbiAgICAgICAgICAgICAgICBfX2h0bWw6IG1hcmtlZChwLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKTtcbn07XG5cbmNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBjb2xvcjogIzIyMjIyMjtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmIC5pbm5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDkwMHB4O1xuXG4gICAgICAgID4gcHJlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDlweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5tYXJrZWQge1xuICAgICAgICBmb250LWZhbWlseTogSGVsdmV0aWNhLCBhcmlhbCwgc2Fucy1zZXJpZjtcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMS42O1xuXG4gICAgICAgID4gKjpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgPiAqOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMCAhaW1wb3J0YW50O1xuICAgICAgICB9XG5cbiAgICAgICAgYSB7XG4gICAgICAgICAgICBjb2xvcjogIzQxODNjNDtcbiAgICAgICAgfVxuICAgICAgICBhLmFic2VudCB7XG4gICAgICAgICAgICBjb2xvcjogI2NjMDAwMDtcbiAgICAgICAgfVxuICAgICAgICBhLmFuY2hvciB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogMzBweDtcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAtMzBweDtcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgIH1cblxuICAgICAgICBoMSxcbiAgICAgICAgaDIsXG4gICAgICAgIGgzLFxuICAgICAgICBoNCxcbiAgICAgICAgaDUsXG4gICAgICAgIGg2IHtcbiAgICAgICAgICAgIG1hcmdpbjogMjBweCAwIDEwcHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbiAgICAgICAgICAgIGN1cnNvcjogdGV4dDtcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxOmhvdmVyIGEuYW5jaG9yLFxuICAgICAgICBoMjpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDM6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGg0OmhvdmVyIGEuYW5jaG9yLFxuICAgICAgICBoNTpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDY6aG92ZXIgYS5hbmNob3Ige1xuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEgdHQsXG4gICAgICAgIGgxIGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDIgdHQsXG4gICAgICAgIGgyIGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDMgdHQsXG4gICAgICAgIGgzIGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDQgdHQsXG4gICAgICAgIGg0IGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDUgdHQsXG4gICAgICAgIGg1IGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDYgdHQsXG4gICAgICAgIGg2IGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDEge1xuICAgICAgICAgICAgZm9udC1zaXplOiAzMnB4O1xuICAgICAgICAgICAgY29sb3I6IGJsYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaDIge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyOHB4O1xuICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBjb2xvcjogYmxhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBoMyB7XG4gICAgICAgICAgICBmb250LXNpemU6IDIycHg7XG4gICAgICAgIH1cblxuICAgICAgICBoNCB7XG4gICAgICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIH1cblxuICAgICAgICBoNSB7XG4gICAgICAgICAgICBmb250LXNpemU6IDE4cHg7XG4gICAgICAgIH1cblxuICAgICAgICBoNiB7XG4gICAgICAgICAgICBjb2xvcjogIzc3Nzc3NztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHAsXG4gICAgICAgIGJsb2NrcXVvdGUsXG4gICAgICAgIHVsLFxuICAgICAgICBvbCxcbiAgICAgICAgZGwsXG4gICAgICAgIGxpLFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgcHJlIHtcbiAgICAgICAgICAgIG1hcmdpbjogMjBweCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaHIge1xuICAgICAgICAgICAgYm9yZGVyOiAwIG5vbmU7XG4gICAgICAgICAgICBjb2xvcjogI2NjY2NjYztcbiAgICAgICAgICAgIGhlaWdodDogNHB4O1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgfVxuXG4gICAgICAgID4gaDI6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgID4gaDE6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgID4gaDE6Zmlyc3QtY2hpbGQgKyBoMiB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDA7XG4gICAgICAgIH1cbiAgICAgICAgPiBoMzpmaXJzdC1jaGlsZCxcbiAgICAgICAgPiBoNDpmaXJzdC1jaGlsZCxcbiAgICAgICAgPiBoNTpmaXJzdC1jaGlsZCxcbiAgICAgICAgPiBoNjpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBhOmZpcnN0LWNoaWxkIGgxLFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGgyLFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGgzLFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGg0LFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGg1LFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGg2IHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHAsXG4gICAgICAgIGgyIHAsXG4gICAgICAgIGgzIHAsXG4gICAgICAgIGg0IHAsXG4gICAgICAgIGg1IHAsXG4gICAgICAgIGg2IHAge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpIHAuZmlyc3Qge1xuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGxpIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgfVxuICAgICAgICB1bCxcbiAgICAgICAgb2wge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAzMHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgdWwgOmZpcnN0LWNoaWxkLFxuICAgICAgICBvbCA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZHQge1xuICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgICAgbWFyZ2luOiAxNXB4IDAgNXB4O1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0OmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZHQgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkdCA+IDpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZGQge1xuICAgICAgICAgICAgbWFyZ2luOiAwIDAgMTVweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgMTVweDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkZCA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGRkID4gOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJsb2NrcXVvdGUge1xuICAgICAgICAgICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjZGRkZGRkO1xuICAgICAgICAgICAgcGFkZGluZzogMCAxNXB4O1xuICAgICAgICAgICAgY29sb3I6ICM3Nzc3Nzc7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2txdW90ZSA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrcXVvdGUgPiA6bGFzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgdHIge1xuICAgICAgICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgdHI6bnRoLWNoaWxkKDJuKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHRoIHtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAxM3B4O1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHRkIHtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTNweDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCA6Zmlyc3QtY2hpbGQsXG4gICAgICAgIHRhYmxlIHRyIHRkIDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHRoIDpsYXN0LWNoaWxkLFxuICAgICAgICB0YWJsZSB0ciB0ZCA6bGFzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nIHtcbiAgICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwYW4uZnJhbWUge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZnJhbWUgPiBzcGFuIHtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZGRkZGQ7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCAwIDA7XG4gICAgICAgICAgICBwYWRkaW5nOiA3cHg7XG4gICAgICAgICAgICB3aWR0aDogYXV0bztcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZyYW1lIHNwYW4gaW1nIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mcmFtZSBzcGFuIHNwYW4ge1xuICAgICAgICAgICAgY2xlYXI6IGJvdGg7XG4gICAgICAgICAgICBjb2xvcjogIzMzMzMzMztcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgcGFkZGluZzogNXB4IDAgMDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLWNlbnRlciB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBjbGVhcjogYm90aDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLWNlbnRlciA+IHNwYW4ge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgbWFyZ2luOiAxM3B4IGF1dG8gMDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLWNlbnRlciBzcGFuIGltZyB7XG4gICAgICAgICAgICBtYXJnaW46IDAgYXV0bztcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLXJpZ2h0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uYWxpZ24tcmlnaHQgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCAwIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLXJpZ2h0IHNwYW4gaW1nIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZmxvYXQtbGVmdCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogMTNweDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LWxlZnQgc3BhbiB7XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZmxvYXQtcmlnaHQge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogMTNweDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mbG9hdC1yaWdodCA+IHNwYW4ge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgbWFyZ2luOiAxM3B4IGF1dG8gMDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSxcbiAgICAgICAgdHQge1xuICAgICAgICAgICAgbWFyZ2luOiAwIDJweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgNXB4O1xuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNlYWVhZWE7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlIGNvZGUge1xuICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBwcmU7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5oaWdobGlnaHQgcHJlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmOGY4Zjg7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgZm9udC1zaXplOiAxN3B4O1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDIzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAxMHB4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmOGY4Zjg7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgZm9udC1zaXplOiAxN3B4O1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDIzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAxMHB4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgICB9XG4gICAgICAgIHByZSBjb2RlLFxuICAgICAgICBwcmUgdHQge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBzdXAge1xuICAgICAgICAgICAgZm9udC1zaXplOiAwLjgzZW07XG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogc3VwZXI7XG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcbiAgICAgICAgfVxuICAgICAgICAqIHtcbiAgICAgICAgICAgIC13ZWJraXQtcHJpbnQtY29sb3ItYWRqdXN0OiBleGFjdDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcm9wTmFtZSA9IHN0eWxlZC5zcGFuYFxuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBjb2xvcjogI2ZmZTM5NDtcbmA7XG5cbmV4cG9ydCBjb25zdCBEZXNjcmlwdGlvbiA9IHN0eWxlZC5wYFxuICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICBmbGV4LXNocmluazogMDtcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgTW9yZUluZm8gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XG4gICAgICAgIHBhZGRpbmc6IDJweCA2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IERvY1dyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcDtcbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlubmVyXCI+e2NoaWxkcmVufTwvZGl2PlxuICAgICAgICA8L0JlYXV0aWZ1bFN0eWxlPlxuICAgICk7XG59O1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/docs/doc-wrapper.tsx","webpack://./packages/core/src/docs/doc-wrapper.tsx"],"names":[".w1gh5fuv",".b1bk6rj1",".p65g85a",".d2b9oy3",".mnvl60p"],"mappings":"AAUuBA,UAAAA,eAAAA,CAAAA,iBAAAA,CAAAA,kBAAAA,CAAAA,4DAAAA,CAAAA,UAAAA,CAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,yBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;AA6CAC,UAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,gBAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,uBAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,kBAAAA,sCAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,CAAAA,kCAAAA,uBAAAA,CAAAA,CAAAA,iCAAAA,0BAAAA,CAAAA,CAAAA,oBAAAA,aAAAA,CAAAA,CAAAA,2BAAAA,aAAAA,CAAAA,CAAAA,2BAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,KAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,8HAAAA,kBAAAA,CAAAA,SAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,wNAAAA,4BAAAA,CAAAA,oBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,WAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,+BAAAA,CAAAA,WAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,aAAAA,CAAAA,cAAAA,CAAAA,CAAAA,mLAAAA,aAAAA,CAAAA,CAAAA,qBAAAA,aAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA,CAAAA,mCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,mCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,wCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,4IAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,kNAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,0IAAAA,YAAAA,CAAAA,CAAAA,6BAAAA,oBAAAA,CAAAA,CAAAA,qBAAAA,QAAAA,CAAAA,CAAAA,0CAAAA,iBAAAA,CAAAA,CAAAA,oEAAAA,YAAAA,CAAAA,CAAAA,qBAAAA,SAAAA,CAAAA,CAAAA,wBAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,SAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oCAAAA,SAAAA,CAAAA,CAAAA,uCAAAA,YAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,wBAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,uCAAAA,YAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,6BAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,aAAAA,CAAAA,CAAAA,4CAAAA,YAAAA,CAAAA,CAAAA,2CAAAA,eAAAA,CAAAA,CAAAA,wBAAAA,cAAAA,CAAAA,SAAAA,CAAAA,wBAAAA,CAAAA,CAAAA,2BAAAA,4BAAAA,CAAAA,sBAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,CAAAA,yCAAAA,wBAAAA,CAAAA,CAAAA,8BAAAA,gBAAAA,CAAAA,wBAAAA,CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,8BAAAA,wBAAAA,CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,sFAAAA,YAAAA,CAAAA,CAAAA,oFAAAA,eAAAA,CAAAA,CAAAA,sBAAAA,cAAAA,CAAAA,CAAAA,6BAAAA,aAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oCAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,CAAAA,sCAAAA,aAAAA,CAAAA,UAAAA,CAAAA,CAAAA,uCAAAA,UAAAA,CAAAA,aAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oCAAAA,aAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,2CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,kBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,6CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,mCAAAA,aAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,0CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,4CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,kCAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,uCAAAA,eAAAA,CAAAA,CAAAA,mCAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,CAAAA,0CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,kBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,4CAAAA,YAAAA,CAAAA,aAAAA,CAAAA,kBAAAA,CAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,2BAAAA,QAAAA,CAAAA,SAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iCAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,sBAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oDAAAA,4BAAAA,CAAAA,WAAAA,CAAAA,CAAAA,sBAAAA,gBAAAA,CAAAA,oBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,oBAAAA,gCAAAA,CAAAA;AA+ZCC,SAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA;AAMGC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AAMHC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,gBAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA;AC7dxB,2veAA2ve","sourcesContent":["import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { marked } from \"marked\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\nimport highlightStyle from \"react-syntax-highlighter/dist/esm/styles/hljs/github\";\n\nexport interface WrapperProps {\n    height: number;\n}\n\nexport const Wrapper = styled.div<WrapperProps>`\n    overflow: hidden;\n    position: relative;\n\n    border-radius: 12px;\n\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2), 0 0 1px rgba(0, 0, 0, 0.4);\n\n    width: 100%;\n    height: ${p => p.height}px;\n\n    margin: 24px 0;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\nexport const Highlight: React.VFC<{ children: string }> = p => {\n    return (\n        <SyntaxHighlighter\n            style={highlightStyle}\n            showLineNumbers={true}\n            lineNumberStyle={{ opacity: 0.5 }}\n            language=\"typescript\">\n            {p.children.trim()}\n        </SyntaxHighlighter>\n    );\n};\n\nexport const Marked: React.VFC<{ children: string }> = p => {\n    return (\n        <div\n            className=\"marked\"\n            dangerouslySetInnerHTML={{\n                __html: marked(p.children),\n            }}\n        />\n    );\n};\n\nconst BeautifulStyle = styled.div`\n    background: white;\n    color: #222222;\n\n    padding: 32px 48px;\n\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n    min-height: 100vh;\n\n    font-family: sans-serif;\n\n    & .inner {\n        position: relative;\n        width: 900px;\n\n        > pre {\n            font-size: 14px;\n            border-radius: 9px;\n        }\n    }\n\n    .marked {\n        font-family: Helvetica, arial, sans-serif;\n        font-size: 18px;\n        line-height: 1.6;\n\n        > *:first-child {\n            margin-top: 0 !important;\n        }\n        > *:last-child {\n            margin-bottom: 0 !important;\n        }\n\n        a {\n            color: #4183c4;\n        }\n        a.absent {\n            color: #cc0000;\n        }\n        a.anchor {\n            display: block;\n            padding-left: 30px;\n            margin-left: -30px;\n            cursor: pointer;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n            margin: 20px 0 10px;\n            padding: 0;\n            font-weight: bold;\n            -webkit-font-smoothing: antialiased;\n            cursor: text;\n            position: relative;\n        }\n\n        h1:hover a.anchor,\n        h2:hover a.anchor,\n        h3:hover a.anchor,\n        h4:hover a.anchor,\n        h5:hover a.anchor,\n        h6:hover a.anchor {\n            text-decoration: none;\n        }\n\n        h1 tt,\n        h1 code {\n            font-size: inherit;\n        }\n\n        h2 tt,\n        h2 code {\n            font-size: inherit;\n        }\n\n        h3 tt,\n        h3 code {\n            font-size: inherit;\n        }\n\n        h4 tt,\n        h4 code {\n            font-size: inherit;\n        }\n\n        h5 tt,\n        h5 code {\n            font-size: inherit;\n        }\n\n        h6 tt,\n        h6 code {\n            font-size: inherit;\n        }\n\n        h1 {\n            font-size: 32px;\n            color: black;\n        }\n\n        h2 {\n            font-size: 28px;\n            border-bottom: 1px solid #cccccc;\n            color: black;\n        }\n\n        h3 {\n            font-size: 22px;\n        }\n\n        h4 {\n            font-size: 20px;\n        }\n\n        h5 {\n            font-size: 18px;\n        }\n\n        h6 {\n            color: #777777;\n            font-size: 18px;\n        }\n\n        p,\n        blockquote,\n        ul,\n        ol,\n        dl,\n        li,\n        table,\n        pre {\n            margin: 20px 0;\n        }\n\n        hr {\n            border: 0 none;\n            color: #cccccc;\n            height: 4px;\n            padding: 0;\n        }\n\n        > h2:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h1:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h1:first-child + h2 {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h3:first-child,\n        > h4:first-child,\n        > h5:first-child,\n        > h6:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n\n        a:first-child h1,\n        a:first-child h2,\n        a:first-child h3,\n        a:first-child h4,\n        a:first-child h5,\n        a:first-child h6 {\n            margin-top: 0;\n            padding-top: 0;\n        }\n\n        h1 p,\n        h2 p,\n        h3 p,\n        h4 p,\n        h5 p,\n        h6 p {\n            margin-top: 0;\n        }\n\n        li p.first {\n            display: inline-block;\n        }\n        li {\n            margin: 0;\n        }\n        ul,\n        ol {\n            padding-left: 30px;\n        }\n\n        ul :first-child,\n        ol :first-child {\n            margin-top: 0;\n        }\n\n        dl {\n            padding: 0;\n        }\n        dl dt {\n            font-size: 18px;\n            font-weight: bold;\n            font-style: italic;\n            padding: 0;\n            margin: 15px 0 5px;\n        }\n        dl dt:first-child {\n            padding: 0;\n        }\n        dl dt > :first-child {\n            margin-top: 0;\n        }\n        dl dt > :last-child {\n            margin-bottom: 0;\n        }\n        dl dd {\n            margin: 0 0 15px;\n            padding: 0 15px;\n        }\n        dl dd > :first-child {\n            margin-top: 0;\n        }\n        dl dd > :last-child {\n            margin-bottom: 0;\n        }\n\n        blockquote {\n            border-left: 4px solid #dddddd;\n            padding: 0 15px;\n            color: #777777;\n        }\n        blockquote > :first-child {\n            margin-top: 0;\n        }\n        blockquote > :last-child {\n            margin-bottom: 0;\n        }\n\n        table {\n            font-size: 14px;\n            padding: 0;\n            border-collapse: collapse;\n        }\n        table tr {\n            border-top: 1px solid #cccccc;\n            background-color: white;\n            margin: 0;\n            padding: 0;\n        }\n        table tr:nth-child(2n) {\n            background-color: #f8f8f8;\n        }\n        table tr th {\n            font-weight: bold;\n            border: 1px solid #cccccc;\n            margin: 0;\n            padding: 6px 13px;\n        }\n        table tr td {\n            border: 1px solid #cccccc;\n            margin: 0;\n            padding: 6px 13px;\n        }\n        table tr th :first-child,\n        table tr td :first-child {\n            margin-top: 0;\n        }\n        table tr th :last-child,\n        table tr td :last-child {\n            margin-bottom: 0;\n        }\n\n        img {\n            max-width: 100%;\n        }\n\n        span.frame {\n            display: block;\n            overflow: hidden;\n        }\n        span.frame > span {\n            border: 1px solid #dddddd;\n            display: block;\n            float: left;\n            overflow: hidden;\n            margin: 13px 0 0;\n            padding: 7px;\n            width: auto;\n        }\n        span.frame span img {\n            display: block;\n            float: left;\n        }\n        span.frame span span {\n            clear: both;\n            color: #333333;\n            display: block;\n            padding: 5px 0 0;\n        }\n        span.align-center {\n            display: block;\n            overflow: hidden;\n            clear: both;\n        }\n        span.align-center > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px auto 0;\n            text-align: center;\n        }\n        span.align-center span img {\n            margin: 0 auto;\n            text-align: center;\n        }\n        span.align-right {\n            display: block;\n            overflow: hidden;\n            clear: both;\n        }\n        span.align-right > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px 0 0;\n            text-align: right;\n        }\n        span.align-right span img {\n            margin: 0;\n            text-align: right;\n        }\n        span.float-left {\n            display: block;\n            margin-right: 13px;\n            overflow: hidden;\n            float: left;\n        }\n        span.float-left span {\n            margin: 13px 0 0;\n        }\n        span.float-right {\n            display: block;\n            margin-left: 13px;\n            overflow: hidden;\n            float: right;\n        }\n        span.float-right > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px auto 0;\n            text-align: right;\n        }\n\n        code,\n        tt {\n            margin: 0 2px;\n            padding: 0 5px;\n            white-space: nowrap;\n            border: 1px solid #eaeaea;\n            background-color: #f8f8f8;\n            border-radius: 3px;\n        }\n\n        pre code {\n            margin: 0;\n            padding: 0;\n            white-space: pre;\n            border: none;\n            background: transparent;\n        }\n\n        .highlight pre {\n            background-color: #f8f8f8;\n            border: 1px solid #cccccc;\n            font-size: 17px;\n            line-height: 23px;\n            overflow: auto;\n            padding: 6px 10px;\n            border-radius: 3px;\n        }\n\n        pre {\n            background-color: #f8f8f8;\n            border: 1px solid #cccccc;\n            font-size: 17px;\n            line-height: 23px;\n            overflow: auto;\n            padding: 6px 10px;\n            border-radius: 3px;\n        }\n        pre code,\n        pre tt {\n            background-color: transparent;\n            border: none;\n        }\n\n        sup {\n            font-size: 0.83em;\n            vertical-align: super;\n            line-height: 0;\n        }\n        * {\n            -webkit-print-color-adjust: exact;\n        }\n    }\n`;\n\nexport const PropName = styled.span`\n    font-family: monospace;\n    font-weight: 500;\n    color: #ffe394;\n`;\n\nexport const Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\nexport const DocWrapper: React.FC = p => {\n    const { children } = p;\n    return (\n        <BeautifulStyle>\n            <div className=\"inner\">{children}</div>\n        </BeautifulStyle>\n    );\n};\n",".w1gh5fuv{overflow:hidden;position:relative;border-radius:12px;box-shadow:0 2px 5px rgba(0,0,0,0.2),0 0 1px rgba(0,0,0,0.4);width:100%;height:var(--w1gh5fuv-0);margin:24px 0;}.w1gh5fuv > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\n.b1bk6rj1{background:white;color:#222222;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;font-family:sans-serif;}.b1bk6rj1 .inner{position:relative;width:900px;}.b1bk6rj1 .inner > pre{font-size:14px;border-radius:9px;}.b1bk6rj1 .marked{font-family:Helvetica,arial,sans-serif;font-size:18px;line-height:1.6;}.b1bk6rj1 .marked > *:first-child{margin-top:0 !important;}.b1bk6rj1 .marked > *:last-child{margin-bottom:0 !important;}.b1bk6rj1 .marked a{color:#4183c4;}.b1bk6rj1 .marked a.absent{color:#cc0000;}.b1bk6rj1 .marked a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0;}.b1bk6rj1 .marked h1,.b1bk6rj1 .marked h2,.b1bk6rj1 .marked h3,.b1bk6rj1 .marked h4,.b1bk6rj1 .marked h5,.b1bk6rj1 .marked h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased;cursor:text;position:relative;}.b1bk6rj1 .marked h1:hover a.anchor,.b1bk6rj1 .marked h2:hover a.anchor,.b1bk6rj1 .marked h3:hover a.anchor,.b1bk6rj1 .marked h4:hover a.anchor,.b1bk6rj1 .marked h5:hover a.anchor,.b1bk6rj1 .marked h6:hover a.anchor{-webkit-text-decoration:none;text-decoration:none;}.b1bk6rj1 .marked h1 tt,.b1bk6rj1 .marked h1 code{font-size:inherit;}.b1bk6rj1 .marked h2 tt,.b1bk6rj1 .marked h2 code{font-size:inherit;}.b1bk6rj1 .marked h3 tt,.b1bk6rj1 .marked h3 code{font-size:inherit;}.b1bk6rj1 .marked h4 tt,.b1bk6rj1 .marked h4 code{font-size:inherit;}.b1bk6rj1 .marked h5 tt,.b1bk6rj1 .marked h5 code{font-size:inherit;}.b1bk6rj1 .marked h6 tt,.b1bk6rj1 .marked h6 code{font-size:inherit;}.b1bk6rj1 .marked h1{font-size:32px;color:black;}.b1bk6rj1 .marked h2{font-size:28px;border-bottom:1px solid #cccccc;color:black;}.b1bk6rj1 .marked h3{font-size:22px;}.b1bk6rj1 .marked h4{font-size:20px;}.b1bk6rj1 .marked h5{font-size:18px;}.b1bk6rj1 .marked h6{color:#777777;font-size:18px;}.b1bk6rj1 .marked p,.b1bk6rj1 .marked blockquote,.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol,.b1bk6rj1 .marked dl,.b1bk6rj1 .marked li,.b1bk6rj1 .marked table,.b1bk6rj1 .marked pre{margin:20px 0;}.b1bk6rj1 .marked hr{border:0 none;color:#cccccc;height:4px;padding:0;}.b1bk6rj1 .marked > h2:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child + h2{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h3:first-child,.b1bk6rj1 .marked > h4:first-child,.b1bk6rj1 .marked > h5:first-child,.b1bk6rj1 .marked > h6:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked a:first-child h1,.b1bk6rj1 .marked a:first-child h2,.b1bk6rj1 .marked a:first-child h3,.b1bk6rj1 .marked a:first-child h4,.b1bk6rj1 .marked a:first-child h5,.b1bk6rj1 .marked a:first-child h6{margin-top:0;padding-top:0;}.b1bk6rj1 .marked h1 p,.b1bk6rj1 .marked h2 p,.b1bk6rj1 .marked h3 p,.b1bk6rj1 .marked h4 p,.b1bk6rj1 .marked h5 p,.b1bk6rj1 .marked h6 p{margin-top:0;}.b1bk6rj1 .marked li p.first{display:inline-block;}.b1bk6rj1 .marked li{margin:0;}.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol{padding-left:30px;}.b1bk6rj1 .marked ul :first-child,.b1bk6rj1 .marked ol :first-child{margin-top:0;}.b1bk6rj1 .marked dl{padding:0;}.b1bk6rj1 .marked dl dt{font-size:18px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px;}.b1bk6rj1 .marked dl dt:first-child{padding:0;}.b1bk6rj1 .marked dl dt > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dt > :last-child{margin-bottom:0;}.b1bk6rj1 .marked dl dd{margin:0 0 15px;padding:0 15px;}.b1bk6rj1 .marked dl dd > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dd > :last-child{margin-bottom:0;}.b1bk6rj1 .marked blockquote{border-left:4px solid #dddddd;padding:0 15px;color:#777777;}.b1bk6rj1 .marked blockquote > :first-child{margin-top:0;}.b1bk6rj1 .marked blockquote > :last-child{margin-bottom:0;}.b1bk6rj1 .marked table{font-size:14px;padding:0;border-collapse:collapse;}.b1bk6rj1 .marked table tr{border-top:1px solid #cccccc;background-color:white;margin:0;padding:0;}.b1bk6rj1 .marked table tr:nth-child(2n){background-color:#f8f8f8;}.b1bk6rj1 .marked table tr th{font-weight:bold;border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr td{border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr th :first-child,.b1bk6rj1 .marked table tr td :first-child{margin-top:0;}.b1bk6rj1 .marked table tr th :last-child,.b1bk6rj1 .marked table tr td :last-child{margin-bottom:0;}.b1bk6rj1 .marked img{max-width:100%;}.b1bk6rj1 .marked span.frame{display:block;overflow:hidden;}.b1bk6rj1 .marked span.frame > span{border:1px solid #dddddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto;}.b1bk6rj1 .marked span.frame span img{display:block;float:left;}.b1bk6rj1 .marked span.frame span span{clear:both;color:#333333;display:block;padding:5px 0 0;}.b1bk6rj1 .marked span.align-center{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center;}.b1bk6rj1 .marked span.align-center span img{margin:0 auto;text-align:center;}.b1bk6rj1 .marked span.align-right{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right;}.b1bk6rj1 .marked span.align-right span img{margin:0;text-align:right;}.b1bk6rj1 .marked span.float-left{display:block;margin-right:13px;overflow:hidden;float:left;}.b1bk6rj1 .marked span.float-left span{margin:13px 0 0;}.b1bk6rj1 .marked span.float-right{display:block;margin-left:13px;overflow:hidden;float:right;}.b1bk6rj1 .marked span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right;}.b1bk6rj1 .marked code,.b1bk6rj1 .marked tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px;}.b1bk6rj1 .marked pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent;}.b1bk6rj1 .marked .highlight pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre code,.b1bk6rj1 .marked pre tt{background-color:transparent;border:none;}.b1bk6rj1 .marked sup{font-size:0.83em;vertical-align:super;line-height:0;}.b1bk6rj1 .marked *{-webkit-print-color-adjust:exact;}\n.p65g85a{font-family:monospace;font-weight:500;color:#ffe394;}\n.d2b9oy3{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.mnvl60p{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.mnvl60p button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZG9jcy9kb2Mtd3JhcHBlci50c3giXSwibmFtZXMiOlsiLncxZ2g1ZnV2IiwiLmIxYms2cmoxIiwiLnA2NWc4NWEiLCIuZDJiOW95MyIsIi5tbnZsNjBwIl0sIm1hcHBpbmdzIjoiQUFVdUJBO0FBNkNBQztBQStaQ0M7QUFNR0M7QUFNSEMiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kb2NzL2RvYy13cmFwcGVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgbWFya2VkIH0gZnJvbSBcIm1hcmtlZFwiO1xuaW1wb3J0IFN5bnRheEhpZ2hsaWdodGVyIGZyb20gXCJyZWFjdC1zeW50YXgtaGlnaGxpZ2h0ZXJcIjtcbmltcG9ydCBoaWdobGlnaHRTdHlsZSBmcm9tIFwicmVhY3Qtc3ludGF4LWhpZ2hsaWdodGVyL2Rpc3QvZXNtL3N0eWxlcy9obGpzL2dpdGh1YlwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdyYXBwZXJQcm9wcyB7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBXcmFwcGVyID0gc3R5bGVkLmRpdjxXcmFwcGVyUHJvcHM+YFxuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcblxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAke3AgPT4gcC5oZWlnaHR9cHg7XG5cbiAgICBtYXJnaW46IDI0cHggMDtcblxuICAgID4gOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IEhpZ2hsaWdodDogUmVhY3QuVkZDPHsgY2hpbGRyZW46IHN0cmluZyB9PiA9IHAgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTeW50YXhIaWdobGlnaHRlclxuICAgICAgICAgICAgc3R5bGU9e2hpZ2hsaWdodFN0eWxlfVxuICAgICAgICAgICAgc2hvd0xpbmVOdW1iZXJzPXt0cnVlfVxuICAgICAgICAgICAgbGluZU51bWJlclN0eWxlPXt7IG9wYWNpdHk6IDAuNSB9fVxuICAgICAgICAgICAgbGFuZ3VhZ2U9XCJ0eXBlc2NyaXB0XCI+XG4gICAgICAgICAgICB7cC5jaGlsZHJlbi50cmltKCl9XG4gICAgICAgIDwvU3ludGF4SGlnaGxpZ2h0ZXI+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBNYXJrZWQ6IFJlYWN0LlZGQzx7IGNoaWxkcmVuOiBzdHJpbmcgfT4gPSBwID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtYXJrZWRcIlxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tcbiAgICAgICAgICAgICAgICBfX2h0bWw6IG1hcmtlZChwLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKTtcbn07XG5cbmNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBjb2xvcjogIzIyMjIyMjtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmIC5pbm5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDkwMHB4O1xuXG4gICAgICAgID4gcHJlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDlweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5tYXJrZWQge1xuICAgICAgICBmb250LWZhbWlseTogSGVsdmV0aWNhLCBhcmlhbCwgc2Fucy1zZXJpZjtcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMS42O1xuXG4gICAgICAgID4gKjpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgPiAqOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMCAhaW1wb3J0YW50O1xuICAgICAgICB9XG5cbiAgICAgICAgYSB7XG4gICAgICAgICAgICBjb2xvcjogIzQxODNjNDtcbiAgICAgICAgfVxuICAgICAgICBhLmFic2VudCB7XG4gICAgICAgICAgICBjb2xvcjogI2NjMDAwMDtcbiAgICAgICAgfVxuICAgICAgICBhLmFuY2hvciB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogMzBweDtcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAtMzBweDtcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgIH1cblxuICAgICAgICBoMSxcbiAgICAgICAgaDIsXG4gICAgICAgIGgzLFxuICAgICAgICBoNCxcbiAgICAgICAgaDUsXG4gICAgICAgIGg2IHtcbiAgICAgICAgICAgIG1hcmdpbjogMjBweCAwIDEwcHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbiAgICAgICAgICAgIGN1cnNvcjogdGV4dDtcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxOmhvdmVyIGEuYW5jaG9yLFxuICAgICAgICBoMjpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDM6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGg0OmhvdmVyIGEuYW5jaG9yLFxuICAgICAgICBoNTpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDY6aG92ZXIgYS5hbmNob3Ige1xuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEgdHQsXG4gICAgICAgIGgxIGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDIgdHQsXG4gICAgICAgIGgyIGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDMgdHQsXG4gICAgICAgIGgzIGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDQgdHQsXG4gICAgICAgIGg0IGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDUgdHQsXG4gICAgICAgIGg1IGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDYgdHQsXG4gICAgICAgIGg2IGNvZGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgaDEge1xuICAgICAgICAgICAgZm9udC1zaXplOiAzMnB4O1xuICAgICAgICAgICAgY29sb3I6IGJsYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaDIge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyOHB4O1xuICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBjb2xvcjogYmxhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBoMyB7XG4gICAgICAgICAgICBmb250LXNpemU6IDIycHg7XG4gICAgICAgIH1cblxuICAgICAgICBoNCB7XG4gICAgICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIH1cblxuICAgICAgICBoNSB7XG4gICAgICAgICAgICBmb250LXNpemU6IDE4cHg7XG4gICAgICAgIH1cblxuICAgICAgICBoNiB7XG4gICAgICAgICAgICBjb2xvcjogIzc3Nzc3NztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHAsXG4gICAgICAgIGJsb2NrcXVvdGUsXG4gICAgICAgIHVsLFxuICAgICAgICBvbCxcbiAgICAgICAgZGwsXG4gICAgICAgIGxpLFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgcHJlIHtcbiAgICAgICAgICAgIG1hcmdpbjogMjBweCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaHIge1xuICAgICAgICAgICAgYm9yZGVyOiAwIG5vbmU7XG4gICAgICAgICAgICBjb2xvcjogI2NjY2NjYztcbiAgICAgICAgICAgIGhlaWdodDogNHB4O1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgfVxuXG4gICAgICAgID4gaDI6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgID4gaDE6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgID4gaDE6Zmlyc3QtY2hpbGQgKyBoMiB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDA7XG4gICAgICAgIH1cbiAgICAgICAgPiBoMzpmaXJzdC1jaGlsZCxcbiAgICAgICAgPiBoNDpmaXJzdC1jaGlsZCxcbiAgICAgICAgPiBoNTpmaXJzdC1jaGlsZCxcbiAgICAgICAgPiBoNjpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBhOmZpcnN0LWNoaWxkIGgxLFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGgyLFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGgzLFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGg0LFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGg1LFxuICAgICAgICBhOmZpcnN0LWNoaWxkIGg2IHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHAsXG4gICAgICAgIGgyIHAsXG4gICAgICAgIGgzIHAsXG4gICAgICAgIGg0IHAsXG4gICAgICAgIGg1IHAsXG4gICAgICAgIGg2IHAge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpIHAuZmlyc3Qge1xuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGxpIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgfVxuICAgICAgICB1bCxcbiAgICAgICAgb2wge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAzMHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgdWwgOmZpcnN0LWNoaWxkLFxuICAgICAgICBvbCA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZHQge1xuICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgICAgbWFyZ2luOiAxNXB4IDAgNXB4O1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0OmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZHQgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkdCA+IDpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZGQge1xuICAgICAgICAgICAgbWFyZ2luOiAwIDAgMTVweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgMTVweDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkZCA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGRkID4gOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJsb2NrcXVvdGUge1xuICAgICAgICAgICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjZGRkZGRkO1xuICAgICAgICAgICAgcGFkZGluZzogMCAxNXB4O1xuICAgICAgICAgICAgY29sb3I6ICM3Nzc3Nzc7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2txdW90ZSA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrcXVvdGUgPiA6bGFzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGUge1xuICAgICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgdHIge1xuICAgICAgICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgdHI6bnRoLWNoaWxkKDJuKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHRoIHtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAxM3B4O1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHRkIHtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTNweDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCA6Zmlyc3QtY2hpbGQsXG4gICAgICAgIHRhYmxlIHRyIHRkIDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHRoIDpsYXN0LWNoaWxkLFxuICAgICAgICB0YWJsZSB0ciB0ZCA6bGFzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nIHtcbiAgICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwYW4uZnJhbWUge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZnJhbWUgPiBzcGFuIHtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZGRkZGQ7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCAwIDA7XG4gICAgICAgICAgICBwYWRkaW5nOiA3cHg7XG4gICAgICAgICAgICB3aWR0aDogYXV0bztcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZyYW1lIHNwYW4gaW1nIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mcmFtZSBzcGFuIHNwYW4ge1xuICAgICAgICAgICAgY2xlYXI6IGJvdGg7XG4gICAgICAgICAgICBjb2xvcjogIzMzMzMzMztcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgcGFkZGluZzogNXB4IDAgMDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLWNlbnRlciB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBjbGVhcjogYm90aDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLWNlbnRlciA+IHNwYW4ge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgbWFyZ2luOiAxM3B4IGF1dG8gMDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLWNlbnRlciBzcGFuIGltZyB7XG4gICAgICAgICAgICBtYXJnaW46IDAgYXV0bztcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLXJpZ2h0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uYWxpZ24tcmlnaHQgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCAwIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLXJpZ2h0IHNwYW4gaW1nIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZmxvYXQtbGVmdCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogMTNweDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LWxlZnQgc3BhbiB7XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZmxvYXQtcmlnaHQge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogMTNweDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mbG9hdC1yaWdodCA+IHNwYW4ge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgbWFyZ2luOiAxM3B4IGF1dG8gMDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSxcbiAgICAgICAgdHQge1xuICAgICAgICAgICAgbWFyZ2luOiAwIDJweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgNXB4O1xuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNlYWVhZWE7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlIGNvZGUge1xuICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBwcmU7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5oaWdobGlnaHQgcHJlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmOGY4Zjg7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgZm9udC1zaXplOiAxN3B4O1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDIzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAxMHB4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmOGY4Zjg7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgZm9udC1zaXplOiAxN3B4O1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDIzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAxMHB4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgICB9XG4gICAgICAgIHByZSBjb2RlLFxuICAgICAgICBwcmUgdHQge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBzdXAge1xuICAgICAgICAgICAgZm9udC1zaXplOiAwLjgzZW07XG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogc3VwZXI7XG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcbiAgICAgICAgfVxuICAgICAgICAqIHtcbiAgICAgICAgICAgIC13ZWJraXQtcHJpbnQtY29sb3ItYWRqdXN0OiBleGFjdDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcm9wTmFtZSA9IHN0eWxlZC5zcGFuYFxuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBjb2xvcjogI2ZmZTM5NDtcbmA7XG5cbmV4cG9ydCBjb25zdCBEZXNjcmlwdGlvbiA9IHN0eWxlZC5wYFxuICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICBmbGV4LXNocmluazogMDtcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgTW9yZUluZm8gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XG4gICAgICAgIHBhZGRpbmc6IDJweCA2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IERvY1dyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcDtcbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlubmVyXCI+e2NoaWxkcmVufTwvZGl2PlxuICAgICAgICA8L0JlYXV0aWZ1bFN0eWxlPlxuICAgICk7XG59O1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/examples/header-menus.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".s7szcfi{width:175px;padding:8px 0;border-radius:6px;box-shadow:0px 0px 1px rgba(62,65,86,0.7),0px 6px 12px rgba(62,65,86,0.35);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:white;font-size:13px;font-weight:600;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Open Sans\", \"Helvetica Neue\",sans-serif;}.s7szcfi .danger{color:rgba(255,40,40,0.8);}.s7szcfi .danger:hover{color:rgba(255,40,40,1);}.s7szcfi > div{padding:6px 8px;color:rgba(0,0,0,0.7);-webkit-transition:background-color 100ms;transition:background-color 100ms;cursor:pointer;}.s7szcfi > div:hover{background-color:rgba(0,0,0,0.05);color:rgba(0,0,0,0.9);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZG9jcy9leGFtcGxlcy9oZWFkZXItbWVudXMuc3Rvcmllcy50c3giXSwibmFtZXMiOlsiLnM3c3pjZmkiXSwibWFwcGluZ3MiOiJBQXVDbUJBIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZG9jcy9leGFtcGxlcy9oZWFkZXItbWVudXMuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIC8vIEB0cy1ub2NoZWNrXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX1NUT1JZX18gPSBcImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXFxcIkBsaW5hcmlhL3JlYWN0XFxcIjtcXG5pbXBvcnQgUmVhY3QgZnJvbSBcXFwicmVhY3RcXFwiO1xcbmltcG9ydCB7IHVzZUxheWVyIH0gZnJvbSBcXFwicmVhY3QtbGFhZ1xcXCI7XFxuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXFxcIi4uLy4uL2RhdGEtZWRpdG9yL2RhdGEtZWRpdG9yXFxcIjtcXG5pbXBvcnQgeyBCZWF1dGlmdWxXcmFwcGVyLCBEZXNjcmlwdGlvbiwgZGVmYXVsdFByb3BzLCB1c2VBbGxNb2NrZWRLaW5kcyB9IGZyb20gXFxcIi4uLy4uL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHNcXFwiO1xcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcXFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1xcXCI7XFxuaW1wb3J0IHsgU2ltcGxlVGhlbWVXcmFwcGVyIH0gZnJvbSBcXFwiLi4vLi4vc3Rvcmllcy9zdG9yeS11dGlsc1xcXCI7XFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICB0aXRsZTogXFxcIkdsaWRlLURhdGEtR3JpZC9EYXRhRWRpdG9yIERlbW9zXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVxcXCJIZWFkZXIgbWVudXNcXFwiXFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj17XFxuICAgICAgICAgICAgICAgICAgICAgICAgPD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGVhZGVycyBvbiB0aGUgZGF0YSBncmlkIGNhbiBiZSBjb25maWd1cmVkIHRvIHN1cHBvcnQgbWVudXMuIFdlIHByb3ZpZGUgdGhlIGV2ZW50cyBhbmRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB0cmlhbmdsZSwgeW91IHByb3ZpZGUgdGhlIG1lbnUuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC8+XFxuICAgICAgICAgICAgICAgICAgICB9PlxcbiAgICAgICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cXG4gICAgICAgICAgICA8L1NpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICksXFxuICAgIF0sXFxufTtcXG5cXG5jb25zdCBTaW1wbGVNZW51ID0gc3R5bGVkLmRpdmBcXG4gICAgd2lkdGg6IDE3NXB4O1xcbiAgICBwYWRkaW5nOiA4cHggMDtcXG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNyksIDBweCA2cHggMTJweCByZ2JhKDYyLCA2NSwgODYsIDAuMzUpO1xcblxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcblxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsIFxcXCJPcGVuIFNhbnNcXFwiLFxcbiAgICAgICAgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgc2Fucy1zZXJpZjtcXG5cXG4gICAgLmRhbmdlciB7XFxuICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMC44KTtcXG4gICAgICAgIDpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCA0MCwgNDAsIDEpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgID4gZGl2IHtcXG4gICAgICAgIHBhZGRpbmc6IDZweCA4cHg7XFxuICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xcbiAgICAgICAgOmhvdmVyIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcbiAgICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOSk7XFxuICAgICAgICB9XFxuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDEwMG1zO1xcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB9XFxuYDtcXG5cXG5leHBvcnQgY29uc3QgSGVhZGVyTWVudXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcXG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcXG5cXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcXG4gICAgICAgIHJldHVybiBjb2xzLm1hcChjID0+ICh7XFxuICAgICAgICAgICAgLi4uYyxcXG4gICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxcbiAgICAgICAgfSkpO1xcbiAgICB9LCBbY29sc10pO1xcblxcbiAgICBjb25zdCBbbWVudSwgc2V0TWVudV0gPVxcbiAgICAgICAgUmVhY3QudXNlU3RhdGU8e1xcbiAgICAgICAgICAgIGNvbDogbnVtYmVyO1xcbiAgICAgICAgICAgIGJvdW5kczogUmVjdGFuZ2xlO1xcbiAgICAgICAgfT4oKTtcXG5cXG4gICAgY29uc3QgaXNPcGVuID0gbWVudSAhPT0gdW5kZWZpbmVkO1xcblxcbiAgICBjb25zdCB7IGxheWVyUHJvcHMsIHJlbmRlckxheWVyIH0gPSB1c2VMYXllcih7XFxuICAgICAgICBpc09wZW4sXFxuICAgICAgICBhdXRvOiB0cnVlLFxcbiAgICAgICAgcGxhY2VtZW50OiBcXFwiYm90dG9tLWVuZFxcXCIsXFxuICAgICAgICB0cmlnZ2VyT2Zmc2V0OiAyLFxcbiAgICAgICAgb25PdXRzaWRlQ2xpY2s6ICgpID0+IHNldE1lbnUodW5kZWZpbmVkKSxcXG4gICAgICAgIHRyaWdnZXI6IHtcXG4gICAgICAgICAgICBnZXRCb3VuZHM6ICgpID0+ICh7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IG1lbnU/LmJvdW5kcy54ID8/IDAsXFxuICAgICAgICAgICAgICAgIHRvcDogbWVudT8uYm91bmRzLnkgPz8gMCxcXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1lbnU/LmJvdW5kcy53aWR0aCA/PyAwLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lbnU/LmJvdW5kcy5oZWlnaHQgPz8gMCxcXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChtZW51Py5ib3VuZHMueCA/PyAwKSArIChtZW51Py5ib3VuZHMud2lkdGggPz8gMCksXFxuICAgICAgICAgICAgICAgIGJvdHRvbTogKG1lbnU/LmJvdW5kcy55ID8/IDApICsgKG1lbnU/LmJvdW5kcy5oZWlnaHQgPz8gMCksXFxuICAgICAgICAgICAgfSksXFxuICAgICAgICB9LFxcbiAgICB9KTtcXG5cXG4gICAgY29uc3Qgb25IZWFkZXJNZW51Q2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sOiBudW1iZXIsIGJvdW5kczogUmVjdGFuZ2xlKSA9PiB7XFxuICAgICAgICBzZXRNZW51KHsgY29sLCBib3VuZHMgfSk7XFxuICAgIH0sIFtdKTtcXG5cXG4gICAgY29uc3Qgb25IZWFkZXJDbGlja2VkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xcbiAgICAgICAgXFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwiSGVhZGVyIGNsaWNrZWRcXFwiKTtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPD5cXG4gICAgICAgICAgICA8RGF0YUVkaXRvclxcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XFxuICAgICAgICAgICAgICAgIG9uSGVhZGVyTWVudUNsaWNrPXtvbkhlYWRlck1lbnVDbGlja31cXG4gICAgICAgICAgICAgICAgb25IZWFkZXJDbGlja2VkPXtvbkhlYWRlckNsaWNrZWR9XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3JlYWxDb2xzfVxcbiAgICAgICAgICAgICAgICBvbkNlbGxDb250ZXh0TWVudT17KF8sIGUpID0+IGUucHJldmVudERlZmF1bHQoKX1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XFxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cXG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICAgIHtpc09wZW4gJiZcXG4gICAgICAgICAgICAgICAgcmVuZGVyTGF5ZXIoXFxuICAgICAgICAgICAgICAgICAgICA8U2ltcGxlTWVudSB7Li4ubGF5ZXJQcm9wc30+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlRoZXNlIGRvIG5vdGhpbmc8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+QWRkIGNvbHVtbiByaWdodDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIGxlZnQ8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwiZGFuZ2VyXFxcIiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWxldGVcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvU2ltcGxlTWVudT5cXG4gICAgICAgICAgICAgICAgKX1cXG4gICAgICAgIDwvPlxcbiAgICApO1xcbn07XFxuXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX0xPQ0FUSU9OU19NQVBfXyA9IHtcIkhlYWRlck1lbnVzXCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjozOCxcImxpbmVcIjo2Nn0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjEzN30sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjozOCxcImxpbmVcIjo2Nn0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjoxMzd9fX07XG4gICAgXG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUxheWVyIH0gZnJvbSBcInJlYWN0LWxhYWdcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IgfSBmcm9tIFwiLi4vLi4vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3JcIjtcbmltcG9ydCB7IEJlYXV0aWZ1bFdyYXBwZXIsIERlc2NyaXB0aW9uLCBkZWZhdWx0UHJvcHMsIHVzZUFsbE1vY2tlZEtpbmRzIH0gZnJvbSBcIi4uLy4uL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHNcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uLy4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IFNpbXBsZVRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtwYXJhbWV0ZXJzOiB7XCJzdG9yeVNvdXJjZVwiOntcInNvdXJjZVwiOlwiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcXFwiQGxpbmFyaWEvcmVhY3RcXFwiO1xcbmltcG9ydCBSZWFjdCBmcm9tIFxcXCJyZWFjdFxcXCI7XFxuaW1wb3J0IHsgdXNlTGF5ZXIgfSBmcm9tIFxcXCJyZWFjdC1sYWFnXFxcIjtcXG5pbXBvcnQgeyBEYXRhRWRpdG9yIH0gZnJvbSBcXFwiLi4vLi4vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3JcXFwiO1xcbmltcG9ydCB7IEJlYXV0aWZ1bFdyYXBwZXIsIERlc2NyaXB0aW9uLCBkZWZhdWx0UHJvcHMsIHVzZUFsbE1vY2tlZEtpbmRzIH0gZnJvbSBcXFwiLi4vLi4vZGF0YS1lZGl0b3Ivc3Rvcmllcy91dGlsc1xcXCI7XFxuaW1wb3J0IHR5cGUgeyBSZWN0YW5nbGUgfSBmcm9tIFxcXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBTaW1wbGVUaGVtZVdyYXBwZXIgfSBmcm9tIFxcXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXFxcIjtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiR2xpZGUtRGF0YS1HcmlkL0RhdGFFZGl0b3IgRGVtb3NcXFwiLFxcblxcbiAgICBkZWNvcmF0b3JzOiBbXFxuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XFxcIkhlYWRlciBtZW51c1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcXG4gICAgICAgICAgICAgICAgICAgICAgICA8PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIZWFkZXJzIG9uIHRoZSBkYXRhIGdyaWQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCBtZW51cy4gV2UgcHJvdmlkZSB0aGUgZXZlbnRzIGFuZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRyaWFuZ2xlLCB5b3UgcHJvdmlkZSB0aGUgbWVudS5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz5cXG4gICAgICAgICAgICAgICAgICAgIH0+XFxuICAgICAgICAgICAgICAgICAgICA8U3RvcnkgLz5cXG4gICAgICAgICAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxcbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmNvbnN0IFNpbXBsZU1lbnUgPSBzdHlsZWQuZGl2YFxcbiAgICB3aWR0aDogMTc1cHg7XFxuICAgIHBhZGRpbmc6IDhweCAwO1xcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICAgIGJveC1zaGFkb3c6IDBweCAwcHggMXB4IHJnYmEoNjIsIDY1LCA4NiwgMC43KSwgMHB4IDZweCAxMnB4IHJnYmEoNjIsIDY1LCA4NiwgMC4zNSk7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIENhbnRhcmVsbCwgXFxcIk9wZW4gU2Fuc1xcXCIsXFxuICAgICAgICBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmO1xcblxcbiAgICAuZGFuZ2VyIHtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgNDAsIDQwLCAwLjgpO1xcbiAgICAgICAgOmhvdmVyIHtcXG4gICAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMSk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgPiBkaXYge1xcbiAgICAgICAgcGFkZGluZzogNnB4IDhweDtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XFxuICAgICAgICA6aG92ZXIge1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxuICAgICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTAwbXM7XFxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIH1cXG5gO1xcblxcbmV4cG9ydCBjb25zdCBIZWFkZXJNZW51czogUmVhY3QuVkZDID0gKCkgPT4ge1xcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xcblxcbiAgICBjb25zdCByZWFsQ29scyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKGMgPT4gKHtcXG4gICAgICAgICAgICAuLi5jLFxcbiAgICAgICAgICAgIGhhc01lbnU6IHRydWUsXFxuICAgICAgICB9KSk7XFxuICAgIH0sIFtjb2xzXSk7XFxuXFxuICAgIGNvbnN0IFttZW51LCBzZXRNZW51XSA9XFxuICAgICAgICBSZWFjdC51c2VTdGF0ZTx7XFxuICAgICAgICAgICAgY29sOiBudW1iZXI7XFxuICAgICAgICAgICAgYm91bmRzOiBSZWN0YW5nbGU7XFxuICAgICAgICB9PigpO1xcblxcbiAgICBjb25zdCBpc09wZW4gPSBtZW51ICE9PSB1bmRlZmluZWQ7XFxuXFxuICAgIGNvbnN0IHsgbGF5ZXJQcm9wcywgcmVuZGVyTGF5ZXIgfSA9IHVzZUxheWVyKHtcXG4gICAgICAgIGlzT3BlbixcXG4gICAgICAgIGF1dG86IHRydWUsXFxuICAgICAgICBwbGFjZW1lbnQ6IFxcXCJib3R0b20tZW5kXFxcIixcXG4gICAgICAgIHRyaWdnZXJPZmZzZXQ6IDIsXFxuICAgICAgICBvbk91dHNpZGVDbGljazogKCkgPT4gc2V0TWVudSh1bmRlZmluZWQpLFxcbiAgICAgICAgdHJpZ2dlcjoge1xcbiAgICAgICAgICAgIGdldEJvdW5kczogKCkgPT4gKHtcXG4gICAgICAgICAgICAgICAgbGVmdDogbWVudT8uYm91bmRzLnggPz8gMCxcXG4gICAgICAgICAgICAgICAgdG9wOiBtZW51Py5ib3VuZHMueSA/PyAwLFxcbiAgICAgICAgICAgICAgICB3aWR0aDogbWVudT8uYm91bmRzLndpZHRoID8/IDAsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogbWVudT8uYm91bmRzLmhlaWdodCA/PyAwLFxcbiAgICAgICAgICAgICAgICByaWdodDogKG1lbnU/LmJvdW5kcy54ID8/IDApICsgKG1lbnU/LmJvdW5kcy53aWR0aCA/PyAwKSxcXG4gICAgICAgICAgICAgICAgYm90dG9tOiAobWVudT8uYm91bmRzLnkgPz8gMCkgKyAobWVudT8uYm91bmRzLmhlaWdodCA/PyAwKSxcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgIH0sXFxuICAgIH0pO1xcblxcbiAgICBjb25zdCBvbkhlYWRlck1lbnVDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChjb2w6IG51bWJlciwgYm91bmRzOiBSZWN0YW5nbGUpID0+IHtcXG4gICAgICAgIHNldE1lbnUoeyBjb2wsIGJvdW5kcyB9KTtcXG4gICAgfSwgW10pO1xcblxcbiAgICBjb25zdCBvbkhlYWRlckNsaWNrZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XFxuICAgICAgICBcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJIZWFkZXIgY2xpY2tlZFxcXCIpO1xcbiAgICB9LCBbXSk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8PlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e29uSGVhZGVyTWVudUNsaWNrfVxcbiAgICAgICAgICAgICAgICBvbkhlYWRlckNsaWNrZWQ9e29uSGVhZGVyQ2xpY2tlZH1cXG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XFxuICAgICAgICAgICAgICAgIG9uQ2VsbENvbnRleHRNZW51PXsoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxcbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cXG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAge2lzT3BlbiAmJlxcbiAgICAgICAgICAgICAgICByZW5kZXJMYXllcihcXG4gICAgICAgICAgICAgICAgICAgIDxTaW1wbGVNZW51IHsuLi5sYXllclByb3BzfT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+VGhlc2UgZG8gbm90aGluZzwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIHJpZ2h0PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PkFkZCBjb2x1bW4gbGVmdDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVxcXCJkYW5nZXJcXFwiIG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlbGV0ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9TaW1wbGVNZW51PlxcbiAgICAgICAgICAgICAgICApfVxcbiAgICAgICAgPC8+XFxuICAgICk7XFxufTtcXG5cIixcImxvY2F0aW9uc01hcFwiOntcImhlYWRlci1tZW51c1wiOntcInN0YXJ0TG9jXCI6e1wiY29sXCI6MzgsXCJsaW5lXCI6NjZ9LFwiZW5kTG9jXCI6e1wiY29sXCI6MSxcImxpbmVcIjoxMzd9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6MzgsXCJsaW5lXCI6NjZ9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6MTM3fX19fSx9LFxuICAgIHRpdGxlOiBcIkdsaWRlLURhdGEtR3JpZC9EYXRhRWRpdG9yIERlbW9zXCIsXG5cbiAgICBkZWNvcmF0b3JzOiBbXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkhlYWRlciBtZW51c1wiXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIZWFkZXJzIG9uIHRoZSBkYXRhIGdyaWQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCBtZW51cy4gV2UgcHJvdmlkZSB0aGUgZXZlbnRzIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHJpYW5nbGUsIHlvdSBwcm92aWRlIHRoZSBtZW51LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgfT5cbiAgICAgICAgICAgICAgICAgICAgPFN0b3J5IC8+XG4gICAgICAgICAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IFNpbXBsZU1lbnUgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxNzVweDtcbiAgICBwYWRkaW5nOiA4cHggMDtcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgYm94LXNoYWRvdzogMHB4IDBweCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjcpLCAwcHggNnB4IDEycHggcmdiYSg2MiwgNjUsIDg2LCAwLjM1KTtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICBmb250LXdlaWdodDogNjAwO1xuICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFwiU2Vnb2UgVUlcIiwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCBcIk9wZW4gU2Fuc1wiLFxuICAgICAgICBcIkhlbHZldGljYSBOZXVlXCIsIHNhbnMtc2VyaWY7XG5cbiAgICAuZGFuZ2VyIHtcbiAgICAgICAgY29sb3I6IHJnYmEoMjU1LCA0MCwgNDAsIDAuOCk7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICA+IGRpdiB7XG4gICAgICAgIHBhZGRpbmc6IDZweCA4cHg7XG4gICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xuICAgICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDEwMG1zO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IEhlYWRlck1lbnVzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IHJlYWxDb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzLm1hcChjID0+ICh7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgaGFzTWVudTogdHJ1ZSxcbiAgICAgICAgfSkpO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICBjb25zdCBbbWVudSwgc2V0TWVudV0gPVxuICAgICAgICBSZWFjdC51c2VTdGF0ZTx7XG4gICAgICAgICAgICBjb2w6IG51bWJlcjtcbiAgICAgICAgICAgIGJvdW5kczogUmVjdGFuZ2xlO1xuICAgICAgICB9PigpO1xuXG4gICAgY29uc3QgaXNPcGVuID0gbWVudSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgeyBsYXllclByb3BzLCByZW5kZXJMYXllciB9ID0gdXNlTGF5ZXIoe1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIGF1dG86IHRydWUsXG4gICAgICAgIHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsXG4gICAgICAgIHRyaWdnZXJPZmZzZXQ6IDIsXG4gICAgICAgIG9uT3V0c2lkZUNsaWNrOiAoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCksXG4gICAgICAgIHRyaWdnZXI6IHtcbiAgICAgICAgICAgIGdldEJvdW5kczogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBtZW51Py5ib3VuZHMueCA/PyAwLFxuICAgICAgICAgICAgICAgIHRvcDogbWVudT8uYm91bmRzLnkgPz8gMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogbWVudT8uYm91bmRzLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtZW51Py5ib3VuZHMuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChtZW51Py5ib3VuZHMueCA/PyAwKSArIChtZW51Py5ib3VuZHMud2lkdGggPz8gMCksXG4gICAgICAgICAgICAgICAgYm90dG9tOiAobWVudT8uYm91bmRzLnkgPz8gMCkgKyAobWVudT8uYm91bmRzLmhlaWdodCA/PyAwKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25IZWFkZXJNZW51Q2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sOiBudW1iZXIsIGJvdW5kczogUmVjdGFuZ2xlKSA9PiB7XG4gICAgICAgIHNldE1lbnUoeyBjb2wsIGJvdW5kcyB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBvbkhlYWRlckNsaWNrZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSGVhZGVyIGNsaWNrZWRcIik7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e29uSGVhZGVyTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja2VkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3JlYWxDb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbENvbnRleHRNZW51PXsoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtpc09wZW4gJiZcbiAgICAgICAgICAgICAgICByZW5kZXJMYXllcihcbiAgICAgICAgICAgICAgICAgICAgPFNpbXBsZU1lbnUgey4uLmxheWVyUHJvcHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlRoZXNlIGRvIG5vdGhpbmc8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIHJpZ2h0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+QWRkIGNvbHVtbiBsZWZ0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRhbmdlclwiIG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9TaW1wbGVNZW51PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgIDwvPlxuICAgICk7XG59O1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/docs/examples/header-menus.stories.tsx","webpack://./packages/core/src/docs/examples/header-menus.stories.tsx"],"names":[".s7szcfi"],"mappings":"AAuCmBA,SAAAA,WAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,0EAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,sBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,+HAAAA,CAAAA,CAAAA,iBAAAA,yBAAAA,CAAAA,CAAAA,uBAAAA,uBAAAA,CAAAA,CAAAA,eAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,iCAAAA,CAAAA,qBAAAA,CAAAA;ACtCnB,29mBAA29mB","sourcesContent":["\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import { styled } from \\\"@linaria/react\\\";\\nimport React from \\\"react\\\";\\nimport { useLayer } from \\\"react-laag\\\";\\nimport { DataEditor } from \\\"../../data-editor/data-editor\\\";\\nimport { BeautifulWrapper, Description, defaultProps, useAllMockedKinds } from \\\"../../data-editor/stories/utils\\\";\\nimport type { Rectangle } from \\\"../../data-grid/data-grid-types\\\";\\nimport { SimpleThemeWrapper } from \\\"../../stories/story-utils\\\";\\n\\nexport default {\\n    title: \\\"Glide-Data-Grid/DataEditor Demos\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <BeautifulWrapper\\n                    title=\\\"Header menus\\\"\\n                    description={\\n                        <>\\n                            <Description>\\n                                Headers on the data grid can be configured to support menus. We provide the events and\\n                                the triangle, you provide the menu.\\n                            </Description>\\n                        </>\\n                    }>\\n                    <Story />\\n                </BeautifulWrapper>\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst SimpleMenu = styled.div`\\n    width: 175px;\\n    padding: 8px 0;\\n    border-radius: 6px;\\n    box-shadow: 0px 0px 1px rgba(62, 65, 86, 0.7), 0px 6px 12px rgba(62, 65, 86, 0.35);\\n\\n    display: flex;\\n    flex-direction: column;\\n\\n    background-color: white;\\n    font-size: 13px;\\n    font-weight: 600;\\n    font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Oxygen, Ubuntu, Cantarell, \\\"Open Sans\\\",\\n        \\\"Helvetica Neue\\\", sans-serif;\\n\\n    .danger {\\n        color: rgba(255, 40, 40, 0.8);\\n        :hover {\\n            color: rgba(255, 40, 40, 1);\\n        }\\n    }\\n\\n    > div {\\n        padding: 6px 8px;\\n        color: rgba(0, 0, 0, 0.7);\\n        :hover {\\n            background-color: rgba(0, 0, 0, 0.05);\\n            color: rgba(0, 0, 0, 0.9);\\n        }\\n        transition: background-color 100ms;\\n        cursor: pointer;\\n    }\\n`;\\n\\nexport const HeaderMenus: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const realCols = React.useMemo(() => {\\n        return cols.map(c => ({\\n            ...c,\\n            hasMenu: true,\\n        }));\\n    }, [cols]);\\n\\n    const [menu, setMenu] =\\n        React.useState<{\\n            col: number;\\n            bounds: Rectangle;\\n        }>();\\n\\n    const isOpen = menu !== undefined;\\n\\n    const { layerProps, renderLayer } = useLayer({\\n        isOpen,\\n        auto: true,\\n        placement: \\\"bottom-end\\\",\\n        triggerOffset: 2,\\n        onOutsideClick: () => setMenu(undefined),\\n        trigger: {\\n            getBounds: () => ({\\n                left: menu?.bounds.x ?? 0,\\n                top: menu?.bounds.y ?? 0,\\n                width: menu?.bounds.width ?? 0,\\n                height: menu?.bounds.height ?? 0,\\n                right: (menu?.bounds.x ?? 0) + (menu?.bounds.width ?? 0),\\n                bottom: (menu?.bounds.y ?? 0) + (menu?.bounds.height ?? 0),\\n            }),\\n        },\\n    });\\n\\n    const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\\n        setMenu({ col, bounds });\\n    }, []);\\n\\n    const onHeaderClicked = React.useCallback(() => {\\n        \\n        console.log(\\\"Header clicked\\\");\\n    }, []);\\n\\n    return (\\n        <>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                onHeaderMenuClick={onHeaderMenuClick}\\n                onHeaderClicked={onHeaderClicked}\\n                columns={realCols}\\n                onCellContextMenu={(_, e) => e.preventDefault()}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={1000}\\n            />\\n            {isOpen &&\\n                renderLayer(\\n                    <SimpleMenu {...layerProps}>\\n                        <div onClick={() => setMenu(undefined)}>These do nothing</div>\\n                        <div onClick={() => setMenu(undefined)}>Add column right</div>\\n                        <div onClick={() => setMenu(undefined)}>Add column left</div>\\n                        <div className=\\\"danger\\\" onClick={() => setMenu(undefined)}>\\n                            Delete\\n                        </div>\\n                    </SimpleMenu>\\n                )}\\n        </>\\n    );\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"HeaderMenus\":{\"startLoc\":{\"col\":38,\"line\":66},\"endLoc\":{\"col\":1,\"line\":137},\"startBody\":{\"col\":38,\"line\":66},\"endBody\":{\"col\":1,\"line\":137}}};\n    \nimport { styled } from \"@linaria/react\";\nimport React from \"react\";\nimport { useLayer } from \"react-laag\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, defaultProps, useAllMockedKinds } from \"../../data-editor/stories/utils\";\nimport type { Rectangle } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"import { styled } from \\\"@linaria/react\\\";\\nimport React from \\\"react\\\";\\nimport { useLayer } from \\\"react-laag\\\";\\nimport { DataEditor } from \\\"../../data-editor/data-editor\\\";\\nimport { BeautifulWrapper, Description, defaultProps, useAllMockedKinds } from \\\"../../data-editor/stories/utils\\\";\\nimport type { Rectangle } from \\\"../../data-grid/data-grid-types\\\";\\nimport { SimpleThemeWrapper } from \\\"../../stories/story-utils\\\";\\n\\nexport default {\\n    title: \\\"Glide-Data-Grid/DataEditor Demos\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <BeautifulWrapper\\n                    title=\\\"Header menus\\\"\\n                    description={\\n                        <>\\n                            <Description>\\n                                Headers on the data grid can be configured to support menus. We provide the events and\\n                                the triangle, you provide the menu.\\n                            </Description>\\n                        </>\\n                    }>\\n                    <Story />\\n                </BeautifulWrapper>\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst SimpleMenu = styled.div`\\n    width: 175px;\\n    padding: 8px 0;\\n    border-radius: 6px;\\n    box-shadow: 0px 0px 1px rgba(62, 65, 86, 0.7), 0px 6px 12px rgba(62, 65, 86, 0.35);\\n\\n    display: flex;\\n    flex-direction: column;\\n\\n    background-color: white;\\n    font-size: 13px;\\n    font-weight: 600;\\n    font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Oxygen, Ubuntu, Cantarell, \\\"Open Sans\\\",\\n        \\\"Helvetica Neue\\\", sans-serif;\\n\\n    .danger {\\n        color: rgba(255, 40, 40, 0.8);\\n        :hover {\\n            color: rgba(255, 40, 40, 1);\\n        }\\n    }\\n\\n    > div {\\n        padding: 6px 8px;\\n        color: rgba(0, 0, 0, 0.7);\\n        :hover {\\n            background-color: rgba(0, 0, 0, 0.05);\\n            color: rgba(0, 0, 0, 0.9);\\n        }\\n        transition: background-color 100ms;\\n        cursor: pointer;\\n    }\\n`;\\n\\nexport const HeaderMenus: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const realCols = React.useMemo(() => {\\n        return cols.map(c => ({\\n            ...c,\\n            hasMenu: true,\\n        }));\\n    }, [cols]);\\n\\n    const [menu, setMenu] =\\n        React.useState<{\\n            col: number;\\n            bounds: Rectangle;\\n        }>();\\n\\n    const isOpen = menu !== undefined;\\n\\n    const { layerProps, renderLayer } = useLayer({\\n        isOpen,\\n        auto: true,\\n        placement: \\\"bottom-end\\\",\\n        triggerOffset: 2,\\n        onOutsideClick: () => setMenu(undefined),\\n        trigger: {\\n            getBounds: () => ({\\n                left: menu?.bounds.x ?? 0,\\n                top: menu?.bounds.y ?? 0,\\n                width: menu?.bounds.width ?? 0,\\n                height: menu?.bounds.height ?? 0,\\n                right: (menu?.bounds.x ?? 0) + (menu?.bounds.width ?? 0),\\n                bottom: (menu?.bounds.y ?? 0) + (menu?.bounds.height ?? 0),\\n            }),\\n        },\\n    });\\n\\n    const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\\n        setMenu({ col, bounds });\\n    }, []);\\n\\n    const onHeaderClicked = React.useCallback(() => {\\n        \\n        console.log(\\\"Header clicked\\\");\\n    }, []);\\n\\n    return (\\n        <>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                onHeaderMenuClick={onHeaderMenuClick}\\n                onHeaderClicked={onHeaderClicked}\\n                columns={realCols}\\n                onCellContextMenu={(_, e) => e.preventDefault()}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={1000}\\n            />\\n            {isOpen &&\\n                renderLayer(\\n                    <SimpleMenu {...layerProps}>\\n                        <div onClick={() => setMenu(undefined)}>These do nothing</div>\\n                        <div onClick={() => setMenu(undefined)}>Add column right</div>\\n                        <div onClick={() => setMenu(undefined)}>Add column left</div>\\n                        <div className=\\\"danger\\\" onClick={() => setMenu(undefined)}>\\n                            Delete\\n                        </div>\\n                    </SimpleMenu>\\n                )}\\n        </>\\n    );\\n};\\n\",\"locationsMap\":{\"header-menus\":{\"startLoc\":{\"col\":38,\"line\":66},\"endLoc\":{\"col\":1,\"line\":137},\"startBody\":{\"col\":38,\"line\":66},\"endBody\":{\"col\":1,\"line\":137}}}},},\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Header menus\"\n                    description={\n                        <>\n                            <Description>\n                                Headers on the data grid can be configured to support menus. We provide the events and\n                                the triangle, you provide the menu.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst SimpleMenu = styled.div`\n    width: 175px;\n    padding: 8px 0;\n    border-radius: 6px;\n    box-shadow: 0px 0px 1px rgba(62, 65, 86, 0.7), 0px 6px 12px rgba(62, 65, 86, 0.35);\n\n    display: flex;\n    flex-direction: column;\n\n    background-color: white;\n    font-size: 13px;\n    font-weight: 600;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\",\n        \"Helvetica Neue\", sans-serif;\n\n    .danger {\n        color: rgba(255, 40, 40, 0.8);\n        :hover {\n            color: rgba(255, 40, 40, 1);\n        }\n    }\n\n    > div {\n        padding: 6px 8px;\n        color: rgba(0, 0, 0, 0.7);\n        :hover {\n            background-color: rgba(0, 0, 0, 0.05);\n            color: rgba(0, 0, 0, 0.9);\n        }\n        transition: background-color 100ms;\n        cursor: pointer;\n    }\n`;\n\nexport const HeaderMenus: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        return cols.map(c => ({\n            ...c,\n            hasMenu: true,\n        }));\n    }, [cols]);\n\n    const [menu, setMenu] =\n        React.useState<{\n            col: number;\n            bounds: Rectangle;\n        }>();\n\n    const isOpen = menu !== undefined;\n\n    const { layerProps, renderLayer } = useLayer({\n        isOpen,\n        auto: true,\n        placement: \"bottom-end\",\n        triggerOffset: 2,\n        onOutsideClick: () => setMenu(undefined),\n        trigger: {\n            getBounds: () => ({\n                left: menu?.bounds.x ?? 0,\n                top: menu?.bounds.y ?? 0,\n                width: menu?.bounds.width ?? 0,\n                height: menu?.bounds.height ?? 0,\n                right: (menu?.bounds.x ?? 0) + (menu?.bounds.width ?? 0),\n                bottom: (menu?.bounds.y ?? 0) + (menu?.bounds.height ?? 0),\n            }),\n        },\n    });\n\n    const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\n        setMenu({ col, bounds });\n    }, []);\n\n    const onHeaderClicked = React.useCallback(() => {\n        // eslint-disable-next-line no-console\n        console.log(\"Header clicked\");\n    }, []);\n\n    return (\n        <>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                onHeaderMenuClick={onHeaderMenuClick}\n                onHeaderClicked={onHeaderClicked}\n                columns={realCols}\n                onCellContextMenu={(_, e) => e.preventDefault()}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n            />\n            {isOpen &&\n                renderLayer(\n                    <SimpleMenu {...layerProps}>\n                        <div onClick={() => setMenu(undefined)}>These do nothing</div>\n                        <div onClick={() => setMenu(undefined)}>Add column right</div>\n                        <div onClick={() => setMenu(undefined)}>Add column left</div>\n                        <div className=\"danger\" onClick={() => setMenu(undefined)}>\n                            Delete\n                        </div>\n                    </SimpleMenu>\n                )}\n        </>\n    );\n};\n",".s7szcfi{width:175px;padding:8px 0;border-radius:6px;box-shadow:0px 0px 1px rgba(62,65,86,0.7),0px 6px 12px rgba(62,65,86,0.35);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:white;font-size:13px;font-weight:600;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Open Sans\", \"Helvetica Neue\",sans-serif;}.s7szcfi .danger{color:rgba(255,40,40,0.8);}.s7szcfi .danger:hover{color:rgba(255,40,40,1);}.s7szcfi > div{padding:6px 8px;color:rgba(0,0,0,0.7);-webkit-transition:background-color 100ms;transition:background-color 100ms;cursor:pointer;}.s7szcfi > div:hover{background-color:rgba(0,0,0,0.05);color:rgba(0,0,0,0.9);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZG9jcy9leGFtcGxlcy9oZWFkZXItbWVudXMuc3Rvcmllcy50c3giXSwibmFtZXMiOlsiLnM3c3pjZmkiXSwibWFwcGluZ3MiOiJBQXVDbUJBIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZG9jcy9leGFtcGxlcy9oZWFkZXItbWVudXMuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIC8vIEB0cy1ub2NoZWNrXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX1NUT1JZX18gPSBcImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXFxcIkBsaW5hcmlhL3JlYWN0XFxcIjtcXG5pbXBvcnQgUmVhY3QgZnJvbSBcXFwicmVhY3RcXFwiO1xcbmltcG9ydCB7IHVzZUxheWVyIH0gZnJvbSBcXFwicmVhY3QtbGFhZ1xcXCI7XFxuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXFxcIi4uLy4uL2RhdGEtZWRpdG9yL2RhdGEtZWRpdG9yXFxcIjtcXG5pbXBvcnQgeyBCZWF1dGlmdWxXcmFwcGVyLCBEZXNjcmlwdGlvbiwgZGVmYXVsdFByb3BzLCB1c2VBbGxNb2NrZWRLaW5kcyB9IGZyb20gXFxcIi4uLy4uL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHNcXFwiO1xcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcXFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1xcXCI7XFxuaW1wb3J0IHsgU2ltcGxlVGhlbWVXcmFwcGVyIH0gZnJvbSBcXFwiLi4vLi4vc3Rvcmllcy9zdG9yeS11dGlsc1xcXCI7XFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICB0aXRsZTogXFxcIkdsaWRlLURhdGEtR3JpZC9EYXRhRWRpdG9yIERlbW9zXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVxcXCJIZWFkZXIgbWVudXNcXFwiXFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj17XFxuICAgICAgICAgICAgICAgICAgICAgICAgPD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGVhZGVycyBvbiB0aGUgZGF0YSBncmlkIGNhbiBiZSBjb25maWd1cmVkIHRvIHN1cHBvcnQgbWVudXMuIFdlIHByb3ZpZGUgdGhlIGV2ZW50cyBhbmRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB0cmlhbmdsZSwgeW91IHByb3ZpZGUgdGhlIG1lbnUuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC8+XFxuICAgICAgICAgICAgICAgICAgICB9PlxcbiAgICAgICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cXG4gICAgICAgICAgICA8L1NpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICksXFxuICAgIF0sXFxufTtcXG5cXG5jb25zdCBTaW1wbGVNZW51ID0gc3R5bGVkLmRpdmBcXG4gICAgd2lkdGg6IDE3NXB4O1xcbiAgICBwYWRkaW5nOiA4cHggMDtcXG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNyksIDBweCA2cHggMTJweCByZ2JhKDYyLCA2NSwgODYsIDAuMzUpO1xcblxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcblxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsIFxcXCJPcGVuIFNhbnNcXFwiLFxcbiAgICAgICAgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgc2Fucy1zZXJpZjtcXG5cXG4gICAgLmRhbmdlciB7XFxuICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMC44KTtcXG4gICAgICAgIDpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCA0MCwgNDAsIDEpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgID4gZGl2IHtcXG4gICAgICAgIHBhZGRpbmc6IDZweCA4cHg7XFxuICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xcbiAgICAgICAgOmhvdmVyIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcbiAgICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOSk7XFxuICAgICAgICB9XFxuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDEwMG1zO1xcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB9XFxuYDtcXG5cXG5leHBvcnQgY29uc3QgSGVhZGVyTWVudXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcXG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcXG5cXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcXG4gICAgICAgIHJldHVybiBjb2xzLm1hcChjID0+ICh7XFxuICAgICAgICAgICAgLi4uYyxcXG4gICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxcbiAgICAgICAgfSkpO1xcbiAgICB9LCBbY29sc10pO1xcblxcbiAgICBjb25zdCBbbWVudSwgc2V0TWVudV0gPVxcbiAgICAgICAgUmVhY3QudXNlU3RhdGU8e1xcbiAgICAgICAgICAgIGNvbDogbnVtYmVyO1xcbiAgICAgICAgICAgIGJvdW5kczogUmVjdGFuZ2xlO1xcbiAgICAgICAgfT4oKTtcXG5cXG4gICAgY29uc3QgaXNPcGVuID0gbWVudSAhPT0gdW5kZWZpbmVkO1xcblxcbiAgICBjb25zdCB7IGxheWVyUHJvcHMsIHJlbmRlckxheWVyIH0gPSB1c2VMYXllcih7XFxuICAgICAgICBpc09wZW4sXFxuICAgICAgICBhdXRvOiB0cnVlLFxcbiAgICAgICAgcGxhY2VtZW50OiBcXFwiYm90dG9tLWVuZFxcXCIsXFxuICAgICAgICB0cmlnZ2VyT2Zmc2V0OiAyLFxcbiAgICAgICAgb25PdXRzaWRlQ2xpY2s6ICgpID0+IHNldE1lbnUodW5kZWZpbmVkKSxcXG4gICAgICAgIHRyaWdnZXI6IHtcXG4gICAgICAgICAgICBnZXRCb3VuZHM6ICgpID0+ICh7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IG1lbnU/LmJvdW5kcy54ID8/IDAsXFxuICAgICAgICAgICAgICAgIHRvcDogbWVudT8uYm91bmRzLnkgPz8gMCxcXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1lbnU/LmJvdW5kcy53aWR0aCA/PyAwLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lbnU/LmJvdW5kcy5oZWlnaHQgPz8gMCxcXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChtZW51Py5ib3VuZHMueCA/PyAwKSArIChtZW51Py5ib3VuZHMud2lkdGggPz8gMCksXFxuICAgICAgICAgICAgICAgIGJvdHRvbTogKG1lbnU/LmJvdW5kcy55ID8/IDApICsgKG1lbnU/LmJvdW5kcy5oZWlnaHQgPz8gMCksXFxuICAgICAgICAgICAgfSksXFxuICAgICAgICB9LFxcbiAgICB9KTtcXG5cXG4gICAgY29uc3Qgb25IZWFkZXJNZW51Q2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sOiBudW1iZXIsIGJvdW5kczogUmVjdGFuZ2xlKSA9PiB7XFxuICAgICAgICBzZXRNZW51KHsgY29sLCBib3VuZHMgfSk7XFxuICAgIH0sIFtdKTtcXG5cXG4gICAgY29uc3Qgb25IZWFkZXJDbGlja2VkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xcbiAgICAgICAgXFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwiSGVhZGVyIGNsaWNrZWRcXFwiKTtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPD5cXG4gICAgICAgICAgICA8RGF0YUVkaXRvclxcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxcbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XFxuICAgICAgICAgICAgICAgIG9uSGVhZGVyTWVudUNsaWNrPXtvbkhlYWRlck1lbnVDbGlja31cXG4gICAgICAgICAgICAgICAgb25IZWFkZXJDbGlja2VkPXtvbkhlYWRlckNsaWNrZWR9XFxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3JlYWxDb2xzfVxcbiAgICAgICAgICAgICAgICBvbkNlbGxDb250ZXh0TWVudT17KF8sIGUpID0+IGUucHJldmVudERlZmF1bHQoKX1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XFxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cXG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICAgIHtpc09wZW4gJiZcXG4gICAgICAgICAgICAgICAgcmVuZGVyTGF5ZXIoXFxuICAgICAgICAgICAgICAgICAgICA8U2ltcGxlTWVudSB7Li4ubGF5ZXJQcm9wc30+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlRoZXNlIGRvIG5vdGhpbmc8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+QWRkIGNvbHVtbiByaWdodDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIGxlZnQ8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwiZGFuZ2VyXFxcIiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWxldGVcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvU2ltcGxlTWVudT5cXG4gICAgICAgICAgICAgICAgKX1cXG4gICAgICAgIDwvPlxcbiAgICApO1xcbn07XFxuXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX0xPQ0FUSU9OU19NQVBfXyA9IHtcIkhlYWRlck1lbnVzXCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjozOCxcImxpbmVcIjo2Nn0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjEzN30sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjozOCxcImxpbmVcIjo2Nn0sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjoxMzd9fX07XG4gICAgXG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUxheWVyIH0gZnJvbSBcInJlYWN0LWxhYWdcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IgfSBmcm9tIFwiLi4vLi4vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3JcIjtcbmltcG9ydCB7IEJlYXV0aWZ1bFdyYXBwZXIsIERlc2NyaXB0aW9uLCBkZWZhdWx0UHJvcHMsIHVzZUFsbE1vY2tlZEtpbmRzIH0gZnJvbSBcIi4uLy4uL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHNcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uLy4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IFNpbXBsZVRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtwYXJhbWV0ZXJzOiB7XCJzdG9yeVNvdXJjZVwiOntcInNvdXJjZVwiOlwiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcXFwiQGxpbmFyaWEvcmVhY3RcXFwiO1xcbmltcG9ydCBSZWFjdCBmcm9tIFxcXCJyZWFjdFxcXCI7XFxuaW1wb3J0IHsgdXNlTGF5ZXIgfSBmcm9tIFxcXCJyZWFjdC1sYWFnXFxcIjtcXG5pbXBvcnQgeyBEYXRhRWRpdG9yIH0gZnJvbSBcXFwiLi4vLi4vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3JcXFwiO1xcbmltcG9ydCB7IEJlYXV0aWZ1bFdyYXBwZXIsIERlc2NyaXB0aW9uLCBkZWZhdWx0UHJvcHMsIHVzZUFsbE1vY2tlZEtpbmRzIH0gZnJvbSBcXFwiLi4vLi4vZGF0YS1lZGl0b3Ivc3Rvcmllcy91dGlsc1xcXCI7XFxuaW1wb3J0IHR5cGUgeyBSZWN0YW5nbGUgfSBmcm9tIFxcXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBTaW1wbGVUaGVtZVdyYXBwZXIgfSBmcm9tIFxcXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXFxcIjtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiR2xpZGUtRGF0YS1HcmlkL0RhdGFFZGl0b3IgRGVtb3NcXFwiLFxcblxcbiAgICBkZWNvcmF0b3JzOiBbXFxuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XFxcIkhlYWRlciBtZW51c1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcXG4gICAgICAgICAgICAgICAgICAgICAgICA8PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIZWFkZXJzIG9uIHRoZSBkYXRhIGdyaWQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCBtZW51cy4gV2UgcHJvdmlkZSB0aGUgZXZlbnRzIGFuZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRyaWFuZ2xlLCB5b3UgcHJvdmlkZSB0aGUgbWVudS5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz5cXG4gICAgICAgICAgICAgICAgICAgIH0+XFxuICAgICAgICAgICAgICAgICAgICA8U3RvcnkgLz5cXG4gICAgICAgICAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxcbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmNvbnN0IFNpbXBsZU1lbnUgPSBzdHlsZWQuZGl2YFxcbiAgICB3aWR0aDogMTc1cHg7XFxuICAgIHBhZGRpbmc6IDhweCAwO1xcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICAgIGJveC1zaGFkb3c6IDBweCAwcHggMXB4IHJnYmEoNjIsIDY1LCA4NiwgMC43KSwgMHB4IDZweCAxMnB4IHJnYmEoNjIsIDY1LCA4NiwgMC4zNSk7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIENhbnRhcmVsbCwgXFxcIk9wZW4gU2Fuc1xcXCIsXFxuICAgICAgICBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmO1xcblxcbiAgICAuZGFuZ2VyIHtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgNDAsIDQwLCAwLjgpO1xcbiAgICAgICAgOmhvdmVyIHtcXG4gICAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMSk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgPiBkaXYge1xcbiAgICAgICAgcGFkZGluZzogNnB4IDhweDtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XFxuICAgICAgICA6aG92ZXIge1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxuICAgICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTAwbXM7XFxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIH1cXG5gO1xcblxcbmV4cG9ydCBjb25zdCBIZWFkZXJNZW51czogUmVhY3QuVkZDID0gKCkgPT4ge1xcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xcblxcbiAgICBjb25zdCByZWFsQ29scyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKGMgPT4gKHtcXG4gICAgICAgICAgICAuLi5jLFxcbiAgICAgICAgICAgIGhhc01lbnU6IHRydWUsXFxuICAgICAgICB9KSk7XFxuICAgIH0sIFtjb2xzXSk7XFxuXFxuICAgIGNvbnN0IFttZW51LCBzZXRNZW51XSA9XFxuICAgICAgICBSZWFjdC51c2VTdGF0ZTx7XFxuICAgICAgICAgICAgY29sOiBudW1iZXI7XFxuICAgICAgICAgICAgYm91bmRzOiBSZWN0YW5nbGU7XFxuICAgICAgICB9PigpO1xcblxcbiAgICBjb25zdCBpc09wZW4gPSBtZW51ICE9PSB1bmRlZmluZWQ7XFxuXFxuICAgIGNvbnN0IHsgbGF5ZXJQcm9wcywgcmVuZGVyTGF5ZXIgfSA9IHVzZUxheWVyKHtcXG4gICAgICAgIGlzT3BlbixcXG4gICAgICAgIGF1dG86IHRydWUsXFxuICAgICAgICBwbGFjZW1lbnQ6IFxcXCJib3R0b20tZW5kXFxcIixcXG4gICAgICAgIHRyaWdnZXJPZmZzZXQ6IDIsXFxuICAgICAgICBvbk91dHNpZGVDbGljazogKCkgPT4gc2V0TWVudSh1bmRlZmluZWQpLFxcbiAgICAgICAgdHJpZ2dlcjoge1xcbiAgICAgICAgICAgIGdldEJvdW5kczogKCkgPT4gKHtcXG4gICAgICAgICAgICAgICAgbGVmdDogbWVudT8uYm91bmRzLnggPz8gMCxcXG4gICAgICAgICAgICAgICAgdG9wOiBtZW51Py5ib3VuZHMueSA/PyAwLFxcbiAgICAgICAgICAgICAgICB3aWR0aDogbWVudT8uYm91bmRzLndpZHRoID8/IDAsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogbWVudT8uYm91bmRzLmhlaWdodCA/PyAwLFxcbiAgICAgICAgICAgICAgICByaWdodDogKG1lbnU/LmJvdW5kcy54ID8/IDApICsgKG1lbnU/LmJvdW5kcy53aWR0aCA/PyAwKSxcXG4gICAgICAgICAgICAgICAgYm90dG9tOiAobWVudT8uYm91bmRzLnkgPz8gMCkgKyAobWVudT8uYm91bmRzLmhlaWdodCA/PyAwKSxcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgIH0sXFxuICAgIH0pO1xcblxcbiAgICBjb25zdCBvbkhlYWRlck1lbnVDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChjb2w6IG51bWJlciwgYm91bmRzOiBSZWN0YW5nbGUpID0+IHtcXG4gICAgICAgIHNldE1lbnUoeyBjb2wsIGJvdW5kcyB9KTtcXG4gICAgfSwgW10pO1xcblxcbiAgICBjb25zdCBvbkhlYWRlckNsaWNrZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XFxuICAgICAgICBcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJIZWFkZXIgY2xpY2tlZFxcXCIpO1xcbiAgICB9LCBbXSk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8PlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e29uSGVhZGVyTWVudUNsaWNrfVxcbiAgICAgICAgICAgICAgICBvbkhlYWRlckNsaWNrZWQ9e29uSGVhZGVyQ2xpY2tlZH1cXG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XFxuICAgICAgICAgICAgICAgIG9uQ2VsbENvbnRleHRNZW51PXsoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxcbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cXG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAge2lzT3BlbiAmJlxcbiAgICAgICAgICAgICAgICByZW5kZXJMYXllcihcXG4gICAgICAgICAgICAgICAgICAgIDxTaW1wbGVNZW51IHsuLi5sYXllclByb3BzfT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+VGhlc2UgZG8gbm90aGluZzwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIHJpZ2h0PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PkFkZCBjb2x1bW4gbGVmdDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVxcXCJkYW5nZXJcXFwiIG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlbGV0ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9TaW1wbGVNZW51PlxcbiAgICAgICAgICAgICAgICApfVxcbiAgICAgICAgPC8+XFxuICAgICk7XFxufTtcXG5cIixcImxvY2F0aW9uc01hcFwiOntcImhlYWRlci1tZW51c1wiOntcInN0YXJ0TG9jXCI6e1wiY29sXCI6MzgsXCJsaW5lXCI6NjZ9LFwiZW5kTG9jXCI6e1wiY29sXCI6MSxcImxpbmVcIjoxMzd9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6MzgsXCJsaW5lXCI6NjZ9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6MTM3fX19fSx9LFxuICAgIHRpdGxlOiBcIkdsaWRlLURhdGEtR3JpZC9EYXRhRWRpdG9yIERlbW9zXCIsXG5cbiAgICBkZWNvcmF0b3JzOiBbXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkhlYWRlciBtZW51c1wiXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIZWFkZXJzIG9uIHRoZSBkYXRhIGdyaWQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCBtZW51cy4gV2UgcHJvdmlkZSB0aGUgZXZlbnRzIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHJpYW5nbGUsIHlvdSBwcm92aWRlIHRoZSBtZW51LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgfT5cbiAgICAgICAgICAgICAgICAgICAgPFN0b3J5IC8+XG4gICAgICAgICAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IFNpbXBsZU1lbnUgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxNzVweDtcbiAgICBwYWRkaW5nOiA4cHggMDtcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgYm94LXNoYWRvdzogMHB4IDBweCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjcpLCAwcHggNnB4IDEycHggcmdiYSg2MiwgNjUsIDg2LCAwLjM1KTtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICBmb250LXdlaWdodDogNjAwO1xuICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFwiU2Vnb2UgVUlcIiwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCBcIk9wZW4gU2Fuc1wiLFxuICAgICAgICBcIkhlbHZldGljYSBOZXVlXCIsIHNhbnMtc2VyaWY7XG5cbiAgICAuZGFuZ2VyIHtcbiAgICAgICAgY29sb3I6IHJnYmEoMjU1LCA0MCwgNDAsIDAuOCk7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICA+IGRpdiB7XG4gICAgICAgIHBhZGRpbmc6IDZweCA4cHg7XG4gICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xuICAgICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDEwMG1zO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IEhlYWRlck1lbnVzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IHJlYWxDb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzLm1hcChjID0+ICh7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgaGFzTWVudTogdHJ1ZSxcbiAgICAgICAgfSkpO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICBjb25zdCBbbWVudSwgc2V0TWVudV0gPVxuICAgICAgICBSZWFjdC51c2VTdGF0ZTx7XG4gICAgICAgICAgICBjb2w6IG51bWJlcjtcbiAgICAgICAgICAgIGJvdW5kczogUmVjdGFuZ2xlO1xuICAgICAgICB9PigpO1xuXG4gICAgY29uc3QgaXNPcGVuID0gbWVudSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgeyBsYXllclByb3BzLCByZW5kZXJMYXllciB9ID0gdXNlTGF5ZXIoe1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIGF1dG86IHRydWUsXG4gICAgICAgIHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsXG4gICAgICAgIHRyaWdnZXJPZmZzZXQ6IDIsXG4gICAgICAgIG9uT3V0c2lkZUNsaWNrOiAoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCksXG4gICAgICAgIHRyaWdnZXI6IHtcbiAgICAgICAgICAgIGdldEJvdW5kczogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBtZW51Py5ib3VuZHMueCA/PyAwLFxuICAgICAgICAgICAgICAgIHRvcDogbWVudT8uYm91bmRzLnkgPz8gMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogbWVudT8uYm91bmRzLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtZW51Py5ib3VuZHMuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChtZW51Py5ib3VuZHMueCA/PyAwKSArIChtZW51Py5ib3VuZHMud2lkdGggPz8gMCksXG4gICAgICAgICAgICAgICAgYm90dG9tOiAobWVudT8uYm91bmRzLnkgPz8gMCkgKyAobWVudT8uYm91bmRzLmhlaWdodCA/PyAwKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25IZWFkZXJNZW51Q2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sOiBudW1iZXIsIGJvdW5kczogUmVjdGFuZ2xlKSA9PiB7XG4gICAgICAgIHNldE1lbnUoeyBjb2wsIGJvdW5kcyB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBvbkhlYWRlckNsaWNrZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSGVhZGVyIGNsaWNrZWRcIik7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e29uSGVhZGVyTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja2VkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3JlYWxDb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbENvbnRleHRNZW51PXsoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtpc09wZW4gJiZcbiAgICAgICAgICAgICAgICByZW5kZXJMYXllcihcbiAgICAgICAgICAgICAgICAgICAgPFNpbXBsZU1lbnUgey4uLmxheWVyUHJvcHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlRoZXNlIGRvIG5vdGhpbmc8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIHJpZ2h0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+QWRkIGNvbHVtbiBsZWZ0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRhbmdlclwiIG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9TaW1wbGVNZW51PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgIDwvPlxuICAgICk7XG59O1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/growing-entry/growing-entry-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".ifmjl02{position:absolute;left:0;right:0;top:0;bottom:0;width:100%;height:100%;border-radius:0px;resize:none;white-space:pre-wrap;min-width:100%;overflow:hidden;border:0;background-color:transparent;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;}.ifmjl02::-webkit-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::-moz-placeholder{color:var(--gdg-text-light);}.ifmjl02:-ms-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::placeholder{color:var(--gdg-text-light);}.invalid .ifmjl02{-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration-color:#d60606;text-decoration-color:#d60606;}\n.s71wzxx{visibility:hidden;white-space:pre-wrap;word-wrap:break-word;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;min-width:100%;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;padding-bottom:2px;}\n.gecuh31{position:relative;margin-top:6px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZ3Jvd2luZy1lbnRyeS9ncm93aW5nLWVudHJ5LXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIuaWZtamwwMiIsIi5zNzF3enh4IiwiLmdlY3VoMzEiXSwibWFwcGluZ3MiOiJBQUV3QkE7QUFtQ0NDO0FBb0JRQyIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IElucHV0Qm94ID0gc3R5bGVkLnRleHRhcmVhYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgYm9yZGVyLXJhZGl1czogMHB4O1xuXG4gICAgcmVzaXplOiBub25lO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICBtaW4td2lkdGg6IDEwMCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3JkZXI6IDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICA6OnBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWxpZ2h0KTtcbiAgICB9XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG5cbiAgICAuaW52YWxpZCAmIHtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbi1jb2xvcjogI2Q2MDYwNjtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgU2hhZG93Qm94ID0gc3R5bGVkLmRpdmBcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgIHdvcmQtd3JhcDogYnJlYWstd29yZDtcblxuICAgIHdpZHRoOiBtYXgtY29udGVudDtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG5cbiAgICBtaW4td2lkdGg6IDEwMCU7XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG5cbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xuYDtcblxuZXhwb3J0IGNvbnN0IEdyb3dpbmdFbnRyeVN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbWFyZ2luLXRvcDogNnB4O1xuYDtcbiJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/growing-entry/growing-entry-style.tsx","webpack://./packages/core/src/growing-entry/growing-entry-style.tsx"],"names":[".ifmjl02",".s71wzxx",".gecuh31"],"mappings":"AAEwBA,SAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAAA,QAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,WAAAA,CAAAA,oBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,QAAAA,CAAAA,4BAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,SAAAA,CAAAA,QAAAA,CAAAA,CAAAA,oCAAAA,2BAAAA,CAAAA,CAAAA,2BAAAA,2BAAAA,CAAAA,CAAAA,+BAAAA,2BAAAA,CAAAA,CAAAA,sBAAAA,2BAAAA,CAAAA,CAAAA,kBAAAA,iCAAAA,CAAAA,yBAAAA,CAAAA,qCAAAA,CAAAA,6BAAAA,CAAAA;AAmCCC,SAAAA,iBAAAA,CAAAA,oBAAAA,CAAAA,oBAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,cAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,SAAAA,CAAAA,QAAAA,CAAAA,kBAAAA,CAAAA;AAoBQC,SAAAA,iBAAAA,CAAAA,cAAAA,CAAAA;ACtDjC,+nEAA+nE","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const InputBox = styled.textarea`\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n\n    border-radius: 0px;\n\n    resize: none;\n    white-space: pre-wrap;\n    min-width: 100%;\n    overflow: hidden;\n    border: 0;\n    background-color: transparent;\n\n    ::placeholder {\n        color: var(--gdg-text-light);\n    }\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    .invalid & {\n        text-decoration: underline;\n        text-decoration-color: #d60606;\n    }\n`;\n\nexport const ShadowBox = styled.div`\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n\n    width: max-content;\n    max-width: 100%;\n\n    min-width: 100%;\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    padding-bottom: 2px;\n`;\n\nexport const GrowingEntryStyle = styled.div`\n    position: relative;\n    margin-top: 6px;\n`;\n",".ifmjl02{position:absolute;left:0;right:0;top:0;bottom:0;width:100%;height:100%;border-radius:0px;resize:none;white-space:pre-wrap;min-width:100%;overflow:hidden;border:0;background-color:transparent;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;}.ifmjl02::-webkit-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::-moz-placeholder{color:var(--gdg-text-light);}.ifmjl02:-ms-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::placeholder{color:var(--gdg-text-light);}.invalid .ifmjl02{-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration-color:#d60606;text-decoration-color:#d60606;}\n.s71wzxx{visibility:hidden;white-space:pre-wrap;word-wrap:break-word;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;min-width:100%;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;padding-bottom:2px;}\n.gecuh31{position:relative;margin-top:6px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvZ3Jvd2luZy1lbnRyeS9ncm93aW5nLWVudHJ5LXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIuaWZtamwwMiIsIi5zNzF3enh4IiwiLmdlY3VoMzEiXSwibWFwcGluZ3MiOiJBQUV3QkE7QUFtQ0NDO0FBb0JRQyIsImZpbGUiOiIvaG9tZS9ydW5uZXIvd29yay9nbGlkZS1kYXRhLWdyaWQvZ2xpZGUtZGF0YS1ncmlkL3BhY2thZ2VzL2NvcmUvc3JjL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IElucHV0Qm94ID0gc3R5bGVkLnRleHRhcmVhYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgYm9yZGVyLXJhZGl1czogMHB4O1xuXG4gICAgcmVzaXplOiBub25lO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICBtaW4td2lkdGg6IDEwMCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3JkZXI6IDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICA6OnBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWxpZ2h0KTtcbiAgICB9XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG5cbiAgICAuaW52YWxpZCAmIHtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbi1jb2xvcjogI2Q2MDYwNjtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgU2hhZG93Qm94ID0gc3R5bGVkLmRpdmBcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgIHdvcmQtd3JhcDogYnJlYWstd29yZDtcblxuICAgIHdpZHRoOiBtYXgtY29udGVudDtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG5cbiAgICBtaW4td2lkdGg6IDEwMCU7XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG5cbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xuYDtcblxuZXhwb3J0IGNvbnN0IEdyb3dpbmdFbnRyeVN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbWFyZ2luLXRvcDogNnB4O1xuYDtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/markdown-div/private/markdown-container.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".m1fme8sm{word-break:break-word;-webkit-touch-callout:default;padding-top:6px;}.m1fme8sm > *{margin:0;}.m1fme8sm *:last-child{margin-bottom:0;}.m1fme8sm p img{width:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvbWFya2Rvd24tZGl2L3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLnRzeCJdLCJuYW1lcyI6WyIubTFmbWU4c20iXSwibWFwcGluZ3MiOiJBQUVpQ0EiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9tYXJrZG93bi1kaXYvcHJpdmF0ZS9tYXJrZG93bi1jb250YWluZXIudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bkNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcbiAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IGRlZmF1bHQ7XG4gICAgcGFkZGluZy10b3A6IDZweDtcblxuICAgID4gKiB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICB9XG5cbiAgICAmICo6bGFzdC1jaGlsZCB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgfVxuXG4gICAgJiBwIGltZyB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cbmA7XG4iXX0=*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/markdown-div/private/markdown-container.tsx","webpack://./packages/core/src/markdown-div/private/markdown-container.tsx"],"names":[".m1fme8sm"],"mappings":"AAEiCA,UAAAA,qBAAAA,CAAAA,6BAAAA,CAAAA,eAAAA,CAAAA,CAAAA,cAAAA,QAAAA,CAAAA,CAAAA,uBAAAA,eAAAA,CAAAA,CAAAA,gBAAAA,UAAAA,CAAAA;ACDjC,25BAA25B","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const MarkdownContainer = styled.div`\n    word-break: break-word;\n    -webkit-touch-callout: default;\n    padding-top: 6px;\n\n    > * {\n        margin: 0;\n    }\n\n    & *:last-child {\n        margin-bottom: 0;\n    }\n\n    & p img {\n        width: 100%;\n    }\n`;\n",".m1fme8sm{word-break:break-word;-webkit-touch-callout:default;padding-top:6px;}.m1fme8sm > *{margin:0;}.m1fme8sm *:last-child{margin-bottom:0;}.m1fme8sm p img{width:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvbWFya2Rvd24tZGl2L3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLnRzeCJdLCJuYW1lcyI6WyIubTFmbWU4c20iXSwibWFwcGluZ3MiOiJBQUVpQ0EiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9tYXJrZG93bi1kaXYvcHJpdmF0ZS9tYXJrZG93bi1jb250YWluZXIudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bkNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcbiAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IGRlZmF1bHQ7XG4gICAgcGFkZGluZy10b3A6IDZweDtcblxuICAgID4gKiB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICB9XG5cbiAgICAmICo6bGFzdC1jaGlsZCB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgfVxuXG4gICAgJiBwIGltZyB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cbmA7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/infinite-scroller.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".s3se5hb .dvn-scroller{overflow:var(--s3se5hb-0);-webkit-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0);}.s3se5hb .hidden{visibility:hidden;}.s3se5hb .dvn-scroll-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;pointer-events:none;}.s3se5hb .dvn-scroll-inner > *{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}.s3se5hb .dvn-scroll-inner .dvn-spacer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.s3se5hb .dvn-scroll-inner .dvn-stack{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.s3se5hb .dvn-underlay > *{position:absolute;left:0;top:0;}.s3se5hb canvas{outline:none;}.s3se5hb canvas *{height:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9pbmZpbml0ZS1zY3JvbGxlci50c3giXSwibmFtZXMiOlsiLnMzc2U1aGIiXSwibWFwcGluZ3MiOiJBQTRCMEJBIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9pbmZpbml0ZS1zY3JvbGxlci50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcIi4uL2NvbW1vbi9yZXNpemUtZGV0ZWN0b3JcIjtcbmltcG9ydCB7IGJyb3dzZXJJc1NhZmFyaSB9IGZyb20gXCIuLi9jb21tb24vYnJvd3Nlci1kZXRlY3RcIjtcbmltcG9ydCB7IHVzZUV2ZW50TGlzdGVuZXIgfSBmcm9tIFwiLi4vY29tbW9uL3V0aWxzXCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHkgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHByZXZlbnREaWFnb25hbFNjcm9sbGluZz86IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgZHJhZ2dhYmxlOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHBhZGRpbmdSaWdodD86IG51bWJlcjtcbiAgICByZWFkb25seSBwYWRkaW5nQm90dG9tPzogbnVtYmVyO1xuICAgIHJlYWRvbmx5IGNsaWVudEhlaWdodDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbFdpZHRoOiBudW1iZXI7XG4gICAgcmVhZG9ubHkgc2Nyb2xsSGVpZ2h0OiBudW1iZXI7XG4gICAgcmVhZG9ubHkgc2Nyb2xsVG9FbmQ/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGluaXRpYWxTaXplPzogcmVhZG9ubHkgW3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnRQcm9wcz86IHtcbiAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgfTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgcmVhZG9ubHkgbWluaW1hcD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICByZWFkb25seSBzY3JvbGxSZWY/OiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD47XG4gICAgcmVhZG9ubHkgdXBkYXRlOiAocmVnaW9uOiBSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0pID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNjcm9sbFJlZ2lvblN0eWxlID0gc3R5bGVkLmRpdjx7IGlzU2FmYXJpOiBib29sZWFuIH0+YFxuICAgIC5kdm4tc2Nyb2xsZXIge1xuICAgICAgICBvdmVyZmxvdzogJHtwID0+IChwLmlzU2FmYXJpID8gXCJzY3JvbGxcIiA6IFwiYXV0b1wiKX07XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgLmhpZGRlbiB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuZHZuLXNjcm9sbC1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3BhY2VyIHtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3RhY2sge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZHZuLXVuZGVybGF5ID4gKiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgIH1cblxuICAgIGNhbnZhcyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG5cbiAgICAgICAgKiB7XG4gICAgICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG50eXBlIFNjcm9sbExvY2sgPSBbdW5kZWZpbmVkLCBudW1iZXJdIHwgW251bWJlciwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZWF0RXZlbnQoZTogUmVhY3QuTW91c2VFdmVudCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVRvdWNoVXBEZWxheWVkKGRlbGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBbaGFzVG91Y2hlcywgc2V0SGFzVG91Y2hlc10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBjYlRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNiVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRIYXNUb3VjaGVzKHRydWUpO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiVGltZXIuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHNldEhhc1RvdWNoZXMoZmFsc2UpLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtkZWxheV1cbiAgICAgICAgKSxcbiAgICAgICAgd2luZG93LFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuZXhwb3J0IGNvbnN0IEluZmluaXRlU2Nyb2xsZXI6IFJlYWN0LkZDPFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwLFxuICAgICAgICBwYWRkaW5nUmlnaHQgPSAwLFxuICAgICAgICByaWdodEVsZW1lbnQsXG4gICAgICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgbWluaW1hcCxcbiAgICB9ID0gcDtcbiAgICBjb25zdCBwYWRkZXJzOiBSZWFjdC5SZWFjdE5vZGVbXSA9IFtdO1xuXG4gICAgY29uc3QgcmlnaHRFbGVtZW50U3RpY2t5ID0gcmlnaHRFbGVtZW50UHJvcHM/LnN0aWNreSA/PyBmYWxzZTtcbiAgICBjb25zdCByaWdodEVsZW1lbnRGaWxsID0gcmlnaHRFbGVtZW50UHJvcHM/LmZpbGwgPz8gZmFsc2U7XG5cbiAgICBjb25zdCBvZmZzZXRZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IGxhc3RTY3JvbGxZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IHNjcm9sbGVyID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsIHx8IHNjcm9sbFRvRW5kICE9PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGg7XG4gICAgfSwgW3Njcm9sbFRvRW5kXSk7XG5cbiAgICBjb25zdCBsYXN0U2Nyb2xsUG9zaXRpb24gPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgIGxvY2tEaXJlY3Rpb246IHVuZGVmaW5lZCBhcyBTY3JvbGxMb2NrLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmlnaHRXcmFwUmVmID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBoYXNUb3VjaGVzID0gdXNlVG91Y2hVcERlbGF5ZWQoMjAwKTtcbiAgICBjb25zdCBbaXNJZGxlLCBzZXRJc0lkbGVdID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgaWRsZVRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0lkbGUgfHwgaGFzVG91Y2hlcyB8fCBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBzY3JvbGxlci5jdXJyZW50O1xuICAgICAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgW2x4LCBseV0gPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uO1xuICAgICAgICBpZiAobHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGx4O1xuICAgICAgICB9IGVsc2UgaWYgKGx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcCA9IGx5O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSwgW2hhc1RvdWNoZXMsIGlzSWRsZV0pO1xuXG4gICAgY29uc3Qgb25TY3JvbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsVG9wID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsTGVmdCA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgY29uc3QgZHggPSBzY3JvbGxMZWZ0IC0gbGFzdFNjcm9sbExlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gc2Nyb2xsVG9wIC0gbGFzdFNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNUb3VjaGVzICYmXG4gICAgICAgICAgICBkeCAhPT0gMCAmJlxuICAgICAgICAgICAgZHkgIT09IDAgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhkeCkgPiAzIHx8IE1hdGguYWJzKGR5KSA+IDMpICYmXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcgJiZcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPVxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGR4KSA8IE1hdGguYWJzKGR5KSA/IFtsYXN0U2Nyb2xsTGVmdCwgdW5kZWZpbmVkXSA6IFt1bmRlZmluZWQsIGxhc3RTY3JvbGxUb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jayA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb247XG5cbiAgICAgICAgc2Nyb2xsTGVmdCA9IGxvY2s/LlswXSA/PyBzY3JvbGxMZWZ0O1xuICAgICAgICBzY3JvbGxUb3AgPSBsb2NrPy5bMV0gPz8gc2Nyb2xsVG9wO1xuICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXG4gICAgICAgIGNvbnN0IG5ld1kgPSBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbGFzdFNjcm9sbFkuY3VycmVudCAtIG5ld1k7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxhc3RTY3JvbGxZLmN1cnJlbnQgPSBuZXdZO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNjcm9sbGFibGVIZWlnaHQgPiAwICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoZGVsdGEpID4gMjAwMCB8fCBuZXdZID09PSAwIHx8IG5ld1kgPT09IHNjcm9sbGFibGVIZWlnaHQpICYmXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPiBlbC5zY3JvbGxIZWlnaHQgKyA1XG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcHJvZyA9IG5ld1kgLyBzY3JvbGxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcmVjb21wdXRlZCA9IChzY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQpICogcHJvZztcbiAgICAgICAgICAgIG9mZnNldFkuY3VycmVudCA9IHJlY29tcHV0ZWQgLSBuZXdZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZGxlVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRJc0lkbGUoZmFsc2UpO1xuICAgICAgICAgICAgaWRsZVRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRJc0lkbGUodHJ1ZSksIDIwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgeDogc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHk6IG5ld1kgKyBvZmZzZXRZLmN1cnJlbnQsXG4gICAgICAgICAgICB3aWR0aDogZWwuY2xpZW50V2lkdGggLSBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsLmNsaWVudEhlaWdodCAtIHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHJpZ2h0V3JhcFJlZi5jdXJyZW50Py5jbGllbnRXaWR0aCA/PyAwLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBzY3JvbGxIZWlnaHQsIHVwZGF0ZSwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCBoYXNUb3VjaGVzXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFJlZiA9IFJlYWN0LnVzZVJlZihvblNjcm9sbCk7XG4gICAgb25TY3JvbGxSZWYuY3VycmVudCA9IG9uU2Nyb2xsO1xuXG4gICAgY29uc3QgbGFzdFByb3BzID0gUmVhY3QudXNlUmVmPHsgd2lkdGg/OiBudW1iZXI7IGhlaWdodD86IG51bWJlciB9PigpO1xuXG4gICAgY29uc3QgZGlkRmlyc3RTY3JvbGwgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaWRGaXJzdFNjcm9sbC5jdXJyZW50KSBvblNjcm9sbCgpO1xuICAgICAgICBlbHNlIGRpZEZpcnN0U2Nyb2xsLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtvblNjcm9sbCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0XSk7XG5cbiAgICBjb25zdCBzZXRSZWZzID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChpbnN0YW5jZTogSFRNTERpdkVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBzY3JvbGxlci5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsUmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxSZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbc2Nyb2xsUmVmXVxuICAgICk7XG5cbiAgICBsZXQga2V5ID0gMDtcbiAgICBsZXQgaCA9IDA7XG4gICAgcGFkZGVycy5wdXNoKDxkaXYga2V5PXtrZXkrK30gc3R5bGU9e3sgd2lkdGg6IHNjcm9sbFdpZHRoLCBoZWlnaHQ6IDAgfX0gLz4pO1xuICAgIHdoaWxlIChoIDwgc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHRvQWRkID0gTWF0aC5taW4oNV8wMDBfMDAwLCBzY3JvbGxIZWlnaHQgLSBoKTtcbiAgICAgICAgcGFkZGVycy5wdXNoKDxkaXYga2V5PXtrZXkrK30gc3R5bGU9e3sgd2lkdGg6IDAsIGhlaWdodDogdG9BZGQgfX0gLz4pO1xuICAgICAgICBoICs9IHRvQWRkO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcjxIVE1MRGl2RWxlbWVudD4oaW5pdGlhbFNpemUpO1xuXG4gICAgaWYgKGxhc3RQcm9wcy5jdXJyZW50Py5oZWlnaHQgIT09IGhlaWdodCB8fCBsYXN0UHJvcHMuY3VycmVudD8ud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IG9uU2Nyb2xsUmVmLmN1cnJlbnQoKSwgMCk7XG4gICAgICAgIGxhc3RQcm9wcy5jdXJyZW50ID0geyB3aWR0aCwgaGVpZ2h0IH07XG4gICAgfVxuXG4gICAgaWYgKCh3aWR0aCA/PyAwKSA9PT0gMCB8fCAoaGVpZ2h0ID8/IDApID09PSAwKSByZXR1cm4gPGRpdiByZWY9e3JlZn0gLz47XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IHJlZj17cmVmfT5cbiAgICAgICAgICAgIDxTY3JvbGxSZWdpb25TdHlsZSBpc1NhZmFyaT17YnJvd3NlcklzU2FmYXJpLnZhbHVlfT5cbiAgICAgICAgICAgICAgICB7bWluaW1hcH1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImR2bi11bmRlcmxheVwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIHJlZj17c2V0UmVmc31cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e2xhc3RQcm9wcy5jdXJyZW50fVxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU9e2RyYWdnYWJsZX1cbiAgICAgICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcImR2bi1zY3JvbGxlciBcIiArIChjbGFzc05hbWUgPz8gXCJcIil9XG4gICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsPXtvblNjcm9sbH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtcImR2bi1zY3JvbGwtaW5uZXJcIiArIChyaWdodEVsZW1lbnQgPT09IHVuZGVmaW5lZCA/IFwiIGhpZGRlblwiIDogXCJcIil9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdm4tc3RhY2tcIj57cGFkZGVyc308L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtyaWdodEVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyFyaWdodEVsZW1lbnRGaWxsICYmIDxkaXYgY2xhc3NOYW1lPVwiZHZuLXNwYWNlclwiIC8+fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY9e3JpZ2h0V3JhcFJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXtlYXRFdmVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VVcD17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZT17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IGNsaWVudEhlaWdodCAtIE1hdGguY2VpbChkcHIgJSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAtNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IHBhZGRpbmdSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4R3JvdzogcmlnaHRFbGVtZW50RmlsbCA/IDEgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0RWxlbWVudFN0aWNreSA/IHBhZGRpbmdSaWdodCA/PyAwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmlnaHRFbGVtZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9TY3JvbGxSZWdpb25TdHlsZT5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG4iXX0=*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/infinite-scroller.tsx","webpack://./packages/core/src/scrolling-data-grid/infinite-scroller.tsx"],"names":[".s3se5hb"],"mappings":"AA4B0BA,uBAAAA,yBAAAA,CAAAA,oCAAAA,CAAAA,gCAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,CAAAA,2BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,+BAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,uCAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,sCAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,2BAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,CAAAA,gBAAAA,YAAAA,CAAAA,CAAAA,kBAAAA,QAAAA,CAAAA;AC3B1B,u+cAAu+c","sourcesContent":["import { styled } from \"@linaria/react\";\nimport type { Rectangle } from \"..\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"../common/resize-detector\";\nimport { browserIsSafari } from \"../common/browser-detect\";\nimport { useEventListener } from \"../common/utils\";\n\ninterface Props {\n    readonly className?: string;\n    readonly preventDiagonalScrolling?: boolean;\n    readonly draggable: boolean;\n    readonly paddingRight?: number;\n    readonly paddingBottom?: number;\n    readonly clientHeight: number;\n    readonly scrollWidth: number;\n    readonly scrollHeight: number;\n    readonly scrollToEnd?: boolean;\n    readonly initialSize?: readonly [width: number, height: number];\n    readonly rightElementProps?: {\n        readonly sticky?: boolean;\n        readonly fill?: boolean;\n    };\n    readonly rightElement?: React.ReactNode;\n    readonly minimap?: React.ReactNode;\n    readonly scrollRef?: React.MutableRefObject<HTMLDivElement | null>;\n    readonly update: (region: Rectangle & { paddingRight: number }) => void;\n}\n\nconst ScrollRegionStyle = styled.div<{ isSafari: boolean }>`\n    .dvn-scroller {\n        overflow: ${p => (p.isSafari ? \"scroll\" : \"auto\")};\n        transform: translate3d(0, 0, 0);\n    }\n\n    .hidden {\n        visibility: hidden;\n    }\n\n    .dvn-scroll-inner {\n        display: flex;\n        pointer-events: none;\n\n        > * {\n            flex-shrink: 0;\n        }\n\n        .dvn-spacer {\n            flex-grow: 1;\n        }\n\n        .dvn-stack {\n            display: flex;\n            flex-direction: column;\n        }\n    }\n\n    .dvn-underlay > * {\n        position: absolute;\n        left: 0;\n        top: 0;\n    }\n\n    canvas {\n        outline: none;\n\n        * {\n            height: 0;\n        }\n    }\n`;\n\ntype ScrollLock = [undefined, number] | [number, undefined] | undefined;\n\nfunction eatEvent(e: React.MouseEvent) {\n    e.stopPropagation();\n}\n\nfunction useTouchUpDelayed(delay: number): boolean {\n    const [hasTouches, setHasTouches] = React.useState(false);\n\n    const cbTimer = React.useRef(0);\n    useEventListener(\n        \"touchstart\",\n        React.useCallback(() => {\n            window.clearTimeout(cbTimer.current);\n            setHasTouches(true);\n        }, []),\n        window,\n        true,\n        false\n    );\n\n    useEventListener(\n        \"touchend\",\n        React.useCallback(\n            e => {\n                if (e.touches.length === 0) {\n                    cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);\n                }\n            },\n            [delay]\n        ),\n        window,\n        true,\n        false\n    );\n\n    return hasTouches;\n}\n\nexport const InfiniteScroller: React.FC<Props> = p => {\n    const {\n        children,\n        clientHeight,\n        scrollHeight,\n        scrollWidth,\n        update,\n        draggable,\n        className,\n        preventDiagonalScrolling = false,\n        paddingBottom = 0,\n        paddingRight = 0,\n        rightElement,\n        rightElementProps,\n        scrollRef,\n        scrollToEnd,\n        initialSize,\n        minimap,\n    } = p;\n    const padders: React.ReactNode[] = [];\n\n    const rightElementSticky = rightElementProps?.sticky ?? false;\n    const rightElementFill = rightElementProps?.fill ?? false;\n\n    const offsetY = React.useRef(0);\n    const lastScrollY = React.useRef(0);\n    const scroller = React.useRef<HTMLDivElement | null>(null);\n\n    const dpr = window.devicePixelRatio;\n\n    React.useEffect(() => {\n        const el = scroller.current;\n        if (el === null || scrollToEnd !== true) return;\n\n        el.scrollLeft = el.scrollWidth - el.clientWidth;\n    }, [scrollToEnd]);\n\n    const lastScrollPosition = React.useRef({\n        scrollLeft: 0,\n        scrollTop: 0,\n        lockDirection: undefined as ScrollLock,\n    });\n\n    const rightWrapRef = React.useRef<HTMLDivElement | null>(null);\n\n    const hasTouches = useTouchUpDelayed(200);\n    const [isIdle, setIsIdle] = React.useState(true);\n    const idleTimer = React.useRef(0);\n\n    React.useEffect(() => {\n        if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === undefined) return;\n        const el = scroller.current;\n        if (el === null) return;\n        const [lx, ly] = lastScrollPosition.current.lockDirection;\n        if (lx !== undefined) {\n            el.scrollLeft = lx;\n        } else if (ly !== undefined) {\n            el.scrollTop = ly;\n        }\n        lastScrollPosition.current.lockDirection = undefined;\n    }, [hasTouches, isIdle]);\n\n    const onScroll = React.useCallback(() => {\n        const el = scroller.current;\n        if (el === null) return;\n\n        let scrollTop = el.scrollTop;\n        let scrollLeft = el.scrollLeft;\n        const lastScrollTop = lastScrollPosition.current.scrollTop;\n        const lastScrollLeft = lastScrollPosition.current.scrollLeft;\n\n        const dx = scrollLeft - lastScrollLeft;\n        const dy = scrollTop - lastScrollTop;\n\n        if (\n            hasTouches &&\n            dx !== 0 &&\n            dy !== 0 &&\n            (Math.abs(dx) > 3 || Math.abs(dy) > 3) &&\n            preventDiagonalScrolling &&\n            lastScrollPosition.current.lockDirection === undefined\n        ) {\n            lastScrollPosition.current.lockDirection =\n                Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, undefined] : [undefined, lastScrollTop];\n        }\n\n        const lock = lastScrollPosition.current.lockDirection;\n\n        scrollLeft = lock?.[0] ?? scrollLeft;\n        scrollTop = lock?.[1] ?? scrollTop;\n        lastScrollPosition.current.scrollLeft = scrollLeft;\n        lastScrollPosition.current.scrollTop = scrollTop;\n\n        const newY = scrollTop;\n        const delta = lastScrollY.current - newY;\n        const scrollableHeight = el.scrollHeight - el.clientHeight;\n        lastScrollY.current = newY;\n\n        if (\n            scrollableHeight > 0 &&\n            (Math.abs(delta) > 2000 || newY === 0 || newY === scrollableHeight) &&\n            scrollHeight > el.scrollHeight + 5\n        ) {\n            const prog = newY / scrollableHeight;\n            const recomputed = (scrollHeight - el.clientHeight) * prog;\n            offsetY.current = recomputed - newY;\n        }\n\n        if (lock !== undefined) {\n            window.clearTimeout(idleTimer.current);\n            setIsIdle(false);\n            idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);\n        }\n\n        update({\n            x: scrollLeft,\n            y: newY + offsetY.current,\n            width: el.clientWidth - paddingRight,\n            height: el.clientHeight - paddingBottom,\n            paddingRight: rightWrapRef.current?.clientWidth ?? 0,\n        });\n    }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);\n\n    const onScrollRef = React.useRef(onScroll);\n    onScrollRef.current = onScroll;\n\n    const lastProps = React.useRef<{ width?: number; height?: number }>();\n\n    const didFirstScroll = React.useRef(false);\n    React.useEffect(() => {\n        if (didFirstScroll.current) onScroll();\n        else didFirstScroll.current = true;\n    }, [onScroll, paddingBottom, paddingRight]);\n\n    const setRefs = React.useCallback(\n        (instance: HTMLDivElement | null) => {\n            scroller.current = instance;\n            if (scrollRef !== undefined) {\n                scrollRef.current = instance;\n            }\n        },\n        [scrollRef]\n    );\n\n    let key = 0;\n    let h = 0;\n    padders.push(<div key={key++} style={{ width: scrollWidth, height: 0 }} />);\n    while (h < scrollHeight) {\n        const toAdd = Math.min(5_000_000, scrollHeight - h);\n        padders.push(<div key={key++} style={{ width: 0, height: toAdd }} />);\n        h += toAdd;\n    }\n\n    const { ref, width, height } = useResizeDetector<HTMLDivElement>(initialSize);\n\n    if (lastProps.current?.height !== height || lastProps.current?.width !== width) {\n        window.setTimeout(() => onScrollRef.current(), 0);\n        lastProps.current = { width, height };\n    }\n\n    if ((width ?? 0) === 0 || (height ?? 0) === 0) return <div ref={ref} />;\n\n    return (\n        <div ref={ref}>\n            <ScrollRegionStyle isSafari={browserIsSafari.value}>\n                {minimap}\n                <div className=\"dvn-underlay\">{children}</div>\n                <div\n                    ref={setRefs}\n                    style={lastProps.current}\n                    draggable={draggable}\n                    onDragStart={e => {\n                        if (!draggable) {\n                            e.stopPropagation();\n                            e.preventDefault();\n                        }\n                    }}\n                    className={\"dvn-scroller \" + (className ?? \"\")}\n                    onScroll={onScroll}>\n                    <div className={\"dvn-scroll-inner\" + (rightElement === undefined ? \" hidden\" : \"\")}>\n                        <div className=\"dvn-stack\">{padders}</div>\n                        {rightElement !== undefined && (\n                            <>\n                                {!rightElementFill && <div className=\"dvn-spacer\" />}\n                                <div\n                                    ref={rightWrapRef}\n                                    onMouseDown={eatEvent}\n                                    onMouseUp={eatEvent}\n                                    onMouseMove={eatEvent}\n                                    style={{\n                                        height,\n                                        maxHeight: clientHeight - Math.ceil(dpr % 1),\n                                        position: \"sticky\",\n                                        top: 0,\n                                        paddingLeft: 1,\n                                        marginBottom: -40,\n                                        marginRight: paddingRight,\n                                        flexGrow: rightElementFill ? 1 : undefined,\n                                        right: rightElementSticky ? paddingRight ?? 0 : undefined,\n                                        pointerEvents: \"auto\",\n                                    }}>\n                                    {rightElement}\n                                </div>\n                            </>\n                        )}\n                    </div>\n                </div>\n            </ScrollRegionStyle>\n        </div>\n    );\n};\n",".s3se5hb .dvn-scroller{overflow:var(--s3se5hb-0);-webkit-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0);}.s3se5hb .hidden{visibility:hidden;}.s3se5hb .dvn-scroll-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;pointer-events:none;}.s3se5hb .dvn-scroll-inner > *{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}.s3se5hb .dvn-scroll-inner .dvn-spacer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.s3se5hb .dvn-scroll-inner .dvn-stack{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.s3se5hb .dvn-underlay > *{position:absolute;left:0;top:0;}.s3se5hb canvas{outline:none;}.s3se5hb canvas *{height:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9pbmZpbml0ZS1zY3JvbGxlci50c3giXSwibmFtZXMiOlsiLnMzc2U1aGIiXSwibWFwcGluZ3MiOiJBQTRCMEJBIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9pbmZpbml0ZS1zY3JvbGxlci50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcIi4uL2NvbW1vbi9yZXNpemUtZGV0ZWN0b3JcIjtcbmltcG9ydCB7IGJyb3dzZXJJc1NhZmFyaSB9IGZyb20gXCIuLi9jb21tb24vYnJvd3Nlci1kZXRlY3RcIjtcbmltcG9ydCB7IHVzZUV2ZW50TGlzdGVuZXIgfSBmcm9tIFwiLi4vY29tbW9uL3V0aWxzXCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHkgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHByZXZlbnREaWFnb25hbFNjcm9sbGluZz86IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgZHJhZ2dhYmxlOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IHBhZGRpbmdSaWdodD86IG51bWJlcjtcbiAgICByZWFkb25seSBwYWRkaW5nQm90dG9tPzogbnVtYmVyO1xuICAgIHJlYWRvbmx5IGNsaWVudEhlaWdodDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbFdpZHRoOiBudW1iZXI7XG4gICAgcmVhZG9ubHkgc2Nyb2xsSGVpZ2h0OiBudW1iZXI7XG4gICAgcmVhZG9ubHkgc2Nyb2xsVG9FbmQ/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGluaXRpYWxTaXplPzogcmVhZG9ubHkgW3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnRQcm9wcz86IHtcbiAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgfTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgcmVhZG9ubHkgbWluaW1hcD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICByZWFkb25seSBzY3JvbGxSZWY/OiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD47XG4gICAgcmVhZG9ubHkgdXBkYXRlOiAocmVnaW9uOiBSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0pID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNjcm9sbFJlZ2lvblN0eWxlID0gc3R5bGVkLmRpdjx7IGlzU2FmYXJpOiBib29sZWFuIH0+YFxuICAgIC5kdm4tc2Nyb2xsZXIge1xuICAgICAgICBvdmVyZmxvdzogJHtwID0+IChwLmlzU2FmYXJpID8gXCJzY3JvbGxcIiA6IFwiYXV0b1wiKX07XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgLmhpZGRlbiB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuZHZuLXNjcm9sbC1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3BhY2VyIHtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3RhY2sge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZHZuLXVuZGVybGF5ID4gKiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgIH1cblxuICAgIGNhbnZhcyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG5cbiAgICAgICAgKiB7XG4gICAgICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG50eXBlIFNjcm9sbExvY2sgPSBbdW5kZWZpbmVkLCBudW1iZXJdIHwgW251bWJlciwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZWF0RXZlbnQoZTogUmVhY3QuTW91c2VFdmVudCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVRvdWNoVXBEZWxheWVkKGRlbGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBbaGFzVG91Y2hlcywgc2V0SGFzVG91Y2hlc10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBjYlRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNiVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRIYXNUb3VjaGVzKHRydWUpO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiVGltZXIuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHNldEhhc1RvdWNoZXMoZmFsc2UpLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtkZWxheV1cbiAgICAgICAgKSxcbiAgICAgICAgd2luZG93LFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuZXhwb3J0IGNvbnN0IEluZmluaXRlU2Nyb2xsZXI6IFJlYWN0LkZDPFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwLFxuICAgICAgICBwYWRkaW5nUmlnaHQgPSAwLFxuICAgICAgICByaWdodEVsZW1lbnQsXG4gICAgICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgbWluaW1hcCxcbiAgICB9ID0gcDtcbiAgICBjb25zdCBwYWRkZXJzOiBSZWFjdC5SZWFjdE5vZGVbXSA9IFtdO1xuXG4gICAgY29uc3QgcmlnaHRFbGVtZW50U3RpY2t5ID0gcmlnaHRFbGVtZW50UHJvcHM/LnN0aWNreSA/PyBmYWxzZTtcbiAgICBjb25zdCByaWdodEVsZW1lbnRGaWxsID0gcmlnaHRFbGVtZW50UHJvcHM/LmZpbGwgPz8gZmFsc2U7XG5cbiAgICBjb25zdCBvZmZzZXRZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IGxhc3RTY3JvbGxZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IHNjcm9sbGVyID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsIHx8IHNjcm9sbFRvRW5kICE9PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGg7XG4gICAgfSwgW3Njcm9sbFRvRW5kXSk7XG5cbiAgICBjb25zdCBsYXN0U2Nyb2xsUG9zaXRpb24gPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgIGxvY2tEaXJlY3Rpb246IHVuZGVmaW5lZCBhcyBTY3JvbGxMb2NrLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmlnaHRXcmFwUmVmID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBoYXNUb3VjaGVzID0gdXNlVG91Y2hVcERlbGF5ZWQoMjAwKTtcbiAgICBjb25zdCBbaXNJZGxlLCBzZXRJc0lkbGVdID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgaWRsZVRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0lkbGUgfHwgaGFzVG91Y2hlcyB8fCBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBzY3JvbGxlci5jdXJyZW50O1xuICAgICAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgW2x4LCBseV0gPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uO1xuICAgICAgICBpZiAobHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGx4O1xuICAgICAgICB9IGVsc2UgaWYgKGx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcCA9IGx5O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSwgW2hhc1RvdWNoZXMsIGlzSWRsZV0pO1xuXG4gICAgY29uc3Qgb25TY3JvbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsVG9wID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsTGVmdCA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgY29uc3QgZHggPSBzY3JvbGxMZWZ0IC0gbGFzdFNjcm9sbExlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gc2Nyb2xsVG9wIC0gbGFzdFNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNUb3VjaGVzICYmXG4gICAgICAgICAgICBkeCAhPT0gMCAmJlxuICAgICAgICAgICAgZHkgIT09IDAgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhkeCkgPiAzIHx8IE1hdGguYWJzKGR5KSA+IDMpICYmXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcgJiZcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPVxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGR4KSA8IE1hdGguYWJzKGR5KSA/IFtsYXN0U2Nyb2xsTGVmdCwgdW5kZWZpbmVkXSA6IFt1bmRlZmluZWQsIGxhc3RTY3JvbGxUb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jayA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb247XG5cbiAgICAgICAgc2Nyb2xsTGVmdCA9IGxvY2s/LlswXSA/PyBzY3JvbGxMZWZ0O1xuICAgICAgICBzY3JvbGxUb3AgPSBsb2NrPy5bMV0gPz8gc2Nyb2xsVG9wO1xuICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXG4gICAgICAgIGNvbnN0IG5ld1kgPSBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbGFzdFNjcm9sbFkuY3VycmVudCAtIG5ld1k7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxhc3RTY3JvbGxZLmN1cnJlbnQgPSBuZXdZO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNjcm9sbGFibGVIZWlnaHQgPiAwICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoZGVsdGEpID4gMjAwMCB8fCBuZXdZID09PSAwIHx8IG5ld1kgPT09IHNjcm9sbGFibGVIZWlnaHQpICYmXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPiBlbC5zY3JvbGxIZWlnaHQgKyA1XG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcHJvZyA9IG5ld1kgLyBzY3JvbGxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcmVjb21wdXRlZCA9IChzY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQpICogcHJvZztcbiAgICAgICAgICAgIG9mZnNldFkuY3VycmVudCA9IHJlY29tcHV0ZWQgLSBuZXdZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZGxlVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRJc0lkbGUoZmFsc2UpO1xuICAgICAgICAgICAgaWRsZVRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRJc0lkbGUodHJ1ZSksIDIwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgeDogc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHk6IG5ld1kgKyBvZmZzZXRZLmN1cnJlbnQsXG4gICAgICAgICAgICB3aWR0aDogZWwuY2xpZW50V2lkdGggLSBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsLmNsaWVudEhlaWdodCAtIHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHJpZ2h0V3JhcFJlZi5jdXJyZW50Py5jbGllbnRXaWR0aCA/PyAwLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBzY3JvbGxIZWlnaHQsIHVwZGF0ZSwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCBoYXNUb3VjaGVzXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFJlZiA9IFJlYWN0LnVzZVJlZihvblNjcm9sbCk7XG4gICAgb25TY3JvbGxSZWYuY3VycmVudCA9IG9uU2Nyb2xsO1xuXG4gICAgY29uc3QgbGFzdFByb3BzID0gUmVhY3QudXNlUmVmPHsgd2lkdGg/OiBudW1iZXI7IGhlaWdodD86IG51bWJlciB9PigpO1xuXG4gICAgY29uc3QgZGlkRmlyc3RTY3JvbGwgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaWRGaXJzdFNjcm9sbC5jdXJyZW50KSBvblNjcm9sbCgpO1xuICAgICAgICBlbHNlIGRpZEZpcnN0U2Nyb2xsLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtvblNjcm9sbCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0XSk7XG5cbiAgICBjb25zdCBzZXRSZWZzID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChpbnN0YW5jZTogSFRNTERpdkVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBzY3JvbGxlci5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsUmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxSZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbc2Nyb2xsUmVmXVxuICAgICk7XG5cbiAgICBsZXQga2V5ID0gMDtcbiAgICBsZXQgaCA9IDA7XG4gICAgcGFkZGVycy5wdXNoKDxkaXYga2V5PXtrZXkrK30gc3R5bGU9e3sgd2lkdGg6IHNjcm9sbFdpZHRoLCBoZWlnaHQ6IDAgfX0gLz4pO1xuICAgIHdoaWxlIChoIDwgc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHRvQWRkID0gTWF0aC5taW4oNV8wMDBfMDAwLCBzY3JvbGxIZWlnaHQgLSBoKTtcbiAgICAgICAgcGFkZGVycy5wdXNoKDxkaXYga2V5PXtrZXkrK30gc3R5bGU9e3sgd2lkdGg6IDAsIGhlaWdodDogdG9BZGQgfX0gLz4pO1xuICAgICAgICBoICs9IHRvQWRkO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcjxIVE1MRGl2RWxlbWVudD4oaW5pdGlhbFNpemUpO1xuXG4gICAgaWYgKGxhc3RQcm9wcy5jdXJyZW50Py5oZWlnaHQgIT09IGhlaWdodCB8fCBsYXN0UHJvcHMuY3VycmVudD8ud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IG9uU2Nyb2xsUmVmLmN1cnJlbnQoKSwgMCk7XG4gICAgICAgIGxhc3RQcm9wcy5jdXJyZW50ID0geyB3aWR0aCwgaGVpZ2h0IH07XG4gICAgfVxuXG4gICAgaWYgKCh3aWR0aCA/PyAwKSA9PT0gMCB8fCAoaGVpZ2h0ID8/IDApID09PSAwKSByZXR1cm4gPGRpdiByZWY9e3JlZn0gLz47XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IHJlZj17cmVmfT5cbiAgICAgICAgICAgIDxTY3JvbGxSZWdpb25TdHlsZSBpc1NhZmFyaT17YnJvd3NlcklzU2FmYXJpLnZhbHVlfT5cbiAgICAgICAgICAgICAgICB7bWluaW1hcH1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImR2bi11bmRlcmxheVwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIHJlZj17c2V0UmVmc31cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e2xhc3RQcm9wcy5jdXJyZW50fVxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU9e2RyYWdnYWJsZX1cbiAgICAgICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcImR2bi1zY3JvbGxlciBcIiArIChjbGFzc05hbWUgPz8gXCJcIil9XG4gICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsPXtvblNjcm9sbH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtcImR2bi1zY3JvbGwtaW5uZXJcIiArIChyaWdodEVsZW1lbnQgPT09IHVuZGVmaW5lZCA/IFwiIGhpZGRlblwiIDogXCJcIil9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdm4tc3RhY2tcIj57cGFkZGVyc308L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtyaWdodEVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyFyaWdodEVsZW1lbnRGaWxsICYmIDxkaXYgY2xhc3NOYW1lPVwiZHZuLXNwYWNlclwiIC8+fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY9e3JpZ2h0V3JhcFJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXtlYXRFdmVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VVcD17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZT17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IGNsaWVudEhlaWdodCAtIE1hdGguY2VpbChkcHIgJSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAtNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IHBhZGRpbmdSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4R3JvdzogcmlnaHRFbGVtZW50RmlsbCA/IDEgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0RWxlbWVudFN0aWNreSA/IHBhZGRpbmdSaWdodCA/PyAwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmlnaHRFbGVtZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9TY3JvbGxSZWdpb25TdHlsZT5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".i1ua65x0{width:100%;height:100px;}.i1ua65x0 > *{position:absolute;width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5pMXVhNjV4MCJdLCJtYXBwaW5ncyI6IkFBa0J1QkEiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIC8vIEB0cy1ub2NoZWNrXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX1NUT1JZX18gPSBcImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5cXG5pbXBvcnQgeyBCdWlsZGVyVGhlbWVXcmFwcGVyIH0gZnJvbSBcXFwiLi4vc3Rvcmllcy9zdG9yeS11dGlsc1xcXCI7XFxuaW1wb3J0IEdyaWRTY3JvbGxlciBmcm9tIFxcXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXFxcIkBsaW5hcmlhL3JlYWN0XFxcIjtcXG5pbXBvcnQgeyBDb21wYWN0U2VsZWN0aW9uLCBHcmlkQ2VsbCwgR3JpZENlbGxLaW5kLCBSZWN0YW5nbGUsIEl0ZW0gfSBmcm9tIFxcXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBnZXREZWZhdWx0VGhlbWUgfSBmcm9tIFxcXCIuLlxcXCI7XFxuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXFxcIi4uL2RhdGEtZ3JpZC9jZWxscy9jZWxsLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBDZWxsUmVuZGVyZXJzIH0gZnJvbSBcXFwiLi4vZGF0YS1ncmlkL2NlbGxzXFxcIjtcXG5cXG5jb25zdCBJbm5lckNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMHB4O1xcblxcbiAgICA+ICoge1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIH1cXG5gO1xcblxcbmNvbnN0IGdldENlbGxSZW5kZXJlcjogR2V0Q2VsbFJlbmRlcmVyQ2FsbGJhY2sgPSBjZWxsID0+IHtcXG4gICAgaWYgKGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiU3ViY29tcG9uZW50cy9TY3JvbGxpbmdEYXRhR3JpZFxcXCIsXFxuXFxuICAgIGRlY29yYXRvcnM6IFtcXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxcbiAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxNTAwfSBoZWlnaHQ9ezEwMDB9PlxcbiAgICAgICAgICAgICAgICAgICAgPElubmVyQ29udGFpbmVyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxcbiAgICAgICAgICAgICAgICAgICAgPC9Jbm5lckNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgICAgPC9CdWlsZGVyVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmV4cG9ydCBmdW5jdGlvbiBTaW1wbGVub3Rlc3QoKSB7XFxuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XFxuICAgIGNvbnN0IFt5LCBzZXRZXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XFxuICAgIGNvbnN0IFt0cmFuc2xhdGVYLCBzZXRUeF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXIgfCB1bmRlZmluZWQ+KDApO1xcbiAgICBjb25zdCBbdHJhbnNsYXRlWSwgc2V0VHldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcXG5cXG4gICAgY29uc3Qgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChyYW5nZTogUmVjdGFuZ2xlLCB0eD86IG51bWJlciwgdHk/OiBudW1iZXIpID0+IHtcXG4gICAgICAgIHNldFgocmFuZ2UueCk7XFxuICAgICAgICBzZXRZKHJhbmdlLnkpO1xcbiAgICAgICAgc2V0VHgodHgpO1xcbiAgICAgICAgc2V0VHkodHkpO1xcbiAgICB9LCBbXSk7XFxuXFxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcXG4gICAgICAgIGxldCBqID0gMDtcXG4gICAgICAgIHJldHVybiBbXFxcIk9uZVxcXCIsIFxcXCJUd29cXFwiLCBcXFwiVGhyZWVcXFwiLCBcXFwiRm91clxcXCIsIFxcXCJGaXZlXFxcIiwgXFxcIlNpeFxcXCIsIFxcXCJTZXZlblxcXCIsIFxcXCJFaWdodFxcXCIsIFxcXCJOaW5lXFxcIiwgXFxcIlRlblxcXCJdLm1hcCh0ID0+ICh7XFxuICAgICAgICAgICAgdGl0bGU6IHQsXFxuICAgICAgICAgICAgd2lkdGg6IDEyMiArIChqICs9IDUwKSxcXG4gICAgICAgIH0pKTtcXG4gICAgfSwgW10pO1xcblxcbiAgICBjb25zdCBnZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xcbiAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxcbiAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9LCR7cm93fSBUZXN0aW5nIHRoaW5ncyB0aGF0IGFyZSB3YXkgdG9vIGxvbmdgLFxcbiAgICAgICAgICAgIGRhdGE6IGAke2NvbH0sJHtyb3d9IFRlc3RpbmcgdGhpbmdzIHRoYXQgYXJlIHdheSB0b28gbG9uZ2AsXFxuICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgfSksXFxuICAgICAgICBbXVxcbiAgICApO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEdyaWRTY3JvbGxlclxcbiAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17Z2V0Q2VsbFJlbmRlcmVyfVxcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgcm93cz17MTBfMDAwfVxcbiAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17ZmFsc2V9XFxuICAgICAgICAgICAgY2xpZW50U2l6ZT17WzEwMDAsIDEwMDBdfVxcbiAgICAgICAgICAgIGNlbGxYT2Zmc2V0PXt4fVxcbiAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXt5fVxcbiAgICAgICAgICAgIGRyYXdIZWFkZXI9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBleHBlcmltZW50YWw9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBoZWFkZXJJY29ucz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DYW52YXNCbHVyPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DZWxsRm9jdXNlZD17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyYWdFbmQ9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyYWdMZWF2ZT17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyb3A9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkl0ZW1Ib3ZlcmVkPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25LZXlEb3duPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25LZXlVcD17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25Nb3VzZVVwPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgY2FudmFzUmVmPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgY2xhc3NOYW1lPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgZmlsbEhhbmRsZT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGZpeGVkU2hhZG93WD17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGZpeGVkU2hhZG93WT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGdldFJvd1RoZW1lT3ZlcnJpZGU9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgaW1hZ2VXaW5kb3dMb2FkZXI9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkhlYWRlck1lbnVDbGljaz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBkcmF3Q3VzdG9tQ2VsbD17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGRyYXdGb2N1c1Jpbmc9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG92ZXJzY3JvbGxYPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgb3ZlcnNjcm9sbFk9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICByaWdodEVsZW1lbnQ9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHNjcm9sbFJlZj17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHNob3dNaW5pbWFwPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgc2Nyb2xsVG9FbmQ9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17NTB9XFxuICAgICAgICAgICAgaXNGb2N1c2VkPXt0cnVlfVxcbiAgICAgICAgICAgIHRoZW1lPXtnZXREZWZhdWx0VGhlbWUoKX1cXG4gICAgICAgICAgICBpc0ZpbGxpbmc9e2ZhbHNlfVxcbiAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXs1MDB9XFxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUhlaWdodD17NTB9XFxuICAgICAgICAgICAgdHJhbnNsYXRlWD17dHJhbnNsYXRlWH1cXG4gICAgICAgICAgICB0cmFuc2xhdGVZPXt0cmFuc2xhdGVZfVxcbiAgICAgICAgICAgIGxvY2tDb2x1bW5zPXswfVxcbiAgICAgICAgICAgIHNlbGVjdGlvbj17e1xcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcXG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxcbiAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgZmlyc3RDb2xBY2Nlc3NpYmxlPXt0cnVlfVxcbiAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXszNH1cXG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQ9ezQ0fVxcbiAgICAgICAgICAgIHRyYWlsaW5nUm93VHlwZT17XFxcIm5vbmVcXFwifVxcbiAgICAgICAgICAgIHJvd0hlaWdodD17MzR9XFxuICAgICAgICAgICAgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZD17b25WaXNpYmxlUmVnaW9uQ2hhbmdlZH1cXG4gICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxcbiAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICBmcmVlemVDb2x1bW5zPXswfVxcbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXsoKSA9PiB0cnVlfVxcbiAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3RydWV9XFxuICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17dHJ1ZX1cXG4gICAgICAgIC8+XFxuICAgICk7XFxufVxcblwiO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgX19MT0NBVElPTlNfTUFQX18gPSB7XCJTaW1wbGVub3Rlc3RcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjcsXCJsaW5lXCI6NDN9LFwiZW5kTG9jXCI6e1wiY29sXCI6MSxcImxpbmVcIjoxNTJ9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6NyxcImxpbmVcIjo0M30sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjoxNTJ9fX07XG4gICAgXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgR3JpZFNjcm9sbGVyIGZyb20gXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgQ29tcGFjdFNlbGVjdGlvbiwgR3JpZENlbGwsIEdyaWRDZWxsS2luZCwgUmVjdGFuZ2xlLCBJdGVtIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRUaGVtZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHMvY2VsbC10eXBlc1wiO1xuaW1wb3J0IHsgQ2VsbFJlbmRlcmVycyB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHNcIjtcblxuY29uc3QgSW5uZXJDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwcHg7XG5cbiAgICA+ICoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuYDtcblxuY29uc3QgZ2V0Q2VsbFJlbmRlcmVyOiBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayA9IGNlbGwgPT4ge1xuICAgIGlmIChjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7cGFyYW1ldGVyczoge1wic3RvcnlTb3VyY2VcIjp7XCJzb3VyY2VcIjpcImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5cXG5pbXBvcnQgeyBCdWlsZGVyVGhlbWVXcmFwcGVyIH0gZnJvbSBcXFwiLi4vc3Rvcmllcy9zdG9yeS11dGlsc1xcXCI7XFxuaW1wb3J0IEdyaWRTY3JvbGxlciBmcm9tIFxcXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXFxcIkBsaW5hcmlhL3JlYWN0XFxcIjtcXG5pbXBvcnQgeyBDb21wYWN0U2VsZWN0aW9uLCBHcmlkQ2VsbCwgR3JpZENlbGxLaW5kLCBSZWN0YW5nbGUsIEl0ZW0gfSBmcm9tIFxcXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBnZXREZWZhdWx0VGhlbWUgfSBmcm9tIFxcXCIuLlxcXCI7XFxuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXFxcIi4uL2RhdGEtZ3JpZC9jZWxscy9jZWxsLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBDZWxsUmVuZGVyZXJzIH0gZnJvbSBcXFwiLi4vZGF0YS1ncmlkL2NlbGxzXFxcIjtcXG5cXG5jb25zdCBJbm5lckNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMHB4O1xcblxcbiAgICA+ICoge1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIH1cXG5gO1xcblxcbmNvbnN0IGdldENlbGxSZW5kZXJlcjogR2V0Q2VsbFJlbmRlcmVyQ2FsbGJhY2sgPSBjZWxsID0+IHtcXG4gICAgaWYgKGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiU3ViY29tcG9uZW50cy9TY3JvbGxpbmdEYXRhR3JpZFxcXCIsXFxuXFxuICAgIGRlY29yYXRvcnM6IFtcXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxcbiAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxNTAwfSBoZWlnaHQ9ezEwMDB9PlxcbiAgICAgICAgICAgICAgICAgICAgPElubmVyQ29udGFpbmVyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxcbiAgICAgICAgICAgICAgICAgICAgPC9Jbm5lckNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgICAgPC9CdWlsZGVyVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmV4cG9ydCBmdW5jdGlvbiBTaW1wbGVub3Rlc3QoKSB7XFxuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XFxuICAgIGNvbnN0IFt5LCBzZXRZXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XFxuICAgIGNvbnN0IFt0cmFuc2xhdGVYLCBzZXRUeF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXIgfCB1bmRlZmluZWQ+KDApO1xcbiAgICBjb25zdCBbdHJhbnNsYXRlWSwgc2V0VHldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcXG5cXG4gICAgY29uc3Qgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChyYW5nZTogUmVjdGFuZ2xlLCB0eD86IG51bWJlciwgdHk/OiBudW1iZXIpID0+IHtcXG4gICAgICAgIHNldFgocmFuZ2UueCk7XFxuICAgICAgICBzZXRZKHJhbmdlLnkpO1xcbiAgICAgICAgc2V0VHgodHgpO1xcbiAgICAgICAgc2V0VHkodHkpO1xcbiAgICB9LCBbXSk7XFxuXFxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcXG4gICAgICAgIGxldCBqID0gMDtcXG4gICAgICAgIHJldHVybiBbXFxcIk9uZVxcXCIsIFxcXCJUd29cXFwiLCBcXFwiVGhyZWVcXFwiLCBcXFwiRm91clxcXCIsIFxcXCJGaXZlXFxcIiwgXFxcIlNpeFxcXCIsIFxcXCJTZXZlblxcXCIsIFxcXCJFaWdodFxcXCIsIFxcXCJOaW5lXFxcIiwgXFxcIlRlblxcXCJdLm1hcCh0ID0+ICh7XFxuICAgICAgICAgICAgdGl0bGU6IHQsXFxuICAgICAgICAgICAgd2lkdGg6IDEyMiArIChqICs9IDUwKSxcXG4gICAgICAgIH0pKTtcXG4gICAgfSwgW10pO1xcblxcbiAgICBjb25zdCBnZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xcbiAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxcbiAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9LCR7cm93fSBUZXN0aW5nIHRoaW5ncyB0aGF0IGFyZSB3YXkgdG9vIGxvbmdgLFxcbiAgICAgICAgICAgIGRhdGE6IGAke2NvbH0sJHtyb3d9IFRlc3RpbmcgdGhpbmdzIHRoYXQgYXJlIHdheSB0b28gbG9uZ2AsXFxuICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgfSksXFxuICAgICAgICBbXVxcbiAgICApO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEdyaWRTY3JvbGxlclxcbiAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17Z2V0Q2VsbFJlbmRlcmVyfVxcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgcm93cz17MTBfMDAwfVxcbiAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17ZmFsc2V9XFxuICAgICAgICAgICAgY2xpZW50U2l6ZT17WzEwMDAsIDEwMDBdfVxcbiAgICAgICAgICAgIGNlbGxYT2Zmc2V0PXt4fVxcbiAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXt5fVxcbiAgICAgICAgICAgIGRyYXdIZWFkZXI9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBleHBlcmltZW50YWw9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBoZWFkZXJJY29ucz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DYW52YXNCbHVyPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DZWxsRm9jdXNlZD17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyYWdFbmQ9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyYWdMZWF2ZT17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyb3A9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkl0ZW1Ib3ZlcmVkPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25LZXlEb3duPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25LZXlVcD17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25Nb3VzZVVwPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgY2FudmFzUmVmPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgY2xhc3NOYW1lPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgZmlsbEhhbmRsZT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGZpeGVkU2hhZG93WD17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGZpeGVkU2hhZG93WT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGdldFJvd1RoZW1lT3ZlcnJpZGU9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgaW1hZ2VXaW5kb3dMb2FkZXI9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkhlYWRlck1lbnVDbGljaz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBkcmF3Q3VzdG9tQ2VsbD17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGRyYXdGb2N1c1Jpbmc9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG92ZXJzY3JvbGxYPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgb3ZlcnNjcm9sbFk9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICByaWdodEVsZW1lbnQ9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHNjcm9sbFJlZj17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHNob3dNaW5pbWFwPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgc2Nyb2xsVG9FbmQ9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17NTB9XFxuICAgICAgICAgICAgaXNGb2N1c2VkPXt0cnVlfVxcbiAgICAgICAgICAgIHRoZW1lPXtnZXREZWZhdWx0VGhlbWUoKX1cXG4gICAgICAgICAgICBpc0ZpbGxpbmc9e2ZhbHNlfVxcbiAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXs1MDB9XFxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUhlaWdodD17NTB9XFxuICAgICAgICAgICAgdHJhbnNsYXRlWD17dHJhbnNsYXRlWH1cXG4gICAgICAgICAgICB0cmFuc2xhdGVZPXt0cmFuc2xhdGVZfVxcbiAgICAgICAgICAgIGxvY2tDb2x1bW5zPXswfVxcbiAgICAgICAgICAgIHNlbGVjdGlvbj17e1xcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcXG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxcbiAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgZmlyc3RDb2xBY2Nlc3NpYmxlPXt0cnVlfVxcbiAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXszNH1cXG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQ9ezQ0fVxcbiAgICAgICAgICAgIHRyYWlsaW5nUm93VHlwZT17XFxcIm5vbmVcXFwifVxcbiAgICAgICAgICAgIHJvd0hlaWdodD17MzR9XFxuICAgICAgICAgICAgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZD17b25WaXNpYmxlUmVnaW9uQ2hhbmdlZH1cXG4gICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxcbiAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICBmcmVlemVDb2x1bW5zPXswfVxcbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXsoKSA9PiB0cnVlfVxcbiAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3RydWV9XFxuICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17dHJ1ZX1cXG4gICAgICAgIC8+XFxuICAgICk7XFxufVxcblwiLFwibG9jYXRpb25zTWFwXCI6e1wic2ltcGxlbm90ZXN0XCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjo3LFwibGluZVwiOjQzfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6MTUyfSxcInN0YXJ0Qm9keVwiOntcImNvbFwiOjcsXCJsaW5lXCI6NDN9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6MTUyfX19fSx9LFxuICAgIHRpdGxlOiBcIlN1YmNvbXBvbmVudHMvU2Nyb2xsaW5nRGF0YUdyaWRcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxNTAwfSBoZWlnaHQ9ezEwMDB9PlxuICAgICAgICAgICAgICAgICAgICA8SW5uZXJDb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3RvcnkgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9Jbm5lckNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L0J1aWxkZXJUaGVtZVdyYXBwZXI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSxcbiAgICBdLFxufTtcblxuZXhwb3J0IGNvbnN0IFNpbXBsZW5vdGVzdCA9IGZ1bmN0aW9uIFNpbXBsZW5vdGVzdCgpIHtcbiAgICBjb25zdCBbeCwgc2V0WF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KDApO1xuICAgIGNvbnN0IFt5LCBzZXRZXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XG4gICAgY29uc3QgW3RyYW5zbGF0ZVgsIHNldFR4XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlciB8IHVuZGVmaW5lZD4oMCk7XG4gICAgY29uc3QgW3RyYW5zbGF0ZVksIHNldFR5XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlciB8IHVuZGVmaW5lZD4oMCk7XG5cbiAgICBjb25zdCBvblZpc2libGVSZWdpb25DaGFuZ2VkID0gUmVhY3QudXNlQ2FsbGJhY2soKHJhbmdlOiBSZWN0YW5nbGUsIHR4PzogbnVtYmVyLCB0eT86IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRYKHJhbmdlLngpO1xuICAgICAgICBzZXRZKHJhbmdlLnkpO1xuICAgICAgICBzZXRUeCh0eCk7XG4gICAgICAgIHNldFR5KHR5KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2x1bW5zID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgcmV0dXJuIFtcIk9uZVwiLCBcIlR3b1wiLCBcIlRocmVlXCIsIFwiRm91clwiLCBcIkZpdmVcIiwgXCJTaXhcIiwgXCJTZXZlblwiLCBcIkVpZ2h0XCIsIFwiTmluZVwiLCBcIlRlblwiXS5tYXAodCA9PiAoe1xuICAgICAgICAgICAgdGl0bGU6IHQsXG4gICAgICAgICAgICB3aWR0aDogMTIyICsgKGogKz0gNTApLFxuICAgICAgICB9KSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xuICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7Y29sfSwke3Jvd30gVGVzdGluZyB0aGluZ3MgdGhhdCBhcmUgd2F5IHRvbyBsb25nYCxcbiAgICAgICAgICAgIGRhdGE6IGAke2NvbH0sJHtyb3d9IFRlc3RpbmcgdGhpbmdzIHRoYXQgYXJlIHdheSB0b28gbG9uZ2AsXG4gICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICBbXVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8R3JpZFNjcm9sbGVyXG4gICAgICAgICAgICBnZXRDZWxsUmVuZGVyZXI9e2dldENlbGxSZW5kZXJlcn1cbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICBlbmFibGVHcm91cHM9e2ZhbHNlfVxuICAgICAgICAgICAgY2xpZW50U2l6ZT17WzEwMDAsIDEwMDBdfVxuICAgICAgICAgICAgY2VsbFhPZmZzZXQ9e3h9XG4gICAgICAgICAgICBjZWxsWU9mZnNldD17eX1cbiAgICAgICAgICAgIGRyYXdIZWFkZXI9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaGVhZGVySWNvbnM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNhbnZhc0JsdXI9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uQ2FudmFzRm9jdXNlZD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25DZWxsRm9jdXNlZD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Db250ZXh0TWVudT17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25EcmFnRW5kPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdMZWF2ZT17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25EcmFnT3ZlckNlbGw9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyb3A9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uS2V5RG93bj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25LZXlVcD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Nb3VzZURvd249eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uTW91c2VVcD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgY2FudmFzUmVmPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGRpc2FibGVkUm93cz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZmlsbEhhbmRsZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZml4ZWRTaGFkb3dYPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaXhlZFNoYWRvd1k9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaW1hZ2VXaW5kb3dMb2FkZXI9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uSGVhZGVyTWVudUNsaWNrPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBwcmVsaWdodENlbGxzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBkcmF3Q3VzdG9tQ2VsbD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZHJhd0ZvY3VzUmluZz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaW5pdGlhbFNpemU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG92ZXJzY3JvbGxYPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBvdmVyc2Nyb2xsWT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nPXt1bmRlZmluZWR9XG4gICAgICAgICAgICByaWdodEVsZW1lbnQ9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudFByb3BzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBzY3JvbGxSZWY9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNob3dNaW5pbWFwPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBzY3JvbGxUb0VuZD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgbWluQ29sdW1uV2lkdGg9ezUwfVxuICAgICAgICAgICAgaXNGb2N1c2VkPXt0cnVlfVxuICAgICAgICAgICAgdGhlbWU9e2dldERlZmF1bHRUaGVtZSgpfVxuICAgICAgICAgICAgaXNGaWxsaW5nPXtmYWxzZX1cbiAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXs1MDB9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5SGVpZ2h0PXs1MH1cbiAgICAgICAgICAgIHRyYW5zbGF0ZVg9e3RyYW5zbGF0ZVh9XG4gICAgICAgICAgICB0cmFuc2xhdGVZPXt0cmFuc2xhdGVZfVxuICAgICAgICAgICAgbG9ja0NvbHVtbnM9ezB9XG4gICAgICAgICAgICBzZWxlY3Rpb249e3tcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcm93czogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBmaXJzdENvbEFjY2Vzc2libGU9e3RydWV9XG4gICAgICAgICAgICBncm91cEhlYWRlckhlaWdodD17MzR9XG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQ9ezQ0fVxuICAgICAgICAgICAgdHJhaWxpbmdSb3dUeXBlPXtcIm5vbmVcIn1cbiAgICAgICAgICAgIHJvd0hlaWdodD17MzR9XG4gICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPXtvblZpc2libGVSZWdpb25DaGFuZ2VkfVxuICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezB9XG4gICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17KCkgPT4gdHJ1ZX1cbiAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3RydWV9XG4gICAgICAgICAgICBzbW9vdGhTY3JvbGxZPXt0cnVlfVxuICAgICAgICAvPlxuICAgICk7XG59OyJdfQ==*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx","webpack://./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx"],"names":[".i1ua65x0"],"mappings":"AAkBuBA,UAAAA,UAAAA,CAAAA,YAAAA,CAAAA,CAAAA,cAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACjBvB,m6sBAAm6sB","sourcesContent":["\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import * as React from \\\"react\\\";\\n\\nimport { BuilderThemeWrapper } from \\\"../stories/story-utils\\\";\\nimport GridScroller from \\\"./scrolling-data-grid\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport { CompactSelection, GridCell, GridCellKind, Rectangle, Item } from \\\"../data-grid/data-grid-types\\\";\\nimport { getDefaultTheme } from \\\"..\\\";\\nimport type { GetCellRendererCallback } from \\\"../data-grid/cells/cell-types\\\";\\nimport { CellRenderers } from \\\"../data-grid/cells\\\";\\n\\nconst InnerContainer = styled.div`\\n    width: 100%;\\n    height: 100px;\\n\\n    > * {\\n        position: absolute;\\n        width: 100%;\\n        height: 100%;\\n    }\\n`;\\n\\nconst getCellRenderer: GetCellRendererCallback = cell => {\\n    if (cell.kind === GridCellKind.Custom) return undefined;\\n    return CellRenderers[cell.kind] as any;\\n};\\n\\nexport default {\\n    title: \\\"Subcomponents/ScrollingDataGrid\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <div>\\n                <BuilderThemeWrapper width={1500} height={1000}>\\n                    <InnerContainer>\\n                        <Story />\\n                    </InnerContainer>\\n                </BuilderThemeWrapper>\\n            </div>\\n        ),\\n    ],\\n};\\n\\nexport function Simplenotest() {\\n    const [x, setX] = React.useState<number>(0);\\n    const [y, setY] = React.useState<number>(0);\\n    const [translateX, setTx] = React.useState<number | undefined>(0);\\n    const [translateY, setTy] = React.useState<number | undefined>(0);\\n\\n    const onVisibleRegionChanged = React.useCallback((range: Rectangle, tx?: number, ty?: number) => {\\n        setX(range.x);\\n        setY(range.y);\\n        setTx(tx);\\n        setTy(ty);\\n    }, []);\\n\\n    const columns = React.useMemo(() => {\\n        let j = 0;\\n        return [\\\"One\\\", \\\"Two\\\", \\\"Three\\\", \\\"Four\\\", \\\"Five\\\", \\\"Six\\\", \\\"Seven\\\", \\\"Eight\\\", \\\"Nine\\\", \\\"Ten\\\"].map(t => ({\\n            title: t,\\n            width: 122 + (j += 50),\\n        }));\\n    }, []);\\n\\n    const getCellContent = React.useCallback(\\n        ([col, row]: Item): GridCell => ({\\n            kind: GridCellKind.Text,\\n            displayData: `${col},${row} Testing things that are way too long`,\\n            data: `${col},${row} Testing things that are way too long`,\\n            allowOverlay: true,\\n        }),\\n        []\\n    );\\n\\n    return (\\n        <GridScroller\\n            getCellRenderer={getCellRenderer}\\n            onMouseMove={() => undefined}\\n            rows={10_000}\\n            enableGroups={false}\\n            clientSize={[1000, 1000]}\\n            cellXOffset={x}\\n            cellYOffset={y}\\n            drawHeader={undefined}\\n            experimental={undefined}\\n            headerIcons={undefined}\\n            isDraggable={undefined}\\n            onCanvasBlur={() => undefined}\\n            onCanvasFocused={() => undefined}\\n            onCellFocused={() => undefined}\\n            onContextMenu={() => undefined}\\n            onDragEnd={() => undefined}\\n            onDragLeave={() => undefined}\\n            onDragOverCell={() => undefined}\\n            onDragStart={() => undefined}\\n            onDrop={() => undefined}\\n            onItemHovered={() => undefined}\\n            onKeyDown={() => undefined}\\n            onKeyUp={() => undefined}\\n            onMouseDown={() => undefined}\\n            onMouseUp={() => undefined}\\n            canvasRef={undefined}\\n            className={undefined}\\n            disabledRows={undefined}\\n            fillHandle={undefined}\\n            fixedShadowX={undefined}\\n            fixedShadowY={undefined}\\n            getGroupDetails={undefined}\\n            getRowThemeOverride={undefined}\\n            highlightRegions={undefined}\\n            imageWindowLoader={undefined}\\n            onHeaderMenuClick={undefined}\\n            prelightCells={undefined}\\n            drawCustomCell={undefined}\\n            drawFocusRing={undefined}\\n            initialSize={undefined}\\n            overscrollX={undefined}\\n            overscrollY={undefined}\\n            preventDiagonalScrolling={undefined}\\n            rightElement={undefined}\\n            rightElementProps={undefined}\\n            scrollRef={undefined}\\n            showMinimap={undefined}\\n            scrollToEnd={undefined}\\n            minColumnWidth={50}\\n            isFocused={true}\\n            theme={getDefaultTheme()}\\n            isFilling={false}\\n            maxColumnWidth={500}\\n            accessibilityHeight={50}\\n            translateX={translateX}\\n            translateY={translateY}\\n            lockColumns={0}\\n            selection={{\\n                current: undefined,\\n                rows: CompactSelection.empty(),\\n                columns: CompactSelection.empty(),\\n            }}\\n            firstColAccessible={true}\\n            groupHeaderHeight={34}\\n            headerHeight={44}\\n            trailingRowType={\\\"none\\\"}\\n            rowHeight={34}\\n            onVisibleRegionChanged={onVisibleRegionChanged}\\n            columns={columns}\\n            getCellContent={getCellContent}\\n            freezeColumns={0}\\n            verticalBorder={() => true}\\n            smoothScrollX={true}\\n            smoothScrollY={true}\\n        />\\n    );\\n}\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Simplenotest\":{\"startLoc\":{\"col\":7,\"line\":43},\"endLoc\":{\"col\":1,\"line\":152},\"startBody\":{\"col\":7,\"line\":43},\"endBody\":{\"col\":1,\"line\":152}}};\n    \nimport * as React from \"react\";\n\nimport { BuilderThemeWrapper } from \"../stories/story-utils\";\nimport GridScroller from \"./scrolling-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport { CompactSelection, GridCell, GridCellKind, Rectangle, Item } from \"../data-grid/data-grid-types\";\nimport { getDefaultTheme } from \"..\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport { CellRenderers } from \"../data-grid/cells\";\n\nconst InnerContainer = styled.div`\n    width: 100%;\n    height: 100px;\n\n    > * {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\nconst getCellRenderer: GetCellRendererCallback = cell => {\n    if (cell.kind === GridCellKind.Custom) return undefined;\n    return CellRenderers[cell.kind] as any;\n};\n\nexport default {parameters: {\"storySource\":{\"source\":\"import * as React from \\\"react\\\";\\n\\nimport { BuilderThemeWrapper } from \\\"../stories/story-utils\\\";\\nimport GridScroller from \\\"./scrolling-data-grid\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport { CompactSelection, GridCell, GridCellKind, Rectangle, Item } from \\\"../data-grid/data-grid-types\\\";\\nimport { getDefaultTheme } from \\\"..\\\";\\nimport type { GetCellRendererCallback } from \\\"../data-grid/cells/cell-types\\\";\\nimport { CellRenderers } from \\\"../data-grid/cells\\\";\\n\\nconst InnerContainer = styled.div`\\n    width: 100%;\\n    height: 100px;\\n\\n    > * {\\n        position: absolute;\\n        width: 100%;\\n        height: 100%;\\n    }\\n`;\\n\\nconst getCellRenderer: GetCellRendererCallback = cell => {\\n    if (cell.kind === GridCellKind.Custom) return undefined;\\n    return CellRenderers[cell.kind] as any;\\n};\\n\\nexport default {\\n    title: \\\"Subcomponents/ScrollingDataGrid\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <div>\\n                <BuilderThemeWrapper width={1500} height={1000}>\\n                    <InnerContainer>\\n                        <Story />\\n                    </InnerContainer>\\n                </BuilderThemeWrapper>\\n            </div>\\n        ),\\n    ],\\n};\\n\\nexport function Simplenotest() {\\n    const [x, setX] = React.useState<number>(0);\\n    const [y, setY] = React.useState<number>(0);\\n    const [translateX, setTx] = React.useState<number | undefined>(0);\\n    const [translateY, setTy] = React.useState<number | undefined>(0);\\n\\n    const onVisibleRegionChanged = React.useCallback((range: Rectangle, tx?: number, ty?: number) => {\\n        setX(range.x);\\n        setY(range.y);\\n        setTx(tx);\\n        setTy(ty);\\n    }, []);\\n\\n    const columns = React.useMemo(() => {\\n        let j = 0;\\n        return [\\\"One\\\", \\\"Two\\\", \\\"Three\\\", \\\"Four\\\", \\\"Five\\\", \\\"Six\\\", \\\"Seven\\\", \\\"Eight\\\", \\\"Nine\\\", \\\"Ten\\\"].map(t => ({\\n            title: t,\\n            width: 122 + (j += 50),\\n        }));\\n    }, []);\\n\\n    const getCellContent = React.useCallback(\\n        ([col, row]: Item): GridCell => ({\\n            kind: GridCellKind.Text,\\n            displayData: `${col},${row} Testing things that are way too long`,\\n            data: `${col},${row} Testing things that are way too long`,\\n            allowOverlay: true,\\n        }),\\n        []\\n    );\\n\\n    return (\\n        <GridScroller\\n            getCellRenderer={getCellRenderer}\\n            onMouseMove={() => undefined}\\n            rows={10_000}\\n            enableGroups={false}\\n            clientSize={[1000, 1000]}\\n            cellXOffset={x}\\n            cellYOffset={y}\\n            drawHeader={undefined}\\n            experimental={undefined}\\n            headerIcons={undefined}\\n            isDraggable={undefined}\\n            onCanvasBlur={() => undefined}\\n            onCanvasFocused={() => undefined}\\n            onCellFocused={() => undefined}\\n            onContextMenu={() => undefined}\\n            onDragEnd={() => undefined}\\n            onDragLeave={() => undefined}\\n            onDragOverCell={() => undefined}\\n            onDragStart={() => undefined}\\n            onDrop={() => undefined}\\n            onItemHovered={() => undefined}\\n            onKeyDown={() => undefined}\\n            onKeyUp={() => undefined}\\n            onMouseDown={() => undefined}\\n            onMouseUp={() => undefined}\\n            canvasRef={undefined}\\n            className={undefined}\\n            disabledRows={undefined}\\n            fillHandle={undefined}\\n            fixedShadowX={undefined}\\n            fixedShadowY={undefined}\\n            getGroupDetails={undefined}\\n            getRowThemeOverride={undefined}\\n            highlightRegions={undefined}\\n            imageWindowLoader={undefined}\\n            onHeaderMenuClick={undefined}\\n            prelightCells={undefined}\\n            drawCustomCell={undefined}\\n            drawFocusRing={undefined}\\n            initialSize={undefined}\\n            overscrollX={undefined}\\n            overscrollY={undefined}\\n            preventDiagonalScrolling={undefined}\\n            rightElement={undefined}\\n            rightElementProps={undefined}\\n            scrollRef={undefined}\\n            showMinimap={undefined}\\n            scrollToEnd={undefined}\\n            minColumnWidth={50}\\n            isFocused={true}\\n            theme={getDefaultTheme()}\\n            isFilling={false}\\n            maxColumnWidth={500}\\n            accessibilityHeight={50}\\n            translateX={translateX}\\n            translateY={translateY}\\n            lockColumns={0}\\n            selection={{\\n                current: undefined,\\n                rows: CompactSelection.empty(),\\n                columns: CompactSelection.empty(),\\n            }}\\n            firstColAccessible={true}\\n            groupHeaderHeight={34}\\n            headerHeight={44}\\n            trailingRowType={\\\"none\\\"}\\n            rowHeight={34}\\n            onVisibleRegionChanged={onVisibleRegionChanged}\\n            columns={columns}\\n            getCellContent={getCellContent}\\n            freezeColumns={0}\\n            verticalBorder={() => true}\\n            smoothScrollX={true}\\n            smoothScrollY={true}\\n        />\\n    );\\n}\\n\",\"locationsMap\":{\"simplenotest\":{\"startLoc\":{\"col\":7,\"line\":43},\"endLoc\":{\"col\":1,\"line\":152},\"startBody\":{\"col\":7,\"line\":43},\"endBody\":{\"col\":1,\"line\":152}}}},},\n    title: \"Subcomponents/ScrollingDataGrid\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <div>\n                <BuilderThemeWrapper width={1500} height={1000}>\n                    <InnerContainer>\n                        <Story />\n                    </InnerContainer>\n                </BuilderThemeWrapper>\n            </div>\n        ),\n    ],\n};\n\nexport const Simplenotest = function Simplenotest() {\n    const [x, setX] = React.useState<number>(0);\n    const [y, setY] = React.useState<number>(0);\n    const [translateX, setTx] = React.useState<number | undefined>(0);\n    const [translateY, setTy] = React.useState<number | undefined>(0);\n\n    const onVisibleRegionChanged = React.useCallback((range: Rectangle, tx?: number, ty?: number) => {\n        setX(range.x);\n        setY(range.y);\n        setTx(tx);\n        setTy(ty);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        let j = 0;\n        return [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\"].map(t => ({\n            title: t,\n            width: 122 + (j += 50),\n        }));\n    }, []);\n\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => ({\n            kind: GridCellKind.Text,\n            displayData: `${col},${row} Testing things that are way too long`,\n            data: `${col},${row} Testing things that are way too long`,\n            allowOverlay: true,\n        }),\n        []\n    );\n\n    return (\n        <GridScroller\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            rows={10_000}\n            enableGroups={false}\n            clientSize={[1000, 1000]}\n            cellXOffset={x}\n            cellYOffset={y}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseUp={() => undefined}\n            canvasRef={undefined}\n            className={undefined}\n            disabledRows={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            initialSize={undefined}\n            overscrollX={undefined}\n            overscrollY={undefined}\n            preventDiagonalScrolling={undefined}\n            rightElement={undefined}\n            rightElementProps={undefined}\n            scrollRef={undefined}\n            showMinimap={undefined}\n            scrollToEnd={undefined}\n            minColumnWidth={50}\n            isFocused={true}\n            theme={getDefaultTheme()}\n            isFilling={false}\n            maxColumnWidth={500}\n            accessibilityHeight={50}\n            translateX={translateX}\n            translateY={translateY}\n            lockColumns={0}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.empty(),\n                columns: CompactSelection.empty(),\n            }}\n            firstColAccessible={true}\n            groupHeaderHeight={34}\n            headerHeight={44}\n            trailingRowType={\"none\"}\n            rowHeight={34}\n            onVisibleRegionChanged={onVisibleRegionChanged}\n            columns={columns}\n            getCellContent={getCellContent}\n            freezeColumns={0}\n            verticalBorder={() => true}\n            smoothScrollX={true}\n            smoothScrollY={true}\n        />\n    );\n};",".i1ua65x0{width:100%;height:100px;}.i1ua65x0 > *{position:absolute;width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5pMXVhNjV4MCJdLCJtYXBwaW5ncyI6IkFBa0J1QkEiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIC8vIEB0cy1ub2NoZWNrXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX1NUT1JZX18gPSBcImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5cXG5pbXBvcnQgeyBCdWlsZGVyVGhlbWVXcmFwcGVyIH0gZnJvbSBcXFwiLi4vc3Rvcmllcy9zdG9yeS11dGlsc1xcXCI7XFxuaW1wb3J0IEdyaWRTY3JvbGxlciBmcm9tIFxcXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXFxcIkBsaW5hcmlhL3JlYWN0XFxcIjtcXG5pbXBvcnQgeyBDb21wYWN0U2VsZWN0aW9uLCBHcmlkQ2VsbCwgR3JpZENlbGxLaW5kLCBSZWN0YW5nbGUsIEl0ZW0gfSBmcm9tIFxcXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBnZXREZWZhdWx0VGhlbWUgfSBmcm9tIFxcXCIuLlxcXCI7XFxuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXFxcIi4uL2RhdGEtZ3JpZC9jZWxscy9jZWxsLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBDZWxsUmVuZGVyZXJzIH0gZnJvbSBcXFwiLi4vZGF0YS1ncmlkL2NlbGxzXFxcIjtcXG5cXG5jb25zdCBJbm5lckNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMHB4O1xcblxcbiAgICA+ICoge1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIH1cXG5gO1xcblxcbmNvbnN0IGdldENlbGxSZW5kZXJlcjogR2V0Q2VsbFJlbmRlcmVyQ2FsbGJhY2sgPSBjZWxsID0+IHtcXG4gICAgaWYgKGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiU3ViY29tcG9uZW50cy9TY3JvbGxpbmdEYXRhR3JpZFxcXCIsXFxuXFxuICAgIGRlY29yYXRvcnM6IFtcXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxcbiAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxNTAwfSBoZWlnaHQ9ezEwMDB9PlxcbiAgICAgICAgICAgICAgICAgICAgPElubmVyQ29udGFpbmVyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxcbiAgICAgICAgICAgICAgICAgICAgPC9Jbm5lckNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgICAgPC9CdWlsZGVyVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmV4cG9ydCBmdW5jdGlvbiBTaW1wbGVub3Rlc3QoKSB7XFxuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XFxuICAgIGNvbnN0IFt5LCBzZXRZXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XFxuICAgIGNvbnN0IFt0cmFuc2xhdGVYLCBzZXRUeF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXIgfCB1bmRlZmluZWQ+KDApO1xcbiAgICBjb25zdCBbdHJhbnNsYXRlWSwgc2V0VHldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcXG5cXG4gICAgY29uc3Qgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChyYW5nZTogUmVjdGFuZ2xlLCB0eD86IG51bWJlciwgdHk/OiBudW1iZXIpID0+IHtcXG4gICAgICAgIHNldFgocmFuZ2UueCk7XFxuICAgICAgICBzZXRZKHJhbmdlLnkpO1xcbiAgICAgICAgc2V0VHgodHgpO1xcbiAgICAgICAgc2V0VHkodHkpO1xcbiAgICB9LCBbXSk7XFxuXFxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcXG4gICAgICAgIGxldCBqID0gMDtcXG4gICAgICAgIHJldHVybiBbXFxcIk9uZVxcXCIsIFxcXCJUd29cXFwiLCBcXFwiVGhyZWVcXFwiLCBcXFwiRm91clxcXCIsIFxcXCJGaXZlXFxcIiwgXFxcIlNpeFxcXCIsIFxcXCJTZXZlblxcXCIsIFxcXCJFaWdodFxcXCIsIFxcXCJOaW5lXFxcIiwgXFxcIlRlblxcXCJdLm1hcCh0ID0+ICh7XFxuICAgICAgICAgICAgdGl0bGU6IHQsXFxuICAgICAgICAgICAgd2lkdGg6IDEyMiArIChqICs9IDUwKSxcXG4gICAgICAgIH0pKTtcXG4gICAgfSwgW10pO1xcblxcbiAgICBjb25zdCBnZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xcbiAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxcbiAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9LCR7cm93fSBUZXN0aW5nIHRoaW5ncyB0aGF0IGFyZSB3YXkgdG9vIGxvbmdgLFxcbiAgICAgICAgICAgIGRhdGE6IGAke2NvbH0sJHtyb3d9IFRlc3RpbmcgdGhpbmdzIHRoYXQgYXJlIHdheSB0b28gbG9uZ2AsXFxuICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgfSksXFxuICAgICAgICBbXVxcbiAgICApO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEdyaWRTY3JvbGxlclxcbiAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17Z2V0Q2VsbFJlbmRlcmVyfVxcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgcm93cz17MTBfMDAwfVxcbiAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17ZmFsc2V9XFxuICAgICAgICAgICAgY2xpZW50U2l6ZT17WzEwMDAsIDEwMDBdfVxcbiAgICAgICAgICAgIGNlbGxYT2Zmc2V0PXt4fVxcbiAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXt5fVxcbiAgICAgICAgICAgIGRyYXdIZWFkZXI9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBleHBlcmltZW50YWw9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBoZWFkZXJJY29ucz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DYW52YXNCbHVyPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DZWxsRm9jdXNlZD17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyYWdFbmQ9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyYWdMZWF2ZT17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyb3A9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkl0ZW1Ib3ZlcmVkPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25LZXlEb3duPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25LZXlVcD17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25Nb3VzZVVwPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgY2FudmFzUmVmPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgY2xhc3NOYW1lPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgZmlsbEhhbmRsZT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGZpeGVkU2hhZG93WD17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGZpeGVkU2hhZG93WT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGdldFJvd1RoZW1lT3ZlcnJpZGU9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgaW1hZ2VXaW5kb3dMb2FkZXI9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkhlYWRlck1lbnVDbGljaz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBkcmF3Q3VzdG9tQ2VsbD17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGRyYXdGb2N1c1Jpbmc9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG92ZXJzY3JvbGxYPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgb3ZlcnNjcm9sbFk9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICByaWdodEVsZW1lbnQ9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHNjcm9sbFJlZj17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHNob3dNaW5pbWFwPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgc2Nyb2xsVG9FbmQ9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17NTB9XFxuICAgICAgICAgICAgaXNGb2N1c2VkPXt0cnVlfVxcbiAgICAgICAgICAgIHRoZW1lPXtnZXREZWZhdWx0VGhlbWUoKX1cXG4gICAgICAgICAgICBpc0ZpbGxpbmc9e2ZhbHNlfVxcbiAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXs1MDB9XFxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUhlaWdodD17NTB9XFxuICAgICAgICAgICAgdHJhbnNsYXRlWD17dHJhbnNsYXRlWH1cXG4gICAgICAgICAgICB0cmFuc2xhdGVZPXt0cmFuc2xhdGVZfVxcbiAgICAgICAgICAgIGxvY2tDb2x1bW5zPXswfVxcbiAgICAgICAgICAgIHNlbGVjdGlvbj17e1xcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcXG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxcbiAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgZmlyc3RDb2xBY2Nlc3NpYmxlPXt0cnVlfVxcbiAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXszNH1cXG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQ9ezQ0fVxcbiAgICAgICAgICAgIHRyYWlsaW5nUm93VHlwZT17XFxcIm5vbmVcXFwifVxcbiAgICAgICAgICAgIHJvd0hlaWdodD17MzR9XFxuICAgICAgICAgICAgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZD17b25WaXNpYmxlUmVnaW9uQ2hhbmdlZH1cXG4gICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxcbiAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICBmcmVlemVDb2x1bW5zPXswfVxcbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXsoKSA9PiB0cnVlfVxcbiAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3RydWV9XFxuICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17dHJ1ZX1cXG4gICAgICAgIC8+XFxuICAgICk7XFxufVxcblwiO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgX19MT0NBVElPTlNfTUFQX18gPSB7XCJTaW1wbGVub3Rlc3RcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjcsXCJsaW5lXCI6NDN9LFwiZW5kTG9jXCI6e1wiY29sXCI6MSxcImxpbmVcIjoxNTJ9LFwic3RhcnRCb2R5XCI6e1wiY29sXCI6NyxcImxpbmVcIjo0M30sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjoxNTJ9fX07XG4gICAgXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgR3JpZFNjcm9sbGVyIGZyb20gXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgQ29tcGFjdFNlbGVjdGlvbiwgR3JpZENlbGwsIEdyaWRDZWxsS2luZCwgUmVjdGFuZ2xlLCBJdGVtIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRUaGVtZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHMvY2VsbC10eXBlc1wiO1xuaW1wb3J0IHsgQ2VsbFJlbmRlcmVycyB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHNcIjtcblxuY29uc3QgSW5uZXJDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwcHg7XG5cbiAgICA+ICoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuYDtcblxuY29uc3QgZ2V0Q2VsbFJlbmRlcmVyOiBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayA9IGNlbGwgPT4ge1xuICAgIGlmIChjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7cGFyYW1ldGVyczoge1wic3RvcnlTb3VyY2VcIjp7XCJzb3VyY2VcIjpcImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5cXG5pbXBvcnQgeyBCdWlsZGVyVGhlbWVXcmFwcGVyIH0gZnJvbSBcXFwiLi4vc3Rvcmllcy9zdG9yeS11dGlsc1xcXCI7XFxuaW1wb3J0IEdyaWRTY3JvbGxlciBmcm9tIFxcXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXFxcIkBsaW5hcmlhL3JlYWN0XFxcIjtcXG5pbXBvcnQgeyBDb21wYWN0U2VsZWN0aW9uLCBHcmlkQ2VsbCwgR3JpZENlbGxLaW5kLCBSZWN0YW5nbGUsIEl0ZW0gfSBmcm9tIFxcXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBnZXREZWZhdWx0VGhlbWUgfSBmcm9tIFxcXCIuLlxcXCI7XFxuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXFxcIi4uL2RhdGEtZ3JpZC9jZWxscy9jZWxsLXR5cGVzXFxcIjtcXG5pbXBvcnQgeyBDZWxsUmVuZGVyZXJzIH0gZnJvbSBcXFwiLi4vZGF0YS1ncmlkL2NlbGxzXFxcIjtcXG5cXG5jb25zdCBJbm5lckNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMHB4O1xcblxcbiAgICA+ICoge1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIH1cXG5gO1xcblxcbmNvbnN0IGdldENlbGxSZW5kZXJlcjogR2V0Q2VsbFJlbmRlcmVyQ2FsbGJhY2sgPSBjZWxsID0+IHtcXG4gICAgaWYgKGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiU3ViY29tcG9uZW50cy9TY3JvbGxpbmdEYXRhR3JpZFxcXCIsXFxuXFxuICAgIGRlY29yYXRvcnM6IFtcXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxcbiAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxNTAwfSBoZWlnaHQ9ezEwMDB9PlxcbiAgICAgICAgICAgICAgICAgICAgPElubmVyQ29udGFpbmVyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxcbiAgICAgICAgICAgICAgICAgICAgPC9Jbm5lckNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgICAgPC9CdWlsZGVyVGhlbWVXcmFwcGVyPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgKSxcXG4gICAgXSxcXG59O1xcblxcbmV4cG9ydCBmdW5jdGlvbiBTaW1wbGVub3Rlc3QoKSB7XFxuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XFxuICAgIGNvbnN0IFt5LCBzZXRZXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XFxuICAgIGNvbnN0IFt0cmFuc2xhdGVYLCBzZXRUeF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXIgfCB1bmRlZmluZWQ+KDApO1xcbiAgICBjb25zdCBbdHJhbnNsYXRlWSwgc2V0VHldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcXG5cXG4gICAgY29uc3Qgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChyYW5nZTogUmVjdGFuZ2xlLCB0eD86IG51bWJlciwgdHk/OiBudW1iZXIpID0+IHtcXG4gICAgICAgIHNldFgocmFuZ2UueCk7XFxuICAgICAgICBzZXRZKHJhbmdlLnkpO1xcbiAgICAgICAgc2V0VHgodHgpO1xcbiAgICAgICAgc2V0VHkodHkpO1xcbiAgICB9LCBbXSk7XFxuXFxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcXG4gICAgICAgIGxldCBqID0gMDtcXG4gICAgICAgIHJldHVybiBbXFxcIk9uZVxcXCIsIFxcXCJUd29cXFwiLCBcXFwiVGhyZWVcXFwiLCBcXFwiRm91clxcXCIsIFxcXCJGaXZlXFxcIiwgXFxcIlNpeFxcXCIsIFxcXCJTZXZlblxcXCIsIFxcXCJFaWdodFxcXCIsIFxcXCJOaW5lXFxcIiwgXFxcIlRlblxcXCJdLm1hcCh0ID0+ICh7XFxuICAgICAgICAgICAgdGl0bGU6IHQsXFxuICAgICAgICAgICAgd2lkdGg6IDEyMiArIChqICs9IDUwKSxcXG4gICAgICAgIH0pKTtcXG4gICAgfSwgW10pO1xcblxcbiAgICBjb25zdCBnZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xcbiAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxcbiAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9LCR7cm93fSBUZXN0aW5nIHRoaW5ncyB0aGF0IGFyZSB3YXkgdG9vIGxvbmdgLFxcbiAgICAgICAgICAgIGRhdGE6IGAke2NvbH0sJHtyb3d9IFRlc3RpbmcgdGhpbmdzIHRoYXQgYXJlIHdheSB0b28gbG9uZ2AsXFxuICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxcbiAgICAgICAgfSksXFxuICAgICAgICBbXVxcbiAgICApO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEdyaWRTY3JvbGxlclxcbiAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17Z2V0Q2VsbFJlbmRlcmVyfVxcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgcm93cz17MTBfMDAwfVxcbiAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17ZmFsc2V9XFxuICAgICAgICAgICAgY2xpZW50U2l6ZT17WzEwMDAsIDEwMDBdfVxcbiAgICAgICAgICAgIGNlbGxYT2Zmc2V0PXt4fVxcbiAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXt5fVxcbiAgICAgICAgICAgIGRyYXdIZWFkZXI9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBleHBlcmltZW50YWw9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBoZWFkZXJJY29ucz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DYW52YXNCbHVyPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25DZWxsRm9jdXNlZD17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyYWdFbmQ9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyYWdMZWF2ZT17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkRyb3A9eygpID0+IHVuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkl0ZW1Ib3ZlcmVkPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25LZXlEb3duPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25LZXlVcD17KCkgPT4gdW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgb25Nb3VzZVVwPXsoKSA9PiB1bmRlZmluZWR9XFxuICAgICAgICAgICAgY2FudmFzUmVmPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgY2xhc3NOYW1lPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgZmlsbEhhbmRsZT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGZpeGVkU2hhZG93WD17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGZpeGVkU2hhZG93WT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGdldFJvd1RoZW1lT3ZlcnJpZGU9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgaW1hZ2VXaW5kb3dMb2FkZXI9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBvbkhlYWRlck1lbnVDbGljaz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBkcmF3Q3VzdG9tQ2VsbD17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIGRyYXdGb2N1c1Jpbmc9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIG92ZXJzY3JvbGxYPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgb3ZlcnNjcm9sbFk9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICByaWdodEVsZW1lbnQ9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHNjcm9sbFJlZj17dW5kZWZpbmVkfVxcbiAgICAgICAgICAgIHNob3dNaW5pbWFwPXt1bmRlZmluZWR9XFxuICAgICAgICAgICAgc2Nyb2xsVG9FbmQ9e3VuZGVmaW5lZH1cXG4gICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17NTB9XFxuICAgICAgICAgICAgaXNGb2N1c2VkPXt0cnVlfVxcbiAgICAgICAgICAgIHRoZW1lPXtnZXREZWZhdWx0VGhlbWUoKX1cXG4gICAgICAgICAgICBpc0ZpbGxpbmc9e2ZhbHNlfVxcbiAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXs1MDB9XFxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUhlaWdodD17NTB9XFxuICAgICAgICAgICAgdHJhbnNsYXRlWD17dHJhbnNsYXRlWH1cXG4gICAgICAgICAgICB0cmFuc2xhdGVZPXt0cmFuc2xhdGVZfVxcbiAgICAgICAgICAgIGxvY2tDb2x1bW5zPXswfVxcbiAgICAgICAgICAgIHNlbGVjdGlvbj17e1xcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcXG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxcbiAgICAgICAgICAgIH19XFxuICAgICAgICAgICAgZmlyc3RDb2xBY2Nlc3NpYmxlPXt0cnVlfVxcbiAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXszNH1cXG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQ9ezQ0fVxcbiAgICAgICAgICAgIHRyYWlsaW5nUm93VHlwZT17XFxcIm5vbmVcXFwifVxcbiAgICAgICAgICAgIHJvd0hlaWdodD17MzR9XFxuICAgICAgICAgICAgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZD17b25WaXNpYmxlUmVnaW9uQ2hhbmdlZH1cXG4gICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxcbiAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICBmcmVlemVDb2x1bW5zPXswfVxcbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXsoKSA9PiB0cnVlfVxcbiAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3RydWV9XFxuICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17dHJ1ZX1cXG4gICAgICAgIC8+XFxuICAgICk7XFxufVxcblwiLFwibG9jYXRpb25zTWFwXCI6e1wic2ltcGxlbm90ZXN0XCI6e1wic3RhcnRMb2NcIjp7XCJjb2xcIjo3LFwibGluZVwiOjQzfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6MTUyfSxcInN0YXJ0Qm9keVwiOntcImNvbFwiOjcsXCJsaW5lXCI6NDN9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6MTUyfX19fSx9LFxuICAgIHRpdGxlOiBcIlN1YmNvbXBvbmVudHMvU2Nyb2xsaW5nRGF0YUdyaWRcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxNTAwfSBoZWlnaHQ9ezEwMDB9PlxuICAgICAgICAgICAgICAgICAgICA8SW5uZXJDb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3RvcnkgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9Jbm5lckNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L0J1aWxkZXJUaGVtZVdyYXBwZXI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSxcbiAgICBdLFxufTtcblxuZXhwb3J0IGNvbnN0IFNpbXBsZW5vdGVzdCA9IGZ1bmN0aW9uIFNpbXBsZW5vdGVzdCgpIHtcbiAgICBjb25zdCBbeCwgc2V0WF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KDApO1xuICAgIGNvbnN0IFt5LCBzZXRZXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XG4gICAgY29uc3QgW3RyYW5zbGF0ZVgsIHNldFR4XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlciB8IHVuZGVmaW5lZD4oMCk7XG4gICAgY29uc3QgW3RyYW5zbGF0ZVksIHNldFR5XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlciB8IHVuZGVmaW5lZD4oMCk7XG5cbiAgICBjb25zdCBvblZpc2libGVSZWdpb25DaGFuZ2VkID0gUmVhY3QudXNlQ2FsbGJhY2soKHJhbmdlOiBSZWN0YW5nbGUsIHR4PzogbnVtYmVyLCB0eT86IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRYKHJhbmdlLngpO1xuICAgICAgICBzZXRZKHJhbmdlLnkpO1xuICAgICAgICBzZXRUeCh0eCk7XG4gICAgICAgIHNldFR5KHR5KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2x1bW5zID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgcmV0dXJuIFtcIk9uZVwiLCBcIlR3b1wiLCBcIlRocmVlXCIsIFwiRm91clwiLCBcIkZpdmVcIiwgXCJTaXhcIiwgXCJTZXZlblwiLCBcIkVpZ2h0XCIsIFwiTmluZVwiLCBcIlRlblwiXS5tYXAodCA9PiAoe1xuICAgICAgICAgICAgdGl0bGU6IHQsXG4gICAgICAgICAgICB3aWR0aDogMTIyICsgKGogKz0gNTApLFxuICAgICAgICB9KSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xuICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7Y29sfSwke3Jvd30gVGVzdGluZyB0aGluZ3MgdGhhdCBhcmUgd2F5IHRvbyBsb25nYCxcbiAgICAgICAgICAgIGRhdGE6IGAke2NvbH0sJHtyb3d9IFRlc3RpbmcgdGhpbmdzIHRoYXQgYXJlIHdheSB0b28gbG9uZ2AsXG4gICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICBbXVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8R3JpZFNjcm9sbGVyXG4gICAgICAgICAgICBnZXRDZWxsUmVuZGVyZXI9e2dldENlbGxSZW5kZXJlcn1cbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICBlbmFibGVHcm91cHM9e2ZhbHNlfVxuICAgICAgICAgICAgY2xpZW50U2l6ZT17WzEwMDAsIDEwMDBdfVxuICAgICAgICAgICAgY2VsbFhPZmZzZXQ9e3h9XG4gICAgICAgICAgICBjZWxsWU9mZnNldD17eX1cbiAgICAgICAgICAgIGRyYXdIZWFkZXI9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaGVhZGVySWNvbnM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNhbnZhc0JsdXI9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uQ2FudmFzRm9jdXNlZD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25DZWxsRm9jdXNlZD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Db250ZXh0TWVudT17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25EcmFnRW5kPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdMZWF2ZT17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25EcmFnT3ZlckNlbGw9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyb3A9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uS2V5RG93bj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25LZXlVcD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Nb3VzZURvd249eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uTW91c2VVcD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgY2FudmFzUmVmPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGRpc2FibGVkUm93cz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZmlsbEhhbmRsZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZml4ZWRTaGFkb3dYPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaXhlZFNoYWRvd1k9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaW1hZ2VXaW5kb3dMb2FkZXI9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uSGVhZGVyTWVudUNsaWNrPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBwcmVsaWdodENlbGxzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBkcmF3Q3VzdG9tQ2VsbD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZHJhd0ZvY3VzUmluZz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaW5pdGlhbFNpemU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG92ZXJzY3JvbGxYPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBvdmVyc2Nyb2xsWT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nPXt1bmRlZmluZWR9XG4gICAgICAgICAgICByaWdodEVsZW1lbnQ9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudFByb3BzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBzY3JvbGxSZWY9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNob3dNaW5pbWFwPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBzY3JvbGxUb0VuZD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgbWluQ29sdW1uV2lkdGg9ezUwfVxuICAgICAgICAgICAgaXNGb2N1c2VkPXt0cnVlfVxuICAgICAgICAgICAgdGhlbWU9e2dldERlZmF1bHRUaGVtZSgpfVxuICAgICAgICAgICAgaXNGaWxsaW5nPXtmYWxzZX1cbiAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXs1MDB9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5SGVpZ2h0PXs1MH1cbiAgICAgICAgICAgIHRyYW5zbGF0ZVg9e3RyYW5zbGF0ZVh9XG4gICAgICAgICAgICB0cmFuc2xhdGVZPXt0cmFuc2xhdGVZfVxuICAgICAgICAgICAgbG9ja0NvbHVtbnM9ezB9XG4gICAgICAgICAgICBzZWxlY3Rpb249e3tcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcm93czogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBmaXJzdENvbEFjY2Vzc2libGU9e3RydWV9XG4gICAgICAgICAgICBncm91cEhlYWRlckhlaWdodD17MzR9XG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQ9ezQ0fVxuICAgICAgICAgICAgdHJhaWxpbmdSb3dUeXBlPXtcIm5vbmVcIn1cbiAgICAgICAgICAgIHJvd0hlaWdodD17MzR9XG4gICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPXtvblZpc2libGVSZWdpb25DaGFuZ2VkfVxuICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezB9XG4gICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17KCkgPT4gdHJ1ZX1cbiAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3RydWV9XG4gICAgICAgICAgICBzbW9vdGhTY3JvbGxZPXt0cnVlfVxuICAgICAgICAvPlxuICAgICk7XG59OyJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".m3brspx{position:absolute;right:44px;bottom:44px;background-color:var(--gdg-bg-cell);background:linear-gradient(var(--gdg-bg-cell),var(--gdg-bg-cell-medium));border-radius:4px;z-index:1;box-shadow:0 0 0 1px var(--gdg-border-color),0 2px 5px rgba(0,0,0,0.08);overflow:hidden;}.m3brspx .header{position:absolute;left:0;top:0;width:100%;height:4px;background-color:var(--gdg-bg-header);box-shadow:0 0 0 1px var(--gdg-border-color);}.m3brspx .locationMarker{position:absolute;border:1px solid var(--gdg-accent-color);background-color:var(--gdg-accent-light);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLnRzeCJdLCJuYW1lcyI6WyIubTNicnNweCJdLCJtYXBwaW5ncyI6IkFBb0ZxQkEiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCBEYXRhR3JpZERuZCwgeyBEYXRhR3JpZERuZFByb3BzIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC1kbmQvZGF0YS1ncmlkLWRuZFwiO1xuaW1wb3J0IHR5cGUgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxlciB9IGZyb20gXCIuL2luZmluaXRlLXNjcm9sbGVyXCI7XG5pbXBvcnQgY2xhbXAgZnJvbSBcImxvZGFzaC9jbGFtcC5qc1wiO1xuXG50eXBlIFByb3BzID0gT21pdDxEYXRhR3JpZERuZFByb3BzLCBcIndpZHRoXCIgfCBcImhlaWdodFwiIHwgXCJldmVudFRhcmdldFJlZlwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxpbmdEYXRhR3JpZFByb3BzIGV4dGVuZHMgUHJvcHMge1xuICAgIHJlYWRvbmx5IGNsYXNzTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ6XG4gICAgICAgIHwgKChcbiAgICAgICAgICAgICAgcmFuZ2U6IFJlY3RhbmdsZSxcbiAgICAgICAgICAgICAgY2xpZW50V2lkdGg6IG51bWJlcixcbiAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBudW1iZXIsXG4gICAgICAgICAgICAgIHJpZ2h0RWxXaWR0aDogbnVtYmVyLFxuICAgICAgICAgICAgICB0eDogbnVtYmVyLFxuICAgICAgICAgICAgICB0eTogbnVtYmVyXG4gICAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBDYXVzZXMgdGhlIGdyaWQgdG8gc2Nyb2xsIHRvIHRoZSBlbmQgd2hlbiBmbGlwcGVkIHRvIHRydWVcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIERhdGFFZGl0b3JSZWYuc2Nyb2xsVG99IGluc3RlYWRcbiAgICAgKiBAZ3JvdXAgRGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNjcm9sbFRvRW5kOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IHNjcm9sbFJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxIVE1MRGl2RWxlbWVudCB8IG51bGw+IHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG92ZXJzY3JvbGwgcHJvcGVydGllcyBhcmUgdXNlZCB0byBhbGxvdyB0aGUgZ3JpZCB0byBzY3JvbGwgcGFzdCB0aGUgbG9naWNhbCBlbmQgb2YgdGhlIGNvbnRlbnQgYnkgYSBmaXhlZFxuICAgICAqIG51bWJlciBvZiBwaXhlbHMuIFRoaXMgaXMgdXNlZnVsIHBhcnRpY3VsYXJseSBvbiB0aGUgWCBheGlzIGlmIHlvdSBhbGxvdyBmb3IgcmVzaXppbmcgY29sdW1ucyBhcyBpdCBjYW4gbWFrZVxuICAgICAqIHJlc2l6aW5nIHRoZSBmaW5hbCBjb2x1bW4gc2lnbmlmaWNhbnRseSBlYXNpZXIuXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBvdmVyc2Nyb2xsWDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIC8qKiB7QGluaGVyaXREb2Mgb3ZlcnNjcm9sbFh9XG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgb3ZlcnNjcm9sbFk6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBpbml0aWFsIHNpemUgZm9yIHRoZSBncmlkIHdoaWNoIGNhbiBwcmV2ZW50IGEgZmxpY2tlciBvbiBsb2FkIGlmIHRoZSBpbml0aWFsIHNpemUgaXMga25vd24gcHJpb3IgdG9cbiAgICAgKiBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBpbml0aWFsU2l6ZTogcmVhZG9ubHkgW3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXSB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IGFueSBkaWFnb25hbCBzY3JvbGxpbmcuXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogSWYgYHJpZ2h0RWxlbWVudFByb3BzLnN0aWNreWAgaXMgc2V0IHRvIHRydWUgdGhlIHJpZ2h0IGVsZW1lbnQgd2lsbCBiZSB2aXNpYmxlIGF0IGFsbCB0aW1lcywgb3RoZXJ3aXNlIHRoZSB1c2VyXG4gICAgICogd2lsbCBuZWVkIHRvIHNjcm9sbCB0byB0aGUgZW5kIHRvIHJldmVhbCBpdC5cbiAgICAgKlxuICAgICAqIElmIGByaWdodEVsZW1lbnRQcm9wcy5maWxsYCBpcyBzZXQsIHRoZSByaWdodCBlbGVtZW50cyBjb250YWluZXIgd2lsbCBmaWxsIHRvIGNvbnN1bWUgYWxsIHJlbWFpbmluZyBzcGFjZSAoaWZcbiAgICAgKiBhbnkpIGF0IHRoZSBlbmQgb2YgdGhlIGdyaWQuIFRoaXMgZG9lcyBub3QgcGxheSBuaWNlIHdpdGggZ3Jvd2luZyBjb2x1bW5zLlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgcmlnaHRFbGVtZW50UHJvcHM6XG4gICAgICAgIHwge1xuICAgICAgICAgICAgICByZWFkb25seSBzdGlja3k/OiBib29sZWFuO1xuICAgICAgICAgICAgICByZWFkb25seSBmaWxsPzogYm9vbGVhbjtcbiAgICAgICAgICB9XG4gICAgICAgIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFRoZSByaWdodCBlbGVtZW50IGlzIGEgRE9NIG5vZGUgd2hpY2ggY2FuIGJlIGluc2VydGVkIGF0IHRoZSBlbmQgb2YgdGhlIGhvcml6b250YWwgc2Nyb2xsIHJlZ2lvbi4gVGhpcyBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGNyZWF0ZSBhIHJpZ2h0IGhhbmRsZSBwYW5lbCwgbWFrZSBhIGJpZyBhZGQgYnV0dG9uLCBvciBkaXNwbGF5IG1lc3NhZ2VzLlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHJpZ2h0RWxlbWVudDogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgdGhlIGludGVyYWN0aXZlIG1pbmltYXAuXG4gICAgICogQGRlZmF1bHRWYWx1ZSBmYWxzZVxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNob3dNaW5pbWFwOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IGNsaWVudFNpemU6IHJlYWRvbmx5IFtudW1iZXIsIG51bWJlcl07XG59XG5cbmNvbnN0IE1pbmltYXBTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiA0NHB4O1xuICAgIGJvdHRvbTogNDRweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHZhcigtLWdkZy1iZy1jZWxsKSwgdmFyKC0tZ2RnLWJnLWNlbGwtbWVkaXVtKSk7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIHotaW5kZXg6IDE7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1ib3JkZXItY29sb3IpLCAwIDJweCA1cHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcblxuICAgIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgICAuaGVhZGVyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDRweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWhlYWRlcik7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKTtcbiAgICB9XG5cbiAgICAubG9jYXRpb25NYXJrZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtbGlnaHQpO1xuICAgIH1cbmA7XG5cbmNvbnN0IEdyaWRTY3JvbGxlcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8U2Nyb2xsaW5nRGF0YUdyaWRQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGNvbHVtbnMsXG4gICAgICAgIHJvd3MsXG4gICAgICAgIHJvd0hlaWdodCxcbiAgICAgICAgaGVhZGVySGVpZ2h0LFxuICAgICAgICBncm91cEhlYWRlckhlaWdodCxcbiAgICAgICAgZW5hYmxlR3JvdXBzLFxuICAgICAgICBmcmVlemVDb2x1bW5zLFxuICAgICAgICBleHBlcmltZW50YWwsXG4gICAgICAgIGNsaWVudFNpemUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCxcbiAgICAgICAgc2Nyb2xsVG9FbmQsXG4gICAgICAgIHNjcm9sbFJlZixcbiAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLFxuICAgICAgICByaWdodEVsZW1lbnQsXG4gICAgICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgICAgICBvdmVyc2Nyb2xsWCxcbiAgICAgICAgb3ZlcnNjcm9sbFksXG4gICAgICAgIHNob3dNaW5pbWFwID0gZmFsc2UsXG4gICAgICAgIGluaXRpYWxTaXplLFxuICAgICAgICBzbW9vdGhTY3JvbGxYID0gZmFsc2UsXG4gICAgICAgIHNtb290aFNjcm9sbFkgPSBmYWxzZSxcbiAgICAgICAgaXNEcmFnZ2FibGUsXG4gICAgfSA9IHA7XG4gICAgY29uc3QgeyBwYWRkaW5nUmlnaHQsIHBhZGRpbmdCb3R0b20gfSA9IGV4cGVyaW1lbnRhbCA/PyB7fTtcblxuICAgIGNvbnN0IFtjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0XSA9IGNsaWVudFNpemU7XG4gICAgY29uc3QgbGFzdCA9IFJlYWN0LnVzZVJlZjxSZWN0YW5nbGUgfCB1bmRlZmluZWQ+KCk7XG4gICAgY29uc3QgbGFzdFggPSBSZWFjdC51c2VSZWY8bnVtYmVyIHwgdW5kZWZpbmVkPigpO1xuICAgIGNvbnN0IGxhc3RZID0gUmVhY3QudXNlUmVmPG51bWJlciB8IHVuZGVmaW5lZD4oKTtcbiAgICBjb25zdCBsYXN0U2l6ZSA9IFJlYWN0LnVzZVJlZjxyZWFkb25seSBbbnVtYmVyLCBudW1iZXJdIHwgdW5kZWZpbmVkPigpO1xuXG4gICAgY29uc3Qgd2lkdGggPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLm1heCgwLCBvdmVyc2Nyb2xsWCA/PyAwKTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbHVtbnMpIHtcbiAgICAgICAgICAgIHIgKz0gYy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9LCBbY29sdW1ucywgb3ZlcnNjcm9sbFhdKTtcblxuICAgIGxldCBoZWlnaHQgPSBlbmFibGVHcm91cHMgPyBoZWFkZXJIZWlnaHQgKyBncm91cEhlYWRlckhlaWdodCA6IGhlYWRlckhlaWdodDtcbiAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBoZWlnaHQgKz0gcm93cyAqIHJvd0hlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHJvd0hlaWdodChyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3ZlcnNjcm9sbFkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWlnaHQgKz0gb3ZlcnNjcm9sbFk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdEFyZ3MgPSBSZWFjdC51c2VSZWY8UmVjdGFuZ2xlICYgeyBwYWRkaW5nUmlnaHQ6IG51bWJlciB9PigpO1xuXG4gICAgY29uc3QgcHJvY2Vzc0FyZ3MgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChsYXN0QXJncy5jdXJyZW50ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgYXJncyA9IHsgLi4ubGFzdEFyZ3MuY3VycmVudCB9O1xuXG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHR4ID0gYXJncy54IDwgMCA/IC1hcmdzLnggOiAwO1xuICAgICAgICBsZXQgY2VsbFJpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGNlbGxYID0gMDtcblxuICAgICAgICBhcmdzLnggPSBhcmdzLnggPCAwID8gMCA6IGFyZ3MueDtcblxuICAgICAgICBsZXQgc3RpY2t5Q29sV2lkdGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyZWV6ZUNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgc3RpY2t5Q29sV2lkdGggKz0gY29sdW1uc1tpXS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb25zdCBjeCA9IHggLSBzdGlja3lDb2xXaWR0aDtcbiAgICAgICAgICAgIGlmIChhcmdzLnggPj0gY3ggKyBjLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGNlbGxYKys7XG4gICAgICAgICAgICAgICAgY2VsbFJpZ2h0Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChzbW9vdGhTY3JvbGxYKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4ICs9IGN4IC0gYXJncy54O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxYKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnggKyBhcmdzLndpZHRoID4gY3gpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGMud2lkdGg7XG4gICAgICAgICAgICAgICAgY2VsbFJpZ2h0Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHR5ID0gMDtcbiAgICAgICAgbGV0IGNlbGxZID0gMDtcbiAgICAgICAgbGV0IGNlbGxCb3R0b20gPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHNtb290aFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICBjZWxsWSA9IE1hdGguZmxvb3IoYXJncy55IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0eSA9IGNlbGxZICogcm93SGVpZ2h0IC0gYXJncy55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxsWSA9IE1hdGguY2VpbChhcmdzLnkgLyByb3dIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbEJvdHRvbSA9IE1hdGguY2VpbChhcmdzLmhlaWdodCAvIHJvd0hlaWdodCkgKyBjZWxsWTtcbiAgICAgICAgICAgIGlmICh0eSA8IDApIGNlbGxCb3R0b20rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmggPSByb3dIZWlnaHQocm93KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjeSA9IHkgKyAoc21vb3RoU2Nyb2xsWSA/IDAgOiByaCAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLnkgPj0geSArIHJoKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gcmg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxZKys7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueSA+IGN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gcmg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbW9vdGhTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eSArPSBjeSAtIGFyZ3MueTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxZKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2VsbEJvdHRvbSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy55ICsgYXJncy5oZWlnaHQgPiByaCAvIDIgKyB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gcmg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWN0OiBSZWN0YW5nbGUgPSB7XG4gICAgICAgICAgICB4OiBjZWxsWCxcbiAgICAgICAgICAgIHk6IGNlbGxZLFxuICAgICAgICAgICAgd2lkdGg6IGNlbGxSaWdodCAtIGNlbGxYLFxuICAgICAgICAgICAgaGVpZ2h0OiBjZWxsQm90dG9tIC0gY2VsbFksXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb2xkUmVjdCA9IGxhc3QuY3VycmVudDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBvbGRSZWN0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG9sZFJlY3QueSAhPT0gcmVjdC55IHx8XG4gICAgICAgICAgICBvbGRSZWN0LnggIT09IHJlY3QueCB8fFxuICAgICAgICAgICAgb2xkUmVjdC5oZWlnaHQgIT09IHJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICBvbGRSZWN0LndpZHRoICE9PSByZWN0LndpZHRoIHx8XG4gICAgICAgICAgICBsYXN0WC5jdXJyZW50ICE9PSB0eCB8fFxuICAgICAgICAgICAgbGFzdFkuY3VycmVudCAhPT0gdHkgfHxcbiAgICAgICAgICAgIGFyZ3Mud2lkdGggIT09IGxhc3RTaXplLmN1cnJlbnQ/LlswXSB8fFxuICAgICAgICAgICAgYXJncy5oZWlnaHQgIT09IGxhc3RTaXplLmN1cnJlbnQ/LlsxXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ/LihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNlbGxYLFxuICAgICAgICAgICAgICAgICAgICB5OiBjZWxsWSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNlbGxSaWdodCAtIGNlbGxYLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNlbGxCb3R0b20gLSBjZWxsWSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZ3Mud2lkdGgsXG4gICAgICAgICAgICAgICAgYXJncy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgYXJncy5wYWRkaW5nUmlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICB0eCxcbiAgICAgICAgICAgICAgICB0eVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxhc3QuY3VycmVudCA9IHJlY3Q7XG4gICAgICAgICAgICBsYXN0WC5jdXJyZW50ID0gdHg7XG4gICAgICAgICAgICBsYXN0WS5jdXJyZW50ID0gdHk7XG4gICAgICAgICAgICBsYXN0U2l6ZS5jdXJyZW50ID0gW2FyZ3Mud2lkdGgsIGFyZ3MuaGVpZ2h0XTtcbiAgICAgICAgfVxuICAgIH0sIFtjb2x1bW5zLCByb3dIZWlnaHQsIHJvd3MsIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQsIGZyZWV6ZUNvbHVtbnMsIHNtb290aFNjcm9sbFgsIHNtb290aFNjcm9sbFldKTtcblxuICAgIGNvbnN0IG9uU2Nyb2xsVXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChhcmdzOiBSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0pID0+IHtcbiAgICAgICAgICAgIGxhc3RBcmdzLmN1cnJlbnQgPSBhcmdzO1xuICAgICAgICAgICAgcHJvY2Vzc0FyZ3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgW3Byb2Nlc3NBcmdzXVxuICAgICk7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwcm9jZXNzQXJncygpO1xuICAgIH0sIFtwcm9jZXNzQXJnc10pO1xuXG4gICAgY29uc3Qgc2Nyb2xsZXIgPSBzY3JvbGxSZWY/LmN1cnJlbnQgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGFzcGVjdCA9IGNsYW1wKHdpZHRoIC8gaGVpZ2h0LCAyIC8gMywgMS41KTtcbiAgICBjb25zdCBtYXhTaXplID0gMjAwO1xuICAgIGNvbnN0IHcgPSBhc3BlY3QgPiAxID8gbWF4U2l6ZSA6IE1hdGguY2VpbChtYXhTaXplICogYXNwZWN0KTtcbiAgICBjb25zdCBoID0gYXNwZWN0ID4gMSA/IE1hdGguY2VpbChtYXhTaXplIC8gYXNwZWN0KSA6IG1heFNpemU7XG4gICAgY29uc3QgaFJhdGlvID0gdyAvIHdpZHRoO1xuICAgIGNvbnN0IHZSYXRpbyA9IGggLyBoZWlnaHQ7XG4gICAgY29uc3QgdldpZHRoID0gTWF0aC5taW4oY2xpZW50V2lkdGggKiBNYXRoLm1heChoUmF0aW8sIDAuMDEpLCB3KTtcbiAgICBjb25zdCB2SGVpZ2h0ID0gTWF0aC5taW4oY2xpZW50SGVpZ2h0ICogTWF0aC5tYXgodlJhdGlvLCAwLjAxKSwgaCk7XG4gICAgY29uc3QgbGVmdCA9ICgoc2Nyb2xsZXI/LnNjcm9sbExlZnQgPz8gMCkgLyAod2lkdGggLSBjbGllbnRXaWR0aCkpICogKHcgLSB2V2lkdGgpO1xuICAgIGNvbnN0IHRvcCA9ICgoc2Nyb2xsZXI/LnNjcm9sbFRvcCA/PyAwKSAvIChoZWlnaHQgLSBjbGllbnRIZWlnaHQpKSAqIChoIC0gdkhlaWdodCk7XG5cbiAgICBjb25zdCBtaW5pbWFwOiBSZWFjdC5SZWFjdE5vZGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaG93TWluaW1hcCB8fCB2V2lkdGggPT09IDAgfHwgdkhlaWdodCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICBjb25zdCBoYW5kbGVNb3VzZSA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzID0gZS5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IGUuY2xpZW50WCAtIGJvdW5kcy54IC0gdldpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBlLmNsaWVudFkgLSBib3VuZHMueSAtIHZIZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdTY3JvbGxMZWZ0ID0gKHdpZHRoIC0gc2Nyb2xsZXIuY2xpZW50V2lkdGgpICogKHggLyAodyAtIHZXaWR0aCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsVG9wID0gKGhlaWdodCAtIHNjcm9sbGVyLmNsaWVudEhlaWdodCkgKiAoeSAvIChoIC0gdkhlaWdodCkpO1xuXG4gICAgICAgICAgICBzY3JvbGxlci5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgbGVmdDogbmV3U2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IG5ld1Njcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogZS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJhdXRvXCIgOiBcInNtb290aFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxNaW5pbWFwU3R5bGVcbiAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogdywgaGVpZ2h0OiBoIH19XG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJtaW5pbWFwLWNvbnRhaW5lclwiXG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5idXR0b25zICE9PSAxKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlKGUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlTW91c2V9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyXCIgLz5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxvY2F0aW9uTWFya2VyXCJcbiAgICAgICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e2UgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB2V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IE1hdGgubWluKHZXaWR0aCwgdkhlaWdodCAqIDAuMiwgOSksXG4gICAgICAgICAgICAgICAgICAgIH19PjwvZGl2PlxuICAgICAgICAgICAgPC9NaW5pbWFwU3R5bGU+XG4gICAgICAgICk7XG4gICAgfSwgW2gsIGhlaWdodCwgbGVmdCwgc2Nyb2xsZXIsIHNob3dNaW5pbWFwLCB0b3AsIHZIZWlnaHQsIHZXaWR0aCwgdywgd2lkdGhdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxJbmZpbml0ZVNjcm9sbGVyXG4gICAgICAgICAgICBzY3JvbGxSZWY9e3Njcm9sbFJlZn1cbiAgICAgICAgICAgIG1pbmltYXA9e21pbmltYXB9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZz17cHJldmVudERpYWdvbmFsU2Nyb2xsaW5nfVxuICAgICAgICAgICAgZHJhZ2dhYmxlPXtpc0RyYWdnYWJsZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgaXNEcmFnZ2FibGUgPT09IFwic3RyaW5nXCJ9XG4gICAgICAgICAgICBzY3JvbGxXaWR0aD17d2lkdGggKyAocGFkZGluZ1JpZ2h0ID8/IDApfVxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0PXtoZWlnaHQgKyAocGFkZGluZ0JvdHRvbSA/PyAwKX1cbiAgICAgICAgICAgIGNsaWVudEhlaWdodD17Y2xpZW50SGVpZ2h0fVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50PXtyaWdodEVsZW1lbnR9XG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tPXtwYWRkaW5nQm90dG9tfVxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0PXtwYWRkaW5nUmlnaHR9XG4gICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17cmlnaHRFbGVtZW50UHJvcHN9XG4gICAgICAgICAgICB1cGRhdGU9e29uU2Nyb2xsVXBkYXRlfVxuICAgICAgICAgICAgaW5pdGlhbFNpemU9e2luaXRpYWxTaXplfVxuICAgICAgICAgICAgc2Nyb2xsVG9FbmQ9e3Njcm9sbFRvRW5kfT5cbiAgICAgICAgICAgIDxEYXRhR3JpZERuZFxuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0UmVmPXtzY3JvbGxSZWZ9XG4gICAgICAgICAgICAgICAgd2lkdGg9e2NsaWVudFdpZHRofVxuICAgICAgICAgICAgICAgIGhlaWdodD17Y2xpZW50SGVpZ2h0fVxuICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlIZWlnaHQ9e3AuYWNjZXNzaWJpbGl0eUhlaWdodH1cbiAgICAgICAgICAgICAgICBjYW52YXNSZWY9e3AuY2FudmFzUmVmfVxuICAgICAgICAgICAgICAgIGNlbGxYT2Zmc2V0PXtwLmNlbGxYT2Zmc2V0fVxuICAgICAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXtwLmNlbGxZT2Zmc2V0fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3AuY29sdW1uc31cbiAgICAgICAgICAgICAgICBkaXNhYmxlZFJvd3M9e3AuZGlzYWJsZWRSb3dzfVxuICAgICAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17cC5lbmFibGVHcm91cHN9XG4gICAgICAgICAgICAgICAgZmlsbEhhbmRsZT17cC5maWxsSGFuZGxlfVxuICAgICAgICAgICAgICAgIGZpcnN0Q29sQWNjZXNzaWJsZT17cC5maXJzdENvbEFjY2Vzc2libGV9XG4gICAgICAgICAgICAgICAgZml4ZWRTaGFkb3dYPXtwLmZpeGVkU2hhZG93WH1cbiAgICAgICAgICAgICAgICBmaXhlZFNoYWRvd1k9e3AuZml4ZWRTaGFkb3dZfVxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9e3AuZnJlZXplQ29sdW1uc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17cC5nZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsUmVuZGVyZXI9e3AuZ2V0Q2VsbFJlbmRlcmVyfVxuICAgICAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17cC5nZXRHcm91cERldGFpbHN9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17cC5nZXRSb3dUaGVtZU92ZXJyaWRlfVxuICAgICAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXtwLmdyb3VwSGVhZGVySGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhlYWRlckhlaWdodD17cC5oZWFkZXJIZWlnaHR9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17cC5oaWdobGlnaHRSZWdpb25zfVxuICAgICAgICAgICAgICAgIGltYWdlV2luZG93TG9hZGVyPXtwLmltYWdlV2luZG93TG9hZGVyfVxuICAgICAgICAgICAgICAgIGlzRmlsbGluZz17cC5pc0ZpbGxpbmd9XG4gICAgICAgICAgICAgICAgaXNGb2N1c2VkPXtwLmlzRm9jdXNlZH1cbiAgICAgICAgICAgICAgICBsb2NrQ29sdW1ucz17cC5sb2NrQ29sdW1uc31cbiAgICAgICAgICAgICAgICBtYXhDb2x1bW5XaWR0aD17cC5tYXhDb2x1bW5XaWR0aH1cbiAgICAgICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17cC5taW5Db2x1bW5XaWR0aH1cbiAgICAgICAgICAgICAgICBvbkhlYWRlck1lbnVDbGljaz17cC5vbkhlYWRlck1lbnVDbGlja31cbiAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZT17cC5vbk1vdXNlTW92ZX1cbiAgICAgICAgICAgICAgICBwcmVsaWdodENlbGxzPXtwLnByZWxpZ2h0Q2VsbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXtwLnJvd0hlaWdodH1cbiAgICAgICAgICAgICAgICByb3dzPXtwLnJvd3N9XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uPXtwLnNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICB0aGVtZT17cC50aGVtZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd1R5cGU9e3AudHJhaWxpbmdSb3dUeXBlfVxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg9e3AudHJhbnNsYXRlWH1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZPXtwLnRyYW5zbGF0ZVl9XG4gICAgICAgICAgICAgICAgdmVydGljYWxCb3JkZXI9e3AudmVydGljYWxCb3JkZXJ9XG4gICAgICAgICAgICAgICAgZHJhd0N1c3RvbUNlbGw9e3AuZHJhd0N1c3RvbUNlbGx9XG4gICAgICAgICAgICAgICAgZHJhd0ZvY3VzUmluZz17cC5kcmF3Rm9jdXNSaW5nfVxuICAgICAgICAgICAgICAgIGRyYXdIZWFkZXI9e3AuZHJhd0hlYWRlcn1cbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWw9e3AuZXhwZXJpbWVudGFsfVxuICAgICAgICAgICAgICAgIGdyaWRSZWY9e3AuZ3JpZFJlZn1cbiAgICAgICAgICAgICAgICBoZWFkZXJJY29ucz17cC5oZWFkZXJJY29uc31cbiAgICAgICAgICAgICAgICBpc0RyYWdnYWJsZT17cC5pc0RyYWdnYWJsZX1cbiAgICAgICAgICAgICAgICBvbkNhbnZhc0JsdXI9e3Aub25DYW52YXNCbHVyfVxuICAgICAgICAgICAgICAgIG9uQ2FudmFzRm9jdXNlZD17cC5vbkNhbnZhc0ZvY3VzZWR9XG4gICAgICAgICAgICAgICAgb25DZWxsRm9jdXNlZD17cC5vbkNlbGxGb2N1c2VkfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e3Aub25Db2x1bW5Nb3ZlZH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17cC5vbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZUVuZD17cC5vbkNvbHVtblJlc2l6ZUVuZH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZVN0YXJ0PXtwLm9uQ29sdW1uUmVzaXplU3RhcnR9XG4gICAgICAgICAgICAgICAgb25Db250ZXh0TWVudT17cC5vbkNvbnRleHRNZW51fVxuICAgICAgICAgICAgICAgIG9uRHJhZ0VuZD17cC5vbkRyYWdFbmR9XG4gICAgICAgICAgICAgICAgb25EcmFnTGVhdmU9e3Aub25EcmFnTGVhdmV9XG4gICAgICAgICAgICAgICAgb25EcmFnT3ZlckNlbGw9e3Aub25EcmFnT3ZlckNlbGx9XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e3Aub25EcmFnU3RhcnR9XG4gICAgICAgICAgICAgICAgb25Ecm9wPXtwLm9uRHJvcH1cbiAgICAgICAgICAgICAgICBvbkl0ZW1Ib3ZlcmVkPXtwLm9uSXRlbUhvdmVyZWR9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtwLm9uS2V5RG93bn1cbiAgICAgICAgICAgICAgICBvbktleVVwPXtwLm9uS2V5VXB9XG4gICAgICAgICAgICAgICAgb25Nb3VzZURvd249e3Aub25Nb3VzZURvd259XG4gICAgICAgICAgICAgICAgb25Nb3VzZVVwPXtwLm9uTW91c2VVcH1cbiAgICAgICAgICAgICAgICBvblJvd01vdmVkPXtwLm9uUm93TW92ZWR9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17cC5zbW9vdGhTY3JvbGxYfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3Auc21vb3RoU2Nyb2xsWX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvSW5maW5pdGVTY3JvbGxlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR3JpZFNjcm9sbGVyO1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx","webpack://./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx"],"names":[".m3brspx"],"mappings":"AAoFqBA,SAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,mCAAAA,CAAAA,wEAAAA,CAAAA,iBAAAA,CAAAA,SAAAA,CAAAA,uEAAAA,CAAAA,eAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,UAAAA,CAAAA,qCAAAA,CAAAA,4CAAAA,CAAAA,CAAAA,yBAAAA,iBAAAA,CAAAA,wCAAAA,CAAAA,wCAAAA,CAAAA;ACnFrB,m2qBAAm2qB","sourcesContent":["import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport DataGridDnd, { DataGridDndProps } from \"../data-grid-dnd/data-grid-dnd\";\nimport type { Rectangle } from \"../data-grid/data-grid-types\";\nimport { InfiniteScroller } from \"./infinite-scroller\";\nimport clamp from \"lodash/clamp.js\";\n\ntype Props = Omit<DataGridDndProps, \"width\" | \"height\" | \"eventTargetRef\">;\n\nexport interface ScrollingDataGridProps extends Props {\n    readonly className: string | undefined;\n    readonly onVisibleRegionChanged:\n        | ((\n              range: Rectangle,\n              clientWidth: number,\n              clientHeight: number,\n              rightElWidth: number,\n              tx: number,\n              ty: number\n          ) => void)\n        | undefined;\n    /**\n     * Causes the grid to scroll to the end when flipped to true\n     * @deprecated Use {@link DataEditorRef.scrollTo} instead\n     * @group Deprecated\n     */\n    readonly scrollToEnd: boolean | undefined;\n    readonly scrollRef: React.MutableRefObject<HTMLDivElement | null> | undefined;\n\n    /**\n     * The overscroll properties are used to allow the grid to scroll past the logical end of the content by a fixed\n     * number of pixels. This is useful particularly on the X axis if you allow for resizing columns as it can make\n     * resizing the final column significantly easier.\n     *\n     * @group Advanced\n     */\n    readonly overscrollX: number | undefined;\n    /** {@inheritDoc overscrollX}\n     * @group Advanced\n     */\n    readonly overscrollY: number | undefined;\n    /**\n     * Provides an initial size for the grid which can prevent a flicker on load if the initial size is known prior to\n     * layout.\n     *\n     * @group Advanced\n     */\n    readonly initialSize: readonly [width: number, height: number] | undefined;\n    /**\n     * Set to true to prevent any diagonal scrolling.\n     * @group Advanced\n     */\n    readonly preventDiagonalScrolling: boolean | undefined;\n\n    /**\n     * If `rightElementProps.sticky` is set to true the right element will be visible at all times, otherwise the user\n     * will need to scroll to the end to reveal it.\n     *\n     * If `rightElementProps.fill` is set, the right elements container will fill to consume all remaining space (if\n     * any) at the end of the grid. This does not play nice with growing columns.\n     *\n     * @group Advanced\n     */\n    readonly rightElementProps:\n        | {\n              readonly sticky?: boolean;\n              readonly fill?: boolean;\n          }\n        | undefined;\n    /**\n     * The right element is a DOM node which can be inserted at the end of the horizontal scroll region. This can be\n     * used to create a right handle panel, make a big add button, or display messages.\n     * @group Advanced\n     */\n    readonly rightElement: React.ReactNode | undefined;\n    /**\n     * Enables/disables the interactive minimap.\n     * @defaultValue false\n     * @group Advanced\n     */\n    readonly showMinimap: boolean | undefined;\n    readonly clientSize: readonly [number, number];\n}\n\nconst MinimapStyle = styled.div`\n    position: absolute;\n    right: 44px;\n    bottom: 44px;\n    background-color: var(--gdg-bg-cell);\n    background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n    border-radius: 4px;\n    z-index: 1;\n    box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n\n    overflow: hidden;\n\n    .header {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 4px;\n        background-color: var(--gdg-bg-header);\n        box-shadow: 0 0 0 1px var(--gdg-border-color);\n    }\n\n    .locationMarker {\n        position: absolute;\n\n        border: 1px solid var(--gdg-accent-color);\n        background-color: var(--gdg-accent-light);\n    }\n`;\n\nconst GridScroller: React.FunctionComponent<ScrollingDataGridProps> = p => {\n    const {\n        columns,\n        rows,\n        rowHeight,\n        headerHeight,\n        groupHeaderHeight,\n        enableGroups,\n        freezeColumns,\n        experimental,\n        clientSize,\n        className,\n        onVisibleRegionChanged,\n        scrollToEnd,\n        scrollRef,\n        preventDiagonalScrolling,\n        rightElement,\n        rightElementProps,\n        overscrollX,\n        overscrollY,\n        showMinimap = false,\n        initialSize,\n        smoothScrollX = false,\n        smoothScrollY = false,\n        isDraggable,\n    } = p;\n    const { paddingRight, paddingBottom } = experimental ?? {};\n\n    const [clientWidth, clientHeight] = clientSize;\n    const last = React.useRef<Rectangle | undefined>();\n    const lastX = React.useRef<number | undefined>();\n    const lastY = React.useRef<number | undefined>();\n    const lastSize = React.useRef<readonly [number, number] | undefined>();\n\n    const width = React.useMemo(() => {\n        let r = Math.max(0, overscrollX ?? 0);\n        for (const c of columns) {\n            r += c.width;\n        }\n        return r;\n    }, [columns, overscrollX]);\n\n    let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n    if (typeof rowHeight === \"number\") {\n        height += rows * rowHeight;\n    } else {\n        for (let r = 0; r < rows; r++) {\n            height += rowHeight(r);\n        }\n    }\n    if (overscrollY !== undefined) {\n        height += overscrollY;\n    }\n\n    const lastArgs = React.useRef<Rectangle & { paddingRight: number }>();\n\n    const processArgs = React.useCallback(() => {\n        if (lastArgs.current === undefined) return;\n        const args = { ...lastArgs.current };\n\n        let x = 0;\n        let tx = args.x < 0 ? -args.x : 0;\n        let cellRight = 0;\n        let cellX = 0;\n\n        args.x = args.x < 0 ? 0 : args.x;\n\n        let stickyColWidth = 0;\n        for (let i = 0; i < freezeColumns; i++) {\n            stickyColWidth += columns[i].width;\n        }\n\n        for (const c of columns) {\n            const cx = x - stickyColWidth;\n            if (args.x >= cx + c.width) {\n                x += c.width;\n                cellX++;\n                cellRight++;\n            } else if (args.x > cx) {\n                x += c.width;\n                if (smoothScrollX) {\n                    tx += cx - args.x;\n                } else {\n                    cellX++;\n                }\n                cellRight++;\n            } else if (args.x + args.width > cx) {\n                x += c.width;\n                cellRight++;\n            } else {\n                break;\n            }\n        }\n\n        let ty = 0;\n        let cellY = 0;\n        let cellBottom = 0;\n        if (typeof rowHeight === \"number\") {\n            if (smoothScrollY) {\n                cellY = Math.floor(args.y / rowHeight);\n                ty = cellY * rowHeight - args.y;\n            } else {\n                cellY = Math.ceil(args.y / rowHeight);\n            }\n            cellBottom = Math.ceil(args.height / rowHeight) + cellY;\n            if (ty < 0) cellBottom++;\n        } else {\n            let y = 0;\n            for (let row = 0; row < rows; row++) {\n                const rh = rowHeight(row);\n                const cy = y + (smoothScrollY ? 0 : rh / 2);\n                if (args.y >= y + rh) {\n                    y += rh;\n                    cellY++;\n                    cellBottom++;\n                } else if (args.y > cy) {\n                    y += rh;\n                    if (smoothScrollY) {\n                        ty += cy - args.y;\n                    } else {\n                        cellY++;\n                    }\n                    cellBottom++;\n                } else if (args.y + args.height > rh / 2 + y) {\n                    y += rh;\n                    cellBottom++;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        const rect: Rectangle = {\n            x: cellX,\n            y: cellY,\n            width: cellRight - cellX,\n            height: cellBottom - cellY,\n        };\n\n        const oldRect = last.current;\n\n        if (\n            oldRect === undefined ||\n            oldRect.y !== rect.y ||\n            oldRect.x !== rect.x ||\n            oldRect.height !== rect.height ||\n            oldRect.width !== rect.width ||\n            lastX.current !== tx ||\n            lastY.current !== ty ||\n            args.width !== lastSize.current?.[0] ||\n            args.height !== lastSize.current?.[1]\n        ) {\n            onVisibleRegionChanged?.(\n                {\n                    x: cellX,\n                    y: cellY,\n                    width: cellRight - cellX,\n                    height: cellBottom - cellY,\n                },\n                args.width,\n                args.height,\n                args.paddingRight ?? 0,\n                tx,\n                ty\n            );\n            last.current = rect;\n            lastX.current = tx;\n            lastY.current = ty;\n            lastSize.current = [args.width, args.height];\n        }\n    }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);\n\n    const onScrollUpdate = React.useCallback(\n        (args: Rectangle & { paddingRight: number }) => {\n            lastArgs.current = args;\n            processArgs();\n        },\n        [processArgs]\n    );\n\n    React.useEffect(() => {\n        processArgs();\n    }, [processArgs]);\n\n    const scroller = scrollRef?.current ?? undefined;\n    const aspect = clamp(width / height, 2 / 3, 1.5);\n    const maxSize = 200;\n    const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);\n    const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;\n    const hRatio = w / width;\n    const vRatio = h / height;\n    const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);\n    const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);\n    const left = ((scroller?.scrollLeft ?? 0) / (width - clientWidth)) * (w - vWidth);\n    const top = ((scroller?.scrollTop ?? 0) / (height - clientHeight)) * (h - vHeight);\n\n    const minimap: React.ReactNode = React.useMemo(() => {\n        if (!showMinimap || vWidth === 0 || vHeight === 0) return undefined;\n\n        const handleMouse = (e: React.MouseEvent) => {\n            if (scroller === undefined) return;\n            const bounds = e.currentTarget.getBoundingClientRect();\n            const x = e.clientX - bounds.x - vWidth / 2;\n            const y = e.clientY - bounds.y - vHeight / 2;\n\n            const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));\n            const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));\n\n            scroller.scrollTo({\n                left: newScrollLeft,\n                top: newScrollTop,\n                behavior: e.type === \"mousemove\" ? \"auto\" : \"smooth\",\n            });\n        };\n\n        return (\n            <MinimapStyle\n                style={{ width: w, height: h }}\n                data-testid=\"minimap-container\"\n                onMouseMove={e => {\n                    if (e.buttons !== 1) return;\n                    handleMouse(e);\n                }}\n                onClick={handleMouse}>\n                <div className=\"header\" />\n                <div\n                    className=\"locationMarker\"\n                    onDragStart={e => e.preventDefault()}\n                    style={{\n                        left,\n                        top,\n                        width: vWidth,\n                        height: vHeight,\n                        borderRadius: Math.min(vWidth, vHeight * 0.2, 9),\n                    }}></div>\n            </MinimapStyle>\n        );\n    }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);\n\n    return (\n        <InfiniteScroller\n            scrollRef={scrollRef}\n            minimap={minimap}\n            className={className}\n            preventDiagonalScrolling={preventDiagonalScrolling}\n            draggable={isDraggable === true || typeof isDraggable === \"string\"}\n            scrollWidth={width + (paddingRight ?? 0)}\n            scrollHeight={height + (paddingBottom ?? 0)}\n            clientHeight={clientHeight}\n            rightElement={rightElement}\n            paddingBottom={paddingBottom}\n            paddingRight={paddingRight}\n            rightElementProps={rightElementProps}\n            update={onScrollUpdate}\n            initialSize={initialSize}\n            scrollToEnd={scrollToEnd}>\n            <DataGridDnd\n                eventTargetRef={scrollRef}\n                width={clientWidth}\n                height={clientHeight}\n                accessibilityHeight={p.accessibilityHeight}\n                canvasRef={p.canvasRef}\n                cellXOffset={p.cellXOffset}\n                cellYOffset={p.cellYOffset}\n                columns={p.columns}\n                disabledRows={p.disabledRows}\n                enableGroups={p.enableGroups}\n                fillHandle={p.fillHandle}\n                firstColAccessible={p.firstColAccessible}\n                fixedShadowX={p.fixedShadowX}\n                fixedShadowY={p.fixedShadowY}\n                freezeColumns={p.freezeColumns}\n                getCellContent={p.getCellContent}\n                getCellRenderer={p.getCellRenderer}\n                getGroupDetails={p.getGroupDetails}\n                getRowThemeOverride={p.getRowThemeOverride}\n                groupHeaderHeight={p.groupHeaderHeight}\n                headerHeight={p.headerHeight}\n                highlightRegions={p.highlightRegions}\n                imageWindowLoader={p.imageWindowLoader}\n                isFilling={p.isFilling}\n                isFocused={p.isFocused}\n                lockColumns={p.lockColumns}\n                maxColumnWidth={p.maxColumnWidth}\n                minColumnWidth={p.minColumnWidth}\n                onHeaderMenuClick={p.onHeaderMenuClick}\n                onMouseMove={p.onMouseMove}\n                prelightCells={p.prelightCells}\n                rowHeight={p.rowHeight}\n                rows={p.rows}\n                selection={p.selection}\n                theme={p.theme}\n                trailingRowType={p.trailingRowType}\n                translateX={p.translateX}\n                translateY={p.translateY}\n                verticalBorder={p.verticalBorder}\n                drawCustomCell={p.drawCustomCell}\n                drawFocusRing={p.drawFocusRing}\n                drawHeader={p.drawHeader}\n                experimental={p.experimental}\n                gridRef={p.gridRef}\n                headerIcons={p.headerIcons}\n                isDraggable={p.isDraggable}\n                onCanvasBlur={p.onCanvasBlur}\n                onCanvasFocused={p.onCanvasFocused}\n                onCellFocused={p.onCellFocused}\n                onColumnMoved={p.onColumnMoved}\n                onColumnResize={p.onColumnResize}\n                onColumnResizeEnd={p.onColumnResizeEnd}\n                onColumnResizeStart={p.onColumnResizeStart}\n                onContextMenu={p.onContextMenu}\n                onDragEnd={p.onDragEnd}\n                onDragLeave={p.onDragLeave}\n                onDragOverCell={p.onDragOverCell}\n                onDragStart={p.onDragStart}\n                onDrop={p.onDrop}\n                onItemHovered={p.onItemHovered}\n                onKeyDown={p.onKeyDown}\n                onKeyUp={p.onKeyUp}\n                onMouseDown={p.onMouseDown}\n                onMouseUp={p.onMouseUp}\n                onRowMoved={p.onRowMoved}\n                smoothScrollX={p.smoothScrollX}\n                smoothScrollY={p.smoothScrollY}\n            />\n        </InfiniteScroller>\n    );\n};\n\nexport default GridScroller;\n",".m3brspx{position:absolute;right:44px;bottom:44px;background-color:var(--gdg-bg-cell);background:linear-gradient(var(--gdg-bg-cell),var(--gdg-bg-cell-medium));border-radius:4px;z-index:1;box-shadow:0 0 0 1px var(--gdg-border-color),0 2px 5px rgba(0,0,0,0.08);overflow:hidden;}.m3brspx .header{position:absolute;left:0;top:0;width:100%;height:4px;background-color:var(--gdg-bg-header);box-shadow:0 0 0 1px var(--gdg-border-color);}.m3brspx .locationMarker{position:absolute;border:1px solid var(--gdg-accent-color);background-color:var(--gdg-accent-light);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLnRzeCJdLCJuYW1lcyI6WyIubTNicnNweCJdLCJtYXBwaW5ncyI6IkFBb0ZxQkEiLCJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCBEYXRhR3JpZERuZCwgeyBEYXRhR3JpZERuZFByb3BzIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC1kbmQvZGF0YS1ncmlkLWRuZFwiO1xuaW1wb3J0IHR5cGUgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxlciB9IGZyb20gXCIuL2luZmluaXRlLXNjcm9sbGVyXCI7XG5pbXBvcnQgY2xhbXAgZnJvbSBcImxvZGFzaC9jbGFtcC5qc1wiO1xuXG50eXBlIFByb3BzID0gT21pdDxEYXRhR3JpZERuZFByb3BzLCBcIndpZHRoXCIgfCBcImhlaWdodFwiIHwgXCJldmVudFRhcmdldFJlZlwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxpbmdEYXRhR3JpZFByb3BzIGV4dGVuZHMgUHJvcHMge1xuICAgIHJlYWRvbmx5IGNsYXNzTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ6XG4gICAgICAgIHwgKChcbiAgICAgICAgICAgICAgcmFuZ2U6IFJlY3RhbmdsZSxcbiAgICAgICAgICAgICAgY2xpZW50V2lkdGg6IG51bWJlcixcbiAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBudW1iZXIsXG4gICAgICAgICAgICAgIHJpZ2h0RWxXaWR0aDogbnVtYmVyLFxuICAgICAgICAgICAgICB0eDogbnVtYmVyLFxuICAgICAgICAgICAgICB0eTogbnVtYmVyXG4gICAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBDYXVzZXMgdGhlIGdyaWQgdG8gc2Nyb2xsIHRvIHRoZSBlbmQgd2hlbiBmbGlwcGVkIHRvIHRydWVcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIERhdGFFZGl0b3JSZWYuc2Nyb2xsVG99IGluc3RlYWRcbiAgICAgKiBAZ3JvdXAgRGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNjcm9sbFRvRW5kOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IHNjcm9sbFJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxIVE1MRGl2RWxlbWVudCB8IG51bGw+IHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG92ZXJzY3JvbGwgcHJvcGVydGllcyBhcmUgdXNlZCB0byBhbGxvdyB0aGUgZ3JpZCB0byBzY3JvbGwgcGFzdCB0aGUgbG9naWNhbCBlbmQgb2YgdGhlIGNvbnRlbnQgYnkgYSBmaXhlZFxuICAgICAqIG51bWJlciBvZiBwaXhlbHMuIFRoaXMgaXMgdXNlZnVsIHBhcnRpY3VsYXJseSBvbiB0aGUgWCBheGlzIGlmIHlvdSBhbGxvdyBmb3IgcmVzaXppbmcgY29sdW1ucyBhcyBpdCBjYW4gbWFrZVxuICAgICAqIHJlc2l6aW5nIHRoZSBmaW5hbCBjb2x1bW4gc2lnbmlmaWNhbnRseSBlYXNpZXIuXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBvdmVyc2Nyb2xsWDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIC8qKiB7QGluaGVyaXREb2Mgb3ZlcnNjcm9sbFh9XG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgb3ZlcnNjcm9sbFk6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBpbml0aWFsIHNpemUgZm9yIHRoZSBncmlkIHdoaWNoIGNhbiBwcmV2ZW50IGEgZmxpY2tlciBvbiBsb2FkIGlmIHRoZSBpbml0aWFsIHNpemUgaXMga25vd24gcHJpb3IgdG9cbiAgICAgKiBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBpbml0aWFsU2l6ZTogcmVhZG9ubHkgW3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXSB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IGFueSBkaWFnb25hbCBzY3JvbGxpbmcuXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogSWYgYHJpZ2h0RWxlbWVudFByb3BzLnN0aWNreWAgaXMgc2V0IHRvIHRydWUgdGhlIHJpZ2h0IGVsZW1lbnQgd2lsbCBiZSB2aXNpYmxlIGF0IGFsbCB0aW1lcywgb3RoZXJ3aXNlIHRoZSB1c2VyXG4gICAgICogd2lsbCBuZWVkIHRvIHNjcm9sbCB0byB0aGUgZW5kIHRvIHJldmVhbCBpdC5cbiAgICAgKlxuICAgICAqIElmIGByaWdodEVsZW1lbnRQcm9wcy5maWxsYCBpcyBzZXQsIHRoZSByaWdodCBlbGVtZW50cyBjb250YWluZXIgd2lsbCBmaWxsIHRvIGNvbnN1bWUgYWxsIHJlbWFpbmluZyBzcGFjZSAoaWZcbiAgICAgKiBhbnkpIGF0IHRoZSBlbmQgb2YgdGhlIGdyaWQuIFRoaXMgZG9lcyBub3QgcGxheSBuaWNlIHdpdGggZ3Jvd2luZyBjb2x1bW5zLlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgcmlnaHRFbGVtZW50UHJvcHM6XG4gICAgICAgIHwge1xuICAgICAgICAgICAgICByZWFkb25seSBzdGlja3k/OiBib29sZWFuO1xuICAgICAgICAgICAgICByZWFkb25seSBmaWxsPzogYm9vbGVhbjtcbiAgICAgICAgICB9XG4gICAgICAgIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFRoZSByaWdodCBlbGVtZW50IGlzIGEgRE9NIG5vZGUgd2hpY2ggY2FuIGJlIGluc2VydGVkIGF0IHRoZSBlbmQgb2YgdGhlIGhvcml6b250YWwgc2Nyb2xsIHJlZ2lvbi4gVGhpcyBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGNyZWF0ZSBhIHJpZ2h0IGhhbmRsZSBwYW5lbCwgbWFrZSBhIGJpZyBhZGQgYnV0dG9uLCBvciBkaXNwbGF5IG1lc3NhZ2VzLlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHJpZ2h0RWxlbWVudDogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgdGhlIGludGVyYWN0aXZlIG1pbmltYXAuXG4gICAgICogQGRlZmF1bHRWYWx1ZSBmYWxzZVxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNob3dNaW5pbWFwOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IGNsaWVudFNpemU6IHJlYWRvbmx5IFtudW1iZXIsIG51bWJlcl07XG59XG5cbmNvbnN0IE1pbmltYXBTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiA0NHB4O1xuICAgIGJvdHRvbTogNDRweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHZhcigtLWdkZy1iZy1jZWxsKSwgdmFyKC0tZ2RnLWJnLWNlbGwtbWVkaXVtKSk7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIHotaW5kZXg6IDE7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1ib3JkZXItY29sb3IpLCAwIDJweCA1cHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcblxuICAgIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgICAuaGVhZGVyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDRweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWhlYWRlcik7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKTtcbiAgICB9XG5cbiAgICAubG9jYXRpb25NYXJrZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtbGlnaHQpO1xuICAgIH1cbmA7XG5cbmNvbnN0IEdyaWRTY3JvbGxlcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8U2Nyb2xsaW5nRGF0YUdyaWRQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGNvbHVtbnMsXG4gICAgICAgIHJvd3MsXG4gICAgICAgIHJvd0hlaWdodCxcbiAgICAgICAgaGVhZGVySGVpZ2h0LFxuICAgICAgICBncm91cEhlYWRlckhlaWdodCxcbiAgICAgICAgZW5hYmxlR3JvdXBzLFxuICAgICAgICBmcmVlemVDb2x1bW5zLFxuICAgICAgICBleHBlcmltZW50YWwsXG4gICAgICAgIGNsaWVudFNpemUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCxcbiAgICAgICAgc2Nyb2xsVG9FbmQsXG4gICAgICAgIHNjcm9sbFJlZixcbiAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLFxuICAgICAgICByaWdodEVsZW1lbnQsXG4gICAgICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgICAgICBvdmVyc2Nyb2xsWCxcbiAgICAgICAgb3ZlcnNjcm9sbFksXG4gICAgICAgIHNob3dNaW5pbWFwID0gZmFsc2UsXG4gICAgICAgIGluaXRpYWxTaXplLFxuICAgICAgICBzbW9vdGhTY3JvbGxYID0gZmFsc2UsXG4gICAgICAgIHNtb290aFNjcm9sbFkgPSBmYWxzZSxcbiAgICAgICAgaXNEcmFnZ2FibGUsXG4gICAgfSA9IHA7XG4gICAgY29uc3QgeyBwYWRkaW5nUmlnaHQsIHBhZGRpbmdCb3R0b20gfSA9IGV4cGVyaW1lbnRhbCA/PyB7fTtcblxuICAgIGNvbnN0IFtjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0XSA9IGNsaWVudFNpemU7XG4gICAgY29uc3QgbGFzdCA9IFJlYWN0LnVzZVJlZjxSZWN0YW5nbGUgfCB1bmRlZmluZWQ+KCk7XG4gICAgY29uc3QgbGFzdFggPSBSZWFjdC51c2VSZWY8bnVtYmVyIHwgdW5kZWZpbmVkPigpO1xuICAgIGNvbnN0IGxhc3RZID0gUmVhY3QudXNlUmVmPG51bWJlciB8IHVuZGVmaW5lZD4oKTtcbiAgICBjb25zdCBsYXN0U2l6ZSA9IFJlYWN0LnVzZVJlZjxyZWFkb25seSBbbnVtYmVyLCBudW1iZXJdIHwgdW5kZWZpbmVkPigpO1xuXG4gICAgY29uc3Qgd2lkdGggPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLm1heCgwLCBvdmVyc2Nyb2xsWCA/PyAwKTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbHVtbnMpIHtcbiAgICAgICAgICAgIHIgKz0gYy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9LCBbY29sdW1ucywgb3ZlcnNjcm9sbFhdKTtcblxuICAgIGxldCBoZWlnaHQgPSBlbmFibGVHcm91cHMgPyBoZWFkZXJIZWlnaHQgKyBncm91cEhlYWRlckhlaWdodCA6IGhlYWRlckhlaWdodDtcbiAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBoZWlnaHQgKz0gcm93cyAqIHJvd0hlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHJvd0hlaWdodChyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3ZlcnNjcm9sbFkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWlnaHQgKz0gb3ZlcnNjcm9sbFk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdEFyZ3MgPSBSZWFjdC51c2VSZWY8UmVjdGFuZ2xlICYgeyBwYWRkaW5nUmlnaHQ6IG51bWJlciB9PigpO1xuXG4gICAgY29uc3QgcHJvY2Vzc0FyZ3MgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChsYXN0QXJncy5jdXJyZW50ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgYXJncyA9IHsgLi4ubGFzdEFyZ3MuY3VycmVudCB9O1xuXG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHR4ID0gYXJncy54IDwgMCA/IC1hcmdzLnggOiAwO1xuICAgICAgICBsZXQgY2VsbFJpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGNlbGxYID0gMDtcblxuICAgICAgICBhcmdzLnggPSBhcmdzLnggPCAwID8gMCA6IGFyZ3MueDtcblxuICAgICAgICBsZXQgc3RpY2t5Q29sV2lkdGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyZWV6ZUNvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgc3RpY2t5Q29sV2lkdGggKz0gY29sdW1uc1tpXS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb25zdCBjeCA9IHggLSBzdGlja3lDb2xXaWR0aDtcbiAgICAgICAgICAgIGlmIChhcmdzLnggPj0gY3ggKyBjLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGNlbGxYKys7XG4gICAgICAgICAgICAgICAgY2VsbFJpZ2h0Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChzbW9vdGhTY3JvbGxYKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4ICs9IGN4IC0gYXJncy54O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxYKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnggKyBhcmdzLndpZHRoID4gY3gpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGMud2lkdGg7XG4gICAgICAgICAgICAgICAgY2VsbFJpZ2h0Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHR5ID0gMDtcbiAgICAgICAgbGV0IGNlbGxZID0gMDtcbiAgICAgICAgbGV0IGNlbGxCb3R0b20gPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHNtb290aFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICBjZWxsWSA9IE1hdGguZmxvb3IoYXJncy55IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0eSA9IGNlbGxZICogcm93SGVpZ2h0IC0gYXJncy55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxsWSA9IE1hdGguY2VpbChhcmdzLnkgLyByb3dIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbEJvdHRvbSA9IE1hdGguY2VpbChhcmdzLmhlaWdodCAvIHJvd0hlaWdodCkgKyBjZWxsWTtcbiAgICAgICAgICAgIGlmICh0eSA8IDApIGNlbGxCb3R0b20rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmggPSByb3dIZWlnaHQocm93KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjeSA9IHkgKyAoc21vb3RoU2Nyb2xsWSA/IDAgOiByaCAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLnkgPj0geSArIHJoKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gcmg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxZKys7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueSA+IGN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gcmg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbW9vdGhTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eSArPSBjeSAtIGFyZ3MueTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxZKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2VsbEJvdHRvbSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy55ICsgYXJncy5oZWlnaHQgPiByaCAvIDIgKyB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gcmg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWN0OiBSZWN0YW5nbGUgPSB7XG4gICAgICAgICAgICB4OiBjZWxsWCxcbiAgICAgICAgICAgIHk6IGNlbGxZLFxuICAgICAgICAgICAgd2lkdGg6IGNlbGxSaWdodCAtIGNlbGxYLFxuICAgICAgICAgICAgaGVpZ2h0OiBjZWxsQm90dG9tIC0gY2VsbFksXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb2xkUmVjdCA9IGxhc3QuY3VycmVudDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBvbGRSZWN0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG9sZFJlY3QueSAhPT0gcmVjdC55IHx8XG4gICAgICAgICAgICBvbGRSZWN0LnggIT09IHJlY3QueCB8fFxuICAgICAgICAgICAgb2xkUmVjdC5oZWlnaHQgIT09IHJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICBvbGRSZWN0LndpZHRoICE9PSByZWN0LndpZHRoIHx8XG4gICAgICAgICAgICBsYXN0WC5jdXJyZW50ICE9PSB0eCB8fFxuICAgICAgICAgICAgbGFzdFkuY3VycmVudCAhPT0gdHkgfHxcbiAgICAgICAgICAgIGFyZ3Mud2lkdGggIT09IGxhc3RTaXplLmN1cnJlbnQ/LlswXSB8fFxuICAgICAgICAgICAgYXJncy5oZWlnaHQgIT09IGxhc3RTaXplLmN1cnJlbnQ/LlsxXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ/LihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNlbGxYLFxuICAgICAgICAgICAgICAgICAgICB5OiBjZWxsWSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNlbGxSaWdodCAtIGNlbGxYLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNlbGxCb3R0b20gLSBjZWxsWSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZ3Mud2lkdGgsXG4gICAgICAgICAgICAgICAgYXJncy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgYXJncy5wYWRkaW5nUmlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICB0eCxcbiAgICAgICAgICAgICAgICB0eVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxhc3QuY3VycmVudCA9IHJlY3Q7XG4gICAgICAgICAgICBsYXN0WC5jdXJyZW50ID0gdHg7XG4gICAgICAgICAgICBsYXN0WS5jdXJyZW50ID0gdHk7XG4gICAgICAgICAgICBsYXN0U2l6ZS5jdXJyZW50ID0gW2FyZ3Mud2lkdGgsIGFyZ3MuaGVpZ2h0XTtcbiAgICAgICAgfVxuICAgIH0sIFtjb2x1bW5zLCByb3dIZWlnaHQsIHJvd3MsIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQsIGZyZWV6ZUNvbHVtbnMsIHNtb290aFNjcm9sbFgsIHNtb290aFNjcm9sbFldKTtcblxuICAgIGNvbnN0IG9uU2Nyb2xsVXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChhcmdzOiBSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0pID0+IHtcbiAgICAgICAgICAgIGxhc3RBcmdzLmN1cnJlbnQgPSBhcmdzO1xuICAgICAgICAgICAgcHJvY2Vzc0FyZ3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgW3Byb2Nlc3NBcmdzXVxuICAgICk7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwcm9jZXNzQXJncygpO1xuICAgIH0sIFtwcm9jZXNzQXJnc10pO1xuXG4gICAgY29uc3Qgc2Nyb2xsZXIgPSBzY3JvbGxSZWY/LmN1cnJlbnQgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGFzcGVjdCA9IGNsYW1wKHdpZHRoIC8gaGVpZ2h0LCAyIC8gMywgMS41KTtcbiAgICBjb25zdCBtYXhTaXplID0gMjAwO1xuICAgIGNvbnN0IHcgPSBhc3BlY3QgPiAxID8gbWF4U2l6ZSA6IE1hdGguY2VpbChtYXhTaXplICogYXNwZWN0KTtcbiAgICBjb25zdCBoID0gYXNwZWN0ID4gMSA/IE1hdGguY2VpbChtYXhTaXplIC8gYXNwZWN0KSA6IG1heFNpemU7XG4gICAgY29uc3QgaFJhdGlvID0gdyAvIHdpZHRoO1xuICAgIGNvbnN0IHZSYXRpbyA9IGggLyBoZWlnaHQ7XG4gICAgY29uc3QgdldpZHRoID0gTWF0aC5taW4oY2xpZW50V2lkdGggKiBNYXRoLm1heChoUmF0aW8sIDAuMDEpLCB3KTtcbiAgICBjb25zdCB2SGVpZ2h0ID0gTWF0aC5taW4oY2xpZW50SGVpZ2h0ICogTWF0aC5tYXgodlJhdGlvLCAwLjAxKSwgaCk7XG4gICAgY29uc3QgbGVmdCA9ICgoc2Nyb2xsZXI/LnNjcm9sbExlZnQgPz8gMCkgLyAod2lkdGggLSBjbGllbnRXaWR0aCkpICogKHcgLSB2V2lkdGgpO1xuICAgIGNvbnN0IHRvcCA9ICgoc2Nyb2xsZXI/LnNjcm9sbFRvcCA/PyAwKSAvIChoZWlnaHQgLSBjbGllbnRIZWlnaHQpKSAqIChoIC0gdkhlaWdodCk7XG5cbiAgICBjb25zdCBtaW5pbWFwOiBSZWFjdC5SZWFjdE5vZGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaG93TWluaW1hcCB8fCB2V2lkdGggPT09IDAgfHwgdkhlaWdodCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICBjb25zdCBoYW5kbGVNb3VzZSA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzID0gZS5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IGUuY2xpZW50WCAtIGJvdW5kcy54IC0gdldpZHRoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBlLmNsaWVudFkgLSBib3VuZHMueSAtIHZIZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdTY3JvbGxMZWZ0ID0gKHdpZHRoIC0gc2Nyb2xsZXIuY2xpZW50V2lkdGgpICogKHggLyAodyAtIHZXaWR0aCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsVG9wID0gKGhlaWdodCAtIHNjcm9sbGVyLmNsaWVudEhlaWdodCkgKiAoeSAvIChoIC0gdkhlaWdodCkpO1xuXG4gICAgICAgICAgICBzY3JvbGxlci5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgbGVmdDogbmV3U2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IG5ld1Njcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogZS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJhdXRvXCIgOiBcInNtb290aFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxNaW5pbWFwU3R5bGVcbiAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogdywgaGVpZ2h0OiBoIH19XG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJtaW5pbWFwLWNvbnRhaW5lclwiXG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5idXR0b25zICE9PSAxKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlKGUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlTW91c2V9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyXCIgLz5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxvY2F0aW9uTWFya2VyXCJcbiAgICAgICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e2UgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB2V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IE1hdGgubWluKHZXaWR0aCwgdkhlaWdodCAqIDAuMiwgOSksXG4gICAgICAgICAgICAgICAgICAgIH19PjwvZGl2PlxuICAgICAgICAgICAgPC9NaW5pbWFwU3R5bGU+XG4gICAgICAgICk7XG4gICAgfSwgW2gsIGhlaWdodCwgbGVmdCwgc2Nyb2xsZXIsIHNob3dNaW5pbWFwLCB0b3AsIHZIZWlnaHQsIHZXaWR0aCwgdywgd2lkdGhdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxJbmZpbml0ZVNjcm9sbGVyXG4gICAgICAgICAgICBzY3JvbGxSZWY9e3Njcm9sbFJlZn1cbiAgICAgICAgICAgIG1pbmltYXA9e21pbmltYXB9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZz17cHJldmVudERpYWdvbmFsU2Nyb2xsaW5nfVxuICAgICAgICAgICAgZHJhZ2dhYmxlPXtpc0RyYWdnYWJsZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgaXNEcmFnZ2FibGUgPT09IFwic3RyaW5nXCJ9XG4gICAgICAgICAgICBzY3JvbGxXaWR0aD17d2lkdGggKyAocGFkZGluZ1JpZ2h0ID8/IDApfVxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0PXtoZWlnaHQgKyAocGFkZGluZ0JvdHRvbSA/PyAwKX1cbiAgICAgICAgICAgIGNsaWVudEhlaWdodD17Y2xpZW50SGVpZ2h0fVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50PXtyaWdodEVsZW1lbnR9XG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tPXtwYWRkaW5nQm90dG9tfVxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0PXtwYWRkaW5nUmlnaHR9XG4gICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17cmlnaHRFbGVtZW50UHJvcHN9XG4gICAgICAgICAgICB1cGRhdGU9e29uU2Nyb2xsVXBkYXRlfVxuICAgICAgICAgICAgaW5pdGlhbFNpemU9e2luaXRpYWxTaXplfVxuICAgICAgICAgICAgc2Nyb2xsVG9FbmQ9e3Njcm9sbFRvRW5kfT5cbiAgICAgICAgICAgIDxEYXRhR3JpZERuZFxuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0UmVmPXtzY3JvbGxSZWZ9XG4gICAgICAgICAgICAgICAgd2lkdGg9e2NsaWVudFdpZHRofVxuICAgICAgICAgICAgICAgIGhlaWdodD17Y2xpZW50SGVpZ2h0fVxuICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlIZWlnaHQ9e3AuYWNjZXNzaWJpbGl0eUhlaWdodH1cbiAgICAgICAgICAgICAgICBjYW52YXNSZWY9e3AuY2FudmFzUmVmfVxuICAgICAgICAgICAgICAgIGNlbGxYT2Zmc2V0PXtwLmNlbGxYT2Zmc2V0fVxuICAgICAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXtwLmNlbGxZT2Zmc2V0fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3AuY29sdW1uc31cbiAgICAgICAgICAgICAgICBkaXNhYmxlZFJvd3M9e3AuZGlzYWJsZWRSb3dzfVxuICAgICAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17cC5lbmFibGVHcm91cHN9XG4gICAgICAgICAgICAgICAgZmlsbEhhbmRsZT17cC5maWxsSGFuZGxlfVxuICAgICAgICAgICAgICAgIGZpcnN0Q29sQWNjZXNzaWJsZT17cC5maXJzdENvbEFjY2Vzc2libGV9XG4gICAgICAgICAgICAgICAgZml4ZWRTaGFkb3dYPXtwLmZpeGVkU2hhZG93WH1cbiAgICAgICAgICAgICAgICBmaXhlZFNoYWRvd1k9e3AuZml4ZWRTaGFkb3dZfVxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9e3AuZnJlZXplQ29sdW1uc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17cC5nZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsUmVuZGVyZXI9e3AuZ2V0Q2VsbFJlbmRlcmVyfVxuICAgICAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17cC5nZXRHcm91cERldGFpbHN9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17cC5nZXRSb3dUaGVtZU92ZXJyaWRlfVxuICAgICAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXtwLmdyb3VwSGVhZGVySGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhlYWRlckhlaWdodD17cC5oZWFkZXJIZWlnaHR9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17cC5oaWdobGlnaHRSZWdpb25zfVxuICAgICAgICAgICAgICAgIGltYWdlV2luZG93TG9hZGVyPXtwLmltYWdlV2luZG93TG9hZGVyfVxuICAgICAgICAgICAgICAgIGlzRmlsbGluZz17cC5pc0ZpbGxpbmd9XG4gICAgICAgICAgICAgICAgaXNGb2N1c2VkPXtwLmlzRm9jdXNlZH1cbiAgICAgICAgICAgICAgICBsb2NrQ29sdW1ucz17cC5sb2NrQ29sdW1uc31cbiAgICAgICAgICAgICAgICBtYXhDb2x1bW5XaWR0aD17cC5tYXhDb2x1bW5XaWR0aH1cbiAgICAgICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17cC5taW5Db2x1bW5XaWR0aH1cbiAgICAgICAgICAgICAgICBvbkhlYWRlck1lbnVDbGljaz17cC5vbkhlYWRlck1lbnVDbGlja31cbiAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZT17cC5vbk1vdXNlTW92ZX1cbiAgICAgICAgICAgICAgICBwcmVsaWdodENlbGxzPXtwLnByZWxpZ2h0Q2VsbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXtwLnJvd0hlaWdodH1cbiAgICAgICAgICAgICAgICByb3dzPXtwLnJvd3N9XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uPXtwLnNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICB0aGVtZT17cC50aGVtZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd1R5cGU9e3AudHJhaWxpbmdSb3dUeXBlfVxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg9e3AudHJhbnNsYXRlWH1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZPXtwLnRyYW5zbGF0ZVl9XG4gICAgICAgICAgICAgICAgdmVydGljYWxCb3JkZXI9e3AudmVydGljYWxCb3JkZXJ9XG4gICAgICAgICAgICAgICAgZHJhd0N1c3RvbUNlbGw9e3AuZHJhd0N1c3RvbUNlbGx9XG4gICAgICAgICAgICAgICAgZHJhd0ZvY3VzUmluZz17cC5kcmF3Rm9jdXNSaW5nfVxuICAgICAgICAgICAgICAgIGRyYXdIZWFkZXI9e3AuZHJhd0hlYWRlcn1cbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWw9e3AuZXhwZXJpbWVudGFsfVxuICAgICAgICAgICAgICAgIGdyaWRSZWY9e3AuZ3JpZFJlZn1cbiAgICAgICAgICAgICAgICBoZWFkZXJJY29ucz17cC5oZWFkZXJJY29uc31cbiAgICAgICAgICAgICAgICBpc0RyYWdnYWJsZT17cC5pc0RyYWdnYWJsZX1cbiAgICAgICAgICAgICAgICBvbkNhbnZhc0JsdXI9e3Aub25DYW52YXNCbHVyfVxuICAgICAgICAgICAgICAgIG9uQ2FudmFzRm9jdXNlZD17cC5vbkNhbnZhc0ZvY3VzZWR9XG4gICAgICAgICAgICAgICAgb25DZWxsRm9jdXNlZD17cC5vbkNlbGxGb2N1c2VkfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e3Aub25Db2x1bW5Nb3ZlZH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17cC5vbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZUVuZD17cC5vbkNvbHVtblJlc2l6ZUVuZH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZVN0YXJ0PXtwLm9uQ29sdW1uUmVzaXplU3RhcnR9XG4gICAgICAgICAgICAgICAgb25Db250ZXh0TWVudT17cC5vbkNvbnRleHRNZW51fVxuICAgICAgICAgICAgICAgIG9uRHJhZ0VuZD17cC5vbkRyYWdFbmR9XG4gICAgICAgICAgICAgICAgb25EcmFnTGVhdmU9e3Aub25EcmFnTGVhdmV9XG4gICAgICAgICAgICAgICAgb25EcmFnT3ZlckNlbGw9e3Aub25EcmFnT3ZlckNlbGx9XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e3Aub25EcmFnU3RhcnR9XG4gICAgICAgICAgICAgICAgb25Ecm9wPXtwLm9uRHJvcH1cbiAgICAgICAgICAgICAgICBvbkl0ZW1Ib3ZlcmVkPXtwLm9uSXRlbUhvdmVyZWR9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXtwLm9uS2V5RG93bn1cbiAgICAgICAgICAgICAgICBvbktleVVwPXtwLm9uS2V5VXB9XG4gICAgICAgICAgICAgICAgb25Nb3VzZURvd249e3Aub25Nb3VzZURvd259XG4gICAgICAgICAgICAgICAgb25Nb3VzZVVwPXtwLm9uTW91c2VVcH1cbiAgICAgICAgICAgICAgICBvblJvd01vdmVkPXtwLm9uUm93TW92ZWR9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17cC5zbW9vdGhTY3JvbGxYfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3Auc21vb3RoU2Nyb2xsWX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvSW5maW5pdGVTY3JvbGxlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR3JpZFNjcm9sbGVyO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/stories/story-utils.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".bheiboo{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100vh;width:100vw;position:relative;}.bheiboo > .content{display:block;width:var(--bheiboo-0);height:var(--bheiboo-1);-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;position:relative;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:border-box;}.bheiboo > .content *,.bheiboo > .content *::before,.bheiboo > .content *::after{box-sizing:inherit;}\n.s15ez7jv{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s15ez7jv *,.s15ez7jv *::before,.s15ez7jv *::after{box-sizing:inherit;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc3Rvcmllcy9zdG9yeS11dGlscy50c3giXSwibmFtZXMiOlsiLmJoZWlib28iLCIuczE1ZXo3anYiXSwibWFwcGluZ3MiOiJBQWF1QkE7QUFnQ0RDIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc3Rvcmllcy9zdG9yeS11dGlscy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHR5cGUgeyBTdG9yeUNvbnRleHQgfSBmcm9tIFwiQHN0b3J5Ym9vay9hZGRvbnNcIjtcbmltcG9ydCBcInJlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL3N0eWxlcy9jYXJvdXNlbC5taW4uY3NzXCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICB1c2VNb3JlVG9wUGFkZGluZz86IGJvb2xlYW47XG4gICAgZmlnbWFEb2M/OiBzdHJpbmc7XG4gICAgY29udGV4dD86IFN0b3J5Q29udGV4dDtcbn1cblxuY29uc3QgQnVpbGRlcldyYXBwZXIgPSBzdHlsZWQuZGl2PFBpY2s8UHJvcHMsIFwid2lkdGhcIiB8IFwiaGVpZ2h0XCI+PmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICYgPiAuY29udGVudCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuXG4gICAgICAgIHdpZHRoOiAke3AgPT4gcC53aWR0aH1weDtcbiAgICAgICAgaGVpZ2h0OiAke3AgPT4gcC5oZWlnaHR9cHg7XG4gICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcblxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAgICAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcbiAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG5cbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuXG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAgICAgKixcbiAgICAgICAgKjo6YmVmb3JlLFxuICAgICAgICAqOjphZnRlciB7XG4gICAgICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xuICAgICAgICB9XG4gICAgfVxuYDtcblxuY29uc3QgU2ltcGxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gICAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAqLFxuICAgICo6OmJlZm9yZSxcbiAgICAqOjphZnRlciB7XG4gICAgICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNsYXNzIEJ1aWxkZXJUaGVtZVdyYXBwZXIgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPFByb3BzPj4ge1xuICAgIHB1YmxpYyByZW5kZXIoKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPEJ1aWxkZXJXcmFwcGVyIHsuLi5yZXN0fT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e2NoaWxkcmVufTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvQnVpbGRlcldyYXBwZXI+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cInBvcnRhbFwiIC8+XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/stories/story-utils.tsx","webpack://./packages/core/src/stories/story-utils.tsx"],"names":[".bheiboo",".s15ez7jv"],"mappings":"AAauBA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oBAAAA,aAAAA,CAAAA,sBAAAA,CAAAA,uBAAAA,CAAAA,yBAAAA,CAAAA,0BAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,yCAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,gBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,iFAAAA,kBAAAA,CAAAA;AAgCDC,UAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,mDAAAA,kBAAAA,CAAAA;AC3CtB,26FAA26F","sourcesContent":["import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport type { StoryContext } from \"@storybook/addons\";\nimport \"react-responsive-carousel/lib/styles/carousel.min.css\";\n\ninterface Props {\n    width: number;\n    height: number;\n    useMoreTopPadding?: boolean;\n    figmaDoc?: string;\n    context?: StoryContext;\n}\n\nconst BuilderWrapper = styled.div<Pick<Props, \"width\" | \"height\">>`\n    display: flex;\n    height: 100vh;\n    width: 100vw;\n    position: relative;\n\n    & > .content {\n        display: block;\n\n        width: ${p => p.width}px;\n        height: ${p => p.height}px;\n        align-self: center;\n\n        position: relative;\n\n        text-rendering: optimizeLegibility;\n        -webkit-font-smoothing: antialiased;\n\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n\n        user-select: none;\n\n        box-sizing: border-box;\n\n        *,\n        *::before,\n        *::after {\n            box-sizing: inherit;\n        }\n    }\n`;\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nexport class BuilderThemeWrapper extends React.PureComponent<React.PropsWithChildren<Props>> {\n    public render(): React.ReactNode {\n        const { context, children, ...rest } = this.props;\n        return (\n            <>\n                <BuilderWrapper {...rest}>\n                    <div className=\"content\">{children}</div>\n                </BuilderWrapper>\n                <div id=\"portal\" />\n            </>\n        );\n    }\n}\n\nexport const SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n",".bheiboo{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100vh;width:100vw;position:relative;}.bheiboo > .content{display:block;width:var(--bheiboo-0);height:var(--bheiboo-1);-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;position:relative;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:border-box;}.bheiboo > .content *,.bheiboo > .content *::before,.bheiboo > .content *::after{box-sizing:inherit;}\n.s15ez7jv{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s15ez7jv *,.s15ez7jv *::before,.s15ez7jv *::after{box-sizing:inherit;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc3Rvcmllcy9zdG9yeS11dGlscy50c3giXSwibmFtZXMiOlsiLmJoZWlib28iLCIuczE1ZXo3anYiXSwibWFwcGluZ3MiOiJBQWF1QkE7QUFnQ0RDIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvY29yZS9zcmMvc3Rvcmllcy9zdG9yeS11dGlscy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHR5cGUgeyBTdG9yeUNvbnRleHQgfSBmcm9tIFwiQHN0b3J5Ym9vay9hZGRvbnNcIjtcbmltcG9ydCBcInJlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL3N0eWxlcy9jYXJvdXNlbC5taW4uY3NzXCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICB1c2VNb3JlVG9wUGFkZGluZz86IGJvb2xlYW47XG4gICAgZmlnbWFEb2M/OiBzdHJpbmc7XG4gICAgY29udGV4dD86IFN0b3J5Q29udGV4dDtcbn1cblxuY29uc3QgQnVpbGRlcldyYXBwZXIgPSBzdHlsZWQuZGl2PFBpY2s8UHJvcHMsIFwid2lkdGhcIiB8IFwiaGVpZ2h0XCI+PmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICYgPiAuY29udGVudCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuXG4gICAgICAgIHdpZHRoOiAke3AgPT4gcC53aWR0aH1weDtcbiAgICAgICAgaGVpZ2h0OiAke3AgPT4gcC5oZWlnaHR9cHg7XG4gICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcblxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAgICAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcbiAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG5cbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuXG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAgICAgKixcbiAgICAgICAgKjo6YmVmb3JlLFxuICAgICAgICAqOjphZnRlciB7XG4gICAgICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xuICAgICAgICB9XG4gICAgfVxuYDtcblxuY29uc3QgU2ltcGxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gICAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAqLFxuICAgICo6OmJlZm9yZSxcbiAgICAqOjphZnRlciB7XG4gICAgICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNsYXNzIEJ1aWxkZXJUaGVtZVdyYXBwZXIgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPFByb3BzPj4ge1xuICAgIHB1YmxpYyByZW5kZXIoKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPEJ1aWxkZXJXcmFwcGVyIHsuLi5yZXN0fT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e2NoaWxkcmVufTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvQnVpbGRlcldyYXBwZXI+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cInBvcnRhbFwiIC8+XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/source/src/stories/use-data-source.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".ss4kmn3{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.ss4kmn3 *,.ss4kmn3 *::before,.ss4kmn3 *::after{box-sizing:inherit;}\n.bkh67gx{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.bkh67gx > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.bkh67gx .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.bkh67gx .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\n.d1deot3s{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.m1ml0sw1{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.m1ml0sw1 button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvc291cmNlL3NyYy9zdG9yaWVzL3VzZS1kYXRhLXNvdXJjZS5zdG9yaWVzLnRzeCJdLCJuYW1lcyI6WyIuc3M0a21uMyIsIi5ia2g2N2d4IiwiLmQxZGVvdDNzIiwiLm0xbWwwc3cxIl0sIm1hcHBpbmdzIjoiQUEwQnNCQTtBQWlDQ0M7QUFvRUhDO0FBTUlDIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvc291cmNlL3NyYy9zdG9yaWVzL3VzZS1kYXRhLXNvdXJjZS5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgLy8gQHRzLW5vY2hlY2tcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIF9fU1RPUllfXyA9IFwiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcXFwiQGxpbmFyaWEvcmVhY3RcXFwiO1xcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXFxcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclxcXCI7XFxuaW1wb3J0IHtcXG4gICAgRGF0YUVkaXRvcixcXG4gICAgRGF0YUVkaXRvclByb3BzLFxcbiAgICBEYXRhRWRpdG9yUmVmLFxcbiAgICBHcmlkQ2VsbEtpbmQsXFxuICAgIEdyaWRDb2x1bW4sXFxuICAgIFRoZW1lLFxcbn0gZnJvbSBcXFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCBmYWtlciBmcm9tIFxcXCJmYWtlclxcXCI7XFxuaW1wb3J0IHsgdXNlQ29sbGFwc2luZ0dyb3VwcywgdXNlQ29sdW1uU29ydCwgdXNlTW92ZWFibGVDb2x1bW5zIH0gZnJvbSBcXFwiLi5cXFwiO1xcbmltcG9ydCB7IHVzZVVuZG9SZWRvIH0gZnJvbSBcXFwiLi4vdXNlLXVuZG8tcmVkb1xcXCI7XFxuaW1wb3J0IHsgdXNlTW9ja0RhdGFHZW5lcmF0b3IgfSBmcm9tIFxcXCIuL3V0aWxzXFxcIjtcXG5cXG5mYWtlci5zZWVkKDEzMzcpO1xcblxcbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG5cXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cXG4gICAgKixcXG4gICAgKjo6YmVmb3JlLFxcbiAgICAqOjphZnRlciB7XFxuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xcbiAgICB9XFxuYDtcXG5cXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XFxuICAgIHJldHVybiAoXFxuICAgICAgICA8U2ltcGxlV3JhcHBlcj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwiY29udGVudFxcXCI+e3AuY2hpbGRyZW59PC9kaXY+XFxuICAgICAgICA8L1NpbXBsZVdyYXBwZXI+XFxuICAgICk7XFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiRXh0cmEgUGFja2FnZXMvU291cmNlXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XFxuICAgICAgICApLFxcbiAgICBdLFxcbn07XFxuXFxuY29uc3QgQmVhdXRpZnVsU3R5bGUgPSBzdHlsZWQuZGl2YFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xcbiAgICBjb2xvcjogd2hpdGU7XFxuXFxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG5cXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuXFxuICAgICYgPiBoMSB7XFxuICAgICAgICBmb250LXNpemU6IDUwcHg7XFxuICAgICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XFxuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XFxuICAgIH1cXG5cXG4gICAgLnNpemVyIHtcXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcXG5cXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcblxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xcblxcbiAgICAgICAgLnNpemVyLWNsaXAge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxuXFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuYDtcXG5cXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xcbiAgICB0aXRsZTogc3RyaW5nO1xcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcXG59XFxuXFxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XFxuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcXG5cXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XFxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxcbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXItY2xpcFxcXCIgcmVmPXtyZWZ9PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPz8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cXG4gICAgKTtcXG59O1xcblxcbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXFxuICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcXG5gO1xcblxcbmV4cG9ydCBjb25zdCBNb3JlSW5mbyA9IHN0eWxlZC5wYFxcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XFxuXFxuICAgIGJ1dHRvbiB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XFxuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IDBweCAxcHggMnB4ICMwMDAwMDA0MDtcXG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcXG4gICAgICAgIGJvcmRlcjogbm9uZTtcXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgfVxcbmA7XFxuXFxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XFxuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXFxuICAgIHNtb290aFNjcm9sbFk6IHRydWUsXFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcXG4gICAgcm93TWFya2VyczogXFxcIm5vbmVcXFwiLFxcbiAgICB3aWR0aDogXFxcIjEwMCVcXFwiLFxcbn07XFxuXFxuY29uc3QgdGVzdFRoZW1lOiBUaGVtZSA9IHtcXG4gICAgYWNjZW50Q29sb3I6IFxcXCIjNEY1REZGXFxcIixcXG4gICAgYWNjZW50Rmc6IFxcXCIjRkZGRkZGXFxcIixcXG4gICAgYWNjZW50TGlnaHQ6IFxcXCJyZ2JhKDYyLCAxMTYsIDI1MywgMC4xKVxcXCIsXFxuXFxuICAgIHRleHREYXJrOiBcXFwiIzMxMzEzOVxcXCIsXFxuICAgIHRleHRNZWRpdW06IFxcXCIjNzM3MzgzXFxcIixcXG4gICAgdGV4dExpZ2h0OiBcXFwiI0IyQjJDMFxcXCIsXFxuICAgIHRleHRCdWJibGU6IFxcXCIjMzEzMTM5XFxcIixcXG5cXG4gICAgYmdJY29uSGVhZGVyOiBcXFwiIzczNzM4M1xcXCIsXFxuICAgIGZnSWNvbkhlYWRlcjogXFxcIiNGRkZGRkZcXFwiLFxcbiAgICB0ZXh0SGVhZGVyOiBcXFwiIzMxMzEzOVxcXCIsXFxuICAgIHRleHRHcm91cEhlYWRlcjogXFxcIiMzMTMxMzlCQlxcXCIsXFxuICAgIHRleHRIZWFkZXJTZWxlY3RlZDogXFxcIiNGRkZGRkZcXFwiLFxcblxcbiAgICBiZ0NlbGw6IFxcXCIjRkZGRkZGXFxcIixcXG4gICAgYmdDZWxsTWVkaXVtOiBcXFwiI0ZBRkFGQlxcXCIsXFxuICAgIGJnSGVhZGVyOiBcXFwiI0Y3RjdGOFxcXCIsXFxuICAgIGJnSGVhZGVySGFzRm9jdXM6IFxcXCIjRTlFOUVCXFxcIixcXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcXFwiI0VGRUZGMVxcXCIsXFxuXFxuICAgIGJnQnViYmxlOiBcXFwiI0VERURGM1xcXCIsXFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFxcXCIjRkZGRkZGXFxcIixcXG5cXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFxcXCIjZmZmOWUzXFxcIixcXG5cXG4gICAgYm9yZGVyQ29sb3I6IFxcXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXFxcIixcXG4gICAgaG9yaXpvbnRhbEJvcmRlckNvbG9yOiBcXFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVxcXCIsXFxuICAgIGRyaWxsZG93bkJvcmRlcjogXFxcInJnYmEoMCwgMCwgMCwgMClcXFwiLFxcblxcbiAgICBsaW5rQ29sb3I6IFxcXCIjNEY1REZGXFxcIixcXG5cXG4gICAgY2VsbEhvcml6b250YWxQYWRkaW5nOiA4LFxcbiAgICBjZWxsVmVydGljYWxQYWRkaW5nOiAzLFxcblxcbiAgICBoZWFkZXJGb250U3R5bGU6IFxcXCI2MDAgMTNweFxcXCIsXFxuICAgIGJhc2VGb250U3R5bGU6IFxcXCIxM3B4XFxcIixcXG4gICAgZWRpdG9yRm9udFNpemU6IFxcXCIxM3B4XFxcIixcXG4gICAgbGluZUhlaWdodDogMS40LFxcbiAgICBmb250RmFtaWx5OlxcbiAgICAgICAgXFxcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcXFwiLFxcbn07XFxuXFxuY29uc3QgY29sczogR3JpZENvbHVtbltdID0gW1xcbiAgICB7XFxuICAgICAgICB0aXRsZTogXFxcIkFcXFwiLFxcbiAgICAgICAgd2lkdGg6IDIwMCxcXG4gICAgICAgIGdyb3VwOiBcXFwiR3JvdXAgMVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRpdGxlOiBcXFwiQlxcXCIsXFxuICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgZ3JvdXA6IFxcXCJHcm91cCAxXFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGl0bGU6IFxcXCJDXFxcIixcXG4gICAgICAgIHdpZHRoOiAyMDAsXFxuICAgICAgICBncm91cDogXFxcIkdyb3VwIDJcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0aXRsZTogXFxcIkRcXFwiLFxcbiAgICAgICAgd2lkdGg6IDIwMCxcXG4gICAgICAgIGdyb3VwOiBcXFwiR3JvdXAgMlxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRpdGxlOiBcXFwiRVxcXCIsXFxuICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgZ3JvdXA6IFxcXCJHcm91cCAyXFxcIixcXG4gICAgfSxcXG5dO1xcblxcbmV4cG9ydCBjb25zdCBVc2VEYXRhU291cmNlOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KTtcXG5cXG4gICAgY29uc3Qgcm93cyA9IDEwMF8wMDA7XFxuXFxuICAgIGNvbnN0IG1vdmVBcmdzID0gdXNlTW92ZWFibGVDb2x1bW5zKHtcXG4gICAgICAgIGNvbHVtbnM6IGNvbHMsXFxuICAgICAgICBnZXRDZWxsQ29udGVudDogUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd10pID0+IHtcXG4gICAgICAgICAgICBpZiAoY29sID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd31gLFxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGAke3Jvd31gLFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtjb2x9LCR7cm93fWA7XFxuICAgICAgICAgICAgaWYgKGNhY2hlLmN1cnJlbnRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnRba2V5XSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCkgKyBcXFwiIFxcXCIgKyBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGQgPSBjYWNoZS5jdXJyZW50W2tleV07XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGQsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0sIFtdKSxcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IFtzb3J0LCBzZXRTb3J0XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oKTtcXG5cXG4gICAgY29uc3Qgc29ydEFyZ3MgPSB1c2VDb2x1bW5Tb3J0KHtcXG4gICAgICAgIGNvbHVtbnM6IG1vdmVBcmdzLmNvbHVtbnMsXFxuICAgICAgICBnZXRDZWxsQ29udGVudDogbW92ZUFyZ3MuZ2V0Q2VsbENvbnRlbnQsXFxuICAgICAgICByb3dzLFxcbiAgICAgICAgc29ydDpcXG4gICAgICAgICAgICBzb3J0ID09PSB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgOiB7XFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbW92ZUFyZ3MuY29sdW1uc1tzb3J0XSxcXG4gICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcXFwiZGVzY1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFxcXCJzbWFydFxcXCIsXFxuICAgICAgICAgICAgICAgICAgfSxcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IGNvbGxhcHNlQXJncyA9IHVzZUNvbGxhcHNpbmdHcm91cHMoe1xcbiAgICAgICAgY29sdW1uczogbW92ZUFyZ3MuY29sdW1ucyxcXG4gICAgICAgIHRoZW1lOiB0ZXN0VGhlbWUsXFxuICAgICAgICBmcmVlemVDb2x1bW5zOiAwLFxcbiAgICB9KTtcXG5cXG4gICAgY29uc3Qgb25IZWFkZXJDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7XFxuICAgICAgICBzZXRTb3J0KGluZGV4KTtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XFxcIkN1c3RvbSBzb3VyY2UgZXh0ZW5zaW9uc1xcXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5GaXhtZS48L0Rlc2NyaXB0aW9uPn0+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cXG4gICAgICAgICAgICAgICAgey4uLm1vdmVBcmdzfVxcbiAgICAgICAgICAgICAgICB7Li4uc29ydEFyZ3N9XFxuICAgICAgICAgICAgICAgIHsuLi5jb2xsYXBzZUFyZ3N9XFxuICAgICAgICAgICAgICAgIHJvd3M9e3Jvd3N9XFxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e21vdmVBcmdzLm9uQ29sdW1uTW92ZWR9XFxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja31cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxcbiAgICApO1xcbn07XFxuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXFxuZXhwb3J0IGNvbnN0IFVuZG9SZWRvOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IHsgY29sczogY29sdW1ucywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNik7XFxuXFxuICAgIGNvbnN0IGdyaWRSZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XFxuXFxuICAgIGNvbnN0IHsgZ3JpZFNlbGVjdGlvbiwgb25DZWxsRWRpdGVkLCBvbkdyaWRTZWxlY3Rpb25DaGFuZ2UsIHVuZG8sIGNhblJlZG8sIGNhblVuZG8sIHJlZG8gfSA9IHVzZVVuZG9SZWRvKFxcbiAgICAgICAgZ3JpZFJlZixcXG4gICAgICAgIGdldENlbGxDb250ZW50LFxcbiAgICAgICAgc2V0Q2VsbFZhbHVlXFxuICAgICk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxcbiAgICAgICAgICAgIHRpdGxlPVxcXCJVbmRvIC8gUmVkbyBTdXBwb3J0XFxcIlxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcXG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgQSBzaW1wbGUgdW5kby9yZWRvIGltcGxlbWVudGF0aW9uXFxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgVXNlIGtleWJvYXJkIHNob3J0Y3V0cyBDTUQrWiBhbmQgQ01EK1NISUZUK1ogLyBDVFJMK1ogYW5kIENUUkwrWS4gT3IgY2xpY2sgdGhlc2UgYnV0dG9uczpcXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3VuZG99IGRpc2FibGVkPXshY2FuVW5kb30gc3R5bGU9e3sgb3BhY2l0eTogY2FuVW5kbyA/IDEgOiAwLjQgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVuZG9cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3JlZG99IGRpc2FibGVkPXshY2FuUmVkb30gc3R5bGU9e3sgb3BhY2l0eTogY2FuUmVkbyA/IDEgOiAwLjQgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZG9cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgSXQgd29ya3MgYnkgdGFraW5nIGEgc25hcHNob3Qgb2YgdGhlIGNvbnRlbnQgb2YgYSBjZWxsIGJlZm9yZSBpdCBpcyBlZGl0ZWQgYW5kIHJlcGxheWluZyBhbnlcXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0cyBiYWNrLlxcbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cXG4gICAgICAgICAgICB9PlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XFxuICAgICAgICAgICAgICAgIHJlZj17Z3JpZFJlZn1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtvbkNlbGxFZGl0ZWR9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICAgICAgZ3JpZFNlbGVjdGlvbj17Z3JpZFNlbGVjdGlvbiA/PyB1bmRlZmluZWR9XFxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17b25HcmlkU2VsZWN0aW9uQ2hhbmdlfVxcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XFxuICAgICk7XFxufTtcXG4oVW5kb1JlZG8gYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX0xPQ0FUSU9OU19NQVBfXyA9IHtcIlVzZURhdGFTb3VyY2VcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjQwLFwibGluZVwiOjIyNX0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjI5Nn0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo0MCxcImxpbmVcIjoyMjV9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6Mjk2fX0sXCJVbmRvUmVkb1wiOntcInN0YXJ0TG9jXCI6e1wiY29sXCI6MzUsXCJsaW5lXCI6MzAzfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6MzQ3fSxcInN0YXJ0Qm9keVwiOntcImNvbFwiOjM1LFwibGluZVwiOjMwM30sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjozNDd9fX07XG4gICAgXG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUmVzaXplRGV0ZWN0b3IgfSBmcm9tIFwicmVhY3QtcmVzaXplLWRldGVjdG9yXCI7XG5pbXBvcnQge1xuICAgIERhdGFFZGl0b3IsXG4gICAgRGF0YUVkaXRvclByb3BzLFxuICAgIERhdGFFZGl0b3JSZWYsXG4gICAgR3JpZENlbGxLaW5kLFxuICAgIEdyaWRDb2x1bW4sXG4gICAgVGhlbWUsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IGZha2VyIGZyb20gXCJmYWtlclwiO1xuaW1wb3J0IHsgdXNlQ29sbGFwc2luZ0dyb3VwcywgdXNlQ29sdW1uU29ydCwgdXNlTW92ZWFibGVDb2x1bW5zIH0gZnJvbSBcIi4uXCI7XG5pbXBvcnQgeyB1c2VVbmRvUmVkbyB9IGZyb20gXCIuLi91c2UtdW5kby1yZWRvXCI7XG5pbXBvcnQgeyB1c2VNb2NrRGF0YUdlbmVyYXRvciB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmZha2VyLnNlZWQoMTMzNyk7XG5cbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG5cbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgKixcbiAgICAqOjpiZWZvcmUsXG4gICAgKjo6YWZ0ZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xuICAgIH1cbmA7XG5cbmNvbnN0IFNpbXBsZVRoZW1lV3JhcHBlcjogUmVhY3QuRkMgPSBwID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8U2ltcGxlV3JhcHBlcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGVudFwiPntwLmNoaWxkcmVufTwvZGl2PlxuICAgICAgICA8L1NpbXBsZVdyYXBwZXI+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtwYXJhbWV0ZXJzOiB7XCJzdG9yeVNvdXJjZVwiOntcInNvdXJjZVwiOlwiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcXFwiQGxpbmFyaWEvcmVhY3RcXFwiO1xcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXFxcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclxcXCI7XFxuaW1wb3J0IHtcXG4gICAgRGF0YUVkaXRvcixcXG4gICAgRGF0YUVkaXRvclByb3BzLFxcbiAgICBEYXRhRWRpdG9yUmVmLFxcbiAgICBHcmlkQ2VsbEtpbmQsXFxuICAgIEdyaWRDb2x1bW4sXFxuICAgIFRoZW1lLFxcbn0gZnJvbSBcXFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCBmYWtlciBmcm9tIFxcXCJmYWtlclxcXCI7XFxuaW1wb3J0IHsgdXNlQ29sbGFwc2luZ0dyb3VwcywgdXNlQ29sdW1uU29ydCwgdXNlTW92ZWFibGVDb2x1bW5zIH0gZnJvbSBcXFwiLi5cXFwiO1xcbmltcG9ydCB7IHVzZVVuZG9SZWRvIH0gZnJvbSBcXFwiLi4vdXNlLXVuZG8tcmVkb1xcXCI7XFxuaW1wb3J0IHsgdXNlTW9ja0RhdGFHZW5lcmF0b3IgfSBmcm9tIFxcXCIuL3V0aWxzXFxcIjtcXG5cXG5mYWtlci5zZWVkKDEzMzcpO1xcblxcbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG5cXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cXG4gICAgKixcXG4gICAgKjo6YmVmb3JlLFxcbiAgICAqOjphZnRlciB7XFxuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xcbiAgICB9XFxuYDtcXG5cXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XFxuICAgIHJldHVybiAoXFxuICAgICAgICA8U2ltcGxlV3JhcHBlcj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwiY29udGVudFxcXCI+e3AuY2hpbGRyZW59PC9kaXY+XFxuICAgICAgICA8L1NpbXBsZVdyYXBwZXI+XFxuICAgICk7XFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiRXh0cmEgUGFja2FnZXMvU291cmNlXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XFxuICAgICAgICApLFxcbiAgICBdLFxcbn07XFxuXFxuY29uc3QgQmVhdXRpZnVsU3R5bGUgPSBzdHlsZWQuZGl2YFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xcbiAgICBjb2xvcjogd2hpdGU7XFxuXFxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG5cXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuXFxuICAgICYgPiBoMSB7XFxuICAgICAgICBmb250LXNpemU6IDUwcHg7XFxuICAgICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XFxuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XFxuICAgIH1cXG5cXG4gICAgLnNpemVyIHtcXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcXG5cXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcblxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xcblxcbiAgICAgICAgLnNpemVyLWNsaXAge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxuXFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuYDtcXG5cXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xcbiAgICB0aXRsZTogc3RyaW5nO1xcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcXG59XFxuXFxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XFxuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcXG5cXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XFxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxcbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXItY2xpcFxcXCIgcmVmPXtyZWZ9PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPz8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cXG4gICAgKTtcXG59O1xcblxcbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXFxuICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcXG5gO1xcblxcbmV4cG9ydCBjb25zdCBNb3JlSW5mbyA9IHN0eWxlZC5wYFxcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XFxuXFxuICAgIGJ1dHRvbiB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XFxuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IDBweCAxcHggMnB4ICMwMDAwMDA0MDtcXG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcXG4gICAgICAgIGJvcmRlcjogbm9uZTtcXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgfVxcbmA7XFxuXFxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XFxuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXFxuICAgIHNtb290aFNjcm9sbFk6IHRydWUsXFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcXG4gICAgcm93TWFya2VyczogXFxcIm5vbmVcXFwiLFxcbiAgICB3aWR0aDogXFxcIjEwMCVcXFwiLFxcbn07XFxuXFxuY29uc3QgdGVzdFRoZW1lOiBUaGVtZSA9IHtcXG4gICAgYWNjZW50Q29sb3I6IFxcXCIjNEY1REZGXFxcIixcXG4gICAgYWNjZW50Rmc6IFxcXCIjRkZGRkZGXFxcIixcXG4gICAgYWNjZW50TGlnaHQ6IFxcXCJyZ2JhKDYyLCAxMTYsIDI1MywgMC4xKVxcXCIsXFxuXFxuICAgIHRleHREYXJrOiBcXFwiIzMxMzEzOVxcXCIsXFxuICAgIHRleHRNZWRpdW06IFxcXCIjNzM3MzgzXFxcIixcXG4gICAgdGV4dExpZ2h0OiBcXFwiI0IyQjJDMFxcXCIsXFxuICAgIHRleHRCdWJibGU6IFxcXCIjMzEzMTM5XFxcIixcXG5cXG4gICAgYmdJY29uSGVhZGVyOiBcXFwiIzczNzM4M1xcXCIsXFxuICAgIGZnSWNvbkhlYWRlcjogXFxcIiNGRkZGRkZcXFwiLFxcbiAgICB0ZXh0SGVhZGVyOiBcXFwiIzMxMzEzOVxcXCIsXFxuICAgIHRleHRHcm91cEhlYWRlcjogXFxcIiMzMTMxMzlCQlxcXCIsXFxuICAgIHRleHRIZWFkZXJTZWxlY3RlZDogXFxcIiNGRkZGRkZcXFwiLFxcblxcbiAgICBiZ0NlbGw6IFxcXCIjRkZGRkZGXFxcIixcXG4gICAgYmdDZWxsTWVkaXVtOiBcXFwiI0ZBRkFGQlxcXCIsXFxuICAgIGJnSGVhZGVyOiBcXFwiI0Y3RjdGOFxcXCIsXFxuICAgIGJnSGVhZGVySGFzRm9jdXM6IFxcXCIjRTlFOUVCXFxcIixcXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcXFwiI0VGRUZGMVxcXCIsXFxuXFxuICAgIGJnQnViYmxlOiBcXFwiI0VERURGM1xcXCIsXFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFxcXCIjRkZGRkZGXFxcIixcXG5cXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFxcXCIjZmZmOWUzXFxcIixcXG5cXG4gICAgYm9yZGVyQ29sb3I6IFxcXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXFxcIixcXG4gICAgaG9yaXpvbnRhbEJvcmRlckNvbG9yOiBcXFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVxcXCIsXFxuICAgIGRyaWxsZG93bkJvcmRlcjogXFxcInJnYmEoMCwgMCwgMCwgMClcXFwiLFxcblxcbiAgICBsaW5rQ29sb3I6IFxcXCIjNEY1REZGXFxcIixcXG5cXG4gICAgY2VsbEhvcml6b250YWxQYWRkaW5nOiA4LFxcbiAgICBjZWxsVmVydGljYWxQYWRkaW5nOiAzLFxcblxcbiAgICBoZWFkZXJGb250U3R5bGU6IFxcXCI2MDAgMTNweFxcXCIsXFxuICAgIGJhc2VGb250U3R5bGU6IFxcXCIxM3B4XFxcIixcXG4gICAgZWRpdG9yRm9udFNpemU6IFxcXCIxM3B4XFxcIixcXG4gICAgbGluZUhlaWdodDogMS40LFxcbiAgICBmb250RmFtaWx5OlxcbiAgICAgICAgXFxcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcXFwiLFxcbn07XFxuXFxuY29uc3QgY29sczogR3JpZENvbHVtbltdID0gW1xcbiAgICB7XFxuICAgICAgICB0aXRsZTogXFxcIkFcXFwiLFxcbiAgICAgICAgd2lkdGg6IDIwMCxcXG4gICAgICAgIGdyb3VwOiBcXFwiR3JvdXAgMVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRpdGxlOiBcXFwiQlxcXCIsXFxuICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgZ3JvdXA6IFxcXCJHcm91cCAxXFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGl0bGU6IFxcXCJDXFxcIixcXG4gICAgICAgIHdpZHRoOiAyMDAsXFxuICAgICAgICBncm91cDogXFxcIkdyb3VwIDJcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0aXRsZTogXFxcIkRcXFwiLFxcbiAgICAgICAgd2lkdGg6IDIwMCxcXG4gICAgICAgIGdyb3VwOiBcXFwiR3JvdXAgMlxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRpdGxlOiBcXFwiRVxcXCIsXFxuICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgZ3JvdXA6IFxcXCJHcm91cCAyXFxcIixcXG4gICAgfSxcXG5dO1xcblxcbmV4cG9ydCBjb25zdCBVc2VEYXRhU291cmNlOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KTtcXG5cXG4gICAgY29uc3Qgcm93cyA9IDEwMF8wMDA7XFxuXFxuICAgIGNvbnN0IG1vdmVBcmdzID0gdXNlTW92ZWFibGVDb2x1bW5zKHtcXG4gICAgICAgIGNvbHVtbnM6IGNvbHMsXFxuICAgICAgICBnZXRDZWxsQ29udGVudDogUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd10pID0+IHtcXG4gICAgICAgICAgICBpZiAoY29sID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd31gLFxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGAke3Jvd31gLFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtjb2x9LCR7cm93fWA7XFxuICAgICAgICAgICAgaWYgKGNhY2hlLmN1cnJlbnRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnRba2V5XSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCkgKyBcXFwiIFxcXCIgKyBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGQgPSBjYWNoZS5jdXJyZW50W2tleV07XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGQsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0sIFtdKSxcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IFtzb3J0LCBzZXRTb3J0XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oKTtcXG5cXG4gICAgY29uc3Qgc29ydEFyZ3MgPSB1c2VDb2x1bW5Tb3J0KHtcXG4gICAgICAgIGNvbHVtbnM6IG1vdmVBcmdzLmNvbHVtbnMsXFxuICAgICAgICBnZXRDZWxsQ29udGVudDogbW92ZUFyZ3MuZ2V0Q2VsbENvbnRlbnQsXFxuICAgICAgICByb3dzLFxcbiAgICAgICAgc29ydDpcXG4gICAgICAgICAgICBzb3J0ID09PSB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgOiB7XFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbW92ZUFyZ3MuY29sdW1uc1tzb3J0XSxcXG4gICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcXFwiZGVzY1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFxcXCJzbWFydFxcXCIsXFxuICAgICAgICAgICAgICAgICAgfSxcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IGNvbGxhcHNlQXJncyA9IHVzZUNvbGxhcHNpbmdHcm91cHMoe1xcbiAgICAgICAgY29sdW1uczogbW92ZUFyZ3MuY29sdW1ucyxcXG4gICAgICAgIHRoZW1lOiB0ZXN0VGhlbWUsXFxuICAgICAgICBmcmVlemVDb2x1bW5zOiAwLFxcbiAgICB9KTtcXG5cXG4gICAgY29uc3Qgb25IZWFkZXJDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7XFxuICAgICAgICBzZXRTb3J0KGluZGV4KTtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XFxcIkN1c3RvbSBzb3VyY2UgZXh0ZW5zaW9uc1xcXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5GaXhtZS48L0Rlc2NyaXB0aW9uPn0+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cXG4gICAgICAgICAgICAgICAgey4uLm1vdmVBcmdzfVxcbiAgICAgICAgICAgICAgICB7Li4uc29ydEFyZ3N9XFxuICAgICAgICAgICAgICAgIHsuLi5jb2xsYXBzZUFyZ3N9XFxuICAgICAgICAgICAgICAgIHJvd3M9e3Jvd3N9XFxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e21vdmVBcmdzLm9uQ29sdW1uTW92ZWR9XFxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja31cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxcbiAgICApO1xcbn07XFxuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXFxuZXhwb3J0IGNvbnN0IFVuZG9SZWRvOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IHsgY29sczogY29sdW1ucywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNik7XFxuXFxuICAgIGNvbnN0IGdyaWRSZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XFxuXFxuICAgIGNvbnN0IHsgZ3JpZFNlbGVjdGlvbiwgb25DZWxsRWRpdGVkLCBvbkdyaWRTZWxlY3Rpb25DaGFuZ2UsIHVuZG8sIGNhblJlZG8sIGNhblVuZG8sIHJlZG8gfSA9IHVzZVVuZG9SZWRvKFxcbiAgICAgICAgZ3JpZFJlZixcXG4gICAgICAgIGdldENlbGxDb250ZW50LFxcbiAgICAgICAgc2V0Q2VsbFZhbHVlXFxuICAgICk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxcbiAgICAgICAgICAgIHRpdGxlPVxcXCJVbmRvIC8gUmVkbyBTdXBwb3J0XFxcIlxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcXG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgQSBzaW1wbGUgdW5kby9yZWRvIGltcGxlbWVudGF0aW9uXFxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgVXNlIGtleWJvYXJkIHNob3J0Y3V0cyBDTUQrWiBhbmQgQ01EK1NISUZUK1ogLyBDVFJMK1ogYW5kIENUUkwrWS4gT3IgY2xpY2sgdGhlc2UgYnV0dG9uczpcXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3VuZG99IGRpc2FibGVkPXshY2FuVW5kb30gc3R5bGU9e3sgb3BhY2l0eTogY2FuVW5kbyA/IDEgOiAwLjQgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVuZG9cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3JlZG99IGRpc2FibGVkPXshY2FuUmVkb30gc3R5bGU9e3sgb3BhY2l0eTogY2FuUmVkbyA/IDEgOiAwLjQgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZG9cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgSXQgd29ya3MgYnkgdGFraW5nIGEgc25hcHNob3Qgb2YgdGhlIGNvbnRlbnQgb2YgYSBjZWxsIGJlZm9yZSBpdCBpcyBlZGl0ZWQgYW5kIHJlcGxheWluZyBhbnlcXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0cyBiYWNrLlxcbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cXG4gICAgICAgICAgICB9PlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XFxuICAgICAgICAgICAgICAgIHJlZj17Z3JpZFJlZn1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtvbkNlbGxFZGl0ZWR9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICAgICAgZ3JpZFNlbGVjdGlvbj17Z3JpZFNlbGVjdGlvbiA/PyB1bmRlZmluZWR9XFxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17b25HcmlkU2VsZWN0aW9uQ2hhbmdlfVxcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XFxuICAgICk7XFxufTtcXG4oVW5kb1JlZG8gYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXCIsXCJsb2NhdGlvbnNNYXBcIjp7XCJ1c2UtZGF0YS1zb3VyY2VcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjQwLFwibGluZVwiOjIyNX0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjI5Nn0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo0MCxcImxpbmVcIjoyMjV9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6Mjk2fX0sXCJ1bmRvLXJlZG9cIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjM1LFwibGluZVwiOjMwM30sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjM0N30sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjozNSxcImxpbmVcIjozMDN9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6MzQ3fX19fSx9LFxuICAgIHRpdGxlOiBcIkV4dHJhIFBhY2thZ2VzL1NvdXJjZVwiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxTaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XG4gICAgICAgICAgICA8L1NpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgKSxcbiAgICBdLFxufTtcblxuY29uc3QgQmVhdXRpZnVsU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyNzkwYjk7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjMjc5MGI5LCAjMjA3MGE5KTtcbiAgICBjb2xvcjogd2hpdGU7XG5cbiAgICBwYWRkaW5nOiAzMnB4IDQ4cHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgaGVpZ2h0OiAxMDB2aDtcblxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuXG4gICAgJiA+IGgxIHtcbiAgICAgICAgZm9udC1zaXplOiA1MHB4O1xuICAgICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgbWFyZ2luOiAwIDAgMTJweCAwO1xuICAgIH1cblxuICAgIC5zaXplciB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweCwgcmdiYSg5LCAzMCwgNjYsIDAuMDgpIDBweCAwcHggMHB4IDFweDtcblxuICAgICAgICAuc2l6ZXItY2xpcCB7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcblxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuYDtcblxuaW50ZXJmYWNlIEJlYXV0aWZ1bFByb3BzIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5jb25zdCBCZWF1dGlmdWxXcmFwcGVyOiBSZWFjdC5GQzxCZWF1dGlmdWxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IHRpdGxlLCBjaGlsZHJlbiwgZGVzY3JpcHRpb24gfSA9IHA7XG5cbiAgICBjb25zdCB7IHJlZiwgd2lkdGgsIGhlaWdodCB9ID0gdXNlUmVzaXplRGV0ZWN0b3IoKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxTdHlsZT5cbiAgICAgICAgICAgIDxoMT57dGl0bGV9PC9oMT5cbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2l6ZXJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyLWNsaXBcIiByZWY9e3JlZn0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPz8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0ID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0JlYXV0aWZ1bFN0eWxlPlxuICAgICk7XG59O1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9IHN0eWxlZC5wYFxuICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICBmbGV4LXNocmluazogMDtcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgTW9yZUluZm8gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XG4gICAgICAgIHBhZGRpbmc6IDJweCA2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuYDtcblxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogdHJ1ZSxcbiAgICBzbW9vdGhTY3JvbGxZOiB0cnVlLFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICByb3dNYXJrZXJzOiBcIm5vbmVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG59O1xuXG5jb25zdCB0ZXN0VGhlbWU6IFRoZW1lID0ge1xuICAgIGFjY2VudENvbG9yOiBcIiM0RjVERkZcIixcbiAgICBhY2NlbnRGZzogXCIjRkZGRkZGXCIsXG4gICAgYWNjZW50TGlnaHQ6IFwicmdiYSg2MiwgMTE2LCAyNTMsIDAuMSlcIixcblxuICAgIHRleHREYXJrOiBcIiMzMTMxMzlcIixcbiAgICB0ZXh0TWVkaXVtOiBcIiM3MzczODNcIixcbiAgICB0ZXh0TGlnaHQ6IFwiI0IyQjJDMFwiLFxuICAgIHRleHRCdWJibGU6IFwiIzMxMzEzOVwiLFxuXG4gICAgYmdJY29uSGVhZGVyOiBcIiM3MzczODNcIixcbiAgICBmZ0ljb25IZWFkZXI6IFwiI0ZGRkZGRlwiLFxuICAgIHRleHRIZWFkZXI6IFwiIzMxMzEzOVwiLFxuICAgIHRleHRHcm91cEhlYWRlcjogXCIjMzEzMTM5QkJcIixcbiAgICB0ZXh0SGVhZGVyU2VsZWN0ZWQ6IFwiI0ZGRkZGRlwiLFxuXG4gICAgYmdDZWxsOiBcIiNGRkZGRkZcIixcbiAgICBiZ0NlbGxNZWRpdW06IFwiI0ZBRkFGQlwiLFxuICAgIGJnSGVhZGVyOiBcIiNGN0Y3RjhcIixcbiAgICBiZ0hlYWRlckhhc0ZvY3VzOiBcIiNFOUU5RUJcIixcbiAgICBiZ0hlYWRlckhvdmVyZWQ6IFwiI0VGRUZGMVwiLFxuXG4gICAgYmdCdWJibGU6IFwiI0VERURGM1wiLFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFwiI0ZGRkZGRlwiLFxuXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFwiI2ZmZjllM1wiLFxuXG4gICAgYm9yZGVyQ29sb3I6IFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVwiLFxuICAgIGhvcml6b250YWxCb3JkZXJDb2xvcjogXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXCIsXG4gICAgZHJpbGxkb3duQm9yZGVyOiBcInJnYmEoMCwgMCwgMCwgMClcIixcblxuICAgIGxpbmtDb2xvcjogXCIjNEY1REZGXCIsXG5cbiAgICBjZWxsSG9yaXpvbnRhbFBhZGRpbmc6IDgsXG4gICAgY2VsbFZlcnRpY2FsUGFkZGluZzogMyxcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgIGJhc2VGb250U3R5bGU6IFwiMTNweFwiLFxuICAgIGVkaXRvckZvbnRTaXplOiBcIjEzcHhcIixcbiAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgZm9udEZhbWlseTpcbiAgICAgICAgXCJJbnRlciwgUm9ib3RvLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIGF2ZW5pciBuZXh0LCBhdmVuaXIsIHNlZ29lIHVpLCBoZWx2ZXRpY2EgbmV1ZSwgaGVsdmV0aWNhLCBVYnVudHUsIG5vdG8sIGFyaWFsLCBzYW5zLXNlcmlmXCIsXG59O1xuXG5jb25zdCBjb2xzOiBHcmlkQ29sdW1uW10gPSBbXG4gICAge1xuICAgICAgICB0aXRsZTogXCJBXCIsXG4gICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIGdyb3VwOiBcIkdyb3VwIDFcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiQlwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAxXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkNcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMlwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogXCJEXCIsXG4gICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIGdyb3VwOiBcIkdyb3VwIDJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiRVwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAyXCIsXG4gICAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBVc2VEYXRhU291cmNlOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBSZWFjdC51c2VSZWY8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4oe30pO1xuXG4gICAgY29uc3Qgcm93cyA9IDEwMF8wMDA7XG5cbiAgICBjb25zdCBtb3ZlQXJncyA9IHVzZU1vdmVhYmxlQ29sdW1ucyh7XG4gICAgICAgIGNvbHVtbnM6IGNvbHMsXG4gICAgICAgIGdldENlbGxDb250ZW50OiBSZWFjdC51c2VDYWxsYmFjaygoW2NvbCwgcm93XSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd31gLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7cm93fWAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7Y29sfSwke3Jvd31gO1xuICAgICAgICAgICAgaWYgKGNhY2hlLmN1cnJlbnRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudFtrZXldID0gZmFrZXIubmFtZS5maXJzdE5hbWUoKSArIFwiIFwiICsgZmFrZXIubmFtZS5sYXN0TmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZCA9IGNhY2hlLmN1cnJlbnRba2V5XTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IFtzb3J0LCBzZXRTb3J0XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oKTtcblxuICAgIGNvbnN0IHNvcnRBcmdzID0gdXNlQ29sdW1uU29ydCh7XG4gICAgICAgIGNvbHVtbnM6IG1vdmVBcmdzLmNvbHVtbnMsXG4gICAgICAgIGdldENlbGxDb250ZW50OiBtb3ZlQXJncy5nZXRDZWxsQ29udGVudCxcbiAgICAgICAgcm93cyxcbiAgICAgICAgc29ydDpcbiAgICAgICAgICAgIHNvcnQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtb3ZlQXJncy5jb2x1bW5zW3NvcnRdLFxuICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJkZXNjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJzbWFydFwiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbGxhcHNlQXJncyA9IHVzZUNvbGxhcHNpbmdHcm91cHMoe1xuICAgICAgICBjb2x1bW5zOiBtb3ZlQXJncy5jb2x1bW5zLFxuICAgICAgICB0aGVtZTogdGVzdFRoZW1lLFxuICAgICAgICBmcmVlemVDb2x1bW5zOiAwLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25IZWFkZXJDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldFNvcnQoaW5kZXgpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyIHRpdGxlPVwiQ3VzdG9tIHNvdXJjZSBleHRlbnNpb25zXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5GaXhtZS48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLm1vdmVBcmdzfVxuICAgICAgICAgICAgICAgIHsuLi5zb3J0QXJnc31cbiAgICAgICAgICAgICAgICB7Li4uY29sbGFwc2VBcmdzfVxuICAgICAgICAgICAgICAgIHJvd3M9e3Jvd3N9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5Nb3ZlZD17bW92ZUFyZ3Mub25Db2x1bW5Nb3ZlZH1cbiAgICAgICAgICAgICAgICBvbkhlYWRlckNsaWNrZWQ9e29uSGVhZGVyQ2xpY2t9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07O1xuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFVuZG9SZWRvOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzOiBjb2x1bW5zLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIGNvbnN0IGdyaWRSZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XG5cbiAgICBjb25zdCB7IGdyaWRTZWxlY3Rpb24sIG9uQ2VsbEVkaXRlZCwgb25HcmlkU2VsZWN0aW9uQ2hhbmdlLCB1bmRvLCBjYW5SZWRvLCBjYW5VbmRvLCByZWRvIH0gPSB1c2VVbmRvUmVkbyhcbiAgICAgICAgZ3JpZFJlZixcbiAgICAgICAgZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIHNldENlbGxWYWx1ZVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJVbmRvIC8gUmVkbyBTdXBwb3J0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgc2ltcGxlIHVuZG8vcmVkbyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBVc2Uga2V5Ym9hcmQgc2hvcnRjdXRzIENNRCtaIGFuZCBDTUQrU0hJRlQrWiAvIENUUkwrWiBhbmQgQ1RSTCtZLiBPciBjbGljayB0aGVzZSBidXR0b25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXt1bmRvfSBkaXNhYmxlZD17IWNhblVuZG99IHN0eWxlPXt7IG9wYWNpdHk6IGNhblVuZG8gPyAxIDogMC40IH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVuZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtyZWRvfSBkaXNhYmxlZD17IWNhblJlZG99IHN0eWxlPXt7IG9wYWNpdHk6IGNhblJlZG8gPyAxIDogMC40IH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBJdCB3b3JrcyBieSB0YWtpbmcgYSBzbmFwc2hvdCBvZiB0aGUgY29udGVudCBvZiBhIGNlbGwgYmVmb3JlIGl0IGlzIGVkaXRlZCBhbmQgcmVwbGF5aW5nIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHMgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByZWY9e2dyaWRSZWZ9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtvbkNlbGxFZGl0ZWR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdyaWRTZWxlY3Rpb249e2dyaWRTZWxlY3Rpb24gPz8gdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17b25HcmlkU2VsZWN0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihVbmRvUmVkbyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuIl19*/", "",{"version":3,"sources":["/home/runner/work/glide-data-grid/glide-data-grid/packages/source/src/stories/use-data-source.stories.tsx","webpack://./packages/source/src/stories/use-data-source.stories.tsx"],"names":[".ss4kmn3",".bkh67gx",".d1deot3s",".m1ml0sw1"],"mappings":"AA0BsBA,SAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,gDAAAA,kBAAAA,CAAAA;AAiCCC,SAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,cAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,gBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,4BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA;AAoEHC,UAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AAMIC,UAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA;ACjIxB,2gwCAA2gwC","sourcesContent":["\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\nimport { useResizeDetector } from \\\"react-resize-detector\\\";\\nimport {\\n    DataEditor,\\n    DataEditorProps,\\n    DataEditorRef,\\n    GridCellKind,\\n    GridColumn,\\n    Theme,\\n} from \\\"@glideapps/glide-data-grid\\\";\\nimport faker from \\\"faker\\\";\\nimport { useCollapsingGroups, useColumnSort, useMoveableColumns } from \\\"..\\\";\\nimport { useUndoRedo } from \\\"../use-undo-redo\\\";\\nimport { useMockDataGenerator } from \\\"./utils\\\";\\n\\nfaker.seed(1337);\\n\\nconst SimpleWrapper = styled.div`\\n    text-rendering: optimizeLegibility;\\n    -webkit-font-smoothing: antialiased;\\n\\n    box-sizing: border-box;\\n\\n    *,\\n    *::before,\\n    *::after {\\n        box-sizing: inherit;\\n    }\\n`;\\n\\nconst SimpleThemeWrapper: React.FC = p => {\\n    return (\\n        <SimpleWrapper>\\n            <div className=\\\"content\\\">{p.children}</div>\\n        </SimpleWrapper>\\n    );\\n};\\n\\nexport default {\\n    title: \\\"Extra Packages/Source\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <Story />\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst BeautifulStyle = styled.div`\\n    background-color: #2790b9;\\n    background: linear-gradient(90deg, #2790b9, #2070a9);\\n    color: white;\\n\\n    padding: 32px 48px;\\n\\n    display: flex;\\n    flex-direction: column;\\n    height: 100vh;\\n\\n    font-family: sans-serif;\\n\\n    & > h1 {\\n        font-size: 50px;\\n        font-weight: 600;\\n        flex-shrink: 0;\\n        margin: 0 0 12px 0;\\n    }\\n\\n    .sizer {\\n        flex-grow: 1;\\n\\n        background-color: white;\\n\\n        border-radius: 12px;\\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\\n\\n        .sizer-clip {\\n            border-radius: 12px;\\n            overflow: hidden;\\n            transform: translateZ(0);\\n\\n            height: 100%;\\n        }\\n    }\\n`;\\n\\ninterface BeautifulProps {\\n    title: string;\\n    description?: React.ReactNode;\\n}\\n\\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\\n    const { title, children, description } = p;\\n\\n    const { ref, width, height } = useResizeDetector();\\n\\n    return (\\n        <BeautifulStyle>\\n            <h1>{title}</h1>\\n            {description}\\n            <div className=\\\"sizer\\\">\\n                <div className=\\\"sizer-clip\\\" ref={ref}>\\n                    <div\\n                        style={{\\n                            position: \\\"relative\\\",\\n                            width: width ?? 100,\\n                            height: height ?? 100,\\n                        }}>\\n                        {children}\\n                    </div>\\n                </div>\\n            </div>\\n        </BeautifulStyle>\\n    );\\n};\\n\\nconst Description = styled.p`\\n    font-size: 18px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n`;\\n\\nexport const MoreInfo = styled.p`\\n    font-size: 14px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n\\n    button {\\n        background-color: #f4f4f4;\\n        color: #2b2b2b;\\n        padding: 2px 6px;\\n        font-family: monospace;\\n        font-size: 14px;\\n        border-radius: 4px;\\n        box-shadow: 0px 1px 2px #00000040;\\n        margin: 0 0.1em;\\n        border: none;\\n        cursor: pointer;\\n    }\\n`;\\n\\nconst defaultProps: Partial<DataEditorProps> = {\\n    smoothScrollX: true,\\n    smoothScrollY: true,\\n    isDraggable: false,\\n    rowMarkers: \\\"none\\\",\\n    width: \\\"100%\\\",\\n};\\n\\nconst testTheme: Theme = {\\n    accentColor: \\\"#4F5DFF\\\",\\n    accentFg: \\\"#FFFFFF\\\",\\n    accentLight: \\\"rgba(62, 116, 253, 0.1)\\\",\\n\\n    textDark: \\\"#313139\\\",\\n    textMedium: \\\"#737383\\\",\\n    textLight: \\\"#B2B2C0\\\",\\n    textBubble: \\\"#313139\\\",\\n\\n    bgIconHeader: \\\"#737383\\\",\\n    fgIconHeader: \\\"#FFFFFF\\\",\\n    textHeader: \\\"#313139\\\",\\n    textGroupHeader: \\\"#313139BB\\\",\\n    textHeaderSelected: \\\"#FFFFFF\\\",\\n\\n    bgCell: \\\"#FFFFFF\\\",\\n    bgCellMedium: \\\"#FAFAFB\\\",\\n    bgHeader: \\\"#F7F7F8\\\",\\n    bgHeaderHasFocus: \\\"#E9E9EB\\\",\\n    bgHeaderHovered: \\\"#EFEFF1\\\",\\n\\n    bgBubble: \\\"#EDEDF3\\\",\\n    bgBubbleSelected: \\\"#FFFFFF\\\",\\n\\n    bgSearchResult: \\\"#fff9e3\\\",\\n\\n    borderColor: \\\"rgba(115, 116, 131, 0.16)\\\",\\n    horizontalBorderColor: \\\"rgba(115, 116, 131, 0.16)\\\",\\n    drilldownBorder: \\\"rgba(0, 0, 0, 0)\\\",\\n\\n    linkColor: \\\"#4F5DFF\\\",\\n\\n    cellHorizontalPadding: 8,\\n    cellVerticalPadding: 3,\\n\\n    headerFontStyle: \\\"600 13px\\\",\\n    baseFontStyle: \\\"13px\\\",\\n    editorFontSize: \\\"13px\\\",\\n    lineHeight: 1.4,\\n    fontFamily:\\n        \\\"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\\\",\\n};\\n\\nconst cols: GridColumn[] = [\\n    {\\n        title: \\\"A\\\",\\n        width: 200,\\n        group: \\\"Group 1\\\",\\n    },\\n    {\\n        title: \\\"B\\\",\\n        width: 200,\\n        group: \\\"Group 1\\\",\\n    },\\n    {\\n        title: \\\"C\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n    {\\n        title: \\\"D\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n    {\\n        title: \\\"E\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n];\\n\\nexport const UseDataSource: React.VFC = () => {\\n    const cache = React.useRef<Record<string, string>>({});\\n\\n    const rows = 100_000;\\n\\n    const moveArgs = useMoveableColumns({\\n        columns: cols,\\n        getCellContent: React.useCallback(([col, row]) => {\\n            if (col === 0) {\\n                return {\\n                    kind: GridCellKind.Text,\\n                    allowOverlay: true,\\n                    data: `${row}`,\\n                    displayData: `${row}`,\\n                };\\n            }\\n\\n            const key = `${col},${row}`;\\n            if (cache.current[key] === undefined) {\\n                cache.current[key] = faker.name.firstName() + \\\" \\\" + faker.name.lastName();\\n            }\\n            const d = cache.current[key];\\n\\n            return {\\n                kind: GridCellKind.Text,\\n                allowOverlay: true,\\n                data: d,\\n                displayData: d,\\n            };\\n        }, []),\\n    });\\n\\n    const [sort, setSort] = React.useState<number>();\\n\\n    const sortArgs = useColumnSort({\\n        columns: moveArgs.columns,\\n        getCellContent: moveArgs.getCellContent,\\n        rows,\\n        sort:\\n            sort === undefined\\n                ? undefined\\n                : {\\n                      column: moveArgs.columns[sort],\\n                      direction: \\\"desc\\\",\\n                      mode: \\\"smart\\\",\\n                  },\\n    });\\n\\n    const collapseArgs = useCollapsingGroups({\\n        columns: moveArgs.columns,\\n        theme: testTheme,\\n        freezeColumns: 0,\\n    });\\n\\n    const onHeaderClick = React.useCallback((index: number) => {\\n        setSort(index);\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper title=\\\"Custom source extensions\\\" description={<Description>Fixme.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                {...moveArgs}\\n                {...sortArgs}\\n                {...collapseArgs}\\n                rows={rows}\\n                onColumnMoved={moveArgs.onColumnMoved}\\n                onHeaderClicked={onHeaderClick}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(UseDataSource as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const UndoRedo: React.VFC = () => {\\n    const { cols: columns, getCellContent, setCellValue } = useMockDataGenerator(6);\\n\\n    const gridRef = React.useRef<DataEditorRef>(null);\\n\\n    const { gridSelection, onCellEdited, onGridSelectionChange, undo, canRedo, canUndo, redo } = useUndoRedo(\\n        gridRef,\\n        getCellContent,\\n        setCellValue\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Undo / Redo Support\\\"\\n            description={\\n                <Description>\\n                    A simple undo/redo implementation\\n                    <MoreInfo>\\n                        Use keyboard shortcuts CMD+Z and CMD+SHIFT+Z / CTRL+Z and CTRL+Y. Or click these buttons:\\n                        <button onClick={undo} disabled={!canUndo} style={{ opacity: canUndo ? 1 : 0.4 }}>\\n                            Undo\\n                        </button>\\n                        <button onClick={redo} disabled={!canRedo} style={{ opacity: canRedo ? 1 : 0.4 }}>\\n                            Redo\\n                        </button>\\n                    </MoreInfo>\\n                    <MoreInfo>\\n                        It works by taking a snapshot of the content of a cell before it is edited and replaying any\\n                        edits back.\\n                    </MoreInfo>\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                ref={gridRef}\\n                onCellEdited={onCellEdited}\\n                getCellContent={getCellContent}\\n                gridSelection={gridSelection ?? undefined}\\n                onGridSelectionChange={onGridSelectionChange}\\n                columns={columns}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(UndoRedo as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"UseDataSource\":{\"startLoc\":{\"col\":40,\"line\":225},\"endLoc\":{\"col\":1,\"line\":296},\"startBody\":{\"col\":40,\"line\":225},\"endBody\":{\"col\":1,\"line\":296}},\"UndoRedo\":{\"startLoc\":{\"col\":35,\"line\":303},\"endLoc\":{\"col\":1,\"line\":347},\"startBody\":{\"col\":35,\"line\":303},\"endBody\":{\"col\":1,\"line\":347}}};\n    \nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"react-resize-detector\";\nimport {\n    DataEditor,\n    DataEditorProps,\n    DataEditorRef,\n    GridCellKind,\n    GridColumn,\n    Theme,\n} from \"@glideapps/glide-data-grid\";\nimport faker from \"faker\";\nimport { useCollapsingGroups, useColumnSort, useMoveableColumns } from \"..\";\nimport { useUndoRedo } from \"../use-undo-redo\";\nimport { useMockDataGenerator } from \"./utils\";\n\nfaker.seed(1337);\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {parameters: {\"storySource\":{\"source\":\"import { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\nimport { useResizeDetector } from \\\"react-resize-detector\\\";\\nimport {\\n    DataEditor,\\n    DataEditorProps,\\n    DataEditorRef,\\n    GridCellKind,\\n    GridColumn,\\n    Theme,\\n} from \\\"@glideapps/glide-data-grid\\\";\\nimport faker from \\\"faker\\\";\\nimport { useCollapsingGroups, useColumnSort, useMoveableColumns } from \\\"..\\\";\\nimport { useUndoRedo } from \\\"../use-undo-redo\\\";\\nimport { useMockDataGenerator } from \\\"./utils\\\";\\n\\nfaker.seed(1337);\\n\\nconst SimpleWrapper = styled.div`\\n    text-rendering: optimizeLegibility;\\n    -webkit-font-smoothing: antialiased;\\n\\n    box-sizing: border-box;\\n\\n    *,\\n    *::before,\\n    *::after {\\n        box-sizing: inherit;\\n    }\\n`;\\n\\nconst SimpleThemeWrapper: React.FC = p => {\\n    return (\\n        <SimpleWrapper>\\n            <div className=\\\"content\\\">{p.children}</div>\\n        </SimpleWrapper>\\n    );\\n};\\n\\nexport default {\\n    title: \\\"Extra Packages/Source\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <Story />\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst BeautifulStyle = styled.div`\\n    background-color: #2790b9;\\n    background: linear-gradient(90deg, #2790b9, #2070a9);\\n    color: white;\\n\\n    padding: 32px 48px;\\n\\n    display: flex;\\n    flex-direction: column;\\n    height: 100vh;\\n\\n    font-family: sans-serif;\\n\\n    & > h1 {\\n        font-size: 50px;\\n        font-weight: 600;\\n        flex-shrink: 0;\\n        margin: 0 0 12px 0;\\n    }\\n\\n    .sizer {\\n        flex-grow: 1;\\n\\n        background-color: white;\\n\\n        border-radius: 12px;\\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\\n\\n        .sizer-clip {\\n            border-radius: 12px;\\n            overflow: hidden;\\n            transform: translateZ(0);\\n\\n            height: 100%;\\n        }\\n    }\\n`;\\n\\ninterface BeautifulProps {\\n    title: string;\\n    description?: React.ReactNode;\\n}\\n\\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\\n    const { title, children, description } = p;\\n\\n    const { ref, width, height } = useResizeDetector();\\n\\n    return (\\n        <BeautifulStyle>\\n            <h1>{title}</h1>\\n            {description}\\n            <div className=\\\"sizer\\\">\\n                <div className=\\\"sizer-clip\\\" ref={ref}>\\n                    <div\\n                        style={{\\n                            position: \\\"relative\\\",\\n                            width: width ?? 100,\\n                            height: height ?? 100,\\n                        }}>\\n                        {children}\\n                    </div>\\n                </div>\\n            </div>\\n        </BeautifulStyle>\\n    );\\n};\\n\\nconst Description = styled.p`\\n    font-size: 18px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n`;\\n\\nexport const MoreInfo = styled.p`\\n    font-size: 14px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n\\n    button {\\n        background-color: #f4f4f4;\\n        color: #2b2b2b;\\n        padding: 2px 6px;\\n        font-family: monospace;\\n        font-size: 14px;\\n        border-radius: 4px;\\n        box-shadow: 0px 1px 2px #00000040;\\n        margin: 0 0.1em;\\n        border: none;\\n        cursor: pointer;\\n    }\\n`;\\n\\nconst defaultProps: Partial<DataEditorProps> = {\\n    smoothScrollX: true,\\n    smoothScrollY: true,\\n    isDraggable: false,\\n    rowMarkers: \\\"none\\\",\\n    width: \\\"100%\\\",\\n};\\n\\nconst testTheme: Theme = {\\n    accentColor: \\\"#4F5DFF\\\",\\n    accentFg: \\\"#FFFFFF\\\",\\n    accentLight: \\\"rgba(62, 116, 253, 0.1)\\\",\\n\\n    textDark: \\\"#313139\\\",\\n    textMedium: \\\"#737383\\\",\\n    textLight: \\\"#B2B2C0\\\",\\n    textBubble: \\\"#313139\\\",\\n\\n    bgIconHeader: \\\"#737383\\\",\\n    fgIconHeader: \\\"#FFFFFF\\\",\\n    textHeader: \\\"#313139\\\",\\n    textGroupHeader: \\\"#313139BB\\\",\\n    textHeaderSelected: \\\"#FFFFFF\\\",\\n\\n    bgCell: \\\"#FFFFFF\\\",\\n    bgCellMedium: \\\"#FAFAFB\\\",\\n    bgHeader: \\\"#F7F7F8\\\",\\n    bgHeaderHasFocus: \\\"#E9E9EB\\\",\\n    bgHeaderHovered: \\\"#EFEFF1\\\",\\n\\n    bgBubble: \\\"#EDEDF3\\\",\\n    bgBubbleSelected: \\\"#FFFFFF\\\",\\n\\n    bgSearchResult: \\\"#fff9e3\\\",\\n\\n    borderColor: \\\"rgba(115, 116, 131, 0.16)\\\",\\n    horizontalBorderColor: \\\"rgba(115, 116, 131, 0.16)\\\",\\n    drilldownBorder: \\\"rgba(0, 0, 0, 0)\\\",\\n\\n    linkColor: \\\"#4F5DFF\\\",\\n\\n    cellHorizontalPadding: 8,\\n    cellVerticalPadding: 3,\\n\\n    headerFontStyle: \\\"600 13px\\\",\\n    baseFontStyle: \\\"13px\\\",\\n    editorFontSize: \\\"13px\\\",\\n    lineHeight: 1.4,\\n    fontFamily:\\n        \\\"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\\\",\\n};\\n\\nconst cols: GridColumn[] = [\\n    {\\n        title: \\\"A\\\",\\n        width: 200,\\n        group: \\\"Group 1\\\",\\n    },\\n    {\\n        title: \\\"B\\\",\\n        width: 200,\\n        group: \\\"Group 1\\\",\\n    },\\n    {\\n        title: \\\"C\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n    {\\n        title: \\\"D\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n    {\\n        title: \\\"E\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n];\\n\\nexport const UseDataSource: React.VFC = () => {\\n    const cache = React.useRef<Record<string, string>>({});\\n\\n    const rows = 100_000;\\n\\n    const moveArgs = useMoveableColumns({\\n        columns: cols,\\n        getCellContent: React.useCallback(([col, row]) => {\\n            if (col === 0) {\\n                return {\\n                    kind: GridCellKind.Text,\\n                    allowOverlay: true,\\n                    data: `${row}`,\\n                    displayData: `${row}`,\\n                };\\n            }\\n\\n            const key = `${col},${row}`;\\n            if (cache.current[key] === undefined) {\\n                cache.current[key] = faker.name.firstName() + \\\" \\\" + faker.name.lastName();\\n            }\\n            const d = cache.current[key];\\n\\n            return {\\n                kind: GridCellKind.Text,\\n                allowOverlay: true,\\n                data: d,\\n                displayData: d,\\n            };\\n        }, []),\\n    });\\n\\n    const [sort, setSort] = React.useState<number>();\\n\\n    const sortArgs = useColumnSort({\\n        columns: moveArgs.columns,\\n        getCellContent: moveArgs.getCellContent,\\n        rows,\\n        sort:\\n            sort === undefined\\n                ? undefined\\n                : {\\n                      column: moveArgs.columns[sort],\\n                      direction: \\\"desc\\\",\\n                      mode: \\\"smart\\\",\\n                  },\\n    });\\n\\n    const collapseArgs = useCollapsingGroups({\\n        columns: moveArgs.columns,\\n        theme: testTheme,\\n        freezeColumns: 0,\\n    });\\n\\n    const onHeaderClick = React.useCallback((index: number) => {\\n        setSort(index);\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper title=\\\"Custom source extensions\\\" description={<Description>Fixme.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                {...moveArgs}\\n                {...sortArgs}\\n                {...collapseArgs}\\n                rows={rows}\\n                onColumnMoved={moveArgs.onColumnMoved}\\n                onHeaderClicked={onHeaderClick}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(UseDataSource as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const UndoRedo: React.VFC = () => {\\n    const { cols: columns, getCellContent, setCellValue } = useMockDataGenerator(6);\\n\\n    const gridRef = React.useRef<DataEditorRef>(null);\\n\\n    const { gridSelection, onCellEdited, onGridSelectionChange, undo, canRedo, canUndo, redo } = useUndoRedo(\\n        gridRef,\\n        getCellContent,\\n        setCellValue\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Undo / Redo Support\\\"\\n            description={\\n                <Description>\\n                    A simple undo/redo implementation\\n                    <MoreInfo>\\n                        Use keyboard shortcuts CMD+Z and CMD+SHIFT+Z / CTRL+Z and CTRL+Y. Or click these buttons:\\n                        <button onClick={undo} disabled={!canUndo} style={{ opacity: canUndo ? 1 : 0.4 }}>\\n                            Undo\\n                        </button>\\n                        <button onClick={redo} disabled={!canRedo} style={{ opacity: canRedo ? 1 : 0.4 }}>\\n                            Redo\\n                        </button>\\n                    </MoreInfo>\\n                    <MoreInfo>\\n                        It works by taking a snapshot of the content of a cell before it is edited and replaying any\\n                        edits back.\\n                    </MoreInfo>\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                ref={gridRef}\\n                onCellEdited={onCellEdited}\\n                getCellContent={getCellContent}\\n                gridSelection={gridSelection ?? undefined}\\n                onGridSelectionChange={onGridSelectionChange}\\n                columns={columns}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(UndoRedo as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\",\"locationsMap\":{\"use-data-source\":{\"startLoc\":{\"col\":40,\"line\":225},\"endLoc\":{\"col\":1,\"line\":296},\"startBody\":{\"col\":40,\"line\":225},\"endBody\":{\"col\":1,\"line\":296}},\"undo-redo\":{\"startLoc\":{\"col\":35,\"line\":303},\"endLoc\":{\"col\":1,\"line\":347},\"startBody\":{\"col\":35,\"line\":303},\"endBody\":{\"col\":1,\"line\":347}}}},},\n    title: \"Extra Packages/Source\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nconst testTheme: Theme = {\n    accentColor: \"#4F5DFF\",\n    accentFg: \"#FFFFFF\",\n    accentLight: \"rgba(62, 116, 253, 0.1)\",\n\n    textDark: \"#313139\",\n    textMedium: \"#737383\",\n    textLight: \"#B2B2C0\",\n    textBubble: \"#313139\",\n\n    bgIconHeader: \"#737383\",\n    fgIconHeader: \"#FFFFFF\",\n    textHeader: \"#313139\",\n    textGroupHeader: \"#313139BB\",\n    textHeaderSelected: \"#FFFFFF\",\n\n    bgCell: \"#FFFFFF\",\n    bgCellMedium: \"#FAFAFB\",\n    bgHeader: \"#F7F7F8\",\n    bgHeaderHasFocus: \"#E9E9EB\",\n    bgHeaderHovered: \"#EFEFF1\",\n\n    bgBubble: \"#EDEDF3\",\n    bgBubbleSelected: \"#FFFFFF\",\n\n    bgSearchResult: \"#fff9e3\",\n\n    borderColor: \"rgba(115, 116, 131, 0.16)\",\n    horizontalBorderColor: \"rgba(115, 116, 131, 0.16)\",\n    drilldownBorder: \"rgba(0, 0, 0, 0)\",\n\n    linkColor: \"#4F5DFF\",\n\n    cellHorizontalPadding: 8,\n    cellVerticalPadding: 3,\n\n    headerFontStyle: \"600 13px\",\n    baseFontStyle: \"13px\",\n    editorFontSize: \"13px\",\n    lineHeight: 1.4,\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst cols: GridColumn[] = [\n    {\n        title: \"A\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"B\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"C\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"D\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"E\",\n        width: 200,\n        group: \"Group 2\",\n    },\n];\n\nexport const UseDataSource: React.VFC = () => {\n    const cache = React.useRef<Record<string, string>>({});\n\n    const rows = 100_000;\n\n    const moveArgs = useMoveableColumns({\n        columns: cols,\n        getCellContent: React.useCallback(([col, row]) => {\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    data: `${row}`,\n                    displayData: `${row}`,\n                };\n            }\n\n            const key = `${col},${row}`;\n            if (cache.current[key] === undefined) {\n                cache.current[key] = faker.name.firstName() + \" \" + faker.name.lastName();\n            }\n            const d = cache.current[key];\n\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: d,\n                displayData: d,\n            };\n        }, []),\n    });\n\n    const [sort, setSort] = React.useState<number>();\n\n    const sortArgs = useColumnSort({\n        columns: moveArgs.columns,\n        getCellContent: moveArgs.getCellContent,\n        rows,\n        sort:\n            sort === undefined\n                ? undefined\n                : {\n                      column: moveArgs.columns[sort],\n                      direction: \"desc\",\n                      mode: \"smart\",\n                  },\n    });\n\n    const collapseArgs = useCollapsingGroups({\n        columns: moveArgs.columns,\n        theme: testTheme,\n        freezeColumns: 0,\n    });\n\n    const onHeaderClick = React.useCallback((index: number) => {\n        setSort(index);\n    }, []);\n\n    return (\n        <BeautifulWrapper title=\"Custom source extensions\" description={<Description>Fixme.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...moveArgs}\n                {...sortArgs}\n                {...collapseArgs}\n                rows={rows}\n                onColumnMoved={moveArgs.onColumnMoved}\n                onHeaderClicked={onHeaderClick}\n            />\n        </BeautifulWrapper>\n    );\n};;\n(UseDataSource as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const UndoRedo: React.VFC = () => {\n    const { cols: columns, getCellContent, setCellValue } = useMockDataGenerator(6);\n\n    const gridRef = React.useRef<DataEditorRef>(null);\n\n    const { gridSelection, onCellEdited, onGridSelectionChange, undo, canRedo, canUndo, redo } = useUndoRedo(\n        gridRef,\n        getCellContent,\n        setCellValue\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Undo / Redo Support\"\n            description={\n                <Description>\n                    A simple undo/redo implementation\n                    <MoreInfo>\n                        Use keyboard shortcuts CMD+Z and CMD+SHIFT+Z / CTRL+Z and CTRL+Y. Or click these buttons:\n                        <button onClick={undo} disabled={!canUndo} style={{ opacity: canUndo ? 1 : 0.4 }}>\n                            Undo\n                        </button>\n                        <button onClick={redo} disabled={!canRedo} style={{ opacity: canRedo ? 1 : 0.4 }}>\n                            Redo\n                        </button>\n                    </MoreInfo>\n                    <MoreInfo>\n                        It works by taking a snapshot of the content of a cell before it is edited and replaying any\n                        edits back.\n                    </MoreInfo>\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={gridRef}\n                onCellEdited={onCellEdited}\n                getCellContent={getCellContent}\n                gridSelection={gridSelection ?? undefined}\n                onGridSelectionChange={onGridSelectionChange}\n                columns={columns}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UndoRedo as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n",".ss4kmn3{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.ss4kmn3 *,.ss4kmn3 *::before,.ss4kmn3 *::after{box-sizing:inherit;}\n.bkh67gx{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.bkh67gx > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.bkh67gx .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.bkh67gx .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\n.d1deot3s{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.m1ml0sw1{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.m1ml0sw1 button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvc291cmNlL3NyYy9zdG9yaWVzL3VzZS1kYXRhLXNvdXJjZS5zdG9yaWVzLnRzeCJdLCJuYW1lcyI6WyIuc3M0a21uMyIsIi5ia2g2N2d4IiwiLmQxZGVvdDNzIiwiLm0xbWwwc3cxIl0sIm1hcHBpbmdzIjoiQUEwQnNCQTtBQWlDQ0M7QUFvRUhDO0FBTUlDIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2dsaWRlLWRhdGEtZ3JpZC9nbGlkZS1kYXRhLWdyaWQvcGFja2FnZXMvc291cmNlL3NyYy9zdG9yaWVzL3VzZS1kYXRhLXNvdXJjZS5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIlxuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgLy8gQHRzLW5vY2hlY2tcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIF9fU1RPUllfXyA9IFwiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcXFwiQGxpbmFyaWEvcmVhY3RcXFwiO1xcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXFxcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclxcXCI7XFxuaW1wb3J0IHtcXG4gICAgRGF0YUVkaXRvcixcXG4gICAgRGF0YUVkaXRvclByb3BzLFxcbiAgICBEYXRhRWRpdG9yUmVmLFxcbiAgICBHcmlkQ2VsbEtpbmQsXFxuICAgIEdyaWRDb2x1bW4sXFxuICAgIFRoZW1lLFxcbn0gZnJvbSBcXFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCBmYWtlciBmcm9tIFxcXCJmYWtlclxcXCI7XFxuaW1wb3J0IHsgdXNlQ29sbGFwc2luZ0dyb3VwcywgdXNlQ29sdW1uU29ydCwgdXNlTW92ZWFibGVDb2x1bW5zIH0gZnJvbSBcXFwiLi5cXFwiO1xcbmltcG9ydCB7IHVzZVVuZG9SZWRvIH0gZnJvbSBcXFwiLi4vdXNlLXVuZG8tcmVkb1xcXCI7XFxuaW1wb3J0IHsgdXNlTW9ja0RhdGFHZW5lcmF0b3IgfSBmcm9tIFxcXCIuL3V0aWxzXFxcIjtcXG5cXG5mYWtlci5zZWVkKDEzMzcpO1xcblxcbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG5cXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cXG4gICAgKixcXG4gICAgKjo6YmVmb3JlLFxcbiAgICAqOjphZnRlciB7XFxuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xcbiAgICB9XFxuYDtcXG5cXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XFxuICAgIHJldHVybiAoXFxuICAgICAgICA8U2ltcGxlV3JhcHBlcj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwiY29udGVudFxcXCI+e3AuY2hpbGRyZW59PC9kaXY+XFxuICAgICAgICA8L1NpbXBsZVdyYXBwZXI+XFxuICAgICk7XFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiRXh0cmEgUGFja2FnZXMvU291cmNlXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XFxuICAgICAgICApLFxcbiAgICBdLFxcbn07XFxuXFxuY29uc3QgQmVhdXRpZnVsU3R5bGUgPSBzdHlsZWQuZGl2YFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xcbiAgICBjb2xvcjogd2hpdGU7XFxuXFxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG5cXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuXFxuICAgICYgPiBoMSB7XFxuICAgICAgICBmb250LXNpemU6IDUwcHg7XFxuICAgICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XFxuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XFxuICAgIH1cXG5cXG4gICAgLnNpemVyIHtcXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcXG5cXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcblxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xcblxcbiAgICAgICAgLnNpemVyLWNsaXAge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxuXFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuYDtcXG5cXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xcbiAgICB0aXRsZTogc3RyaW5nO1xcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcXG59XFxuXFxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XFxuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcXG5cXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XFxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxcbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXItY2xpcFxcXCIgcmVmPXtyZWZ9PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPz8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cXG4gICAgKTtcXG59O1xcblxcbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXFxuICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcXG5gO1xcblxcbmV4cG9ydCBjb25zdCBNb3JlSW5mbyA9IHN0eWxlZC5wYFxcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XFxuXFxuICAgIGJ1dHRvbiB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XFxuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IDBweCAxcHggMnB4ICMwMDAwMDA0MDtcXG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcXG4gICAgICAgIGJvcmRlcjogbm9uZTtcXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgfVxcbmA7XFxuXFxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XFxuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXFxuICAgIHNtb290aFNjcm9sbFk6IHRydWUsXFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcXG4gICAgcm93TWFya2VyczogXFxcIm5vbmVcXFwiLFxcbiAgICB3aWR0aDogXFxcIjEwMCVcXFwiLFxcbn07XFxuXFxuY29uc3QgdGVzdFRoZW1lOiBUaGVtZSA9IHtcXG4gICAgYWNjZW50Q29sb3I6IFxcXCIjNEY1REZGXFxcIixcXG4gICAgYWNjZW50Rmc6IFxcXCIjRkZGRkZGXFxcIixcXG4gICAgYWNjZW50TGlnaHQ6IFxcXCJyZ2JhKDYyLCAxMTYsIDI1MywgMC4xKVxcXCIsXFxuXFxuICAgIHRleHREYXJrOiBcXFwiIzMxMzEzOVxcXCIsXFxuICAgIHRleHRNZWRpdW06IFxcXCIjNzM3MzgzXFxcIixcXG4gICAgdGV4dExpZ2h0OiBcXFwiI0IyQjJDMFxcXCIsXFxuICAgIHRleHRCdWJibGU6IFxcXCIjMzEzMTM5XFxcIixcXG5cXG4gICAgYmdJY29uSGVhZGVyOiBcXFwiIzczNzM4M1xcXCIsXFxuICAgIGZnSWNvbkhlYWRlcjogXFxcIiNGRkZGRkZcXFwiLFxcbiAgICB0ZXh0SGVhZGVyOiBcXFwiIzMxMzEzOVxcXCIsXFxuICAgIHRleHRHcm91cEhlYWRlcjogXFxcIiMzMTMxMzlCQlxcXCIsXFxuICAgIHRleHRIZWFkZXJTZWxlY3RlZDogXFxcIiNGRkZGRkZcXFwiLFxcblxcbiAgICBiZ0NlbGw6IFxcXCIjRkZGRkZGXFxcIixcXG4gICAgYmdDZWxsTWVkaXVtOiBcXFwiI0ZBRkFGQlxcXCIsXFxuICAgIGJnSGVhZGVyOiBcXFwiI0Y3RjdGOFxcXCIsXFxuICAgIGJnSGVhZGVySGFzRm9jdXM6IFxcXCIjRTlFOUVCXFxcIixcXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcXFwiI0VGRUZGMVxcXCIsXFxuXFxuICAgIGJnQnViYmxlOiBcXFwiI0VERURGM1xcXCIsXFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFxcXCIjRkZGRkZGXFxcIixcXG5cXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFxcXCIjZmZmOWUzXFxcIixcXG5cXG4gICAgYm9yZGVyQ29sb3I6IFxcXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXFxcIixcXG4gICAgaG9yaXpvbnRhbEJvcmRlckNvbG9yOiBcXFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVxcXCIsXFxuICAgIGRyaWxsZG93bkJvcmRlcjogXFxcInJnYmEoMCwgMCwgMCwgMClcXFwiLFxcblxcbiAgICBsaW5rQ29sb3I6IFxcXCIjNEY1REZGXFxcIixcXG5cXG4gICAgY2VsbEhvcml6b250YWxQYWRkaW5nOiA4LFxcbiAgICBjZWxsVmVydGljYWxQYWRkaW5nOiAzLFxcblxcbiAgICBoZWFkZXJGb250U3R5bGU6IFxcXCI2MDAgMTNweFxcXCIsXFxuICAgIGJhc2VGb250U3R5bGU6IFxcXCIxM3B4XFxcIixcXG4gICAgZWRpdG9yRm9udFNpemU6IFxcXCIxM3B4XFxcIixcXG4gICAgbGluZUhlaWdodDogMS40LFxcbiAgICBmb250RmFtaWx5OlxcbiAgICAgICAgXFxcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcXFwiLFxcbn07XFxuXFxuY29uc3QgY29sczogR3JpZENvbHVtbltdID0gW1xcbiAgICB7XFxuICAgICAgICB0aXRsZTogXFxcIkFcXFwiLFxcbiAgICAgICAgd2lkdGg6IDIwMCxcXG4gICAgICAgIGdyb3VwOiBcXFwiR3JvdXAgMVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRpdGxlOiBcXFwiQlxcXCIsXFxuICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgZ3JvdXA6IFxcXCJHcm91cCAxXFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGl0bGU6IFxcXCJDXFxcIixcXG4gICAgICAgIHdpZHRoOiAyMDAsXFxuICAgICAgICBncm91cDogXFxcIkdyb3VwIDJcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0aXRsZTogXFxcIkRcXFwiLFxcbiAgICAgICAgd2lkdGg6IDIwMCxcXG4gICAgICAgIGdyb3VwOiBcXFwiR3JvdXAgMlxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRpdGxlOiBcXFwiRVxcXCIsXFxuICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgZ3JvdXA6IFxcXCJHcm91cCAyXFxcIixcXG4gICAgfSxcXG5dO1xcblxcbmV4cG9ydCBjb25zdCBVc2VEYXRhU291cmNlOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KTtcXG5cXG4gICAgY29uc3Qgcm93cyA9IDEwMF8wMDA7XFxuXFxuICAgIGNvbnN0IG1vdmVBcmdzID0gdXNlTW92ZWFibGVDb2x1bW5zKHtcXG4gICAgICAgIGNvbHVtbnM6IGNvbHMsXFxuICAgICAgICBnZXRDZWxsQ29udGVudDogUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd10pID0+IHtcXG4gICAgICAgICAgICBpZiAoY29sID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd31gLFxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGAke3Jvd31gLFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtjb2x9LCR7cm93fWA7XFxuICAgICAgICAgICAgaWYgKGNhY2hlLmN1cnJlbnRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnRba2V5XSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCkgKyBcXFwiIFxcXCIgKyBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGQgPSBjYWNoZS5jdXJyZW50W2tleV07XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGQsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0sIFtdKSxcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IFtzb3J0LCBzZXRTb3J0XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oKTtcXG5cXG4gICAgY29uc3Qgc29ydEFyZ3MgPSB1c2VDb2x1bW5Tb3J0KHtcXG4gICAgICAgIGNvbHVtbnM6IG1vdmVBcmdzLmNvbHVtbnMsXFxuICAgICAgICBnZXRDZWxsQ29udGVudDogbW92ZUFyZ3MuZ2V0Q2VsbENvbnRlbnQsXFxuICAgICAgICByb3dzLFxcbiAgICAgICAgc29ydDpcXG4gICAgICAgICAgICBzb3J0ID09PSB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgOiB7XFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbW92ZUFyZ3MuY29sdW1uc1tzb3J0XSxcXG4gICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcXFwiZGVzY1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFxcXCJzbWFydFxcXCIsXFxuICAgICAgICAgICAgICAgICAgfSxcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IGNvbGxhcHNlQXJncyA9IHVzZUNvbGxhcHNpbmdHcm91cHMoe1xcbiAgICAgICAgY29sdW1uczogbW92ZUFyZ3MuY29sdW1ucyxcXG4gICAgICAgIHRoZW1lOiB0ZXN0VGhlbWUsXFxuICAgICAgICBmcmVlemVDb2x1bW5zOiAwLFxcbiAgICB9KTtcXG5cXG4gICAgY29uc3Qgb25IZWFkZXJDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7XFxuICAgICAgICBzZXRTb3J0KGluZGV4KTtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XFxcIkN1c3RvbSBzb3VyY2UgZXh0ZW5zaW9uc1xcXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5GaXhtZS48L0Rlc2NyaXB0aW9uPn0+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cXG4gICAgICAgICAgICAgICAgey4uLm1vdmVBcmdzfVxcbiAgICAgICAgICAgICAgICB7Li4uc29ydEFyZ3N9XFxuICAgICAgICAgICAgICAgIHsuLi5jb2xsYXBzZUFyZ3N9XFxuICAgICAgICAgICAgICAgIHJvd3M9e3Jvd3N9XFxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e21vdmVBcmdzLm9uQ29sdW1uTW92ZWR9XFxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja31cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxcbiAgICApO1xcbn07XFxuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXFxuZXhwb3J0IGNvbnN0IFVuZG9SZWRvOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IHsgY29sczogY29sdW1ucywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNik7XFxuXFxuICAgIGNvbnN0IGdyaWRSZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XFxuXFxuICAgIGNvbnN0IHsgZ3JpZFNlbGVjdGlvbiwgb25DZWxsRWRpdGVkLCBvbkdyaWRTZWxlY3Rpb25DaGFuZ2UsIHVuZG8sIGNhblJlZG8sIGNhblVuZG8sIHJlZG8gfSA9IHVzZVVuZG9SZWRvKFxcbiAgICAgICAgZ3JpZFJlZixcXG4gICAgICAgIGdldENlbGxDb250ZW50LFxcbiAgICAgICAgc2V0Q2VsbFZhbHVlXFxuICAgICk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxcbiAgICAgICAgICAgIHRpdGxlPVxcXCJVbmRvIC8gUmVkbyBTdXBwb3J0XFxcIlxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcXG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgQSBzaW1wbGUgdW5kby9yZWRvIGltcGxlbWVudGF0aW9uXFxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgVXNlIGtleWJvYXJkIHNob3J0Y3V0cyBDTUQrWiBhbmQgQ01EK1NISUZUK1ogLyBDVFJMK1ogYW5kIENUUkwrWS4gT3IgY2xpY2sgdGhlc2UgYnV0dG9uczpcXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3VuZG99IGRpc2FibGVkPXshY2FuVW5kb30gc3R5bGU9e3sgb3BhY2l0eTogY2FuVW5kbyA/IDEgOiAwLjQgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVuZG9cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3JlZG99IGRpc2FibGVkPXshY2FuUmVkb30gc3R5bGU9e3sgb3BhY2l0eTogY2FuUmVkbyA/IDEgOiAwLjQgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZG9cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgSXQgd29ya3MgYnkgdGFraW5nIGEgc25hcHNob3Qgb2YgdGhlIGNvbnRlbnQgb2YgYSBjZWxsIGJlZm9yZSBpdCBpcyBlZGl0ZWQgYW5kIHJlcGxheWluZyBhbnlcXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0cyBiYWNrLlxcbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cXG4gICAgICAgICAgICB9PlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XFxuICAgICAgICAgICAgICAgIHJlZj17Z3JpZFJlZn1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtvbkNlbGxFZGl0ZWR9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICAgICAgZ3JpZFNlbGVjdGlvbj17Z3JpZFNlbGVjdGlvbiA/PyB1bmRlZmluZWR9XFxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17b25HcmlkU2VsZWN0aW9uQ2hhbmdlfVxcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XFxuICAgICk7XFxufTtcXG4oVW5kb1JlZG8gYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBfX0xPQ0FUSU9OU19NQVBfXyA9IHtcIlVzZURhdGFTb3VyY2VcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjQwLFwibGluZVwiOjIyNX0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjI5Nn0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo0MCxcImxpbmVcIjoyMjV9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6Mjk2fX0sXCJVbmRvUmVkb1wiOntcInN0YXJ0TG9jXCI6e1wiY29sXCI6MzUsXCJsaW5lXCI6MzAzfSxcImVuZExvY1wiOntcImNvbFwiOjEsXCJsaW5lXCI6MzQ3fSxcInN0YXJ0Qm9keVwiOntcImNvbFwiOjM1LFwibGluZVwiOjMwM30sXCJlbmRCb2R5XCI6e1wiY29sXCI6MSxcImxpbmVcIjozNDd9fX07XG4gICAgXG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUmVzaXplRGV0ZWN0b3IgfSBmcm9tIFwicmVhY3QtcmVzaXplLWRldGVjdG9yXCI7XG5pbXBvcnQge1xuICAgIERhdGFFZGl0b3IsXG4gICAgRGF0YUVkaXRvclByb3BzLFxuICAgIERhdGFFZGl0b3JSZWYsXG4gICAgR3JpZENlbGxLaW5kLFxuICAgIEdyaWRDb2x1bW4sXG4gICAgVGhlbWUsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IGZha2VyIGZyb20gXCJmYWtlclwiO1xuaW1wb3J0IHsgdXNlQ29sbGFwc2luZ0dyb3VwcywgdXNlQ29sdW1uU29ydCwgdXNlTW92ZWFibGVDb2x1bW5zIH0gZnJvbSBcIi4uXCI7XG5pbXBvcnQgeyB1c2VVbmRvUmVkbyB9IGZyb20gXCIuLi91c2UtdW5kby1yZWRvXCI7XG5pbXBvcnQgeyB1c2VNb2NrRGF0YUdlbmVyYXRvciB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmZha2VyLnNlZWQoMTMzNyk7XG5cbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG5cbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgKixcbiAgICAqOjpiZWZvcmUsXG4gICAgKjo6YWZ0ZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xuICAgIH1cbmA7XG5cbmNvbnN0IFNpbXBsZVRoZW1lV3JhcHBlcjogUmVhY3QuRkMgPSBwID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8U2ltcGxlV3JhcHBlcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGVudFwiPntwLmNoaWxkcmVufTwvZGl2PlxuICAgICAgICA8L1NpbXBsZVdyYXBwZXI+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtwYXJhbWV0ZXJzOiB7XCJzdG9yeVNvdXJjZVwiOntcInNvdXJjZVwiOlwiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcXFwiQGxpbmFyaWEvcmVhY3RcXFwiO1xcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXFxcInJlYWN0XFxcIjtcXG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXFxcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclxcXCI7XFxuaW1wb3J0IHtcXG4gICAgRGF0YUVkaXRvcixcXG4gICAgRGF0YUVkaXRvclByb3BzLFxcbiAgICBEYXRhRWRpdG9yUmVmLFxcbiAgICBHcmlkQ2VsbEtpbmQsXFxuICAgIEdyaWRDb2x1bW4sXFxuICAgIFRoZW1lLFxcbn0gZnJvbSBcXFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcXFwiO1xcbmltcG9ydCBmYWtlciBmcm9tIFxcXCJmYWtlclxcXCI7XFxuaW1wb3J0IHsgdXNlQ29sbGFwc2luZ0dyb3VwcywgdXNlQ29sdW1uU29ydCwgdXNlTW92ZWFibGVDb2x1bW5zIH0gZnJvbSBcXFwiLi5cXFwiO1xcbmltcG9ydCB7IHVzZVVuZG9SZWRvIH0gZnJvbSBcXFwiLi4vdXNlLXVuZG8tcmVkb1xcXCI7XFxuaW1wb3J0IHsgdXNlTW9ja0RhdGFHZW5lcmF0b3IgfSBmcm9tIFxcXCIuL3V0aWxzXFxcIjtcXG5cXG5mYWtlci5zZWVkKDEzMzcpO1xcblxcbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG5cXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cXG4gICAgKixcXG4gICAgKjo6YmVmb3JlLFxcbiAgICAqOjphZnRlciB7XFxuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xcbiAgICB9XFxuYDtcXG5cXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XFxuICAgIHJldHVybiAoXFxuICAgICAgICA8U2ltcGxlV3JhcHBlcj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwiY29udGVudFxcXCI+e3AuY2hpbGRyZW59PC9kaXY+XFxuICAgICAgICA8L1NpbXBsZVdyYXBwZXI+XFxuICAgICk7XFxufTtcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHRpdGxlOiBcXFwiRXh0cmEgUGFja2FnZXMvU291cmNlXFxcIixcXG5cXG4gICAgZGVjb3JhdG9yczogW1xcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cXG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XFxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XFxuICAgICAgICApLFxcbiAgICBdLFxcbn07XFxuXFxuY29uc3QgQmVhdXRpZnVsU3R5bGUgPSBzdHlsZWQuZGl2YFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xcbiAgICBjb2xvcjogd2hpdGU7XFxuXFxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG5cXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuXFxuICAgICYgPiBoMSB7XFxuICAgICAgICBmb250LXNpemU6IDUwcHg7XFxuICAgICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XFxuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XFxuICAgIH1cXG5cXG4gICAgLnNpemVyIHtcXG4gICAgICAgIGZsZXgtZ3JvdzogMTtcXG5cXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcblxcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xcblxcbiAgICAgICAgLnNpemVyLWNsaXAge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxuXFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuYDtcXG5cXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xcbiAgICB0aXRsZTogc3RyaW5nO1xcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcXG59XFxuXFxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XFxuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcXG5cXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XFxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxcbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cXFwic2l6ZXItY2xpcFxcXCIgcmVmPXtyZWZ9PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPz8gMTAwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cXG4gICAgKTtcXG59O1xcblxcbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXFxuICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcXG5gO1xcblxcbmV4cG9ydCBjb25zdCBNb3JlSW5mbyA9IHN0eWxlZC5wYFxcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XFxuXFxuICAgIGJ1dHRvbiB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XFxuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgICAgIGJveC1zaGFkb3c6IDBweCAxcHggMnB4ICMwMDAwMDA0MDtcXG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcXG4gICAgICAgIGJvcmRlcjogbm9uZTtcXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgfVxcbmA7XFxuXFxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XFxuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXFxuICAgIHNtb290aFNjcm9sbFk6IHRydWUsXFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcXG4gICAgcm93TWFya2VyczogXFxcIm5vbmVcXFwiLFxcbiAgICB3aWR0aDogXFxcIjEwMCVcXFwiLFxcbn07XFxuXFxuY29uc3QgdGVzdFRoZW1lOiBUaGVtZSA9IHtcXG4gICAgYWNjZW50Q29sb3I6IFxcXCIjNEY1REZGXFxcIixcXG4gICAgYWNjZW50Rmc6IFxcXCIjRkZGRkZGXFxcIixcXG4gICAgYWNjZW50TGlnaHQ6IFxcXCJyZ2JhKDYyLCAxMTYsIDI1MywgMC4xKVxcXCIsXFxuXFxuICAgIHRleHREYXJrOiBcXFwiIzMxMzEzOVxcXCIsXFxuICAgIHRleHRNZWRpdW06IFxcXCIjNzM3MzgzXFxcIixcXG4gICAgdGV4dExpZ2h0OiBcXFwiI0IyQjJDMFxcXCIsXFxuICAgIHRleHRCdWJibGU6IFxcXCIjMzEzMTM5XFxcIixcXG5cXG4gICAgYmdJY29uSGVhZGVyOiBcXFwiIzczNzM4M1xcXCIsXFxuICAgIGZnSWNvbkhlYWRlcjogXFxcIiNGRkZGRkZcXFwiLFxcbiAgICB0ZXh0SGVhZGVyOiBcXFwiIzMxMzEzOVxcXCIsXFxuICAgIHRleHRHcm91cEhlYWRlcjogXFxcIiMzMTMxMzlCQlxcXCIsXFxuICAgIHRleHRIZWFkZXJTZWxlY3RlZDogXFxcIiNGRkZGRkZcXFwiLFxcblxcbiAgICBiZ0NlbGw6IFxcXCIjRkZGRkZGXFxcIixcXG4gICAgYmdDZWxsTWVkaXVtOiBcXFwiI0ZBRkFGQlxcXCIsXFxuICAgIGJnSGVhZGVyOiBcXFwiI0Y3RjdGOFxcXCIsXFxuICAgIGJnSGVhZGVySGFzRm9jdXM6IFxcXCIjRTlFOUVCXFxcIixcXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcXFwiI0VGRUZGMVxcXCIsXFxuXFxuICAgIGJnQnViYmxlOiBcXFwiI0VERURGM1xcXCIsXFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFxcXCIjRkZGRkZGXFxcIixcXG5cXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFxcXCIjZmZmOWUzXFxcIixcXG5cXG4gICAgYm9yZGVyQ29sb3I6IFxcXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXFxcIixcXG4gICAgaG9yaXpvbnRhbEJvcmRlckNvbG9yOiBcXFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVxcXCIsXFxuICAgIGRyaWxsZG93bkJvcmRlcjogXFxcInJnYmEoMCwgMCwgMCwgMClcXFwiLFxcblxcbiAgICBsaW5rQ29sb3I6IFxcXCIjNEY1REZGXFxcIixcXG5cXG4gICAgY2VsbEhvcml6b250YWxQYWRkaW5nOiA4LFxcbiAgICBjZWxsVmVydGljYWxQYWRkaW5nOiAzLFxcblxcbiAgICBoZWFkZXJGb250U3R5bGU6IFxcXCI2MDAgMTNweFxcXCIsXFxuICAgIGJhc2VGb250U3R5bGU6IFxcXCIxM3B4XFxcIixcXG4gICAgZWRpdG9yRm9udFNpemU6IFxcXCIxM3B4XFxcIixcXG4gICAgbGluZUhlaWdodDogMS40LFxcbiAgICBmb250RmFtaWx5OlxcbiAgICAgICAgXFxcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcXFwiLFxcbn07XFxuXFxuY29uc3QgY29sczogR3JpZENvbHVtbltdID0gW1xcbiAgICB7XFxuICAgICAgICB0aXRsZTogXFxcIkFcXFwiLFxcbiAgICAgICAgd2lkdGg6IDIwMCxcXG4gICAgICAgIGdyb3VwOiBcXFwiR3JvdXAgMVxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRpdGxlOiBcXFwiQlxcXCIsXFxuICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgZ3JvdXA6IFxcXCJHcm91cCAxXFxcIixcXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgdGl0bGU6IFxcXCJDXFxcIixcXG4gICAgICAgIHdpZHRoOiAyMDAsXFxuICAgICAgICBncm91cDogXFxcIkdyb3VwIDJcXFwiLFxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICB0aXRsZTogXFxcIkRcXFwiLFxcbiAgICAgICAgd2lkdGg6IDIwMCxcXG4gICAgICAgIGdyb3VwOiBcXFwiR3JvdXAgMlxcXCIsXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIHRpdGxlOiBcXFwiRVxcXCIsXFxuICAgICAgICB3aWR0aDogMjAwLFxcbiAgICAgICAgZ3JvdXA6IFxcXCJHcm91cCAyXFxcIixcXG4gICAgfSxcXG5dO1xcblxcbmV4cG9ydCBjb25zdCBVc2VEYXRhU291cmNlOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KTtcXG5cXG4gICAgY29uc3Qgcm93cyA9IDEwMF8wMDA7XFxuXFxuICAgIGNvbnN0IG1vdmVBcmdzID0gdXNlTW92ZWFibGVDb2x1bW5zKHtcXG4gICAgICAgIGNvbHVtbnM6IGNvbHMsXFxuICAgICAgICBnZXRDZWxsQ29udGVudDogUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd10pID0+IHtcXG4gICAgICAgICAgICBpZiAoY29sID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd31gLFxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGAke3Jvd31gLFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtjb2x9LCR7cm93fWA7XFxuICAgICAgICAgICAgaWYgKGNhY2hlLmN1cnJlbnRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnRba2V5XSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCkgKyBcXFwiIFxcXCIgKyBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGQgPSBjYWNoZS5jdXJyZW50W2tleV07XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGQsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0sIFtdKSxcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IFtzb3J0LCBzZXRTb3J0XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oKTtcXG5cXG4gICAgY29uc3Qgc29ydEFyZ3MgPSB1c2VDb2x1bW5Tb3J0KHtcXG4gICAgICAgIGNvbHVtbnM6IG1vdmVBcmdzLmNvbHVtbnMsXFxuICAgICAgICBnZXRDZWxsQ29udGVudDogbW92ZUFyZ3MuZ2V0Q2VsbENvbnRlbnQsXFxuICAgICAgICByb3dzLFxcbiAgICAgICAgc29ydDpcXG4gICAgICAgICAgICBzb3J0ID09PSB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgOiB7XFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbW92ZUFyZ3MuY29sdW1uc1tzb3J0XSxcXG4gICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcXFwiZGVzY1xcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFxcXCJzbWFydFxcXCIsXFxuICAgICAgICAgICAgICAgICAgfSxcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IGNvbGxhcHNlQXJncyA9IHVzZUNvbGxhcHNpbmdHcm91cHMoe1xcbiAgICAgICAgY29sdW1uczogbW92ZUFyZ3MuY29sdW1ucyxcXG4gICAgICAgIHRoZW1lOiB0ZXN0VGhlbWUsXFxuICAgICAgICBmcmVlemVDb2x1bW5zOiAwLFxcbiAgICB9KTtcXG5cXG4gICAgY29uc3Qgb25IZWFkZXJDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7XFxuICAgICAgICBzZXRTb3J0KGluZGV4KTtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gKFxcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XFxcIkN1c3RvbSBzb3VyY2UgZXh0ZW5zaW9uc1xcXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5GaXhtZS48L0Rlc2NyaXB0aW9uPn0+XFxuICAgICAgICAgICAgPERhdGFFZGl0b3JcXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cXG4gICAgICAgICAgICAgICAgey4uLm1vdmVBcmdzfVxcbiAgICAgICAgICAgICAgICB7Li4uc29ydEFyZ3N9XFxuICAgICAgICAgICAgICAgIHsuLi5jb2xsYXBzZUFyZ3N9XFxuICAgICAgICAgICAgICAgIHJvd3M9e3Jvd3N9XFxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e21vdmVBcmdzLm9uQ29sdW1uTW92ZWR9XFxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja31cXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxcbiAgICApO1xcbn07XFxuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXFxuZXhwb3J0IGNvbnN0IFVuZG9SZWRvOiBSZWFjdC5WRkMgPSAoKSA9PiB7XFxuICAgIGNvbnN0IHsgY29sczogY29sdW1ucywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNik7XFxuXFxuICAgIGNvbnN0IGdyaWRSZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XFxuXFxuICAgIGNvbnN0IHsgZ3JpZFNlbGVjdGlvbiwgb25DZWxsRWRpdGVkLCBvbkdyaWRTZWxlY3Rpb25DaGFuZ2UsIHVuZG8sIGNhblJlZG8sIGNhblVuZG8sIHJlZG8gfSA9IHVzZVVuZG9SZWRvKFxcbiAgICAgICAgZ3JpZFJlZixcXG4gICAgICAgIGdldENlbGxDb250ZW50LFxcbiAgICAgICAgc2V0Q2VsbFZhbHVlXFxuICAgICk7XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxcbiAgICAgICAgICAgIHRpdGxlPVxcXCJVbmRvIC8gUmVkbyBTdXBwb3J0XFxcIlxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcXG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgQSBzaW1wbGUgdW5kby9yZWRvIGltcGxlbWVudGF0aW9uXFxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgVXNlIGtleWJvYXJkIHNob3J0Y3V0cyBDTUQrWiBhbmQgQ01EK1NISUZUK1ogLyBDVFJMK1ogYW5kIENUUkwrWS4gT3IgY2xpY2sgdGhlc2UgYnV0dG9uczpcXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3VuZG99IGRpc2FibGVkPXshY2FuVW5kb30gc3R5bGU9e3sgb3BhY2l0eTogY2FuVW5kbyA/IDEgOiAwLjQgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVuZG9cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3JlZG99IGRpc2FibGVkPXshY2FuUmVkb30gc3R5bGU9e3sgb3BhY2l0eTogY2FuUmVkbyA/IDEgOiAwLjQgfX0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZG9cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgSXQgd29ya3MgYnkgdGFraW5nIGEgc25hcHNob3Qgb2YgdGhlIGNvbnRlbnQgb2YgYSBjZWxsIGJlZm9yZSBpdCBpcyBlZGl0ZWQgYW5kIHJlcGxheWluZyBhbnlcXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0cyBiYWNrLlxcbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cXG4gICAgICAgICAgICB9PlxcbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXFxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XFxuICAgICAgICAgICAgICAgIHJlZj17Z3JpZFJlZn1cXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtvbkNlbGxFZGl0ZWR9XFxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cXG4gICAgICAgICAgICAgICAgZ3JpZFNlbGVjdGlvbj17Z3JpZFNlbGVjdGlvbiA/PyB1bmRlZmluZWR9XFxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17b25HcmlkU2VsZWN0aW9uQ2hhbmdlfVxcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxcbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XFxuICAgICk7XFxufTtcXG4oVW5kb1JlZG8gYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxcbiAgICB9LFxcbn07XFxuXCIsXCJsb2NhdGlvbnNNYXBcIjp7XCJ1c2UtZGF0YS1zb3VyY2VcIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjQwLFwibGluZVwiOjIyNX0sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjI5Nn0sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjo0MCxcImxpbmVcIjoyMjV9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6Mjk2fX0sXCJ1bmRvLXJlZG9cIjp7XCJzdGFydExvY1wiOntcImNvbFwiOjM1LFwibGluZVwiOjMwM30sXCJlbmRMb2NcIjp7XCJjb2xcIjoxLFwibGluZVwiOjM0N30sXCJzdGFydEJvZHlcIjp7XCJjb2xcIjozNSxcImxpbmVcIjozMDN9LFwiZW5kQm9keVwiOntcImNvbFwiOjEsXCJsaW5lXCI6MzQ3fX19fSx9LFxuICAgIHRpdGxlOiBcIkV4dHJhIFBhY2thZ2VzL1NvdXJjZVwiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxTaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XG4gICAgICAgICAgICA8L1NpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgKSxcbiAgICBdLFxufTtcblxuY29uc3QgQmVhdXRpZnVsU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyNzkwYjk7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjMjc5MGI5LCAjMjA3MGE5KTtcbiAgICBjb2xvcjogd2hpdGU7XG5cbiAgICBwYWRkaW5nOiAzMnB4IDQ4cHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgaGVpZ2h0OiAxMDB2aDtcblxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuXG4gICAgJiA+IGgxIHtcbiAgICAgICAgZm9udC1zaXplOiA1MHB4O1xuICAgICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgbWFyZ2luOiAwIDAgMTJweCAwO1xuICAgIH1cblxuICAgIC5zaXplciB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweCwgcmdiYSg5LCAzMCwgNjYsIDAuMDgpIDBweCAwcHggMHB4IDFweDtcblxuICAgICAgICAuc2l6ZXItY2xpcCB7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcblxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuYDtcblxuaW50ZXJmYWNlIEJlYXV0aWZ1bFByb3BzIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5jb25zdCBCZWF1dGlmdWxXcmFwcGVyOiBSZWFjdC5GQzxCZWF1dGlmdWxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IHRpdGxlLCBjaGlsZHJlbiwgZGVzY3JpcHRpb24gfSA9IHA7XG5cbiAgICBjb25zdCB7IHJlZiwgd2lkdGgsIGhlaWdodCB9ID0gdXNlUmVzaXplRGV0ZWN0b3IoKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxTdHlsZT5cbiAgICAgICAgICAgIDxoMT57dGl0bGV9PC9oMT5cbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2l6ZXJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyLWNsaXBcIiByZWY9e3JlZn0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPz8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0ID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0JlYXV0aWZ1bFN0eWxlPlxuICAgICk7XG59O1xuXG5jb25zdCBEZXNjcmlwdGlvbiA9IHN0eWxlZC5wYFxuICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICBmbGV4LXNocmluazogMDtcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgTW9yZUluZm8gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICAgICAgY29sb3I6ICMyYjJiMmI7XG4gICAgICAgIHBhZGRpbmc6IDJweCA2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgICAgIG1hcmdpbjogMCAwLjFlbTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuYDtcblxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogdHJ1ZSxcbiAgICBzbW9vdGhTY3JvbGxZOiB0cnVlLFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICByb3dNYXJrZXJzOiBcIm5vbmVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG59O1xuXG5jb25zdCB0ZXN0VGhlbWU6IFRoZW1lID0ge1xuICAgIGFjY2VudENvbG9yOiBcIiM0RjVERkZcIixcbiAgICBhY2NlbnRGZzogXCIjRkZGRkZGXCIsXG4gICAgYWNjZW50TGlnaHQ6IFwicmdiYSg2MiwgMTE2LCAyNTMsIDAuMSlcIixcblxuICAgIHRleHREYXJrOiBcIiMzMTMxMzlcIixcbiAgICB0ZXh0TWVkaXVtOiBcIiM3MzczODNcIixcbiAgICB0ZXh0TGlnaHQ6IFwiI0IyQjJDMFwiLFxuICAgIHRleHRCdWJibGU6IFwiIzMxMzEzOVwiLFxuXG4gICAgYmdJY29uSGVhZGVyOiBcIiM3MzczODNcIixcbiAgICBmZ0ljb25IZWFkZXI6IFwiI0ZGRkZGRlwiLFxuICAgIHRleHRIZWFkZXI6IFwiIzMxMzEzOVwiLFxuICAgIHRleHRHcm91cEhlYWRlcjogXCIjMzEzMTM5QkJcIixcbiAgICB0ZXh0SGVhZGVyU2VsZWN0ZWQ6IFwiI0ZGRkZGRlwiLFxuXG4gICAgYmdDZWxsOiBcIiNGRkZGRkZcIixcbiAgICBiZ0NlbGxNZWRpdW06IFwiI0ZBRkFGQlwiLFxuICAgIGJnSGVhZGVyOiBcIiNGN0Y3RjhcIixcbiAgICBiZ0hlYWRlckhhc0ZvY3VzOiBcIiNFOUU5RUJcIixcbiAgICBiZ0hlYWRlckhvdmVyZWQ6IFwiI0VGRUZGMVwiLFxuXG4gICAgYmdCdWJibGU6IFwiI0VERURGM1wiLFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFwiI0ZGRkZGRlwiLFxuXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFwiI2ZmZjllM1wiLFxuXG4gICAgYm9yZGVyQ29sb3I6IFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVwiLFxuICAgIGhvcml6b250YWxCb3JkZXJDb2xvcjogXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXCIsXG4gICAgZHJpbGxkb3duQm9yZGVyOiBcInJnYmEoMCwgMCwgMCwgMClcIixcblxuICAgIGxpbmtDb2xvcjogXCIjNEY1REZGXCIsXG5cbiAgICBjZWxsSG9yaXpvbnRhbFBhZGRpbmc6IDgsXG4gICAgY2VsbFZlcnRpY2FsUGFkZGluZzogMyxcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgIGJhc2VGb250U3R5bGU6IFwiMTNweFwiLFxuICAgIGVkaXRvckZvbnRTaXplOiBcIjEzcHhcIixcbiAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgZm9udEZhbWlseTpcbiAgICAgICAgXCJJbnRlciwgUm9ib3RvLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIGF2ZW5pciBuZXh0LCBhdmVuaXIsIHNlZ29lIHVpLCBoZWx2ZXRpY2EgbmV1ZSwgaGVsdmV0aWNhLCBVYnVudHUsIG5vdG8sIGFyaWFsLCBzYW5zLXNlcmlmXCIsXG59O1xuXG5jb25zdCBjb2xzOiBHcmlkQ29sdW1uW10gPSBbXG4gICAge1xuICAgICAgICB0aXRsZTogXCJBXCIsXG4gICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIGdyb3VwOiBcIkdyb3VwIDFcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiQlwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAxXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkNcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMlwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogXCJEXCIsXG4gICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIGdyb3VwOiBcIkdyb3VwIDJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiRVwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAyXCIsXG4gICAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBVc2VEYXRhU291cmNlOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBSZWFjdC51c2VSZWY8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4oe30pO1xuXG4gICAgY29uc3Qgcm93cyA9IDEwMF8wMDA7XG5cbiAgICBjb25zdCBtb3ZlQXJncyA9IHVzZU1vdmVhYmxlQ29sdW1ucyh7XG4gICAgICAgIGNvbHVtbnM6IGNvbHMsXG4gICAgICAgIGdldENlbGxDb250ZW50OiBSZWFjdC51c2VDYWxsYmFjaygoW2NvbCwgcm93XSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd31gLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7cm93fWAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7Y29sfSwke3Jvd31gO1xuICAgICAgICAgICAgaWYgKGNhY2hlLmN1cnJlbnRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudFtrZXldID0gZmFrZXIubmFtZS5maXJzdE5hbWUoKSArIFwiIFwiICsgZmFrZXIubmFtZS5sYXN0TmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZCA9IGNhY2hlLmN1cnJlbnRba2V5XTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IFtzb3J0LCBzZXRTb3J0XSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oKTtcblxuICAgIGNvbnN0IHNvcnRBcmdzID0gdXNlQ29sdW1uU29ydCh7XG4gICAgICAgIGNvbHVtbnM6IG1vdmVBcmdzLmNvbHVtbnMsXG4gICAgICAgIGdldENlbGxDb250ZW50OiBtb3ZlQXJncy5nZXRDZWxsQ29udGVudCxcbiAgICAgICAgcm93cyxcbiAgICAgICAgc29ydDpcbiAgICAgICAgICAgIHNvcnQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtb3ZlQXJncy5jb2x1bW5zW3NvcnRdLFxuICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJkZXNjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJzbWFydFwiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbGxhcHNlQXJncyA9IHVzZUNvbGxhcHNpbmdHcm91cHMoe1xuICAgICAgICBjb2x1bW5zOiBtb3ZlQXJncy5jb2x1bW5zLFxuICAgICAgICB0aGVtZTogdGVzdFRoZW1lLFxuICAgICAgICBmcmVlemVDb2x1bW5zOiAwLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25IZWFkZXJDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldFNvcnQoaW5kZXgpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyIHRpdGxlPVwiQ3VzdG9tIHNvdXJjZSBleHRlbnNpb25zXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5GaXhtZS48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLm1vdmVBcmdzfVxuICAgICAgICAgICAgICAgIHsuLi5zb3J0QXJnc31cbiAgICAgICAgICAgICAgICB7Li4uY29sbGFwc2VBcmdzfVxuICAgICAgICAgICAgICAgIHJvd3M9e3Jvd3N9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5Nb3ZlZD17bW92ZUFyZ3Mub25Db2x1bW5Nb3ZlZH1cbiAgICAgICAgICAgICAgICBvbkhlYWRlckNsaWNrZWQ9e29uSGVhZGVyQ2xpY2t9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07O1xuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFVuZG9SZWRvOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzOiBjb2x1bW5zLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIGNvbnN0IGdyaWRSZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XG5cbiAgICBjb25zdCB7IGdyaWRTZWxlY3Rpb24sIG9uQ2VsbEVkaXRlZCwgb25HcmlkU2VsZWN0aW9uQ2hhbmdlLCB1bmRvLCBjYW5SZWRvLCBjYW5VbmRvLCByZWRvIH0gPSB1c2VVbmRvUmVkbyhcbiAgICAgICAgZ3JpZFJlZixcbiAgICAgICAgZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIHNldENlbGxWYWx1ZVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJVbmRvIC8gUmVkbyBTdXBwb3J0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgc2ltcGxlIHVuZG8vcmVkbyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBVc2Uga2V5Ym9hcmQgc2hvcnRjdXRzIENNRCtaIGFuZCBDTUQrU0hJRlQrWiAvIENUUkwrWiBhbmQgQ1RSTCtZLiBPciBjbGljayB0aGVzZSBidXR0b25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXt1bmRvfSBkaXNhYmxlZD17IWNhblVuZG99IHN0eWxlPXt7IG9wYWNpdHk6IGNhblVuZG8gPyAxIDogMC40IH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVuZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtyZWRvfSBkaXNhYmxlZD17IWNhblJlZG99IHN0eWxlPXt7IG9wYWNpdHk6IGNhblJlZG8gPyAxIDogMC40IH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBJdCB3b3JrcyBieSB0YWtpbmcgYSBzbmFwc2hvdCBvZiB0aGUgY29udGVudCBvZiBhIGNlbGwgYmVmb3JlIGl0IGlzIGVkaXRlZCBhbmQgcmVwbGF5aW5nIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHMgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByZWY9e2dyaWRSZWZ9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtvbkNlbGxFZGl0ZWR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdyaWRTZWxlY3Rpb249e2dyaWRTZWxlY3Rpb24gPz8gdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17b25HcmlkU2VsZWN0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihVbmRvUmVkbyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./packages/core/dist/index.css":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* linaria:data-grid-overlay-editor-style_115vs9w.linaria.css */\n.d1t1th9s {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow: hidden;\n  box-sizing: border-box;\n  --overlay-top:var(--d1t1th9s-0);\n  left: var(--d1t1th9s-1);\n  top: var(--d1t1th9s-2);\n  min-width: var(--d1t1th9s-3);\n  min-height: var(--d1t1th9s-4);\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 400px;\n  max-height: calc(100vh - var(--d1t1th9s-5));\n  font-family: var(--gdg-font-family);\n  font-size: var(--gdg-editor-font-size);\n  text-align: start;\n}\n@-webkit-keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n@keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n.d1t1th9s.gdg-style {\n  border-radius: 2px;\n  background-color: var(--gdg-bg-cell);\n  box-shadow:\n    0 0 0 1px var(--gdg-accent-color),\n    0px 0px 1px rgba(62, 65, 86, 0.4),\n    0px 6px 12px rgba(62, 65, 86, 0.15);\n  -webkit-animation: glide_fade_in-d1t1th9s 60ms 1;\n  animation: glide_fade_in-d1t1th9s 60ms 1;\n}\n.d1t1th9s.pad {\n  padding: var(--d1t1th9s-6) 8.5px 3px;\n}\n.d1t1th9s .clip-region {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow-y: auto;\n  overflow-x: hidden;\n  border-radius: 2px;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.d1t1th9s .clip-region .gdg-growing-entry {\n  height: 100%;\n}\n.d1t1th9s .clip-region input.gdg-input {\n  width: 100%;\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.d1t1th9s .clip-region textarea.gdg-input {\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n\n/* linaria:scrolling-data-grid_zcytub.linaria.css */\n.m15w2ly5 {\n  position: absolute;\n  right: 44px;\n  bottom: 44px;\n  background-color: var(--gdg-bg-cell);\n  background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n  border-radius: 4px;\n  z-index: 1;\n  box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n}\n.m15w2ly5 .header {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 4px;\n  background-color: var(--gdg-bg-header);\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n}\n.m15w2ly5 .locationMarker {\n  position: absolute;\n  border: 1px solid var(--gdg-accent-color);\n  background-color: var(--gdg-accent-light);\n}\n\n/* linaria:infinite-scroller_1qseojb.linaria.css */\n.s1jz82f8 .dvn-scroller {\n  overflow: var(--s1jz82f8-0);\n  -webkit-transform: translate3d(0, 0, 0);\n  -ms-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n}\n.s1jz82f8 .hidden {\n  visibility: hidden;\n}\n.s1jz82f8 .dvn-scroll-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  pointer-events: none;\n}\n.s1jz82f8 .dvn-scroll-inner > * {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-spacer {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-stack {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n}\n.s1jz82f8 .dvn-underlay > * {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.s1jz82f8 canvas {\n  outline: none;\n}\n.s1jz82f8 canvas * {\n  height: 0;\n}\n\n/* linaria:data-grid-search-style_jgiiup.linaria.css */\n.sxep88s {\n  position: absolute;\n  top: 4px;\n  right: 20px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  padding: 8px;\n  border: 1px solid var(--gdg-border-color);\n  border-radius: 6px;\n  font-size: var(--gdg-editor-font-size);\n  -webkit-transform: translateX(var(--sxep88s-0));\n  -ms-transform: translateX(var(--sxep88s-0));\n  transform: translateX(var(--sxep88s-0));\n  -webkit-transition: -webkit-transform 0.15s;\n  -webkit-transition: transform 0.15s;\n  transition: transform 0.15s;\n}\n.sxep88s .search-bar-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.sxep88s .search-status {\n  padding-top: 4px;\n  font-size: 11px;\n}\n.sxep88s .search-progress {\n  position: absolute;\n  height: 4px;\n  left: 0;\n  bottom: 0;\n  background-color: var(--gdg-text-light);\n}\n.sxep88s input {\n  width: 220px;\n  color: var(--gdg-textDark);\n  background-color: var(--gdg-bg-cell);\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.sxep88s button {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  outline: none;\n  background: none;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  cursor: pointer;\n  color: var(--gdg-text-medium);\n}\n.sxep88s button:hover {\n  color: var(--gdg-text-dark);\n}\n.sxep88s button .button-icon {\n  width: 16px;\n  height: 16px;\n}\n.sxep88s button:disabled {\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n/* linaria:group-rename_yc2zuw.linaria.css */\n.r1kzy40b {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  border: none;\n  outline: none;\n  background-color: var(--gdg-bg-header-has-focus);\n  border-radius: 9px;\n  padding: 0 8px;\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n  color: var(--gdg-text-group-header);\n  min-height: var(--r1kzy40b-0);\n  font: var(--gdg-header-font-style) var(--gdg-font-family);\n}\n.c1sqdbw3 {\n  padding: 0 8px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  background-color: var(--gdg-bg-header);\n}\n\n/* linaria:data-grid-container_gfrgfn.linaria.css */\n.wzg2m5k {\n  position: relative;\n  min-width: 10px;\n  min-height: 10px;\n  max-width: 100%;\n  max-height: 100%;\n  width: var(--wzg2m5k-0);\n  height: var(--wzg2m5k-1);\n  overflow: hidden;\n  overflow: clip;\n  contain: strict;\n}\n.wzg2m5k > :first-child {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n\n/* linaria:bubbles-overlay-editor-style_1022dut.linaria.css */\n.b1bqsp5z {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.b1bqsp5z .boe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 20px;\n  background-color: var(--gdg-bg-bubble);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n}\n.b1bqsp5z textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:drilldown-overlay-editor_1gv6dry.linaria.css */\n.df2kt4a {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.df2kt4a .doe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 24px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n  border-radius: 6px;\n  box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n}\n.df2kt4a .doe-bubble img {\n  height: 16px;\n  object-fit: contain;\n  margin-right: 4px;\n}\n.df2kt4a textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:image-overlay-editor-style_sojiwi.linaria.css */\n.i1eozt10 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  height: 100%;\n}\n.i1eozt10 .centering-container {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  height: 100%;\n}\n.i1eozt10 .centering-container img,\n.i1eozt10 .centering-container canvas {\n  max-height: calc(100vh - var(--overlay-top) - 20px);\n  object-fit: contain;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.i1eozt10 .centering-container canvas {\n  max-width: 380px;\n}\n.i1eozt10 .edit-icon {\n  position: absolute;\n  top: 12px;\n  right: 0;\n  width: 48px;\n  height: 48px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.i1eozt10 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.i1eozt10 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:markdown-container_kvmc63.linaria.css */\n.mlbeo71 {\n  word-break: break-word;\n  -webkit-touch-callout: default;\n  padding-top: 6px;\n}\n.mlbeo71 > * {\n  margin: 0;\n}\n.mlbeo71 *:last-child {\n  margin-bottom: 0;\n}\n.mlbeo71 p img {\n  width: 100%;\n}\n\n/* linaria:growing-entry-style_ycxqui.linaria.css */\n.ijuk0po {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 0px;\n  resize: none;\n  white-space: pre-wrap;\n  min-width: 100%;\n  overflow: hidden;\n  border: 0;\n  background-color: transparent;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n}\n.ijuk0po::-webkit-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::-moz-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po:-ms-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::placeholder {\n  color: var(--gdg-text-light);\n}\n.invalid .ijuk0po {\n  -webkit-text-decoration: underline;\n  text-decoration: underline;\n  -webkit-text-decoration-color: #d60606;\n  text-decoration-color: #d60606;\n}\n.saq3p5l {\n  visibility: hidden;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 100%;\n  min-width: 100%;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n  padding-bottom: 2px;\n}\n.gf8vzix {\n  position: relative;\n  margin-top: 6px;\n}\n\n/* linaria:markdown-overlay-editor-style_nbv04l.linaria.css */\n.mdwzdl1 {\n  min-width: var(--mdwzdl1-0);\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: flex-start;\n  -webkit-box-align: flex-start;\n  -ms-flex-align: flex-start;\n  align-items: flex-start;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  position: relative;\n  color: var(--gdg-text-dark);\n}\n.mdwzdl1 .gf8vzix {\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  min-width: 0;\n}\n.mdwzdl1 .spacer {\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n}\n.mdwzdl1 .edit-icon {\n  position: relative;\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  color: var(--gdg-accent-color);\n  padding: 0;\n  height: 24px;\n  width: 24px;\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  -webkit-transition: all \"0.125s ease\";\n  transition: all \"0.125s ease\";\n  border-radius: 6px;\n}\n.mdwzdl1 .edit-icon > * {\n  width: 16px;\n  height: 16px;\n}\n.mdwzdl1 .edit-hover:hover {\n  background-color: var(--gdg-accent-light);\n  -webkit-transition: background-color 150ms;\n  transition: background-color 150ms;\n}\n.mdwzdl1 .checkmark-hover:hover {\n  color: #ffffff;\n  background-color: var(--gdg-accent-color);\n}\n.mdwzdl1 .md-edit-textarea {\n  position: relative;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  margin-top: 25px;\n  opacity: 0;\n  padding: 0;\n}\n.mdwzdl1 .ml-6 {\n  margin-left: 6px;\n}\n\n/* linaria:number-overlay-editor-style_1i1z3n.linaria.css */\n.n1czszh3 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  margin: 6px 0 3px;\n  color: var(--gdg-text-dark);\n}\n.n1czszh3 > input {\n  font-size: var(--gdg-editor-font-size);\n  padding: 0;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  background-color: var(--gdg-bg-cell);\n}\n\n/* linaria:uri-overlay-editor-style_nguq6d.linaria.css */\n.uf0sjo8 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  min-height: 21px;\n}\n.uf0sjo8 .link-area {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  cursor: pointer;\n  margin-right: 8px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: var(--gdg-link-color);\n  -webkit-text-decoration: underline !important;\n  text-decoration: underline !important;\n}\n.uf0sjo8 .edit-icon {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  width: 32px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.uf0sjo8 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.uf0sjo8 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n/*# sourceMappingURL=index.css.map */\n", "",{"version":3,"sources":["webpack://./packages/core/dist/index.css","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/infinite-scroller.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-search/data-grid-search-style.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/group-rename.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor-container/data-grid-container.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/markdown-div/private/markdown-container.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/growing-entry/growing-entry-style.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/number-overlay-editor-style.tsx","/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx"],"names":[".d1t1th9s",".m15w2ly5",".s1jz82f8",".sxep88s",".r1kzy40b",".c1sqdbw3",".wzg2m5k",".b1bqsp5z",".df2kt4a",".i1eozt10",".mlbeo71",".ijuk0po",".saq3p5l",".gf8vzix",".mdwzdl1",".n1czszh3",".uf0sjo8"],"mappings":"AAAA,+DAA+D;ACCrBA;EAAAA,kBAAAA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,8BAAAA;EAAAA,0BAAAA;EAAAA,sBAAAA;EAAAA,gBAAAA;EAAAA,sBAAAA;EAAAA,+BAAAA;EAAAA,uBAAAA;EAAAA,sBAAAA;EAAAA,4BAAAA;EAAAA,6BAAAA;EAAAA,0BAAAA;EAAAA,uBAAAA;EAAAA,kBAAAA;EAAAA,gBAAAA;EAAAA,2CAAAA;EAAAA,mCAAAA;EAAAA,sCAAAA;EAAAA,iBAAAA;ADwB1C;ACxB0CA;ED0BxC;IC1BwCA,WAAAA;ED4BxC;EACA;IC7BwCA,aAAAA;ED+BxC;AACF;AChC0CA;EDkCxC;IClCwCA,WAAAA;EDoCxC;EACA;ICrCwCA,aAAAA;EDuCxC;AACF;ACxC0CA;EAAAA,kBAAAA;EAAAA,oCAAAA;EAAAA;;;uCD+CH;EC/CGA,gDAAAA;EAAAA,wCAAAA;ADkD1C;AClD0CA;EAAAA,oCAAAA;ADqD1C;ACrD0CA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,8BAAAA;EAAAA,0BAAAA;EAAAA,sBAAAA;EAAAA,gBAAAA;EAAAA,kBAAAA;EAAAA,kBAAAA;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,oBAAAA;EAAAA,YAAAA;ADqE1C;ACrE0CA;EAAAA,YAAAA;ADwE1C;ACxE0CA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,eAAAA;EAAAA,aAAAA;AD8E1C;AC9E0CA;EAAAA,YAAAA;EAAAA,eAAAA;EAAAA,aAAAA;ADmF1C;;AAEA,mDAAmD;AEjF9BC;EAAAA,kBAAAA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,oCAAAA;EAAAA,0EAAAA;EAAAA,kBAAAA;EAAAA,UAAAA;EAAAA,4EAAAA;EAAAA,gBAAAA;AF4FrB;AE5FqBA;EAAAA,kBAAAA;EAAAA,OAAAA;EAAAA,MAAAA;EAAAA,WAAAA;EAAAA,WAAAA;EAAAA,sCAAAA;EAAAA,6CAAAA;AFqGrB;AErGqBA;EAAAA,kBAAAA;EAAAA,yCAAAA;EAAAA,yCAAAA;AF0GrB;;AAEA,kDAAkD;AG5GxBC;EAAAA,2BAAAA;EAAAA,uCAAAA;EAAAA,mCAAAA;EAAAA,+BAAAA;AHkH1B;AGlH0BA;EAAAA,kBAAAA;AHqH1B;AGrH0BA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,oBAAAA;AH4H1B;AG5H0BA;EAAAA,sBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;AHiI1B;AGjI0BA;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,oBAAAA;EAAAA,YAAAA;AHuI1B;AGvI0BA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,8BAAAA;EAAAA,0BAAAA;EAAAA,sBAAAA;AHgJ1B;AGhJ0BA;EAAAA,kBAAAA;EAAAA,OAAAA;EAAAA,MAAAA;AHqJ1B;AGrJ0BA;EAAAA,aAAAA;AHwJ1B;AGxJ0BA;EAAAA,SAAAA;AH2J1B;;AAEA,sDAAsD;AIjKzBC;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,WAAAA;EAAAA,oCAAAA;EAAAA,2BAAAA;EAAAA,YAAAA;EAAAA,yCAAAA;EAAAA,kBAAAA;EAAAA,sCAAAA;EAAAA,+CAAAA;EAAAA,2CAAAA;EAAAA,uCAAAA;EAAAA,2CAAAA;EAAAA,mCAAAA;EAAAA,2BAAAA;AJkL7B;AIlL6BA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;AJwL7B;AIxL6BA;EAAAA,gBAAAA;EAAAA,eAAAA;AJ4L7B;AI5L6BA;EAAAA,kBAAAA;EAAAA,WAAAA;EAAAA,OAAAA;EAAAA,SAAAA;EAAAA,uCAAAA;AJmM7B;AInM6BA;EAAAA,YAAAA;EAAAA,0BAAAA;EAAAA,oCAAAA;EAAAA,YAAAA;EAAAA,eAAAA;EAAAA,aAAAA;AJ2M7B;AI3M6BA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,UAAAA;EAAAA,YAAAA;EAAAA,aAAAA;EAAAA,gBAAAA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,wBAAAA;EAAAA,+BAAAA;EAAAA,qBAAAA;EAAAA,uBAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;EAAAA,eAAAA;EAAAA,6BAAAA;AJiO7B;AIjO6BA;EAAAA,2BAAAA;AJoO7B;AIpO6BA;EAAAA,WAAAA;EAAAA,YAAAA;AJwO7B;AIxO6BA;EAAAA,YAAAA;EAAAA,oBAAAA;AJ4O7B;;AAEA,4CAA4C;AK3OxBC;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,oBAAAA;EAAAA,YAAAA;EAAAA,YAAAA;EAAAA,aAAAA;EAAAA,gDAAAA;EAAAA,kBAAAA;EAAAA,cAAAA;EAAAA,6CAAAA;EAAAA,mCAAAA;EAAAA,6BAAAA;EAAAA,yDAAAA;AL0PpB;AKnOeC;EAAAA,cAAAA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;EAAAA,sCAAAA;AL+Of;;AAEA,mDAAmD;AMrQnCC;EAAAA,kBAAAA;EAAAA,eAAAA;EAAAA,gBAAAA;EAAAA,eAAAA;EAAAA,gBAAAA;EAAAA,uBAAAA;EAAAA,wBAAAA;EAAAA,gBAAAA;EAAAA,cAAAA;EAAAA,eAAAA;ANiRhB;AMjRgBA;EAAAA,kBAAAA;EAAAA,OAAAA;EAAAA,MAAAA;EAAAA,WAAAA;EAAAA,YAAAA;ANwRhB;;AAEA,6DAA6D;AOhSpBC;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,eAAAA;APySzC;AOzSyCA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,wBAAAA;EAAAA,+BAAAA;EAAAA,qBAAAA;EAAAA,uBAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;EAAAA,YAAAA;EAAAA,sCAAAA;EAAAA,2BAAAA;EAAAA,WAAAA;AP6TzC;AO7TyCA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,UAAAA;APqUzC;;AAEA,yDAAyD;AQtUrBC;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,eAAAA;AR+UpC;AQ/UoCA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,wBAAAA;EAAAA,+BAAAA;EAAAA,qBAAAA;EAAAA,uBAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;EAAAA,YAAAA;EAAAA,oCAAAA;EAAAA,2BAAAA;EAAAA,WAAAA;EAAAA,kBAAAA;EAAAA,0EAAAA;ARqWpC;AQrWoCA;EAAAA,YAAAA;EAAAA,mBAAAA;EAAAA,iBAAAA;AR0WpC;AQ1WoCA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,UAAAA;ARkXpC;;AAEA,0DAA0D;ASrXnBC;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,YAAAA;AT4XvC;AS5XuCA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,wBAAAA;EAAAA,+BAAAA;EAAAA,qBAAAA;EAAAA,uBAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;EAAAA,YAAAA;AT2YvC;AS3YuCA;;EAAAA,mDAAAA;EAAAA,mBAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,qBAAAA;EAAAA,iBAAAA;AToZvC;ASpZuCA;EAAAA,gBAAAA;ATuZvC;ASvZuCA;EAAAA,kBAAAA;EAAAA,SAAAA;EAAAA,QAAAA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,8BAAAA;EAAAA,eAAAA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,wBAAAA;EAAAA,+BAAAA;EAAAA,qBAAAA;EAAAA,uBAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;AT4avC;AS5auCA;EAAAA,WAAAA;EAAAA,YAAAA;ATgbvC;AShbuCA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,UAAAA;ATwbvC;;AAEA,kDAAkD;AU1bjBC;EAAAA,sBAAAA;EAAAA,8BAAAA;EAAAA,gBAAAA;AV+bjC;AU/biCA;EAAAA,SAAAA;AVkcjC;AUlciCA;EAAAA,gBAAAA;AVqcjC;AUrciCA;EAAAA,WAAAA;AVwcjC;;AAEA,mDAAmD;AW1c3BC;EAAAA,kBAAAA;EAAAA,OAAAA;EAAAA,QAAAA;EAAAA,MAAAA;EAAAA,SAAAA;EAAAA,WAAAA;EAAAA,YAAAA;EAAAA,kBAAAA;EAAAA,YAAAA;EAAAA,qBAAAA;EAAAA,eAAAA;EAAAA,gBAAAA;EAAAA,SAAAA;EAAAA,6BAAAA;EAAAA,sCAAAA;EAAAA,iBAAAA;EAAAA,mCAAAA;EAAAA,2BAAAA;EAAAA,UAAAA;EAAAA,SAAAA;AXgexB;AWhewBA;EAAAA,4BAAAA;AXmexB;AWnewBA;EAAAA,4BAAAA;AXsexB;AWtewBA;EAAAA,4BAAAA;AXyexB;AWzewBA;EAAAA,4BAAAA;AX4exB;AW5ewBA;EAAAA,kCAAAA;EAAAA,0BAAAA;EAAAA,sCAAAA;EAAAA,8BAAAA;AXkfxB;AWhdyBC;EAAAA,kBAAAA;EAAAA,qBAAAA;EAAAA,qBAAAA;EAAAA,0BAAAA;EAAAA,uBAAAA;EAAAA,kBAAAA;EAAAA,eAAAA;EAAAA,eAAAA;EAAAA,sCAAAA;EAAAA,iBAAAA;EAAAA,mCAAAA;EAAAA,2BAAAA;EAAAA,UAAAA;EAAAA,SAAAA;EAAAA,mBAAAA;AXiezB;AW9ciCC;EAAAA,kBAAAA;EAAAA,eAAAA;AXkdjC;;AAEA,6DAA6D;AYxgBnBC;EAAAA,2BAAAA;EAAAA,WAAAA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,+BAAAA;EAAAA,6BAAAA;EAAAA,0BAAAA;EAAAA,uBAAAA;EAAAA,yBAAAA;EAAAA,sCAAAA;EAAAA,sBAAAA;EAAAA,8BAAAA;EAAAA,kBAAAA;EAAAA,2BAAAA;AZ0hB1C;AY1hB0CA;EAAAA,sBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;EAAAA,YAAAA;AZgiB1C;AYhiB0CA;EAAAA,eAAAA;EAAAA,WAAAA;EAAAA,OAAAA;AZqiB1C;AYriB0CA;EAAAA,kBAAAA;EAAAA,eAAAA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,wBAAAA;EAAAA,+BAAAA;EAAAA,qBAAAA;EAAAA,uBAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;EAAAA,8BAAAA;EAAAA,UAAAA;EAAAA,YAAAA;EAAAA,WAAAA;EAAAA,sBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;EAAAA,qCAAAA;EAAAA,6BAAAA;EAAAA,kBAAAA;AZ+jB1C;AY/jB0CA;EAAAA,WAAAA;EAAAA,YAAAA;AZmkB1C;AYnkB0CA;EAAAA,yCAAAA;EAAAA,0CAAAA;EAAAA,kCAAAA;AZwkB1C;AYxkB0CA;EAAAA,cAAAA;EAAAA,yCAAAA;AZ4kB1C;AY5kB0CA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,gBAAAA;EAAAA,UAAAA;EAAAA,UAAAA;AZslB1C;AYtlB0CA;EAAAA,gBAAAA;AZylB1C;;AAEA,2DAA2D;Aa5lBnBC;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,iBAAAA;EAAAA,2BAAAA;AbomBxC;AapmBwCA;EAAAA,sCAAAA;EAAAA,UAAAA;EAAAA,mCAAAA;EAAAA,2BAAAA;EAAAA,oCAAAA;Ab2mBxC;;AAEA,wDAAwD;Ac7mBnBC;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,oBAAAA;EAAAA,YAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;EAAAA,gBAAAA;Ad4nBrC;Ac5nBqCA;EAAAA,mBAAAA;EAAAA,oBAAAA;EAAAA,oBAAAA;EAAAA,YAAAA;EAAAA,sBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;EAAAA,eAAAA;EAAAA,iBAAAA;EAAAA,gBAAAA;EAAAA,uBAAAA;EAAAA,mBAAAA;EAAAA,4BAAAA;EAAAA,6CAAAA;EAAAA,qCAAAA;Ad6oBrC;Ac7oBqCA;EAAAA,sBAAAA;EAAAA,oBAAAA;EAAAA,cAAAA;EAAAA,WAAAA;EAAAA,8BAAAA;EAAAA,eAAAA;EAAAA,oBAAAA;EAAAA,qBAAAA;EAAAA,oBAAAA;EAAAA,aAAAA;EAAAA,wBAAAA;EAAAA,+BAAAA;EAAAA,qBAAAA;EAAAA,uBAAAA;EAAAA,2BAAAA;EAAAA,yBAAAA;EAAAA,sBAAAA;EAAAA,mBAAAA;AdiqBrC;AcjqBqCA;EAAAA,WAAAA;EAAAA,YAAAA;AdqqBrC;AcrqBqCA;EAAAA,kBAAAA;EAAAA,QAAAA;EAAAA,SAAAA;EAAAA,UAAAA;EAAAA,WAAAA;EAAAA,UAAAA;Ad6qBrC;AACA,oCAAoC","sourcesContent":["/* linaria:data-grid-overlay-editor-style_115vs9w.linaria.css */\n.d1t1th9s {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow: hidden;\n  box-sizing: border-box;\n  --overlay-top:var(--d1t1th9s-0);\n  left: var(--d1t1th9s-1);\n  top: var(--d1t1th9s-2);\n  min-width: var(--d1t1th9s-3);\n  min-height: var(--d1t1th9s-4);\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 400px;\n  max-height: calc(100vh - var(--d1t1th9s-5));\n  font-family: var(--gdg-font-family);\n  font-size: var(--gdg-editor-font-size);\n  text-align: start;\n}\n@-webkit-keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n@keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n.d1t1th9s.gdg-style {\n  border-radius: 2px;\n  background-color: var(--gdg-bg-cell);\n  box-shadow:\n    0 0 0 1px var(--gdg-accent-color),\n    0px 0px 1px rgba(62, 65, 86, 0.4),\n    0px 6px 12px rgba(62, 65, 86, 0.15);\n  -webkit-animation: glide_fade_in-d1t1th9s 60ms 1;\n  animation: glide_fade_in-d1t1th9s 60ms 1;\n}\n.d1t1th9s.pad {\n  padding: var(--d1t1th9s-6) 8.5px 3px;\n}\n.d1t1th9s .clip-region {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow-y: auto;\n  overflow-x: hidden;\n  border-radius: 2px;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.d1t1th9s .clip-region .gdg-growing-entry {\n  height: 100%;\n}\n.d1t1th9s .clip-region input.gdg-input {\n  width: 100%;\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.d1t1th9s .clip-region textarea.gdg-input {\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n\n/* linaria:scrolling-data-grid_zcytub.linaria.css */\n.m15w2ly5 {\n  position: absolute;\n  right: 44px;\n  bottom: 44px;\n  background-color: var(--gdg-bg-cell);\n  background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n  border-radius: 4px;\n  z-index: 1;\n  box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n}\n.m15w2ly5 .header {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 4px;\n  background-color: var(--gdg-bg-header);\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n}\n.m15w2ly5 .locationMarker {\n  position: absolute;\n  border: 1px solid var(--gdg-accent-color);\n  background-color: var(--gdg-accent-light);\n}\n\n/* linaria:infinite-scroller_1qseojb.linaria.css */\n.s1jz82f8 .dvn-scroller {\n  overflow: var(--s1jz82f8-0);\n  -webkit-transform: translate3d(0, 0, 0);\n  -ms-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n}\n.s1jz82f8 .hidden {\n  visibility: hidden;\n}\n.s1jz82f8 .dvn-scroll-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  pointer-events: none;\n}\n.s1jz82f8 .dvn-scroll-inner > * {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-spacer {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-stack {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n}\n.s1jz82f8 .dvn-underlay > * {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.s1jz82f8 canvas {\n  outline: none;\n}\n.s1jz82f8 canvas * {\n  height: 0;\n}\n\n/* linaria:data-grid-search-style_jgiiup.linaria.css */\n.sxep88s {\n  position: absolute;\n  top: 4px;\n  right: 20px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  padding: 8px;\n  border: 1px solid var(--gdg-border-color);\n  border-radius: 6px;\n  font-size: var(--gdg-editor-font-size);\n  -webkit-transform: translateX(var(--sxep88s-0));\n  -ms-transform: translateX(var(--sxep88s-0));\n  transform: translateX(var(--sxep88s-0));\n  -webkit-transition: -webkit-transform 0.15s;\n  -webkit-transition: transform 0.15s;\n  transition: transform 0.15s;\n}\n.sxep88s .search-bar-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.sxep88s .search-status {\n  padding-top: 4px;\n  font-size: 11px;\n}\n.sxep88s .search-progress {\n  position: absolute;\n  height: 4px;\n  left: 0;\n  bottom: 0;\n  background-color: var(--gdg-text-light);\n}\n.sxep88s input {\n  width: 220px;\n  color: var(--gdg-textDark);\n  background-color: var(--gdg-bg-cell);\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.sxep88s button {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  outline: none;\n  background: none;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  cursor: pointer;\n  color: var(--gdg-text-medium);\n}\n.sxep88s button:hover {\n  color: var(--gdg-text-dark);\n}\n.sxep88s button .button-icon {\n  width: 16px;\n  height: 16px;\n}\n.sxep88s button:disabled {\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n/* linaria:group-rename_yc2zuw.linaria.css */\n.r1kzy40b {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  border: none;\n  outline: none;\n  background-color: var(--gdg-bg-header-has-focus);\n  border-radius: 9px;\n  padding: 0 8px;\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n  color: var(--gdg-text-group-header);\n  min-height: var(--r1kzy40b-0);\n  font: var(--gdg-header-font-style) var(--gdg-font-family);\n}\n.c1sqdbw3 {\n  padding: 0 8px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  background-color: var(--gdg-bg-header);\n}\n\n/* linaria:data-grid-container_gfrgfn.linaria.css */\n.wzg2m5k {\n  position: relative;\n  min-width: 10px;\n  min-height: 10px;\n  max-width: 100%;\n  max-height: 100%;\n  width: var(--wzg2m5k-0);\n  height: var(--wzg2m5k-1);\n  overflow: hidden;\n  overflow: clip;\n  contain: strict;\n}\n.wzg2m5k > :first-child {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n\n/* linaria:bubbles-overlay-editor-style_1022dut.linaria.css */\n.b1bqsp5z {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.b1bqsp5z .boe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 20px;\n  background-color: var(--gdg-bg-bubble);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n}\n.b1bqsp5z textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:drilldown-overlay-editor_1gv6dry.linaria.css */\n.df2kt4a {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.df2kt4a .doe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 24px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n  border-radius: 6px;\n  box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n}\n.df2kt4a .doe-bubble img {\n  height: 16px;\n  object-fit: contain;\n  margin-right: 4px;\n}\n.df2kt4a textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:image-overlay-editor-style_sojiwi.linaria.css */\n.i1eozt10 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  height: 100%;\n}\n.i1eozt10 .centering-container {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  height: 100%;\n}\n.i1eozt10 .centering-container img,\n.i1eozt10 .centering-container canvas {\n  max-height: calc(100vh - var(--overlay-top) - 20px);\n  object-fit: contain;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.i1eozt10 .centering-container canvas {\n  max-width: 380px;\n}\n.i1eozt10 .edit-icon {\n  position: absolute;\n  top: 12px;\n  right: 0;\n  width: 48px;\n  height: 48px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.i1eozt10 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.i1eozt10 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:markdown-container_kvmc63.linaria.css */\n.mlbeo71 {\n  word-break: break-word;\n  -webkit-touch-callout: default;\n  padding-top: 6px;\n}\n.mlbeo71 > * {\n  margin: 0;\n}\n.mlbeo71 *:last-child {\n  margin-bottom: 0;\n}\n.mlbeo71 p img {\n  width: 100%;\n}\n\n/* linaria:growing-entry-style_ycxqui.linaria.css */\n.ijuk0po {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 0px;\n  resize: none;\n  white-space: pre-wrap;\n  min-width: 100%;\n  overflow: hidden;\n  border: 0;\n  background-color: transparent;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n}\n.ijuk0po::-webkit-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::-moz-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po:-ms-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::placeholder {\n  color: var(--gdg-text-light);\n}\n.invalid .ijuk0po {\n  -webkit-text-decoration: underline;\n  text-decoration: underline;\n  -webkit-text-decoration-color: #d60606;\n  text-decoration-color: #d60606;\n}\n.saq3p5l {\n  visibility: hidden;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 100%;\n  min-width: 100%;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n  padding-bottom: 2px;\n}\n.gf8vzix {\n  position: relative;\n  margin-top: 6px;\n}\n\n/* linaria:markdown-overlay-editor-style_nbv04l.linaria.css */\n.mdwzdl1 {\n  min-width: var(--mdwzdl1-0);\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: flex-start;\n  -webkit-box-align: flex-start;\n  -ms-flex-align: flex-start;\n  align-items: flex-start;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  position: relative;\n  color: var(--gdg-text-dark);\n}\n.mdwzdl1 .gf8vzix {\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  min-width: 0;\n}\n.mdwzdl1 .spacer {\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n}\n.mdwzdl1 .edit-icon {\n  position: relative;\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  color: var(--gdg-accent-color);\n  padding: 0;\n  height: 24px;\n  width: 24px;\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  -webkit-transition: all \"0.125s ease\";\n  transition: all \"0.125s ease\";\n  border-radius: 6px;\n}\n.mdwzdl1 .edit-icon > * {\n  width: 16px;\n  height: 16px;\n}\n.mdwzdl1 .edit-hover:hover {\n  background-color: var(--gdg-accent-light);\n  -webkit-transition: background-color 150ms;\n  transition: background-color 150ms;\n}\n.mdwzdl1 .checkmark-hover:hover {\n  color: #ffffff;\n  background-color: var(--gdg-accent-color);\n}\n.mdwzdl1 .md-edit-textarea {\n  position: relative;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  margin-top: 25px;\n  opacity: 0;\n  padding: 0;\n}\n.mdwzdl1 .ml-6 {\n  margin-left: 6px;\n}\n\n/* linaria:number-overlay-editor-style_1i1z3n.linaria.css */\n.n1czszh3 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  margin: 6px 0 3px;\n  color: var(--gdg-text-dark);\n}\n.n1czszh3 > input {\n  font-size: var(--gdg-editor-font-size);\n  padding: 0;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  background-color: var(--gdg-bg-cell);\n}\n\n/* linaria:uri-overlay-editor-style_nguq6d.linaria.css */\n.uf0sjo8 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  min-height: 21px;\n}\n.uf0sjo8 .link-area {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  cursor: pointer;\n  margin-right: 8px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: var(--gdg-link-color);\n  -webkit-text-decoration: underline !important;\n  text-decoration: underline !important;\n}\n.uf0sjo8 .edit-icon {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  width: 32px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.uf0sjo8 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.uf0sjo8 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n/*# sourceMappingURL=index.css.map */\n","import { styled } from \"@linaria/react\";\nexport const DataGridOverlayEditorStyle = styled.div`\n    position: absolute;\n\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    box-sizing: border-box;\n\n    --overlay-top: ${(p) => p.targetY}px;\n\n    left: ${(p) => p.targetX - 1}px;\n    top: ${(p) => p.targetY - 1}px;\n    min-width: ${(p) => p.targetWidth + 2}px;\n    min-height: ${(p) => p.targetHeight + 2}px;\n    width: max-content;\n    max-width: 400px;\n    max-height: calc(100vh - ${(p) => p.targetY + 10}px);\n\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n\n    @keyframes glide_fade_in {\n        from {\n            opacity: 0%;\n        }\n\n        to {\n            opacity: 100%;\n        }\n    }\n\n    &.gdg-style {\n        border-radius: 2px;\n        background-color: var(--gdg-bg-cell);\n\n        box-shadow: 0 0 0 1px var(--gdg-accent-color), 0px 0px 1px rgba(62, 65, 86, 0.4),\n            0px 6px 12px rgba(62, 65, 86, 0.15);\n\n        animation: glide_fade_in 60ms 1;\n    }\n\n    &.pad {\n        padding: ${(p) => Math.max(0, (p.targetHeight - 28) / 2)}px 8.5px 3px;\n    }\n\n    .clip-region {\n        display: flex;\n        flex-direction: column;\n        overflow-y: auto;\n        overflow-x: hidden;\n        border-radius: 2px;\n        flex-grow: 1;\n\n        .gdg-growing-entry {\n            height: 100%;\n        }\n\n        & input.gdg-input {\n            width: 100%;\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n\n        & textarea.gdg-input {\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n    }\n\n    text-align: start;\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgdGFyZ2V0WDogbnVtYmVyO1xuICAgIHRhcmdldFk6IG51bWJlcjtcbiAgICB0YXJnZXRXaWR0aDogbnVtYmVyO1xuICAgIHRhcmdldEhlaWdodDogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IERhdGFHcmlkT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdjxQcm9wcz5gXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgIC0tb3ZlcmxheS10b3A6ICR7cCA9PiBwLnRhcmdldFl9cHg7XG5cbiAgICBsZWZ0OiAke3AgPT4gcC50YXJnZXRYIC0gMX1weDtcbiAgICB0b3A6ICR7cCA9PiBwLnRhcmdldFkgLSAxfXB4O1xuICAgIG1pbi13aWR0aDogJHtwID0+IHAudGFyZ2V0V2lkdGggKyAyfXB4O1xuICAgIG1pbi1oZWlnaHQ6ICR7cCA9PiBwLnRhcmdldEhlaWdodCArIDJ9cHg7XG4gICAgd2lkdGg6IG1heC1jb250ZW50O1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtICR7cCA9PiBwLnRhcmdldFkgKyAxMH1weCk7XG5cbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcblxuICAgIEBrZXlmcmFtZXMgZ2xpZGVfZmFkZV9pbiB7XG4gICAgICAgIGZyb20ge1xuICAgICAgICAgICAgb3BhY2l0eTogMCU7XG4gICAgICAgIH1cblxuICAgICAgICB0byB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5nZGctc3R5bGUge1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcblxuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWFjY2VudC1jb2xvciksIDBweCAwcHggMXB4IHJnYmEoNjIsIDY1LCA4NiwgMC40KSxcbiAgICAgICAgICAgIDBweCA2cHggMTJweCByZ2JhKDYyLCA2NSwgODYsIDAuMTUpO1xuXG4gICAgICAgIGFuaW1hdGlvbjogZ2xpZGVfZmFkZV9pbiA2MG1zIDE7XG4gICAgfVxuXG4gICAgJi5wYWQge1xuICAgICAgICBwYWRkaW5nOiAke3AgPT4gTWF0aC5tYXgoMCwgKHAudGFyZ2V0SGVpZ2h0IC0gMjgpIC8gMil9cHggOC41cHggM3B4O1xuICAgIH1cblxuICAgIC5jbGlwLXJlZ2lvbiB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICAgICAgLmdkZy1ncm93aW5nLWVudHJ5IHtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgICYgaW5wdXQuZ2RnLWlucHV0IHtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgICYgdGV4dGFyZWEuZ2RnLWlucHV0IHtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICAgIGJvcmRlci13aWR0aDogMDtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXh0LWFsaWduOiBzdGFydDtcbmA7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQVFPLGFBQU0sNkJBQTZCLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQVE1QixPQUFLLEVBQUU7QUFBQTtBQUFBLFlBRWhCLE9BQUssRUFBRSxVQUFVO0FBQUEsV0FDbEIsT0FBSyxFQUFFLFVBQVU7QUFBQSxpQkFDWCxPQUFLLEVBQUUsY0FBYztBQUFBLGtCQUNwQixPQUFLLEVBQUUsZUFBZTtBQUFBO0FBQUE7QUFBQSwrQkFHVCxPQUFLLEVBQUUsVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBMEI3QixPQUFLLEtBQUssSUFBSSxHQUFJLEdBQUUsZUFBZSxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport DataGridDnd from \"../data-grid-dnd/data-grid-dnd\";\nimport { InfiniteScroller } from \"./infinite-scroller\";\nimport clamp from \"lodash/clamp.js\";\nconst MinimapStyle = styled.div`\n    position: absolute;\n    right: 44px;\n    bottom: 44px;\n    background-color: var(--gdg-bg-cell);\n    background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n    border-radius: 4px;\n    z-index: 1;\n    box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n\n    overflow: hidden;\n\n    .header {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 4px;\n        background-color: var(--gdg-bg-header);\n        box-shadow: 0 0 0 1px var(--gdg-border-color);\n    }\n\n    .locationMarker {\n        position: absolute;\n\n        border: 1px solid var(--gdg-accent-color);\n        background-color: var(--gdg-accent-light);\n    }\n`;\nconst GridScroller = (p) => {\n  const {\n    columns,\n    rows,\n    rowHeight,\n    headerHeight,\n    groupHeaderHeight,\n    enableGroups,\n    freezeColumns,\n    experimental,\n    clientSize,\n    className,\n    onVisibleRegionChanged,\n    scrollToEnd,\n    scrollRef,\n    preventDiagonalScrolling,\n    rightElement,\n    rightElementProps,\n    overscrollX,\n    overscrollY,\n    showMinimap = false,\n    initialSize,\n    smoothScrollX = false,\n    smoothScrollY = false,\n    isDraggable\n  } = p;\n  const { paddingRight, paddingBottom } = experimental ?? {};\n  const [clientWidth, clientHeight] = clientSize;\n  const last = React.useRef();\n  const lastX = React.useRef();\n  const lastY = React.useRef();\n  const lastSize = React.useRef();\n  const width = React.useMemo(() => {\n    let r = Math.max(0, overscrollX ?? 0);\n    for (const c of columns) {\n      r += c.width;\n    }\n    return r;\n  }, [columns, overscrollX]);\n  let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n  if (typeof rowHeight === \"number\") {\n    height += rows * rowHeight;\n  } else {\n    for (let r = 0; r < rows; r++) {\n      height += rowHeight(r);\n    }\n  }\n  if (overscrollY !== void 0) {\n    height += overscrollY;\n  }\n  const lastArgs = React.useRef();\n  const processArgs = React.useCallback(() => {\n    if (lastArgs.current === void 0)\n      return;\n    const args = { ...lastArgs.current };\n    let x = 0;\n    let tx = args.x < 0 ? -args.x : 0;\n    let cellRight = 0;\n    let cellX = 0;\n    args.x = args.x < 0 ? 0 : args.x;\n    let stickyColWidth = 0;\n    for (let i = 0; i < freezeColumns; i++) {\n      stickyColWidth += columns[i].width;\n    }\n    for (const c of columns) {\n      const cx = x - stickyColWidth;\n      if (args.x >= cx + c.width) {\n        x += c.width;\n        cellX++;\n        cellRight++;\n      } else if (args.x > cx) {\n        x += c.width;\n        if (smoothScrollX) {\n          tx += cx - args.x;\n        } else {\n          cellX++;\n        }\n        cellRight++;\n      } else if (args.x + args.width > cx) {\n        x += c.width;\n        cellRight++;\n      } else {\n        break;\n      }\n    }\n    let ty = 0;\n    let cellY = 0;\n    let cellBottom = 0;\n    if (typeof rowHeight === \"number\") {\n      if (smoothScrollY) {\n        cellY = Math.floor(args.y / rowHeight);\n        ty = cellY * rowHeight - args.y;\n      } else {\n        cellY = Math.ceil(args.y / rowHeight);\n      }\n      cellBottom = Math.ceil(args.height / rowHeight) + cellY;\n      if (ty < 0)\n        cellBottom++;\n    } else {\n      let y = 0;\n      for (let row = 0; row < rows; row++) {\n        const rh = rowHeight(row);\n        const cy = y + (smoothScrollY ? 0 : rh / 2);\n        if (args.y >= y + rh) {\n          y += rh;\n          cellY++;\n          cellBottom++;\n        } else if (args.y > cy) {\n          y += rh;\n          if (smoothScrollY) {\n            ty += cy - args.y;\n          } else {\n            cellY++;\n          }\n          cellBottom++;\n        } else if (args.y + args.height > rh / 2 + y) {\n          y += rh;\n          cellBottom++;\n        } else {\n          break;\n        }\n      }\n    }\n    const rect = {\n      x: cellX,\n      y: cellY,\n      width: cellRight - cellX,\n      height: cellBottom - cellY\n    };\n    const oldRect = last.current;\n    if (oldRect === void 0 || oldRect.y !== rect.y || oldRect.x !== rect.x || oldRect.height !== rect.height || oldRect.width !== rect.width || lastX.current !== tx || lastY.current !== ty || args.width !== lastSize.current?.[0] || args.height !== lastSize.current?.[1]) {\n      onVisibleRegionChanged?.({\n        x: cellX,\n        y: cellY,\n        width: cellRight - cellX,\n        height: cellBottom - cellY\n      }, args.width, args.height, args.paddingRight ?? 0, tx, ty);\n      last.current = rect;\n      lastX.current = tx;\n      lastY.current = ty;\n      lastSize.current = [args.width, args.height];\n    }\n  }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);\n  const onScrollUpdate = React.useCallback((args) => {\n    lastArgs.current = args;\n    processArgs();\n  }, [processArgs]);\n  React.useEffect(() => {\n    processArgs();\n  }, [processArgs]);\n  const scroller = scrollRef?.current ?? void 0;\n  const aspect = clamp(width / height, 2 / 3, 1.5);\n  const maxSize = 200;\n  const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);\n  const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;\n  const hRatio = w / width;\n  const vRatio = h / height;\n  const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);\n  const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);\n  const left = (scroller?.scrollLeft ?? 0) / (width - clientWidth) * (w - vWidth);\n  const top = (scroller?.scrollTop ?? 0) / (height - clientHeight) * (h - vHeight);\n  const minimap = React.useMemo(() => {\n    if (!showMinimap || vWidth === 0 || vHeight === 0)\n      return void 0;\n    const handleMouse = (e) => {\n      if (scroller === void 0)\n        return;\n      const bounds = e.currentTarget.getBoundingClientRect();\n      const x = e.clientX - bounds.x - vWidth / 2;\n      const y = e.clientY - bounds.y - vHeight / 2;\n      const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));\n      const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));\n      scroller.scrollTo({\n        left: newScrollLeft,\n        top: newScrollTop,\n        behavior: e.type === \"mousemove\" ? \"auto\" : \"smooth\"\n      });\n    };\n    return /* @__PURE__ */ React.createElement(MinimapStyle, {\n      style: { width: w, height: h },\n      \"data-testid\": \"minimap-container\",\n      onMouseMove: (e) => {\n        if (e.buttons !== 1)\n          return;\n        handleMouse(e);\n      },\n      onClick: handleMouse\n    }, /* @__PURE__ */ React.createElement(\"div\", {\n      className: \"header\"\n    }), /* @__PURE__ */ React.createElement(\"div\", {\n      className: \"locationMarker\",\n      onDragStart: (e) => e.preventDefault(),\n      style: {\n        left,\n        top,\n        width: vWidth,\n        height: vHeight,\n        borderRadius: Math.min(vWidth, vHeight * 0.2, 9)\n      }\n    }));\n  }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);\n  return /* @__PURE__ */ React.createElement(InfiniteScroller, {\n    scrollRef,\n    minimap,\n    className,\n    preventDiagonalScrolling,\n    draggable: isDraggable === true || typeof isDraggable === \"string\",\n    scrollWidth: width + (paddingRight ?? 0),\n    scrollHeight: height + (paddingBottom ?? 0),\n    clientHeight,\n    rightElement,\n    paddingBottom,\n    paddingRight,\n    rightElementProps,\n    update: onScrollUpdate,\n    initialSize,\n    scrollToEnd\n  }, /* @__PURE__ */ React.createElement(DataGridDnd, {\n    eventTargetRef: scrollRef,\n    width: clientWidth,\n    height: clientHeight,\n    accessibilityHeight: p.accessibilityHeight,\n    canvasRef: p.canvasRef,\n    cellXOffset: p.cellXOffset,\n    cellYOffset: p.cellYOffset,\n    columns: p.columns,\n    disabledRows: p.disabledRows,\n    enableGroups: p.enableGroups,\n    fillHandle: p.fillHandle,\n    firstColAccessible: p.firstColAccessible,\n    fixedShadowX: p.fixedShadowX,\n    fixedShadowY: p.fixedShadowY,\n    freezeColumns: p.freezeColumns,\n    getCellContent: p.getCellContent,\n    getCellRenderer: p.getCellRenderer,\n    getGroupDetails: p.getGroupDetails,\n    getRowThemeOverride: p.getRowThemeOverride,\n    groupHeaderHeight: p.groupHeaderHeight,\n    headerHeight: p.headerHeight,\n    highlightRegions: p.highlightRegions,\n    imageWindowLoader: p.imageWindowLoader,\n    isFilling: p.isFilling,\n    isFocused: p.isFocused,\n    lockColumns: p.lockColumns,\n    maxColumnWidth: p.maxColumnWidth,\n    minColumnWidth: p.minColumnWidth,\n    onHeaderMenuClick: p.onHeaderMenuClick,\n    onMouseMove: p.onMouseMove,\n    prelightCells: p.prelightCells,\n    rowHeight: p.rowHeight,\n    rows: p.rows,\n    selection: p.selection,\n    theme: p.theme,\n    trailingRowType: p.trailingRowType,\n    translateX: p.translateX,\n    translateY: p.translateY,\n    verticalBorder: p.verticalBorder,\n    drawCustomCell: p.drawCustomCell,\n    drawFocusRing: p.drawFocusRing,\n    drawHeader: p.drawHeader,\n    experimental: p.experimental,\n    gridRef: p.gridRef,\n    headerIcons: p.headerIcons,\n    isDraggable: p.isDraggable,\n    onCanvasBlur: p.onCanvasBlur,\n    onCanvasFocused: p.onCanvasFocused,\n    onCellFocused: p.onCellFocused,\n    onColumnMoved: p.onColumnMoved,\n    onColumnResize: p.onColumnResize,\n    onColumnResizeEnd: p.onColumnResizeEnd,\n    onColumnResizeStart: p.onColumnResizeStart,\n    onContextMenu: p.onContextMenu,\n    onDragEnd: p.onDragEnd,\n    onDragLeave: p.onDragLeave,\n    onDragOverCell: p.onDragOverCell,\n    onDragStart: p.onDragStart,\n    onDrop: p.onDrop,\n    onItemHovered: p.onItemHovered,\n    onKeyDown: p.onKeyDown,\n    onKeyUp: p.onKeyUp,\n    onMouseDown: p.onMouseDown,\n    onMouseUp: p.onMouseUp,\n    onRowMoved: p.onRowMoved,\n    smoothScrollX: p.smoothScrollX,\n    smoothScrollY: p.smoothScrollY\n  }));\n};\nexport default GridScroller;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IERhdGFHcmlkRG5kLCB7IERhdGFHcmlkRG5kUHJvcHMgfSBmcm9tIFwiLi4vZGF0YS1ncmlkLWRuZC9kYXRhLWdyaWQtZG5kXCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzXCI7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbGVyIH0gZnJvbSBcIi4vaW5maW5pdGUtc2Nyb2xsZXJcIjtcbmltcG9ydCBjbGFtcCBmcm9tIFwibG9kYXNoL2NsYW1wLmpzXCI7XG5cbnR5cGUgUHJvcHMgPSBPbWl0PERhdGFHcmlkRG5kUHJvcHMsIFwid2lkdGhcIiB8IFwiaGVpZ2h0XCIgfCBcImV2ZW50VGFyZ2V0UmVmXCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbGluZ0RhdGFHcmlkUHJvcHMgZXh0ZW5kcyBQcm9wcyB7XG4gICAgcmVhZG9ubHkgY2xhc3NOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcmVhZG9ubHkgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZDpcbiAgICAgICAgfCAoKFxuICAgICAgICAgICAgICByYW5nZTogUmVjdGFuZ2xlLFxuICAgICAgICAgICAgICBjbGllbnRXaWR0aDogbnVtYmVyLFxuICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ6IG51bWJlcixcbiAgICAgICAgICAgICAgcmlnaHRFbFdpZHRoOiBudW1iZXIsXG4gICAgICAgICAgICAgIHR4OiBudW1iZXIsXG4gICAgICAgICAgICAgIHR5OiBudW1iZXJcbiAgICAgICAgICApID0+IHZvaWQpXG4gICAgICAgIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgZ3JpZCB0byBzY3JvbGwgdG8gdGhlIGVuZCB3aGVuIGZsaXBwZWQgdG8gdHJ1ZVxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgRGF0YUVkaXRvclJlZi5zY3JvbGxUb30gaW5zdGVhZFxuICAgICAqIEBncm91cCBEZXByZWNhdGVkXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2Nyb2xsVG9FbmQ6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgcmVhZG9ubHkgc2Nyb2xsUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD4gfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3ZlcnNjcm9sbCBwcm9wZXJ0aWVzIGFyZSB1c2VkIHRvIGFsbG93IHRoZSBncmlkIHRvIHNjcm9sbCBwYXN0IHRoZSBsb2dpY2FsIGVuZCBvZiB0aGUgY29udGVudCBieSBhIGZpeGVkXG4gICAgICogbnVtYmVyIG9mIHBpeGVscy4gVGhpcyBpcyB1c2VmdWwgcGFydGljdWxhcmx5IG9uIHRoZSBYIGF4aXMgaWYgeW91IGFsbG93IGZvciByZXNpemluZyBjb2x1bW5zIGFzIGl0IGNhbiBtYWtlXG4gICAgICogcmVzaXppbmcgdGhlIGZpbmFsIGNvbHVtbiBzaWduaWZpY2FudGx5IGVhc2llci5cbiAgICAgKlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IG92ZXJzY3JvbGxYOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqIHtAaW5oZXJpdERvYyBvdmVyc2Nyb2xsWH1cbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBvdmVyc2Nyb2xsWTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIGluaXRpYWwgc2l6ZSBmb3IgdGhlIGdyaWQgd2hpY2ggY2FuIHByZXZlbnQgYSBmbGlja2VyIG9uIGxvYWQgaWYgdGhlIGluaXRpYWwgc2l6ZSBpcyBrbm93biBwcmlvciB0b1xuICAgICAqIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IGluaXRpYWxTaXplOiByZWFkb25seSBbd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJdIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIHByZXZlbnQgYW55IGRpYWdvbmFsIHNjcm9sbGluZy5cbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiBgcmlnaHRFbGVtZW50UHJvcHMuc3RpY2t5YCBpcyBzZXQgdG8gdHJ1ZSB0aGUgcmlnaHQgZWxlbWVudCB3aWxsIGJlIHZpc2libGUgYXQgYWxsIHRpbWVzLCBvdGhlcndpc2UgdGhlIHVzZXJcbiAgICAgKiB3aWxsIG5lZWQgdG8gc2Nyb2xsIHRvIHRoZSBlbmQgdG8gcmV2ZWFsIGl0LlxuICAgICAqXG4gICAgICogSWYgYHJpZ2h0RWxlbWVudFByb3BzLmZpbGxgIGlzIHNldCwgdGhlIHJpZ2h0IGVsZW1lbnRzIGNvbnRhaW5lciB3aWxsIGZpbGwgdG8gY29uc3VtZSBhbGwgcmVtYWluaW5nIHNwYWNlIChpZlxuICAgICAqIGFueSkgYXQgdGhlIGVuZCBvZiB0aGUgZ3JpZC4gVGhpcyBkb2VzIG5vdCBwbGF5IG5pY2Ugd2l0aCBncm93aW5nIGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSByaWdodEVsZW1lbnRQcm9wczpcbiAgICAgICAgfCB7XG4gICAgICAgICAgICAgIHJlYWRvbmx5IHN0aWNreT86IGJvb2xlYW47XG4gICAgICAgICAgICAgIHJlYWRvbmx5IGZpbGw/OiBib29sZWFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogVGhlIHJpZ2h0IGVsZW1lbnQgaXMgYSBET00gbm9kZSB3aGljaCBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcmVnaW9uLiBUaGlzIGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIGEgcmlnaHQgaGFuZGxlIHBhbmVsLCBtYWtlIGEgYmlnIGFkZCBidXR0b24sIG9yIGRpc3BsYXkgbWVzc2FnZXMuXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgcmlnaHRFbGVtZW50OiBSZWFjdC5SZWFjdE5vZGUgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcy9kaXNhYmxlcyB0aGUgaW50ZXJhY3RpdmUgbWluaW1hcC5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGZhbHNlXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2hvd01pbmltYXA6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgcmVhZG9ubHkgY2xpZW50U2l6ZTogcmVhZG9ubHkgW251bWJlciwgbnVtYmVyXTtcbn1cblxuY29uc3QgTWluaW1hcFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDQ0cHg7XG4gICAgYm90dG9tOiA0NHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodmFyKC0tZ2RnLWJnLWNlbGwpLCB2YXIoLS1nZGctYmctY2VsbC1tZWRpdW0pKTtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgei1pbmRleDogMTtcbiAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWJvcmRlci1jb2xvciksIDAgMnB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xuXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcblxuICAgIC5oZWFkZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogNHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctaGVhZGVyKTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIH1cblxuICAgIC5sb2NhdGlvbk1hcmtlciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1saWdodCk7XG4gICAgfVxuYDtcblxuY29uc3QgR3JpZFNjcm9sbGVyOiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxTY3JvbGxpbmdEYXRhR3JpZFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY29sdW1ucyxcbiAgICAgICAgcm93cyxcbiAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICBoZWFkZXJIZWlnaHQsXG4gICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0LFxuICAgICAgICBlbmFibGVHcm91cHMsXG4gICAgICAgIGZyZWV6ZUNvbHVtbnMsXG4gICAgICAgIGV4cGVyaW1lbnRhbCxcbiAgICAgICAgY2xpZW50U2l6ZSxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkLFxuICAgICAgICBzY3JvbGxUb0VuZCxcbiAgICAgICAgc2Nyb2xsUmVmLFxuICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcsXG4gICAgICAgIHJpZ2h0RWxlbWVudCxcbiAgICAgICAgcmlnaHRFbGVtZW50UHJvcHMsXG4gICAgICAgIG92ZXJzY3JvbGxYLFxuICAgICAgICBvdmVyc2Nyb2xsWSxcbiAgICAgICAgc2hvd01pbmltYXAgPSBmYWxzZSxcbiAgICAgICAgaW5pdGlhbFNpemUsXG4gICAgICAgIHNtb290aFNjcm9sbFggPSBmYWxzZSxcbiAgICAgICAgc21vb3RoU2Nyb2xsWSA9IGZhbHNlLFxuICAgICAgICBpc0RyYWdnYWJsZSxcbiAgICB9ID0gcDtcbiAgICBjb25zdCB7IHBhZGRpbmdSaWdodCwgcGFkZGluZ0JvdHRvbSB9ID0gZXhwZXJpbWVudGFsID8/IHt9O1xuXG4gICAgY29uc3QgW2NsaWVudFdpZHRoLCBjbGllbnRIZWlnaHRdID0gY2xpZW50U2l6ZTtcbiAgICBjb25zdCBsYXN0ID0gUmVhY3QudXNlUmVmPFJlY3RhbmdsZSB8IHVuZGVmaW5lZD4oKTtcbiAgICBjb25zdCBsYXN0WCA9IFJlYWN0LnVzZVJlZjxudW1iZXIgfCB1bmRlZmluZWQ+KCk7XG4gICAgY29uc3QgbGFzdFkgPSBSZWFjdC51c2VSZWY8bnVtYmVyIHwgdW5kZWZpbmVkPigpO1xuICAgIGNvbnN0IGxhc3RTaXplID0gUmVhY3QudXNlUmVmPHJlYWRvbmx5IFtudW1iZXIsIG51bWJlcl0gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICBjb25zdCB3aWR0aCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgciA9IE1hdGgubWF4KDAsIG92ZXJzY3JvbGxYID8/IDApO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sdW1ucykge1xuICAgICAgICAgICAgciArPSBjLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH0sIFtjb2x1bW5zLCBvdmVyc2Nyb2xsWF0pO1xuXG4gICAgbGV0IGhlaWdodCA9IGVuYWJsZUdyb3VwcyA/IGhlYWRlckhlaWdodCArIGdyb3VwSGVhZGVySGVpZ2h0IDogaGVhZGVySGVpZ2h0O1xuICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGhlaWdodCArPSByb3dzICogcm93SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93czsgcisrKSB7XG4gICAgICAgICAgICBoZWlnaHQgKz0gcm93SGVpZ2h0KHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVyc2Nyb2xsWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlaWdodCArPSBvdmVyc2Nyb2xsWTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0QXJncyA9IFJlYWN0LnVzZVJlZjxSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0+KCk7XG5cbiAgICBjb25zdCBwcm9jZXNzQXJncyA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGxhc3RBcmdzLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBhcmdzID0geyAuLi5sYXN0QXJncy5jdXJyZW50IH07XG5cbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICBsZXQgdHggPSBhcmdzLnggPCAwID8gLWFyZ3MueCA6IDA7XG4gICAgICAgIGxldCBjZWxsUmlnaHQgPSAwO1xuICAgICAgICBsZXQgY2VsbFggPSAwO1xuXG4gICAgICAgIGFyZ3MueCA9IGFyZ3MueCA8IDAgPyAwIDogYXJncy54O1xuXG4gICAgICAgIGxldCBzdGlja3lDb2xXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJlZXplQ29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICBzdGlja3lDb2xXaWR0aCArPSBjb2x1bW5zW2ldLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbHVtbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGN4ID0geCAtIHN0aWNreUNvbFdpZHRoO1xuICAgICAgICAgICAgaWYgKGFyZ3MueCA+PSBjeCArIGMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGMud2lkdGg7XG4gICAgICAgICAgICAgICAgY2VsbFgrKztcbiAgICAgICAgICAgICAgICBjZWxsUmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy54ID4gY3gpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGMud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aFNjcm9sbFgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHggKz0gY3ggLSBhcmdzLng7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbFJpZ2h0Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueCArIGFyZ3Mud2lkdGggPiBjeCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBjZWxsUmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHkgPSAwO1xuICAgICAgICBsZXQgY2VsbFkgPSAwO1xuICAgICAgICBsZXQgY2VsbEJvdHRvbSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgIGNlbGxZID0gTWF0aC5mbG9vcihhcmdzLnkgLyByb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHR5ID0gY2VsbFkgKiByb3dIZWlnaHQgLSBhcmdzLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxZID0gTWF0aC5jZWlsKGFyZ3MueSAvIHJvd0hlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsQm90dG9tID0gTWF0aC5jZWlsKGFyZ3MuaGVpZ2h0IC8gcm93SGVpZ2h0KSArIGNlbGxZO1xuICAgICAgICAgICAgaWYgKHR5IDwgMCkgY2VsbEJvdHRvbSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByaCA9IHJvd0hlaWdodChyb3cpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN5ID0geSArIChzbW9vdGhTY3JvbGxZID8gMCA6IHJoIC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MueSA+PSB5ICsgcmgpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByaDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFkrKztcbiAgICAgICAgICAgICAgICAgICAgY2VsbEJvdHRvbSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy55ID4gY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNtb290aFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5ICs9IGN5IC0gYXJncy55O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnkgKyBhcmdzLmhlaWdodCA+IHJoIC8gMiArIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByaDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbEJvdHRvbSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlY3Q6IFJlY3RhbmdsZSA9IHtcbiAgICAgICAgICAgIHg6IGNlbGxYLFxuICAgICAgICAgICAgeTogY2VsbFksXG4gICAgICAgICAgICB3aWR0aDogY2VsbFJpZ2h0IC0gY2VsbFgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNlbGxCb3R0b20gLSBjZWxsWSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvbGRSZWN0ID0gbGFzdC5jdXJyZW50O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG9sZFJlY3QgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgb2xkUmVjdC55ICE9PSByZWN0LnkgfHxcbiAgICAgICAgICAgIG9sZFJlY3QueCAhPT0gcmVjdC54IHx8XG4gICAgICAgICAgICBvbGRSZWN0LmhlaWdodCAhPT0gcmVjdC5oZWlnaHQgfHxcbiAgICAgICAgICAgIG9sZFJlY3Qud2lkdGggIT09IHJlY3Qud2lkdGggfHxcbiAgICAgICAgICAgIGxhc3RYLmN1cnJlbnQgIT09IHR4IHx8XG4gICAgICAgICAgICBsYXN0WS5jdXJyZW50ICE9PSB0eSB8fFxuICAgICAgICAgICAgYXJncy53aWR0aCAhPT0gbGFzdFNpemUuY3VycmVudD8uWzBdIHx8XG4gICAgICAgICAgICBhcmdzLmhlaWdodCAhPT0gbGFzdFNpemUuY3VycmVudD8uWzFdXG4gICAgICAgICkge1xuICAgICAgICAgICAgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZD8uKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2VsbFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNlbGxZLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2VsbFJpZ2h0IC0gY2VsbFgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2VsbEJvdHRvbSAtIGNlbGxZLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXJncy53aWR0aCxcbiAgICAgICAgICAgICAgICBhcmdzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBhcmdzLnBhZGRpbmdSaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgIHR4LFxuICAgICAgICAgICAgICAgIHR5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGFzdC5jdXJyZW50ID0gcmVjdDtcbiAgICAgICAgICAgIGxhc3RYLmN1cnJlbnQgPSB0eDtcbiAgICAgICAgICAgIGxhc3RZLmN1cnJlbnQgPSB0eTtcbiAgICAgICAgICAgIGxhc3RTaXplLmN1cnJlbnQgPSBbYXJncy53aWR0aCwgYXJncy5oZWlnaHRdO1xuICAgICAgICB9XG4gICAgfSwgW2NvbHVtbnMsIHJvd0hlaWdodCwgcm93cywgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCwgZnJlZXplQ29sdW1ucywgc21vb3RoU2Nyb2xsWCwgc21vb3RoU2Nyb2xsWV0pO1xuXG4gICAgY29uc3Qgb25TY3JvbGxVcGRhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgKGFyZ3M6IFJlY3RhbmdsZSAmIHsgcGFkZGluZ1JpZ2h0OiBudW1iZXIgfSkgPT4ge1xuICAgICAgICAgICAgbGFzdEFyZ3MuY3VycmVudCA9IGFyZ3M7XG4gICAgICAgICAgICBwcm9jZXNzQXJncygpO1xuICAgICAgICB9LFxuICAgICAgICBbcHJvY2Vzc0FyZ3NdXG4gICAgKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHByb2Nlc3NBcmdzKCk7XG4gICAgfSwgW3Byb2Nlc3NBcmdzXSk7XG5cbiAgICBjb25zdCBzY3JvbGxlciA9IHNjcm9sbFJlZj8uY3VycmVudCA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgYXNwZWN0ID0gY2xhbXAod2lkdGggLyBoZWlnaHQsIDIgLyAzLCAxLjUpO1xuICAgIGNvbnN0IG1heFNpemUgPSAyMDA7XG4gICAgY29uc3QgdyA9IGFzcGVjdCA+IDEgPyBtYXhTaXplIDogTWF0aC5jZWlsKG1heFNpemUgKiBhc3BlY3QpO1xuICAgIGNvbnN0IGggPSBhc3BlY3QgPiAxID8gTWF0aC5jZWlsKG1heFNpemUgLyBhc3BlY3QpIDogbWF4U2l6ZTtcbiAgICBjb25zdCBoUmF0aW8gPSB3IC8gd2lkdGg7XG4gICAgY29uc3QgdlJhdGlvID0gaCAvIGhlaWdodDtcbiAgICBjb25zdCB2V2lkdGggPSBNYXRoLm1pbihjbGllbnRXaWR0aCAqIE1hdGgubWF4KGhSYXRpbywgMC4wMSksIHcpO1xuICAgIGNvbnN0IHZIZWlnaHQgPSBNYXRoLm1pbihjbGllbnRIZWlnaHQgKiBNYXRoLm1heCh2UmF0aW8sIDAuMDEpLCBoKTtcbiAgICBjb25zdCBsZWZ0ID0gKChzY3JvbGxlcj8uc2Nyb2xsTGVmdCA/PyAwKSAvICh3aWR0aCAtIGNsaWVudFdpZHRoKSkgKiAodyAtIHZXaWR0aCk7XG4gICAgY29uc3QgdG9wID0gKChzY3JvbGxlcj8uc2Nyb2xsVG9wID8/IDApIC8gKGhlaWdodCAtIGNsaWVudEhlaWdodCkpICogKGggLSB2SGVpZ2h0KTtcblxuICAgIGNvbnN0IG1pbmltYXA6IFJlYWN0LlJlYWN0Tm9kZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3dNaW5pbWFwIHx8IHZXaWR0aCA9PT0gMCB8fCB2SGVpZ2h0ID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZU1vdXNlID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gZS5jbGllbnRYIC0gYm91bmRzLnggLSB2V2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIGJvdW5kcy55IC0gdkhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbExlZnQgPSAod2lkdGggLSBzY3JvbGxlci5jbGllbnRXaWR0aCkgKiAoeCAvICh3IC0gdldpZHRoKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdTY3JvbGxUb3AgPSAoaGVpZ2h0IC0gc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSAqICh5IC8gKGggLSB2SGVpZ2h0KSk7XG5cbiAgICAgICAgICAgIHNjcm9sbGVyLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBuZXdTY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogbmV3U2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBlLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgPyBcImF1dG9cIiA6IFwic21vb3RoXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE1pbmltYXBTdHlsZVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiB3LCBoZWlnaHQ6IGggfX1cbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD1cIm1pbmltYXAtY29udGFpbmVyXCJcbiAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbnMgIT09IDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTW91c2UoZSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVNb3VzZX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIiAvPlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibG9jYXRpb25NYXJrZXJcIlxuICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD17ZSA9PiBlLnByZXZlbnREZWZhdWx0KCl9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdkhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogTWF0aC5taW4odldpZHRoLCB2SGVpZ2h0ICogMC4yLCA5KSxcbiAgICAgICAgICAgICAgICAgICAgfX0+PC9kaXY+XG4gICAgICAgICAgICA8L01pbmltYXBTdHlsZT5cbiAgICAgICAgKTtcbiAgICB9LCBbaCwgaGVpZ2h0LCBsZWZ0LCBzY3JvbGxlciwgc2hvd01pbmltYXAsIHRvcCwgdkhlaWdodCwgdldpZHRoLCB3LCB3aWR0aF0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEluZmluaXRlU2Nyb2xsZXJcbiAgICAgICAgICAgIHNjcm9sbFJlZj17c2Nyb2xsUmVmfVxuICAgICAgICAgICAgbWluaW1hcD17bWluaW1hcH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nPXtwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmd9XG4gICAgICAgICAgICBkcmFnZ2FibGU9e2lzRHJhZ2dhYmxlID09PSB0cnVlIHx8IHR5cGVvZiBpc0RyYWdnYWJsZSA9PT0gXCJzdHJpbmdcIn1cbiAgICAgICAgICAgIHNjcm9sbFdpZHRoPXt3aWR0aCArIChwYWRkaW5nUmlnaHQgPz8gMCl9XG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQ9e2hlaWdodCArIChwYWRkaW5nQm90dG9tID8/IDApfVxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0PXtjbGllbnRIZWlnaHR9XG4gICAgICAgICAgICByaWdodEVsZW1lbnQ9e3JpZ2h0RWxlbWVudH1cbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b209e3BhZGRpbmdCb3R0b219XG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ9e3BhZGRpbmdSaWdodH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudFByb3BzPXtyaWdodEVsZW1lbnRQcm9wc31cbiAgICAgICAgICAgIHVwZGF0ZT17b25TY3JvbGxVcGRhdGV9XG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17aW5pdGlhbFNpemV9XG4gICAgICAgICAgICBzY3JvbGxUb0VuZD17c2Nyb2xsVG9FbmR9PlxuICAgICAgICAgICAgPERhdGFHcmlkRG5kXG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXRSZWY9e3Njcm9sbFJlZn1cbiAgICAgICAgICAgICAgICB3aWR0aD17Y2xpZW50V2lkdGh9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXtjbGllbnRIZWlnaHR9XG4gICAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUhlaWdodD17cC5hY2Nlc3NpYmlsaXR5SGVpZ2h0fVxuICAgICAgICAgICAgICAgIGNhbnZhc1JlZj17cC5jYW52YXNSZWZ9XG4gICAgICAgICAgICAgICAgY2VsbFhPZmZzZXQ9e3AuY2VsbFhPZmZzZXR9XG4gICAgICAgICAgICAgICAgY2VsbFlPZmZzZXQ9e3AuY2VsbFlPZmZzZXR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cC5jb2x1bW5zfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkUm93cz17cC5kaXNhYmxlZFJvd3N9XG4gICAgICAgICAgICAgICAgZW5hYmxlR3JvdXBzPXtwLmVuYWJsZUdyb3Vwc31cbiAgICAgICAgICAgICAgICBmaWxsSGFuZGxlPXtwLmZpbGxIYW5kbGV9XG4gICAgICAgICAgICAgICAgZmlyc3RDb2xBY2Nlc3NpYmxlPXtwLmZpcnN0Q29sQWNjZXNzaWJsZX1cbiAgICAgICAgICAgICAgICBmaXhlZFNoYWRvd1g9e3AuZml4ZWRTaGFkb3dYfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WT17cC5maXhlZFNoYWRvd1l9XG4gICAgICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17cC5mcmVlemVDb2x1bW5zfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtwLmdldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17cC5nZXRDZWxsUmVuZGVyZXJ9XG4gICAgICAgICAgICAgICAgZ2V0R3JvdXBEZXRhaWxzPXtwLmdldEdyb3VwRGV0YWlsc31cbiAgICAgICAgICAgICAgICBnZXRSb3dUaGVtZU92ZXJyaWRlPXtwLmdldFJvd1RoZW1lT3ZlcnJpZGV9XG4gICAgICAgICAgICAgICAgZ3JvdXBIZWFkZXJIZWlnaHQ9e3AuZ3JvdXBIZWFkZXJIZWlnaHR9XG4gICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0PXtwLmhlYWRlckhlaWdodH1cbiAgICAgICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXtwLmhpZ2hsaWdodFJlZ2lvbnN9XG4gICAgICAgICAgICAgICAgaW1hZ2VXaW5kb3dMb2FkZXI9e3AuaW1hZ2VXaW5kb3dMb2FkZXJ9XG4gICAgICAgICAgICAgICAgaXNGaWxsaW5nPXtwLmlzRmlsbGluZ31cbiAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ9e3AuaXNGb2N1c2VkfVxuICAgICAgICAgICAgICAgIGxvY2tDb2x1bW5zPXtwLmxvY2tDb2x1bW5zfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXtwLm1heENvbHVtbldpZHRofVxuICAgICAgICAgICAgICAgIG1pbkNvbHVtbldpZHRoPXtwLm1pbkNvbHVtbldpZHRofVxuICAgICAgICAgICAgICAgIG9uSGVhZGVyTWVudUNsaWNrPXtwLm9uSGVhZGVyTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtwLm9uTW91c2VNb3ZlfVxuICAgICAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3AucHJlbGlnaHRDZWxsc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9e3Aucm93SGVpZ2h0fVxuICAgICAgICAgICAgICAgIHJvd3M9e3Aucm93c31cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb249e3Auc2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHRoZW1lPXtwLnRoZW1lfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93VHlwZT17cC50cmFpbGluZ1Jvd1R5cGV9XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWD17cC50cmFuc2xhdGVYfVxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk9e3AudHJhbnNsYXRlWX1cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17cC52ZXJ0aWNhbEJvcmRlcn1cbiAgICAgICAgICAgICAgICBkcmF3Q3VzdG9tQ2VsbD17cC5kcmF3Q3VzdG9tQ2VsbH1cbiAgICAgICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXtwLmRyYXdGb2N1c1Jpbmd9XG4gICAgICAgICAgICAgICAgZHJhd0hlYWRlcj17cC5kcmF3SGVhZGVyfVxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbD17cC5leHBlcmltZW50YWx9XG4gICAgICAgICAgICAgICAgZ3JpZFJlZj17cC5ncmlkUmVmfVxuICAgICAgICAgICAgICAgIGhlYWRlckljb25zPXtwLmhlYWRlckljb25zfVxuICAgICAgICAgICAgICAgIGlzRHJhZ2dhYmxlPXtwLmlzRHJhZ2dhYmxlfVxuICAgICAgICAgICAgICAgIG9uQ2FudmFzQmx1cj17cC5vbkNhbnZhc0JsdXJ9XG4gICAgICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXtwLm9uQ2FudmFzRm9jdXNlZH1cbiAgICAgICAgICAgICAgICBvbkNlbGxGb2N1c2VkPXtwLm9uQ2VsbEZvY3VzZWR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5Nb3ZlZD17cC5vbkNvbHVtbk1vdmVkfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtwLm9uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplRW5kPXtwLm9uQ29sdW1uUmVzaXplRW5kfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplU3RhcnQ9e3Aub25Db2x1bW5SZXNpemVTdGFydH1cbiAgICAgICAgICAgICAgICBvbkNvbnRleHRNZW51PXtwLm9uQ29udGV4dE1lbnV9XG4gICAgICAgICAgICAgICAgb25EcmFnRW5kPXtwLm9uRHJhZ0VuZH1cbiAgICAgICAgICAgICAgICBvbkRyYWdMZWF2ZT17cC5vbkRyYWdMZWF2ZX1cbiAgICAgICAgICAgICAgICBvbkRyYWdPdmVyQ2VsbD17cC5vbkRyYWdPdmVyQ2VsbH1cbiAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD17cC5vbkRyYWdTdGFydH1cbiAgICAgICAgICAgICAgICBvbkRyb3A9e3Aub25Ecm9wfVxuICAgICAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ9e3Aub25JdGVtSG92ZXJlZH1cbiAgICAgICAgICAgICAgICBvbktleURvd249e3Aub25LZXlEb3dufVxuICAgICAgICAgICAgICAgIG9uS2V5VXA9e3Aub25LZXlVcH1cbiAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17cC5vbk1vdXNlRG93bn1cbiAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e3Aub25Nb3VzZVVwfVxuICAgICAgICAgICAgICAgIG9uUm93TW92ZWQ9e3Aub25Sb3dNb3ZlZH1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxYPXtwLnNtb290aFNjcm9sbFh9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWT17cC5zbW9vdGhTY3JvbGxZfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9JbmZpbml0ZVNjcm9sbGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHcmlkU2Nyb2xsZXI7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBK0VBLE1BQU0sZUFBZSxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE4QjVCLE1BQU0sZUFBZ0UsT0FBSztBQUN2RSxRQUFNO0FBQUEsSUFDRjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxjQUFjO0FBQUEsSUFDZDtBQUFBLElBQ0EsZ0JBQWdCO0FBQUEsSUFDaEIsZ0JBQWdCO0FBQUEsSUFDaEI7QUFBQSxNQUNBO0FBQ0osUUFBTSxFQUFFLGNBQWMsa0JBQWtCLGdCQUFnQjtBQUV4RCxRQUFNLENBQUMsYUFBYSxnQkFBZ0I7QUFDcEMsUUFBTSxPQUFPLE1BQU07QUFDbkIsUUFBTSxRQUFRLE1BQU07QUFDcEIsUUFBTSxRQUFRLE1BQU07QUFDcEIsUUFBTSxXQUFXLE1BQU07QUFFdkIsUUFBTSxRQUFRLE1BQU0sUUFBUSxNQUFNO0FBQzlCLFFBQUksSUFBSSxLQUFLLElBQUksR0FBRyxlQUFlO0FBQ25DLGVBQVcsS0FBSyxTQUFTO0FBQ3JCLFdBQUssRUFBRTtBQUFBO0FBRVgsV0FBTztBQUFBLEtBQ1IsQ0FBQyxTQUFTO0FBRWIsTUFBSSxTQUFTLGVBQWUsZUFBZSxvQkFBb0I7QUFDL0QsTUFBSSxPQUFPLGNBQWMsVUFBVTtBQUMvQixjQUFVLE9BQU87QUFBQSxTQUNkO0FBQ0gsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLEtBQUs7QUFDM0IsZ0JBQVUsVUFBVTtBQUFBO0FBQUE7QUFHNUIsTUFBSSxnQkFBZ0IsUUFBVztBQUMzQixjQUFVO0FBQUE7QUFHZCxRQUFNLFdBQVcsTUFBTTtBQUV2QixRQUFNLGNBQWMsTUFBTSxZQUFZLE1BQU07QUFDeEMsUUFBSSxTQUFTLFlBQVk7QUFBVztBQUNwQyxVQUFNLE9BQU8sS0FBSyxTQUFTO0FBRTNCLFFBQUksSUFBSTtBQUNSLFFBQUksS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSTtBQUNoQyxRQUFJLFlBQVk7QUFDaEIsUUFBSSxRQUFRO0FBRVosU0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSztBQUUvQixRQUFJLGlCQUFpQjtBQUNyQixhQUFTLElBQUksR0FBRyxJQUFJLGVBQWUsS0FBSztBQUNwQyx3QkFBa0IsUUFBUSxHQUFHO0FBQUE7QUFHakMsZUFBVyxLQUFLLFNBQVM7QUFDckIsWUFBTSxLQUFLLElBQUk7QUFDZixVQUFJLEtBQUssS0FBSyxLQUFLLEVBQUUsT0FBTztBQUN4QixhQUFLLEVBQUU7QUFDUDtBQUNBO0FBQUEsaUJBQ08sS0FBSyxJQUFJLElBQUk7QUFDcEIsYUFBSyxFQUFFO0FBQ1AsWUFBSSxlQUFlO0FBQ2YsZ0JBQU0sS0FBSyxLQUFLO0FBQUEsZUFDYjtBQUNIO0FBQUE7QUFFSjtBQUFBLGlCQUNPLEtBQUssSUFBSSxLQUFLLFFBQVEsSUFBSTtBQUNqQyxhQUFLLEVBQUU7QUFDUDtBQUFBLGFBQ0c7QUFDSDtBQUFBO0FBQUE7QUFJUixRQUFJLEtBQUs7QUFDVCxRQUFJLFFBQVE7QUFDWixRQUFJLGFBQWE7QUFDakIsUUFBSSxPQUFPLGNBQWMsVUFBVTtBQUMvQixVQUFJLGVBQWU7QUFDZixnQkFBUSxLQUFLLE1BQU0sS0FBSyxJQUFJO0FBQzVCLGFBQUssUUFBUSxZQUFZLEtBQUs7QUFBQSxhQUMzQjtBQUNILGdCQUFRLEtBQUssS0FBSyxLQUFLLElBQUk7QUFBQTtBQUUvQixtQkFBYSxLQUFLLEtBQUssS0FBSyxTQUFTLGFBQWE7QUFDbEQsVUFBSSxLQUFLO0FBQUc7QUFBQSxXQUNUO0FBQ0gsVUFBSSxJQUFJO0FBQ1IsZUFBUyxNQUFNLEdBQUcsTUFBTSxNQUFNLE9BQU87QUFDakMsY0FBTSxLQUFLLFVBQVU7QUFDckIsY0FBTSxLQUFLLElBQUssaUJBQWdCLElBQUksS0FBSztBQUN6QyxZQUFJLEtBQUssS0FBSyxJQUFJLElBQUk7QUFDbEIsZUFBSztBQUNMO0FBQ0E7QUFBQSxtQkFDTyxLQUFLLElBQUksSUFBSTtBQUNwQixlQUFLO0FBQ0wsY0FBSSxlQUFlO0FBQ2Ysa0JBQU0sS0FBSyxLQUFLO0FBQUEsaUJBQ2I7QUFDSDtBQUFBO0FBRUo7QUFBQSxtQkFDTyxLQUFLLElBQUksS0FBSyxTQUFTLEtBQUssSUFBSSxHQUFHO0FBQzFDLGVBQUs7QUFDTDtBQUFBLGVBQ0c7QUFDSDtBQUFBO0FBQUE7QUFBQTtBQUtaLFVBQU0sT0FBa0I7QUFBQSxNQUNwQixHQUFHO0FBQUEsTUFDSCxHQUFHO0FBQUEsTUFDSCxPQUFPLFlBQVk7QUFBQSxNQUNuQixRQUFRLGFBQWE7QUFBQTtBQUd6QixVQUFNLFVBQVUsS0FBSztBQUVyQixRQUNJLFlBQVksVUFDWixRQUFRLE1BQU0sS0FBSyxLQUNuQixRQUFRLE1BQU0sS0FBSyxLQUNuQixRQUFRLFdBQVcsS0FBSyxVQUN4QixRQUFRLFVBQVUsS0FBSyxTQUN2QixNQUFNLFlBQVksTUFDbEIsTUFBTSxZQUFZLE1BQ2xCLEtBQUssVUFBVSxTQUFTLFVBQVUsTUFDbEMsS0FBSyxXQUFXLFNBQVMsVUFBVSxJQUNyQztBQUNFLCtCQUNJO0FBQUEsUUFDSSxHQUFHO0FBQUEsUUFDSCxHQUFHO0FBQUEsUUFDSCxPQUFPLFlBQVk7QUFBQSxRQUNuQixRQUFRLGFBQWE7QUFBQSxTQUV6QixLQUFLLE9BQ0wsS0FBSyxRQUNMLEtBQUssZ0JBQWdCLEdBQ3JCLElBQ0E7QUFFSixXQUFLLFVBQVU7QUFDZixZQUFNLFVBQVU7QUFDaEIsWUFBTSxVQUFVO0FBQ2hCLGVBQVMsVUFBVSxDQUFDLEtBQUssT0FBTyxLQUFLO0FBQUE7QUFBQSxLQUUxQyxDQUFDLFNBQVMsV0FBVyxNQUFNLHdCQUF3QixlQUFlLGVBQWU7QUFFcEYsUUFBTSxpQkFBaUIsTUFBTSxZQUN6QixDQUFDLFNBQStDO0FBQzVDLGFBQVMsVUFBVTtBQUNuQjtBQUFBLEtBRUosQ0FBQztBQUdMLFFBQU0sVUFBVSxNQUFNO0FBQ2xCO0FBQUEsS0FDRCxDQUFDO0FBRUosUUFBTSxXQUFXLFdBQVcsV0FBVztBQUN2QyxRQUFNLFNBQVMsTUFBTSxRQUFRLFFBQVEsSUFBSSxHQUFHO0FBQzVDLFFBQU0sVUFBVTtBQUNoQixRQUFNLElBQUksU0FBUyxJQUFJLFVBQVUsS0FBSyxLQUFLLFVBQVU7QUFDckQsUUFBTSxJQUFJLFNBQVMsSUFBSSxLQUFLLEtBQUssVUFBVSxVQUFVO0FBQ3JELFFBQU0sU0FBUyxJQUFJO0FBQ25CLFFBQU0sU0FBUyxJQUFJO0FBQ25CLFFBQU0sU0FBUyxLQUFLLElBQUksY0FBYyxLQUFLLElBQUksUUFBUSxPQUFPO0FBQzlELFFBQU0sVUFBVSxLQUFLLElBQUksZUFBZSxLQUFLLElBQUksUUFBUSxPQUFPO0FBQ2hFLFFBQU0sT0FBUyxXQUFVLGNBQWMsS0FBTSxTQUFRLGVBQWlCLEtBQUk7QUFDMUUsUUFBTSxNQUFRLFdBQVUsYUFBYSxLQUFNLFVBQVMsZ0JBQWtCLEtBQUk7QUFFMUUsUUFBTSxVQUEyQixNQUFNLFFBQVEsTUFBTTtBQUNqRCxRQUFJLENBQUMsZUFBZSxXQUFXLEtBQUssWUFBWTtBQUFHLGFBQU87QUFFMUQsVUFBTSxjQUFjLENBQUMsTUFBd0I7QUFDekMsVUFBSSxhQUFhO0FBQVc7QUFDNUIsWUFBTSxTQUFTLEVBQUUsY0FBYztBQUMvQixZQUFNLElBQUksRUFBRSxVQUFVLE9BQU8sSUFBSSxTQUFTO0FBQzFDLFlBQU0sSUFBSSxFQUFFLFVBQVUsT0FBTyxJQUFJLFVBQVU7QUFFM0MsWUFBTSxnQkFBaUIsU0FBUSxTQUFTLGVBQWdCLEtBQUssS0FBSTtBQUNqRSxZQUFNLGVBQWdCLFVBQVMsU0FBUyxnQkFBaUIsS0FBSyxLQUFJO0FBRWxFLGVBQVMsU0FBUztBQUFBLFFBQ2QsTUFBTTtBQUFBLFFBQ04sS0FBSztBQUFBLFFBQ0wsVUFBVSxFQUFFLFNBQVMsY0FBYyxTQUFTO0FBQUE7QUFBQTtBQUlwRCxXQUNJLG9DQUFDLGNBQUQ7QUFBQSxNQUNJLE9BQU8sRUFBRSxPQUFPLEdBQUcsUUFBUTtBQUFBLE1BQzNCLGVBQVk7QUFBQSxNQUNaLGFBQWEsT0FBSztBQUNkLFlBQUksRUFBRSxZQUFZO0FBQUc7QUFDckIsb0JBQVk7QUFBQTtBQUFBLE1BRWhCLFNBQVM7QUFBQSxPQUNULG9DQUFDLE9BQUQ7QUFBQSxNQUFLLFdBQVU7QUFBQSxRQUNmLG9DQUFDLE9BQUQ7QUFBQSxNQUNJLFdBQVU7QUFBQSxNQUNWLGFBQWEsT0FBSyxFQUFFO0FBQUEsTUFDcEIsT0FBTztBQUFBLFFBQ0g7QUFBQSxRQUNBO0FBQUEsUUFDQSxPQUFPO0FBQUEsUUFDUCxRQUFRO0FBQUEsUUFDUixjQUFjLEtBQUssSUFBSSxRQUFRLFVBQVUsS0FBSztBQUFBO0FBQUE7QUFBQSxLQUkvRCxDQUFDLEdBQUcsUUFBUSxNQUFNLFVBQVUsYUFBYSxLQUFLLFNBQVMsUUFBUSxHQUFHO0FBRXJFLFNBQ0ksb0NBQUMsa0JBQUQ7QUFBQSxJQUNJO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxXQUFXLGdCQUFnQixRQUFRLE9BQU8sZ0JBQWdCO0FBQUEsSUFDMUQsYUFBYSxRQUFTLGlCQUFnQjtBQUFBLElBQ3RDLGNBQWMsU0FBVSxrQkFBaUI7QUFBQSxJQUN6QztBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLFFBQVE7QUFBQSxJQUNSO0FBQUEsSUFDQTtBQUFBLEtBQ0Esb0NBQUMsYUFBRDtBQUFBLElBQ0ksZ0JBQWdCO0FBQUEsSUFDaEIsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IscUJBQXFCLEVBQUU7QUFBQSxJQUN2QixXQUFXLEVBQUU7QUFBQSxJQUNiLGFBQWEsRUFBRTtBQUFBLElBQ2YsYUFBYSxFQUFFO0FBQUEsSUFDZixTQUFTLEVBQUU7QUFBQSxJQUNYLGNBQWMsRUFBRTtBQUFBLElBQ2hCLGNBQWMsRUFBRTtBQUFBLElBQ2hCLFlBQVksRUFBRTtBQUFBLElBQ2Qsb0JBQW9CLEVBQUU7QUFBQSxJQUN0QixjQUFjLEVBQUU7QUFBQSxJQUNoQixjQUFjLEVBQUU7QUFBQSxJQUNoQixlQUFlLEVBQUU7QUFBQSxJQUNqQixnQkFBZ0IsRUFBRTtBQUFBLElBQ2xCLGlCQUFpQixFQUFFO0FBQUEsSUFDbkIsaUJBQWlCLEVBQUU7QUFBQSxJQUNuQixxQkFBcUIsRUFBRTtBQUFBLElBQ3ZCLG1CQUFtQixFQUFFO0FBQUEsSUFDckIsY0FBYyxFQUFFO0FBQUEsSUFDaEIsa0JBQWtCLEVBQUU7QUFBQSxJQUNwQixtQkFBbUIsRUFBRTtBQUFBLElBQ3JCLFdBQVcsRUFBRTtBQUFBLElBQ2IsV0FBVyxFQUFFO0FBQUEsSUFDYixhQUFhLEVBQUU7QUFBQSxJQUNmLGdCQUFnQixFQUFFO0FBQUEsSUFDbEIsZ0JBQWdCLEVBQUU7QUFBQSxJQUNsQixtQkFBbUIsRUFBRTtBQUFBLElBQ3JCLGFBQWEsRUFBRTtBQUFBLElBQ2YsZUFBZSxFQUFFO0FBQUEsSUFDakIsV0FBVyxFQUFFO0FBQUEsSUFDYixNQUFNLEVBQUU7QUFBQSxJQUNSLFdBQVcsRUFBRTtBQUFBLElBQ2IsT0FBTyxFQUFFO0FBQUEsSUFDVCxpQkFBaUIsRUFBRTtBQUFBLElBQ25CLFlBQVksRUFBRTtBQUFBLElBQ2QsWUFBWSxFQUFFO0FBQUEsSUFDZCxnQkFBZ0IsRUFBRTtBQUFBLElBQ2xCLGdCQUFnQixFQUFFO0FBQUEsSUFDbEIsZUFBZSxFQUFFO0FBQUEsSUFDakIsWUFBWSxFQUFFO0FBQUEsSUFDZCxjQUFjLEVBQUU7QUFBQSxJQUNoQixTQUFTLEVBQUU7QUFBQSxJQUNYLGFBQWEsRUFBRTtBQUFBLElBQ2YsYUFBYSxFQUFFO0FBQUEsSUFDZixjQUFjLEVBQUU7QUFBQSxJQUNoQixpQkFBaUIsRUFBRTtBQUFBLElBQ25CLGVBQWUsRUFBRTtBQUFBLElBQ2pCLGVBQWUsRUFBRTtBQUFBLElBQ2pCLGdCQUFnQixFQUFFO0FBQUEsSUFDbEIsbUJBQW1CLEVBQUU7QUFBQSxJQUNyQixxQkFBcUIsRUFBRTtBQUFBLElBQ3ZCLGVBQWUsRUFBRTtBQUFBLElBQ2pCLFdBQVcsRUFBRTtBQUFBLElBQ2IsYUFBYSxFQUFFO0FBQUEsSUFDZixnQkFBZ0IsRUFBRTtBQUFBLElBQ2xCLGFBQWEsRUFBRTtBQUFBLElBQ2YsUUFBUSxFQUFFO0FBQUEsSUFDVixlQUFlLEVBQUU7QUFBQSxJQUNqQixXQUFXLEVBQUU7QUFBQSxJQUNiLFNBQVMsRUFBRTtBQUFBLElBQ1gsYUFBYSxFQUFFO0FBQUEsSUFDZixXQUFXLEVBQUU7QUFBQSxJQUNiLFlBQVksRUFBRTtBQUFBLElBQ2QsZUFBZSxFQUFFO0FBQUEsSUFDakIsZUFBZSxFQUFFO0FBQUE7QUFBQTtBQU1qQyxlQUFlOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"../common/resize-detector\";\nimport { browserIsSafari } from \"../common/browser-detect\";\nimport { useEventListener } from \"../common/utils\";\nconst ScrollRegionStyle = styled.div`\n    .dvn-scroller {\n        overflow: ${(p) => p.isSafari ? \"scroll\" : \"auto\"};\n        transform: translate3d(0, 0, 0);\n    }\n\n    .hidden {\n        visibility: hidden;\n    }\n\n    .dvn-scroll-inner {\n        display: flex;\n        pointer-events: none;\n\n        > * {\n            flex-shrink: 0;\n        }\n\n        .dvn-spacer {\n            flex-grow: 1;\n        }\n\n        .dvn-stack {\n            display: flex;\n            flex-direction: column;\n        }\n    }\n\n    .dvn-underlay > * {\n        position: absolute;\n        left: 0;\n        top: 0;\n    }\n\n    canvas {\n        outline: none;\n\n        * {\n            height: 0;\n        }\n    }\n`;\nfunction eatEvent(e) {\n  e.stopPropagation();\n}\nfunction useTouchUpDelayed(delay) {\n  const [hasTouches, setHasTouches] = React.useState(false);\n  const cbTimer = React.useRef(0);\n  useEventListener(\"touchstart\", React.useCallback(() => {\n    window.clearTimeout(cbTimer.current);\n    setHasTouches(true);\n  }, []), window, true, false);\n  useEventListener(\"touchend\", React.useCallback((e) => {\n    if (e.touches.length === 0) {\n      cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);\n    }\n  }, [delay]), window, true, false);\n  return hasTouches;\n}\nexport const InfiniteScroller = (p) => {\n  const {\n    children,\n    clientHeight,\n    scrollHeight,\n    scrollWidth,\n    update,\n    draggable,\n    className,\n    preventDiagonalScrolling = false,\n    paddingBottom = 0,\n    paddingRight = 0,\n    rightElement,\n    rightElementProps,\n    scrollRef,\n    scrollToEnd,\n    initialSize,\n    minimap\n  } = p;\n  const padders = [];\n  const rightElementSticky = rightElementProps?.sticky ?? false;\n  const rightElementFill = rightElementProps?.fill ?? false;\n  const offsetY = React.useRef(0);\n  const lastScrollY = React.useRef(0);\n  const scroller = React.useRef(null);\n  const dpr = window.devicePixelRatio;\n  React.useEffect(() => {\n    const el = scroller.current;\n    if (el === null || scrollToEnd !== true)\n      return;\n    el.scrollLeft = el.scrollWidth - el.clientWidth;\n  }, [scrollToEnd]);\n  const lastScrollPosition = React.useRef({\n    scrollLeft: 0,\n    scrollTop: 0,\n    lockDirection: void 0\n  });\n  const rightWrapRef = React.useRef(null);\n  const hasTouches = useTouchUpDelayed(200);\n  const [isIdle, setIsIdle] = React.useState(true);\n  const idleTimer = React.useRef(0);\n  React.useEffect(() => {\n    if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === void 0)\n      return;\n    const el = scroller.current;\n    if (el === null)\n      return;\n    const [lx, ly] = lastScrollPosition.current.lockDirection;\n    if (lx !== void 0) {\n      el.scrollLeft = lx;\n    } else if (ly !== void 0) {\n      el.scrollTop = ly;\n    }\n    lastScrollPosition.current.lockDirection = void 0;\n  }, [hasTouches, isIdle]);\n  const onScroll = React.useCallback(() => {\n    const el = scroller.current;\n    if (el === null)\n      return;\n    let scrollTop = el.scrollTop;\n    let scrollLeft = el.scrollLeft;\n    const lastScrollTop = lastScrollPosition.current.scrollTop;\n    const lastScrollLeft = lastScrollPosition.current.scrollLeft;\n    const dx = scrollLeft - lastScrollLeft;\n    const dy = scrollTop - lastScrollTop;\n    if (hasTouches && dx !== 0 && dy !== 0 && (Math.abs(dx) > 3 || Math.abs(dy) > 3) && preventDiagonalScrolling && lastScrollPosition.current.lockDirection === void 0) {\n      lastScrollPosition.current.lockDirection = Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, void 0] : [void 0, lastScrollTop];\n    }\n    const lock = lastScrollPosition.current.lockDirection;\n    scrollLeft = lock?.[0] ?? scrollLeft;\n    scrollTop = lock?.[1] ?? scrollTop;\n    lastScrollPosition.current.scrollLeft = scrollLeft;\n    lastScrollPosition.current.scrollTop = scrollTop;\n    const newY = scrollTop;\n    const delta = lastScrollY.current - newY;\n    const scrollableHeight = el.scrollHeight - el.clientHeight;\n    lastScrollY.current = newY;\n    if (scrollableHeight > 0 && (Math.abs(delta) > 2e3 || newY === 0 || newY === scrollableHeight) && scrollHeight > el.scrollHeight + 5) {\n      const prog = newY / scrollableHeight;\n      const recomputed = (scrollHeight - el.clientHeight) * prog;\n      offsetY.current = recomputed - newY;\n    }\n    if (lock !== void 0) {\n      window.clearTimeout(idleTimer.current);\n      setIsIdle(false);\n      idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);\n    }\n    update({\n      x: scrollLeft,\n      y: newY + offsetY.current,\n      width: el.clientWidth - paddingRight,\n      height: el.clientHeight - paddingBottom,\n      paddingRight: rightWrapRef.current?.clientWidth ?? 0\n    });\n  }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);\n  const onScrollRef = React.useRef(onScroll);\n  onScrollRef.current = onScroll;\n  const lastProps = React.useRef();\n  const didFirstScroll = React.useRef(false);\n  React.useEffect(() => {\n    if (didFirstScroll.current)\n      onScroll();\n    else\n      didFirstScroll.current = true;\n  }, [onScroll, paddingBottom, paddingRight]);\n  const setRefs = React.useCallback((instance) => {\n    scroller.current = instance;\n    if (scrollRef !== void 0) {\n      scrollRef.current = instance;\n    }\n  }, [scrollRef]);\n  let key = 0;\n  let h = 0;\n  padders.push(/* @__PURE__ */ React.createElement(\"div\", {\n    key: key++,\n    style: { width: scrollWidth, height: 0 }\n  }));\n  while (h < scrollHeight) {\n    const toAdd = Math.min(5e6, scrollHeight - h);\n    padders.push(/* @__PURE__ */ React.createElement(\"div\", {\n      key: key++,\n      style: { width: 0, height: toAdd }\n    }));\n    h += toAdd;\n  }\n  const { ref, width, height } = useResizeDetector(initialSize);\n  if (lastProps.current?.height !== height || lastProps.current?.width !== width) {\n    window.setTimeout(() => onScrollRef.current(), 0);\n    lastProps.current = { width, height };\n  }\n  if ((width ?? 0) === 0 || (height ?? 0) === 0)\n    return /* @__PURE__ */ React.createElement(\"div\", {\n      ref\n    });\n  return /* @__PURE__ */ React.createElement(\"div\", {\n    ref\n  }, /* @__PURE__ */ React.createElement(ScrollRegionStyle, {\n    isSafari: browserIsSafari.value\n  }, minimap, /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"dvn-underlay\"\n  }, children), /* @__PURE__ */ React.createElement(\"div\", {\n    ref: setRefs,\n    style: lastProps.current,\n    draggable,\n    onDragStart: (e) => {\n      if (!draggable) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    },\n    className: \"dvn-scroller \" + (className ?? \"\"),\n    onScroll\n  }, /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"dvn-scroll-inner\" + (rightElement === void 0 ? \" hidden\" : \"\")\n  }, /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"dvn-stack\"\n  }, padders), rightElement !== void 0 && /* @__PURE__ */ React.createElement(React.Fragment, null, !rightElementFill && /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"dvn-spacer\"\n  }), /* @__PURE__ */ React.createElement(\"div\", {\n    ref: rightWrapRef,\n    onMouseDown: eatEvent,\n    onMouseUp: eatEvent,\n    onMouseMove: eatEvent,\n    style: {\n      height,\n      maxHeight: clientHeight - Math.ceil(dpr % 1),\n      position: \"sticky\",\n      top: 0,\n      paddingLeft: 1,\n      marginBottom: -40,\n      marginRight: paddingRight,\n      flexGrow: rightElementFill ? 1 : void 0,\n      right: rightElementSticky ? paddingRight ?? 0 : void 0,\n      pointerEvents: \"auto\"\n    }\n  }, rightElement))))));\n};\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL2luZmluaXRlLXNjcm9sbGVyLnRzeCJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCIuLi9jb21tb24vcmVzaXplLWRldGVjdG9yXCI7XG5pbXBvcnQgeyBicm93c2VySXNTYWZhcmkgfSBmcm9tIFwiLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uL2NvbW1vbi91dGlsc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGNsYXNzTmFtZT86IHN0cmluZztcbiAgICByZWFkb25seSBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGRyYWdnYWJsZTogYm9vbGVhbjtcbiAgICByZWFkb25seSBwYWRkaW5nUmlnaHQ/OiBudW1iZXI7XG4gICAgcmVhZG9ubHkgcGFkZGluZ0JvdHRvbT86IG51bWJlcjtcbiAgICByZWFkb25seSBjbGllbnRIZWlnaHQ6IG51bWJlcjtcbiAgICByZWFkb25seSBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbEhlaWdodDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbFRvRW5kPzogYm9vbGVhbjtcbiAgICByZWFkb25seSBpbml0aWFsU2l6ZT86IHJlYWRvbmx5IFt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcl07XG4gICAgcmVhZG9ubHkgcmlnaHRFbGVtZW50UHJvcHM/OiB7XG4gICAgICAgIHJlYWRvbmx5IHN0aWNreT86IGJvb2xlYW47XG4gICAgICAgIHJlYWRvbmx5IGZpbGw/OiBib29sZWFuO1xuICAgIH07XG4gICAgcmVhZG9ubHkgcmlnaHRFbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIHJlYWRvbmx5IG1pbmltYXA/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgcmVhZG9ubHkgc2Nyb2xsUmVmPzogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxIVE1MRGl2RWxlbWVudCB8IG51bGw+O1xuICAgIHJlYWRvbmx5IHVwZGF0ZTogKHJlZ2lvbjogUmVjdGFuZ2xlICYgeyBwYWRkaW5nUmlnaHQ6IG51bWJlciB9KSA9PiB2b2lkO1xufVxuXG5jb25zdCBTY3JvbGxSZWdpb25TdHlsZSA9IHN0eWxlZC5kaXY8eyBpc1NhZmFyaTogYm9vbGVhbiB9PmBcbiAgICAuZHZuLXNjcm9sbGVyIHtcbiAgICAgICAgb3ZlcmZsb3c6ICR7cCA9PiAocC5pc1NhZmFyaSA/IFwic2Nyb2xsXCIgOiBcImF1dG9cIil9O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgIH1cblxuICAgIC5oaWRkZW4ge1xuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgfVxuXG4gICAgLmR2bi1zY3JvbGwtaW5uZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcblxuICAgICAgICA+ICoge1xuICAgICAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIH1cblxuICAgICAgICAuZHZuLXNwYWNlciB7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAuZHZuLXN0YWNrIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmR2bi11bmRlcmxheSA+ICoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICB9XG5cbiAgICBjYW52YXMge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuXG4gICAgICAgICoge1xuICAgICAgICAgICAgaGVpZ2h0OiAwO1xuICAgICAgICB9XG4gICAgfVxuYDtcblxudHlwZSBTY3JvbGxMb2NrID0gW3VuZGVmaW5lZCwgbnVtYmVyXSB8IFtudW1iZXIsIHVuZGVmaW5lZF0gfCB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGVhdEV2ZW50KGU6IFJlYWN0Lk1vdXNlRXZlbnQpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5mdW5jdGlvbiB1c2VUb3VjaFVwRGVsYXllZChkZWxheTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgW2hhc1RvdWNoZXMsIHNldEhhc1RvdWNoZXNdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgY2JUaW1lciA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFxuICAgICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgICAgUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChjYlRpbWVyLmN1cnJlbnQpO1xuICAgICAgICAgICAgc2V0SGFzVG91Y2hlcyh0cnVlKTtcbiAgICAgICAgfSwgW10pLFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hlbmRcIixcbiAgICAgICAgUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjYlRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRIYXNUb3VjaGVzKGZhbHNlKSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbZGVsYXldXG4gICAgICAgICksXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIGhhc1RvdWNoZXM7XG59XG5cbmV4cG9ydCBjb25zdCBJbmZpbml0ZVNjcm9sbGVyOiBSZWFjdC5GQzxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBjbGllbnRIZWlnaHQsXG4gICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgc2Nyb2xsV2lkdGgsXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZyA9IGZhbHNlLFxuICAgICAgICBwYWRkaW5nQm90dG9tID0gMCxcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gMCxcbiAgICAgICAgcmlnaHRFbGVtZW50LFxuICAgICAgICByaWdodEVsZW1lbnRQcm9wcyxcbiAgICAgICAgc2Nyb2xsUmVmLFxuICAgICAgICBzY3JvbGxUb0VuZCxcbiAgICAgICAgaW5pdGlhbFNpemUsXG4gICAgICAgIG1pbmltYXAsXG4gICAgfSA9IHA7XG4gICAgY29uc3QgcGFkZGVyczogUmVhY3QuUmVhY3ROb2RlW10gPSBbXTtcblxuICAgIGNvbnN0IHJpZ2h0RWxlbWVudFN0aWNreSA9IHJpZ2h0RWxlbWVudFByb3BzPy5zdGlja3kgPz8gZmFsc2U7XG4gICAgY29uc3QgcmlnaHRFbGVtZW50RmlsbCA9IHJpZ2h0RWxlbWVudFByb3BzPy5maWxsID8/IGZhbHNlO1xuXG4gICAgY29uc3Qgb2Zmc2V0WSA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBjb25zdCBsYXN0U2Nyb2xsWSA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBjb25zdCBzY3JvbGxlciA9IFJlYWN0LnVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG4gICAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IHNjcm9sbGVyLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlbCA9PT0gbnVsbCB8fCBzY3JvbGxUb0VuZCAhPT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgICAgIGVsLnNjcm9sbExlZnQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoO1xuICAgIH0sIFtzY3JvbGxUb0VuZF0pO1xuXG4gICAgY29uc3QgbGFzdFNjcm9sbFBvc2l0aW9uID0gUmVhY3QudXNlUmVmKHtcbiAgICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgICAgc2Nyb2xsVG9wOiAwLFxuICAgICAgICBsb2NrRGlyZWN0aW9uOiB1bmRlZmluZWQgYXMgU2Nyb2xsTG9jayxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJpZ2h0V3JhcFJlZiA9IFJlYWN0LnVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG4gICAgY29uc3QgaGFzVG91Y2hlcyA9IHVzZVRvdWNoVXBEZWxheWVkKDIwMCk7XG4gICAgY29uc3QgW2lzSWRsZSwgc2V0SXNJZGxlXSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IGlkbGVUaW1lciA9IFJlYWN0LnVzZVJlZigwKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNJZGxlIHx8IGhhc1RvdWNoZXMgfHwgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQubG9ja0RpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IFtseCwgbHldID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQubG9ja0RpcmVjdGlvbjtcbiAgICAgICAgaWYgKGx4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbExlZnQgPSBseDtcbiAgICAgICAgfSBlbHNlIGlmIChseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbC5zY3JvbGxUb3AgPSBseTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgIH0sIFtoYXNUb3VjaGVzLCBpc0lkbGVdKTtcblxuICAgIGNvbnN0IG9uU2Nyb2xsID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IHNjcm9sbGVyLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlbCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGxldCBzY3JvbGxMZWZ0ID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgY29uc3QgbGFzdFNjcm9sbFRvcCA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgY29uc3QgbGFzdFNjcm9sbExlZnQgPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICAgIGNvbnN0IGR4ID0gc2Nyb2xsTGVmdCAtIGxhc3RTY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBkeSA9IHNjcm9sbFRvcCAtIGxhc3RTY3JvbGxUb3A7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFzVG91Y2hlcyAmJlxuICAgICAgICAgICAgZHggIT09IDAgJiZcbiAgICAgICAgICAgIGR5ICE9PSAwICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoZHgpID4gMyB8fCBNYXRoLmFicyhkeSkgPiAzKSAmJlxuICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nICYmXG4gICAgICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID1cbiAgICAgICAgICAgICAgICBNYXRoLmFicyhkeCkgPCBNYXRoLmFicyhkeSkgPyBbbGFzdFNjcm9sbExlZnQsIHVuZGVmaW5lZF0gOiBbdW5kZWZpbmVkLCBsYXN0U2Nyb2xsVG9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvY2sgPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uO1xuXG4gICAgICAgIHNjcm9sbExlZnQgPSBsb2NrPy5bMF0gPz8gc2Nyb2xsTGVmdDtcbiAgICAgICAgc2Nyb2xsVG9wID0gbG9jaz8uWzFdID8/IHNjcm9sbFRvcDtcbiAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcblxuICAgICAgICBjb25zdCBuZXdZID0gc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGxhc3RTY3JvbGxZLmN1cnJlbnQgLSBuZXdZO1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlSGVpZ2h0ID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICBsYXN0U2Nyb2xsWS5jdXJyZW50ID0gbmV3WTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzY3JvbGxhYmxlSGVpZ2h0ID4gMCAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGRlbHRhKSA+IDIwMDAgfHwgbmV3WSA9PT0gMCB8fCBuZXdZID09PSBzY3JvbGxhYmxlSGVpZ2h0KSAmJlxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID4gZWwuc2Nyb2xsSGVpZ2h0ICsgNVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2cgPSBuZXdZIC8gc2Nyb2xsYWJsZUhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHJlY29tcHV0ZWQgPSAoc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0KSAqIHByb2c7XG4gICAgICAgICAgICBvZmZzZXRZLmN1cnJlbnQgPSByZWNvbXB1dGVkIC0gbmV3WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaWRsZVRpbWVyLmN1cnJlbnQpO1xuICAgICAgICAgICAgc2V0SXNJZGxlKGZhbHNlKTtcbiAgICAgICAgICAgIGlkbGVUaW1lci5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gc2V0SXNJZGxlKHRydWUpLCAyMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlKHtcbiAgICAgICAgICAgIHg6IHNjcm9sbExlZnQsXG4gICAgICAgICAgICB5OiBuZXdZICsgb2Zmc2V0WS5jdXJyZW50LFxuICAgICAgICAgICAgd2lkdGg6IGVsLmNsaWVudFdpZHRoIC0gcGFkZGluZ1JpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0OiBlbC5jbGllbnRIZWlnaHQgLSBwYWRkaW5nQm90dG9tLFxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiByaWdodFdyYXBSZWYuY3VycmVudD8uY2xpZW50V2lkdGggPz8gMCxcbiAgICAgICAgfSk7XG4gICAgfSwgW3BhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodCwgc2Nyb2xsSGVpZ2h0LCB1cGRhdGUsIHByZXZlbnREaWFnb25hbFNjcm9sbGluZywgaGFzVG91Y2hlc10pO1xuXG4gICAgY29uc3Qgb25TY3JvbGxSZWYgPSBSZWFjdC51c2VSZWYob25TY3JvbGwpO1xuICAgIG9uU2Nyb2xsUmVmLmN1cnJlbnQgPSBvblNjcm9sbDtcblxuICAgIGNvbnN0IGxhc3RQcm9wcyA9IFJlYWN0LnVzZVJlZjx7IHdpZHRoPzogbnVtYmVyOyBoZWlnaHQ/OiBudW1iZXIgfT4oKTtcblxuICAgIGNvbnN0IGRpZEZpcnN0U2Nyb2xsID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGlkRmlyc3RTY3JvbGwuY3VycmVudCkgb25TY3JvbGwoKTtcbiAgICAgICAgZWxzZSBkaWRGaXJzdFNjcm9sbC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LCBbb25TY3JvbGwsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodF0pO1xuXG4gICAgY29uc3Qgc2V0UmVmcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoaW5zdGFuY2U6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsZXIuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW3Njcm9sbFJlZl1cbiAgICApO1xuXG4gICAgbGV0IGtleSA9IDA7XG4gICAgbGV0IGggPSAwO1xuICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiBzY3JvbGxXaWR0aCwgaGVpZ2h0OiAwIH19IC8+KTtcbiAgICB3aGlsZSAoaCA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgICBjb25zdCB0b0FkZCA9IE1hdGgubWluKDVfMDAwXzAwMCwgc2Nyb2xsSGVpZ2h0IC0gaCk7XG4gICAgICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiAwLCBoZWlnaHQ6IHRvQWRkIH19IC8+KTtcbiAgICAgICAgaCArPSB0b0FkZDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZiwgd2lkdGgsIGhlaWdodCB9ID0gdXNlUmVzaXplRGV0ZWN0b3I8SFRNTERpdkVsZW1lbnQ+KGluaXRpYWxTaXplKTtcblxuICAgIGlmIChsYXN0UHJvcHMuY3VycmVudD8uaGVpZ2h0ICE9PSBoZWlnaHQgfHwgbGFzdFByb3BzLmN1cnJlbnQ/LndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBvblNjcm9sbFJlZi5jdXJyZW50KCksIDApO1xuICAgICAgICBsYXN0UHJvcHMuY3VycmVudCA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cblxuICAgIGlmICgod2lkdGggPz8gMCkgPT09IDAgfHwgKGhlaWdodCA/PyAwKSA9PT0gMCkgcmV0dXJuIDxkaXYgcmVmPXtyZWZ9IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiByZWY9e3JlZn0+XG4gICAgICAgICAgICA8U2Nyb2xsUmVnaW9uU3R5bGUgaXNTYWZhcmk9e2Jyb3dzZXJJc1NhZmFyaS52YWx1ZX0+XG4gICAgICAgICAgICAgICAge21pbmltYXB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdm4tdW5kZXJsYXlcIj57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICByZWY9e3NldFJlZnN9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtsYXN0UHJvcHMuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlPXtkcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsZXIgXCIgKyAoY2xhc3NOYW1lID8/IFwiXCIpfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbD17b25TY3JvbGx9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsLWlubmVyXCIgKyAocmlnaHRFbGVtZW50ID09PSB1bmRlZmluZWQgPyBcIiBoaWRkZW5cIiA6IFwiXCIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHZuLXN0YWNrXCI+e3BhZGRlcnN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmlnaHRFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmlnaHRFbGVtZW50RmlsbCAmJiA8ZGl2IGNsYXNzTmFtZT1cImR2bi1zcGFjZXJcIiAvPn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtyaWdodFdyYXBSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBjbGllbnRIZWlnaHQgLSBNYXRoLmNlaWwoZHByICUgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogLTQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleEdyb3c6IHJpZ2h0RWxlbWVudEZpbGwgPyAxIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodEVsZW1lbnRTdGlja3kgPyBwYWRkaW5nUmlnaHQgPz8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JpZ2h0RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvU2Nyb2xsUmVnaW9uU3R5bGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuIl0sCiAgIm1hcHBpbmdzIjogIkFBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXVCQSxNQUFNLG9CQUFvQixPQUFPO0FBQUE7QUFBQSxvQkFFYixPQUFNLEVBQUUsV0FBVyxXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMkNsRCxrQkFBa0IsR0FBcUI7QUFDbkMsSUFBRTtBQUFBO0FBR04sMkJBQTJCLE9BQXdCO0FBQy9DLFFBQU0sQ0FBQyxZQUFZLGlCQUFpQixNQUFNLFNBQVM7QUFFbkQsUUFBTSxVQUFVLE1BQU0sT0FBTztBQUM3QixtQkFDSSxjQUNBLE1BQU0sWUFBWSxNQUFNO0FBQ3BCLFdBQU8sYUFBYSxRQUFRO0FBQzVCLGtCQUFjO0FBQUEsS0FDZixLQUNILFFBQ0EsTUFDQTtBQUdKLG1CQUNJLFlBQ0EsTUFBTSxZQUNGLE9BQUs7QUFDRCxRQUFJLEVBQUUsUUFBUSxXQUFXLEdBQUc7QUFDeEIsY0FBUSxVQUFVLE9BQU8sV0FBVyxNQUFNLGNBQWMsUUFBUTtBQUFBO0FBQUEsS0FHeEUsQ0FBQyxTQUVMLFFBQ0EsTUFDQTtBQUdKLFNBQU87QUFBQTtBQUdKLGFBQU0sbUJBQW9DLE9BQUs7QUFDbEQsUUFBTTtBQUFBLElBQ0Y7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLDJCQUEyQjtBQUFBLElBQzNCLGdCQUFnQjtBQUFBLElBQ2hCLGVBQWU7QUFBQSxJQUNmO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxNQUNBO0FBQ0osUUFBTSxVQUE2QjtBQUVuQyxRQUFNLHFCQUFxQixtQkFBbUIsVUFBVTtBQUN4RCxRQUFNLG1CQUFtQixtQkFBbUIsUUFBUTtBQUVwRCxRQUFNLFVBQVUsTUFBTSxPQUFPO0FBQzdCLFFBQU0sY0FBYyxNQUFNLE9BQU87QUFDakMsUUFBTSxXQUFXLE1BQU0sT0FBOEI7QUFFckQsUUFBTSxNQUFNLE9BQU87QUFFbkIsUUFBTSxVQUFVLE1BQU07QUFDbEIsVUFBTSxLQUFLLFNBQVM7QUFDcEIsUUFBSSxPQUFPLFFBQVEsZ0JBQWdCO0FBQU07QUFFekMsT0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHO0FBQUEsS0FDckMsQ0FBQztBQUVKLFFBQU0scUJBQXFCLE1BQU0sT0FBTztBQUFBLElBQ3BDLFlBQVk7QUFBQSxJQUNaLFdBQVc7QUFBQSxJQUNYLGVBQWU7QUFBQTtBQUduQixRQUFNLGVBQWUsTUFBTSxPQUE4QjtBQUV6RCxRQUFNLGFBQWEsa0JBQWtCO0FBQ3JDLFFBQU0sQ0FBQyxRQUFRLGFBQWEsTUFBTSxTQUFTO0FBQzNDLFFBQU0sWUFBWSxNQUFNLE9BQU87QUFFL0IsUUFBTSxVQUFVLE1BQU07QUFDbEIsUUFBSSxDQUFDLFVBQVUsY0FBYyxtQkFBbUIsUUFBUSxrQkFBa0I7QUFBVztBQUNyRixVQUFNLEtBQUssU0FBUztBQUNwQixRQUFJLE9BQU87QUFBTTtBQUNqQixVQUFNLENBQUMsSUFBSSxNQUFNLG1CQUFtQixRQUFRO0FBQzVDLFFBQUksT0FBTyxRQUFXO0FBQ2xCLFNBQUcsYUFBYTtBQUFBLGVBQ1QsT0FBTyxRQUFXO0FBQ3pCLFNBQUcsWUFBWTtBQUFBO0FBRW5CLHVCQUFtQixRQUFRLGdCQUFnQjtBQUFBLEtBQzVDLENBQUMsWUFBWTtBQUVoQixRQUFNLFdBQVcsTUFBTSxZQUFZLE1BQU07QUFDckMsVUFBTSxLQUFLLFNBQVM7QUFDcEIsUUFBSSxPQUFPO0FBQU07QUFFakIsUUFBSSxZQUFZLEdBQUc7QUFDbkIsUUFBSSxhQUFhLEdBQUc7QUFDcEIsVUFBTSxnQkFBZ0IsbUJBQW1CLFFBQVE7QUFDakQsVUFBTSxpQkFBaUIsbUJBQW1CLFFBQVE7QUFFbEQsVUFBTSxLQUFLLGFBQWE7QUFDeEIsVUFBTSxLQUFLLFlBQVk7QUFFdkIsUUFDSSxjQUNBLE9BQU8sS0FDUCxPQUFPLEtBQ04sTUFBSyxJQUFJLE1BQU0sS0FBSyxLQUFLLElBQUksTUFBTSxNQUNwQyw0QkFDQSxtQkFBbUIsUUFBUSxrQkFBa0IsUUFDL0M7QUFDRSx5QkFBbUIsUUFBUSxnQkFDdkIsS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsVUFBYSxDQUFDLFFBQVc7QUFBQTtBQUdoRixVQUFNLE9BQU8sbUJBQW1CLFFBQVE7QUFFeEMsaUJBQWEsT0FBTyxNQUFNO0FBQzFCLGdCQUFZLE9BQU8sTUFBTTtBQUN6Qix1QkFBbUIsUUFBUSxhQUFhO0FBQ3hDLHVCQUFtQixRQUFRLFlBQVk7QUFFdkMsVUFBTSxPQUFPO0FBQ2IsVUFBTSxRQUFRLFlBQVksVUFBVTtBQUNwQyxVQUFNLG1CQUFtQixHQUFHLGVBQWUsR0FBRztBQUM5QyxnQkFBWSxVQUFVO0FBRXRCLFFBQ0ksbUJBQW1CLEtBQ2xCLE1BQUssSUFBSSxTQUFTLE9BQVEsU0FBUyxLQUFLLFNBQVMscUJBQ2xELGVBQWUsR0FBRyxlQUFlLEdBQ25DO0FBQ0UsWUFBTSxPQUFPLE9BQU87QUFDcEIsWUFBTSxhQUFjLGdCQUFlLEdBQUcsZ0JBQWdCO0FBQ3RELGNBQVEsVUFBVSxhQUFhO0FBQUE7QUFHbkMsUUFBSSxTQUFTLFFBQVc7QUFDcEIsYUFBTyxhQUFhLFVBQVU7QUFDOUIsZ0JBQVU7QUFDVixnQkFBVSxVQUFVLE9BQU8sV0FBVyxNQUFNLFVBQVUsT0FBTztBQUFBO0FBR2pFLFdBQU87QUFBQSxNQUNILEdBQUc7QUFBQSxNQUNILEdBQUcsT0FBTyxRQUFRO0FBQUEsTUFDbEIsT0FBTyxHQUFHLGNBQWM7QUFBQSxNQUN4QixRQUFRLEdBQUcsZUFBZTtBQUFBLE1BQzFCLGNBQWMsYUFBYSxTQUFTLGVBQWU7QUFBQTtBQUFBLEtBRXhELENBQUMsZUFBZSxjQUFjLGNBQWMsUUFBUSwwQkFBMEI7QUFFakYsUUFBTSxjQUFjLE1BQU0sT0FBTztBQUNqQyxjQUFZLFVBQVU7QUFFdEIsUUFBTSxZQUFZLE1BQU07QUFFeEIsUUFBTSxpQkFBaUIsTUFBTSxPQUFPO0FBQ3BDLFFBQU0sVUFBVSxNQUFNO0FBQ2xCLFFBQUksZUFBZTtBQUFTO0FBQUE7QUFDdkIscUJBQWUsVUFBVTtBQUFBLEtBQy9CLENBQUMsVUFBVSxlQUFlO0FBRTdCLFFBQU0sVUFBVSxNQUFNLFlBQ2xCLENBQUMsYUFBb0M7QUFDakMsYUFBUyxVQUFVO0FBQ25CLFFBQUksY0FBYyxRQUFXO0FBQ3pCLGdCQUFVLFVBQVU7QUFBQTtBQUFBLEtBRzVCLENBQUM7QUFHTCxNQUFJLE1BQU07QUFDVixNQUFJLElBQUk7QUFDUixVQUFRLEtBQUssb0NBQUMsT0FBRDtBQUFBLElBQUssS0FBSztBQUFBLElBQU8sT0FBTyxFQUFFLE9BQU8sYUFBYSxRQUFRO0FBQUE7QUFDbkUsU0FBTyxJQUFJLGNBQWM7QUFDckIsVUFBTSxRQUFRLEtBQUssSUFBSSxLQUFXLGVBQWU7QUFDakQsWUFBUSxLQUFLLG9DQUFDLE9BQUQ7QUFBQSxNQUFLLEtBQUs7QUFBQSxNQUFPLE9BQU8sRUFBRSxPQUFPLEdBQUcsUUFBUTtBQUFBO0FBQ3pELFNBQUs7QUFBQTtBQUdULFFBQU0sRUFBRSxLQUFLLE9BQU8sV0FBVyxrQkFBa0M7QUFFakUsTUFBSSxVQUFVLFNBQVMsV0FBVyxVQUFVLFVBQVUsU0FBUyxVQUFVLE9BQU87QUFDNUUsV0FBTyxXQUFXLE1BQU0sWUFBWSxXQUFXO0FBQy9DLGNBQVUsVUFBVSxFQUFFLE9BQU87QUFBQTtBQUdqQyxNQUFLLFVBQVMsT0FBTyxLQUFNLFdBQVUsT0FBTztBQUFHLFdBQU8sb0NBQUMsT0FBRDtBQUFBLE1BQUs7QUFBQTtBQUUzRCxTQUNJLG9DQUFDLE9BQUQ7QUFBQSxJQUFLO0FBQUEsS0FDRCxvQ0FBQyxtQkFBRDtBQUFBLElBQW1CLFVBQVUsZ0JBQWdCO0FBQUEsS0FDeEMsU0FDRCxvQ0FBQyxPQUFEO0FBQUEsSUFBSyxXQUFVO0FBQUEsS0FBZ0IsV0FDL0Isb0NBQUMsT0FBRDtBQUFBLElBQ0ksS0FBSztBQUFBLElBQ0wsT0FBTyxVQUFVO0FBQUEsSUFDakI7QUFBQSxJQUNBLGFBQWEsT0FBSztBQUNkLFVBQUksQ0FBQyxXQUFXO0FBQ1osVUFBRTtBQUNGLFVBQUU7QUFBQTtBQUFBO0FBQUEsSUFHVixXQUFXLGtCQUFtQixjQUFhO0FBQUEsSUFDM0M7QUFBQSxLQUNBLG9DQUFDLE9BQUQ7QUFBQSxJQUFLLFdBQVcscUJBQXNCLGtCQUFpQixTQUFZLFlBQVk7QUFBQSxLQUMzRSxvQ0FBQyxPQUFEO0FBQUEsSUFBSyxXQUFVO0FBQUEsS0FBYSxVQUMzQixpQkFBaUIsVUFDZCwwREFDSyxDQUFDLG9CQUFvQixvQ0FBQyxPQUFEO0FBQUEsSUFBSyxXQUFVO0FBQUEsTUFDckMsb0NBQUMsT0FBRDtBQUFBLElBQ0ksS0FBSztBQUFBLElBQ0wsYUFBYTtBQUFBLElBQ2IsV0FBVztBQUFBLElBQ1gsYUFBYTtBQUFBLElBQ2IsT0FBTztBQUFBLE1BQ0g7QUFBQSxNQUNBLFdBQVcsZUFBZSxLQUFLLEtBQUssTUFBTTtBQUFBLE1BQzFDLFVBQVU7QUFBQSxNQUNWLEtBQUs7QUFBQSxNQUNMLGFBQWE7QUFBQSxNQUNiLGNBQWM7QUFBQSxNQUNkLGFBQWE7QUFBQSxNQUNiLFVBQVUsbUJBQW1CLElBQUk7QUFBQSxNQUNqQyxPQUFPLHFCQUFxQixnQkFBZ0IsSUFBSTtBQUFBLE1BQ2hELGVBQWU7QUFBQTtBQUFBLEtBRWxCO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import { styled } from \"@linaria/react\";\nexport const SearchWrapper = styled.div`\n    position: absolute;\n    top: 4px;\n    right: 20px;\n\n    background-color: var(--gdg-bg-cell);\n    color: var(--gdg-text-dark);\n\n    padding: 8px;\n    border: 1px solid var(--gdg-border-color);\n    border-radius: 6px;\n\n    font-size: var(--gdg-editor-font-size);\n\n    transform: translateX(${(p) => p.showSearch ? 0 : 400}px);\n    transition: transform 0.15s;\n\n    .search-bar-inner {\n        display: flex;\n    }\n\n    .search-status {\n        padding-top: 4px;\n        font-size: 11px;\n    }\n\n    .search-progress {\n        position: absolute;\n        height: 4px;\n        left: 0;\n        bottom: 0;\n\n        background-color: var(--gdg-text-light);\n    }\n\n    input {\n        width: 220px;\n        color: var(--gdg-textDark);\n        background-color: var(--gdg-bg-cell);\n        border: none;\n        border-width: 0;\n        outline: none;\n    }\n\n    button {\n        width: 24px;\n        height: 24px;\n        padding: 0;\n\n        border: none;\n        outline: none;\n        background: none;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        cursor: pointer;\n        color: var(--gdg-text-medium);\n\n        :hover {\n            color: var(--gdg-text-dark);\n        }\n\n        .button-icon {\n            width: 16px;\n            height: 16px;\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtc2VhcmNoL2RhdGEtZ3JpZC1zZWFyY2gtc3R5bGUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IFNlYXJjaFdyYXBwZXIgPSBzdHlsZWQuZGl2PHsgc2hvd1NlYXJjaDogYm9vbGVhbiB9PmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiA0cHg7XG4gICAgcmlnaHQ6IDIwcHg7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgcGFkZGluZzogOHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcblxuICAgIGZvbnQtc2l6ZTogdmFyKC0tZ2RnLWVkaXRvci1mb250LXNpemUpO1xuXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKCR7cCA9PiAocC5zaG93U2VhcmNoID8gMCA6IDQwMCl9cHgpO1xuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjE1cztcblxuICAgIC5zZWFyY2gtYmFyLWlubmVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG5cbiAgICAuc2VhcmNoLXN0YXR1cyB7XG4gICAgICAgIHBhZGRpbmctdG9wOiA0cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICB9XG5cbiAgICAuc2VhcmNoLXByb2dyZXNzIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBoZWlnaHQ6IDRweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy10ZXh0LWxpZ2h0KTtcbiAgICB9XG5cbiAgICBpbnB1dCB7XG4gICAgICAgIHdpZHRoOiAyMjBweDtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0RGFyayk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBib3JkZXItd2lkdGg6IDA7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgfVxuXG4gICAgYnV0dG9uIHtcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgcGFkZGluZzogMDtcblxuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQ6IG5vbmU7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LW1lZGl1bSk7XG5cbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5idXR0b24taWNvbiB7XG4gICAgICAgICAgICB3aWR0aDogMTZweDtcbiAgICAgICAgICAgIGhlaWdodDogMTZweDtcbiAgICAgICAgfVxuXG4gICAgICAgIDpkaXNhYmxlZCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUVPLGFBQU0sZ0JBQWdCLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDRCQWNSLE9BQU0sRUFBRSxhQUFhLElBQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { css } from \"@linaria/core\";\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container\";\nconst RenameInput = styled.input`\n    flex-grow: 1;\n    border: none;\n    outline: none;\n    background-color: var(--gdg-bg-header-has-focus);\n    border-radius: 9px;\n    padding: 0 8px;\n    box-shadow: 0 0 0 1px var(--gdg-border-color);\n    color: var(--gdg-text-group-header);\n    min-height: ${(p) => Math.max(16, p.targetHeight - 10)}px;\n    font: var(--gdg-header-font-style) var(--gdg-font-family);\n`;\nexport const GroupRename = (p) => {\n  const { bounds, group, onClose, canvasBounds, onFinish } = p;\n  const [value, setValue] = React.useState(group);\n  return /* @__PURE__ */ React.createElement(ClickOutsideContainer, {\n    style: {\n      position: \"absolute\",\n      left: bounds.x - canvasBounds.left + 1,\n      top: bounds.y - canvasBounds.top,\n      width: bounds.width - 2,\n      height: bounds.height\n    },\n    className: css`\n                padding: 0 8px;\n                display: flex;\n                align-items: center;\n                background-color: var(--gdg-bg-header);\n            `,\n    onClickOutside: onClose\n  }, /* @__PURE__ */ React.createElement(RenameInput, {\n    targetHeight: bounds.height,\n    \"data-testid\": \"group-rename-input\",\n    value,\n    onBlur: onClose,\n    onFocus: (e) => e.target.setSelectionRange(0, value.length),\n    onChange: (e) => setValue(e.target.value),\n    onKeyDown: (e) => {\n      if (e.key === \"Enter\") {\n        onFinish(value);\n      } else if (e.key === \"Escape\") {\n        onClose();\n      }\n    },\n    autoFocus: true\n  }));\n};\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9ncm91cC1yZW5hbWUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IGNzcyB9IGZyb20gXCJAbGluYXJpYS9jb3JlXCI7XG5pbXBvcnQgQ2xpY2tPdXRzaWRlQ29udGFpbmVyIGZyb20gXCIuLi9jbGljay1vdXRzaWRlLWNvbnRhaW5lci9jbGljay1vdXRzaWRlLWNvbnRhaW5lclwiO1xuaW1wb3J0IHR5cGUgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGJvdW5kczogUmVjdGFuZ2xlO1xuICAgIHJlYWRvbmx5IGdyb3VwOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgb25DbG9zZTogKCkgPT4gdm9pZDtcbiAgICByZWFkb25seSBvbkZpbmlzaDogKG5ld1ZhbDogc3RyaW5nKSA9PiB2b2lkO1xuICAgIHJlYWRvbmx5IGNhbnZhc0JvdW5kczogRE9NUmVjdDtcbn1cblxuY29uc3QgUmVuYW1lSW5wdXQgPSBzdHlsZWQuaW5wdXQ8eyB0YXJnZXRIZWlnaHQ6IG51bWJlciB9PmBcbiAgICBmbGV4LWdyb3c6IDE7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWhlYWRlci1oYXMtZm9jdXMpO1xuICAgIGJvcmRlci1yYWRpdXM6IDlweDtcbiAgICBwYWRkaW5nOiAwIDhweDtcbiAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWdyb3VwLWhlYWRlcik7XG4gICAgbWluLWhlaWdodDogJHtwID0+IE1hdGgubWF4KDE2LCBwLnRhcmdldEhlaWdodCAtIDEwKX1weDtcbiAgICBmb250OiB2YXIoLS1nZGctaGVhZGVyLWZvbnQtc3R5bGUpIHZhcigtLWdkZy1mb250LWZhbWlseSk7XG5gO1xuXG5leHBvcnQgY29uc3QgR3JvdXBSZW5hbWU6IFJlYWN0LlZGQzxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGJvdW5kcywgZ3JvdXAsIG9uQ2xvc2UsIGNhbnZhc0JvdW5kcywgb25GaW5pc2ggfSA9IHA7XG5cbiAgICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKGdyb3VwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxDbGlja091dHNpZGVDb250YWluZXJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZHMueCAtIGNhbnZhc0JvdW5kcy5sZWZ0ICsgMSxcbiAgICAgICAgICAgICAgICB0b3A6IGJvdW5kcy55IC0gY2FudmFzQm91bmRzLnRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYm91bmRzLndpZHRoIC0gMixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjc3NgXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXIpO1xuICAgICAgICAgICAgYH1cbiAgICAgICAgICAgIG9uQ2xpY2tPdXRzaWRlPXtvbkNsb3NlfT5cbiAgICAgICAgICAgIDxSZW5hbWVJbnB1dFxuICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodD17Ym91bmRzLmhlaWdodH1cbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD1cImdyb3VwLXJlbmFtZS1pbnB1dFwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQmx1cj17b25DbG9zZX1cbiAgICAgICAgICAgICAgICBvbkZvY3VzPXtlID0+IGUudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKDAsIHZhbHVlLmxlbmd0aCl9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gc2V0VmFsdWUoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkZpbmlzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgYXV0b0ZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9DbGlja091dHNpZGVDb250YWluZXI+XG4gICAgKTtcbn07XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVdBLE1BQU0sY0FBYyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQVNULE9BQUssS0FBSyxJQUFJLElBQUksRUFBRSxlQUFlO0FBQUE7QUFBQTtBQUk5QyxhQUFNLGNBQWdDLE9BQUs7QUFDOUMsUUFBTSxFQUFFLFFBQVEsT0FBTyxTQUFTLGNBQWMsYUFBYTtBQUUzRCxRQUFNLENBQUMsT0FBTyxZQUFZLE1BQU0sU0FBUztBQUV6QyxTQUNJLG9DQUFDLHVCQUFEO0FBQUEsSUFDSSxPQUFPO0FBQUEsTUFDSCxVQUFVO0FBQUEsTUFDVixNQUFNLE9BQU8sSUFBSSxhQUFhLE9BQU87QUFBQSxNQUNyQyxLQUFLLE9BQU8sSUFBSSxhQUFhO0FBQUEsTUFDN0IsT0FBTyxPQUFPLFFBQVE7QUFBQSxNQUN0QixRQUFRLE9BQU87QUFBQTtBQUFBLElBRW5CLFdBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFNWCxnQkFBZ0I7QUFBQSxLQUNoQixvQ0FBQyxhQUFEO0FBQUEsSUFDSSxjQUFjLE9BQU87QUFBQSxJQUNyQixlQUFZO0FBQUEsSUFDWjtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsU0FBUyxPQUFLLEVBQUUsT0FBTyxrQkFBa0IsR0FBRyxNQUFNO0FBQUEsSUFDbEQsVUFBVSxPQUFLLFNBQVMsRUFBRSxPQUFPO0FBQUEsSUFDakMsV0FBVyxPQUFLO0FBQ1osVUFBSSxFQUFFLFFBQVEsU0FBUztBQUNuQixpQkFBUztBQUFBLGlCQUNGLEVBQUUsUUFBUSxVQUFVO0FBQzNCO0FBQUE7QUFBQTtBQUFBLElBR1IsV0FBVztBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nfunction toCss(x) {\n  if (typeof x === \"string\")\n    return x;\n  return `${x}px`;\n}\nconst Wrapper = styled.div`\n    position: relative;\n\n    min-width: 10px;\n    min-height: 10px;\n    max-width: 100%;\n    max-height: 100%;\n\n    width: ${(p) => p.innerWidth};\n    height: ${(p) => p.innerHeight};\n\n    overflow: hidden;\n    overflow: clip;\n\n    contain: strict;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\nexport const DataEditorContainer = (p) => {\n  const { inWidth, inHeight, children, ...rest } = p;\n  return /* @__PURE__ */ React.createElement(Wrapper, {\n    innerHeight: toCss(inHeight),\n    innerWidth: toCss(inWidth),\n    ...rest\n  }, children);\n};\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci1jb250YWluZXIvZGF0YS1ncmlkLWNvbnRhaW5lci50c3giXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGluV2lkdGg6IG51bWJlciB8IHN0cmluZztcbiAgICBpbkhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b0Nzcyh4OiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHJldHVybiB4O1xuICAgIHJldHVybiBgJHt4fXB4YDtcbn1cblxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBpbm5lcldpZHRoOiBzdHJpbmc7IGlubmVySGVpZ2h0OiBzdHJpbmcgfT5gXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgbWluLXdpZHRoOiAxMHB4O1xuICAgIG1pbi1oZWlnaHQ6IDEwcHg7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG5cbiAgICB3aWR0aDogJHtwID0+IHAuaW5uZXJXaWR0aH07XG4gICAgaGVpZ2h0OiAke3AgPT4gcC5pbm5lckhlaWdodH07XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG92ZXJmbG93OiBjbGlwO1xuXG4gICAgY29udGFpbjogc3RyaWN0O1xuXG4gICAgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgUHJvcHMgZXh0ZW5kcyBXcmFwcGVyUHJvcHMsIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PiB7fVxuXG5leHBvcnQgY29uc3QgRGF0YUVkaXRvckNvbnRhaW5lcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48UHJvcHM+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgaW5XaWR0aCwgaW5IZWlnaHQsIGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxXcmFwcGVyIGlubmVySGVpZ2h0PXt0b0NzcyhpbkhlaWdodCl9IGlubmVyV2lkdGg9e3RvQ3NzKGluV2lkdGgpfSB7Li4ucmVzdH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvV3JhcHBlcj5cbiAgICApO1xufTtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBQ0E7QUFPQSxlQUFlLEdBQW9CO0FBQy9CLE1BQUksT0FBTyxNQUFNO0FBQVUsV0FBTztBQUNsQyxTQUFPLEdBQUc7QUFBQTtBQUdkLE1BQU0sVUFBVSxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQVFWLE9BQUssRUFBRTtBQUFBLGNBQ04sT0FBSyxFQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWtCZCxhQUFNLHNCQUErRSxPQUFLO0FBQzdGLFFBQU0sRUFBRSxTQUFTLFVBQVUsYUFBYSxTQUFTO0FBQ2pELFNBQ0ksb0NBQUMsU0FBRDtBQUFBLElBQVMsYUFBYSxNQUFNO0FBQUEsSUFBVyxZQUFZLE1BQU07QUFBQSxPQUFjO0FBQUEsS0FDbEU7QUFBQTsiLAogICJuYW1lcyI6IFtdCn0K*/","import { styled } from \"@linaria/react\";\nexport const BubblesOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .boe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 20px;\n\n        background-color: var(--gdg-bg-bubble);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9idWJibGVzLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBCdWJibGVzT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcblxuICAgIC5ib2UtYnViYmxlIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwcHg7XG5cbiAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgICAgIGhlaWdodDogMjBweDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctYnViYmxlKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICBtYXJnaW46IDJweDtcbiAgICB9XG5cbiAgICB0ZXh0YXJlYSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAwcHg7XG5cbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5gO1xuIl0sCiAgIm1hcHBpbmdzIjogIkFBQUE7QUFFTyxhQUFNLDRCQUE0QixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nconst DrilldownOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .doe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 24px;\n\n        background-color: var(--gdg-bg-cell);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n\n        border-radius: 6px;\n\n        box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n\n        img {\n            height: 16px;\n            object-fit: contain;\n\n            margin-right: 4px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\nconst DrilldownOverlayEditor = (p) => {\n  const { drilldowns } = p;\n  return /* @__PURE__ */ React.createElement(DrilldownOverlayEditorStyle, null, drilldowns.map((d, i) => /* @__PURE__ */ React.createElement(\"div\", {\n    key: i,\n    className: \"doe-bubble\"\n  }, d.img !== void 0 && /* @__PURE__ */ React.createElement(\"img\", {\n    src: d.img\n  }), /* @__PURE__ */ React.createElement(\"div\", null, d.text))));\n};\nexport default DrilldownOverlayEditor;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9kcmlsbGRvd24tb3ZlcmxheS1lZGl0b3IudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IERyaWxsZG93bkNlbGxEYXRhIH0gZnJvbSBcIi4uLy4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmNvbnN0IERyaWxsZG93bk92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG5cbiAgICAuZG9lLWJ1YmJsZSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xuXG4gICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgICAgICBoZWlnaHQ6IDI0cHg7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIG1hcmdpbjogMnB4O1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcblxuICAgICAgICBib3gtc2hhZG93OiAwIDAgMXB4IHJnYmEoNjIsIDY1LCA4NiwgMC40KSwgMCAxcHggM3B4IHJnYmEoNjIsIDY1LCA4NiwgMC40KTtcblxuICAgICAgICBpbWcge1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcblxuICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXh0YXJlYSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAwcHg7XG5cbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGRyaWxsZG93bnM6IHJlYWRvbmx5IERyaWxsZG93bkNlbGxEYXRhW107XG59XG5cbmNvbnN0IERyaWxsZG93bk92ZXJsYXlFZGl0b3I6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgZHJpbGxkb3ducyB9ID0gcDtcbiAgICByZXR1cm4gKFxuICAgICAgICA8RHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlPlxuICAgICAgICAgICAge2RyaWxsZG93bnMubWFwKChkLCBpKSA9PiAoXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzTmFtZT1cImRvZS1idWJibGVcIj5cbiAgICAgICAgICAgICAgICAgICAge2QuaW1nICE9PSB1bmRlZmluZWQgJiYgPGltZyBzcmM9e2QuaW1nfSAvPn1cbiAgICAgICAgICAgICAgICAgICAgPGRpdj57ZC50ZXh0fTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgIDwvRHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlPlxuICAgICk7XG59O1xuZXhwb3J0IGRlZmF1bHQgRHJpbGxkb3duT3ZlcmxheUVkaXRvcjtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUNBO0FBQ0E7QUFFQSxNQUFNLDhCQUE4QixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBNkMzQyxNQUFNLHlCQUF5RCxPQUFLO0FBQ2hFLFFBQU0sRUFBRSxlQUFlO0FBQ3ZCLFNBQ0ksb0NBQUMsNkJBQUQsTUFDSyxXQUFXLElBQUksQ0FBQyxHQUFHLE1BQ2hCLG9DQUFDLE9BQUQ7QUFBQSxJQUFLLEtBQUs7QUFBQSxJQUFHLFdBQVU7QUFBQSxLQUNsQixFQUFFLFFBQVEsVUFBYSxvQ0FBQyxPQUFEO0FBQUEsSUFBSyxLQUFLLEVBQUU7QUFBQSxNQUNwQyxvQ0FBQyxPQUFELE1BQU0sRUFBRTtBQUFBO0FBTTVCLGVBQWU7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import { styled } from \"@linaria/react\";\nexport const ImageOverlayEditorStyle = styled.div`\n    display: flex;\n\n    height: 100%;\n\n    .centering-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        height: 100%;\n\n        img,\n        canvas {\n            max-height: calc(100vh - var(--overlay-top) - 20px);\n            object-fit: contain;\n            user-select: none;\n        }\n\n        canvas {\n            max-width: 380px;\n        }\n    }\n\n    .edit-icon {\n        position: absolute;\n        top: 12px;\n        right: 0;\n        width: 48px;\n        height: 48px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9pbWFnZS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgSW1hZ2VPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAuY2VudGVyaW5nLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGhlaWdodDogMTAwJTtcblxuICAgICAgICBpbWcsXG4gICAgICAgIGNhbnZhcyB7XG4gICAgICAgICAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0tb3ZlcmxheS10b3ApIC0gMjBweCk7XG4gICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXMge1xuICAgICAgICAgICAgbWF4LXdpZHRoOiAzODBweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMTJweDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBRU8sYUFBTSwwQkFBMEIsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/","import { styled } from \"@linaria/react\";\nexport const MarkdownContainer = styled.div`\n    word-break: break-word;\n    -webkit-touch-callout: default;\n    padding-top: 6px;\n\n    > * {\n        margin: 0;\n    }\n\n    & *:last-child {\n        margin-bottom: 0;\n    }\n\n    & p img {\n        width: 100%;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9tYXJrZG93bi1kaXYvcHJpdmF0ZS9tYXJrZG93bi1jb250YWluZXIudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duQ29udGFpbmVyID0gc3R5bGVkLmRpdmBcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xuICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogZGVmYXVsdDtcbiAgICBwYWRkaW5nLXRvcDogNnB4O1xuXG4gICAgPiAqIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgIH1cblxuICAgICYgKjpsYXN0LWNoaWxkIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICB9XG5cbiAgICAmIHAgaW1nIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuYDtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBRU8sYUFBTSxvQkFBb0IsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { styled } from \"@linaria/react\";\nexport const InputBox = styled.textarea`\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n\n    border-radius: 0px;\n\n    resize: none;\n    white-space: pre-wrap;\n    min-width: 100%;\n    overflow: hidden;\n    border: 0;\n    background-color: transparent;\n\n    ::placeholder {\n        color: var(--gdg-text-light);\n    }\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    .invalid & {\n        text-decoration: underline;\n        text-decoration-color: #d60606;\n    }\n`;\nexport const ShadowBox = styled.div`\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n\n    width: max-content;\n    max-width: 100%;\n\n    min-width: 100%;\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    padding-bottom: 2px;\n`;\nexport const GrowingEntryStyle = styled.div`\n    position: relative;\n    margin-top: 6px;\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IElucHV0Qm94ID0gc3R5bGVkLnRleHRhcmVhYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgYm9yZGVyLXJhZGl1czogMHB4O1xuXG4gICAgcmVzaXplOiBub25lO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICBtaW4td2lkdGg6IDEwMCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3JkZXI6IDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICA6OnBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWxpZ2h0KTtcbiAgICB9XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG5cbiAgICAuaW52YWxpZCAmIHtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbi1jb2xvcjogI2Q2MDYwNjtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgU2hhZG93Qm94ID0gc3R5bGVkLmRpdmBcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgIHdvcmQtd3JhcDogYnJlYWstd29yZDtcblxuICAgIHdpZHRoOiBtYXgtY29udGVudDtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG5cbiAgICBtaW4td2lkdGg6IDEwMCU7XG5cbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG5cbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xuYDtcblxuZXhwb3J0IGNvbnN0IEdyb3dpbmdFbnRyeVN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbWFyZ2luLXRvcDogNnB4O1xuYDtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBRU8sYUFBTSxXQUFXLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFtQ3hCLGFBQU0sWUFBWSxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBb0J6QixhQUFNLG9CQUFvQixPQUFPO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { GrowingEntryStyle } from \"../../growing-entry/growing-entry-style\";\nimport { styled } from \"@linaria/react\";\nexport const MarkdownOverlayEditorStyle = styled.div`\n    min-width: ${(p) => p.targetWidth}px;\n    width: 100%;\n    display: flex;\n    align-items: flex-start;\n    justify-content: space-between;\n    position: relative;\n    color: var(--gdg-text-dark);\n\n    ${GrowingEntryStyle} {\n        flex-shrink: 1;\n        min-width: 0;\n    }\n\n    .spacer {\n        flex: 1;\n    }\n\n    .edit-icon {\n        position: relative;\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        color: var(--gdg-accent-color);\n\n        padding: 0;\n\n        height: 24px;\n        width: 24px;\n        flex-shrink: 0;\n\n        transition: all \"0.125s ease\";\n\n        border-radius: 6px;\n\n        > * {\n            width: 16px;\n            height: 16px;\n        }\n    }\n\n    .edit-hover {\n        :hover {\n            background-color: var(--gdg-accent-light);\n            transition: background-color 150ms;\n        }\n    }\n\n    .checkmark-hover {\n        :hover {\n            color: #ffffff;\n            background-color: var(--gdg-accent-color);\n        }\n    }\n\n    .md-edit-textarea {\n        position: relative;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n        margin-top: 25px;\n        opacity: 0;\n        padding: 0;\n    }\n\n    .ml-6 {\n        margin-left: 6px;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9tYXJrZG93bi1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IEdyb3dpbmdFbnRyeVN0eWxlIH0gZnJvbSBcIi4uLy4uL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZVwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgdGFyZ2V0V2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdjxQcm9wcz5gXG4gICAgbWluLXdpZHRoOiAke3AgPT4gcC50YXJnZXRXaWR0aH1weDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuXG4gICAgJHtHcm93aW5nRW50cnlTdHlsZX0ge1xuICAgICAgICBmbGV4LXNocmluazogMTtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgIH1cblxuICAgIC5zcGFjZXIge1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgcGFkZGluZzogMDtcblxuICAgICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICBmbGV4LXNocmluazogMDtcblxuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgXCIwLjEyNXMgZWFzZVwiO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcblxuICAgICAgICA+ICoge1xuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZWRpdC1ob3ZlciB7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTUwbXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuY2hlY2ttYXJrLWhvdmVyIHtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiAjZmZmZmZmO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubWQtZWRpdC10ZXh0YXJlYSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgd2lkdGg6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAwcHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDI1cHg7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgfVxuXG4gICAgLm1sLTYge1xuICAgICAgICBtYXJnaW4tbGVmdDogNnB4O1xuICAgIH1cbmA7XG4iXSwKICAibWFwcGluZ3MiOiAiQUFBQTtBQUNBO0FBTU8sYUFBTSw2QkFBNkIsT0FBTztBQUFBLGlCQUNoQyxPQUFLLEVBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUWxCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { styled } from \"@linaria/react\";\nexport const NumberOverlayEditorStyle = styled.div`\n    display: flex;\n    margin: 6px 0 3px;\n    color: var(--gdg-text-dark);\n\n    > input {\n        font-size: var(--gdg-editor-font-size);\n        padding: 0;\n        font-family: var(--gdg-font-family);\n        color: var(--gdg-text-dark);\n        background-color: var(--gdg-bg-cell);\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9udW1iZXItb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IE51bWJlck92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtYXJnaW46IDZweCAwIDNweDtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICA+IGlucHV0IHtcbiAgICAgICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICB9XG5gO1xuIl0sCiAgIm1hcHBpbmdzIjogIkFBQUE7QUFFTyxhQUFNLDJCQUEyQixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=*/","import { styled } from \"@linaria/react\";\nexport const UriOverlayEditorStyle = styled.div`\n    display: flex;\n\n    flex-grow: 1;\n\n    align-items: center;\n\n    min-height: 21px;\n\n    .link-area {\n        flex-grow: 1;\n        flex-shrink: 1;\n\n        cursor: pointer;\n\n        margin-right: 8px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n\n        color: var(--gdg-link-color);\n        text-decoration: underline !important;\n    }\n\n    .edit-icon {\n        flex-shrink: 0;\n        width: 32px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiL2hvbWUvcnVubmVyL3dvcmsvZ2xpZGUtZGF0YS1ncmlkL2dsaWRlLWRhdGEtZ3JpZC9wYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS91cmktb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IFVyaU92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcblxuICAgIGZsZXgtZ3JvdzogMTtcblxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICBtaW4taGVpZ2h0OiAyMXB4O1xuXG4gICAgLmxpbmstYXJlYSB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcblxuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWxpbmstY29sb3IpO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5lZGl0LWljb24ge1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWNvbG9yKTtcblxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuYDtcbiJdLAogICJtYXBwaW5ncyI6ICJBQUFBO0FBRU8sYUFBTSx3QkFBd0IsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./packages/cells/src/cell.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cell.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_cell_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cell.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_cell_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_cell_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/cells/src/cells/dropdown-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/dropdown-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_dropdown_cell_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/dropdown-cell.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_dropdown_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_dropdown_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/cells/src/cells/links-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/links-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_links_cell_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/links-cell.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_links_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_links_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/cells/src/cells/star-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/star-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_star_cell_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/star-cell.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_star_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_star_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/cells/src/cells/tags-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/tags-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_tags_cell_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/tags-cell.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_tags_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_tags_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor-container/data-grid-container.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor-container/data-grid-container.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_container_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor-container/data-grid-container.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_container_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_container_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor/group-rename.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/group-rename.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_group_rename_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/group-rename.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_group_rename_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_group_rename_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor-repros.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_repros_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_repros_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_repros_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor/stories/utils.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_utils_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/utils.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_utils_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_utils_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_bubbles_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_bubbles_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_bubbles_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_drilldown_overlay_editor_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_drilldown_overlay_editor_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_drilldown_overlay_editor_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_image_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_image_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_image_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_uri_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_uri_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_uri_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-search/data-grid-search-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-search/data-grid-search-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_search_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-search/data-grid-search-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_search_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_search_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/docs/doc-wrapper.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/doc-wrapper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_doc_wrapper_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/doc-wrapper.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_doc_wrapper_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_doc_wrapper_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/docs/examples/header-menus.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/examples/header-menus.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_header_menus_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/examples/header-menus.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_header_menus_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_header_menus_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/growing-entry/growing-entry-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/growing-entry/growing-entry-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_growing_entry_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/growing-entry/growing-entry-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_growing_entry_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_growing_entry_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/markdown-div/private/markdown-container.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/markdown-div/private/markdown-container.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_container_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/markdown-div/private/markdown-container.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_container_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_container_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/infinite-scroller.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/infinite-scroller.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_infinite_scroller_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/infinite-scroller.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_infinite_scroller_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_infinite_scroller_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/scrolling-data-grid.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/stories/story-utils.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/stories/story-utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_story_utils_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/stories/story-utils.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_story_utils_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_story_utils_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/source/src/stories/use-data-source.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/source/src/stories/use-data-source.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_use_data_source_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/source/src/stories/use-data-source.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_use_data_source_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_5_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_use_data_source_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./.storybook/preview.js-generated-config-entry.js":
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// NAMESPACE OBJECT: ./.storybook/preview.js
var preview_namespaceObject = {};
__webpack_require__.r(preview_namespaceObject);
__webpack_require__.d(preview_namespaceObject, {
  "__namedExportsOrder": () => (__namedExportsOrder),
  "parameters": () => (parameters)
});

// EXTERNAL MODULE: ./node_modules/@storybook/client-api/dist/esm/ClientApi.js + 4 modules
var ClientApi = __webpack_require__("./node_modules/@storybook/client-api/dist/esm/ClientApi.js");
// EXTERNAL MODULE: ./node_modules/@storybook/react/dist/esm/client/index.js + 33 modules
var client = __webpack_require__("./node_modules/@storybook/react/dist/esm/client/index.js");
;// CONCATENATED MODULE: ./.storybook/preview.js

(0,client.addParameters)({
  options: {
    showRoots: true,
    storySort: (a, b) => {
      return a[1].name.localeCompare(b[1].name, undefined, {
        numeric: true
      });
    }
  }
});
const parameters = {
  layout: "fullscreen"
};
const __namedExportsOrder = ["parameters"];
;// CONCATENATED MODULE: ./.storybook/preview.js-generated-config-entry.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



Object.keys(preview_namespaceObject).forEach(function (key) {
  var value = preview_namespaceObject[key];

  switch (key) {
    case 'args':
      {
        return (0,ClientApi/* addArgs */.uc)(value);
      }

    case 'argTypes':
      {
        return (0,ClientApi/* addArgTypes */.v9)(value);
      }

    case 'decorators':
      {
        return value.forEach(function (decorator) {
          return (0,ClientApi/* addDecorator */.$9)(decorator, false);
        });
      }

    case 'loaders':
      {
        return value.forEach(function (loader) {
          return (0,ClientApi/* addLoader */.HZ)(loader, false);
        });
      }

    case 'parameters':
      {
        return (0,ClientApi/* addParameters */.h1)(_objectSpread({}, value), false);
      }

    case 'argTypesEnhancers':
      {
        return value.forEach(function (enhancer) {
          return (0,ClientApi/* addArgTypesEnhancer */.My)(enhancer);
        });
      }

    case 'argsEnhancers':
      {
        return value.forEach(function (enhancer) {
          return (0,ClientApi/* addArgsEnhancer */._C)(enhancer);
        });
      }

    case 'render':
      {
        return (0,ClientApi/* setGlobalRender */.$P)(value);
      }

    case 'globals':
    case 'globalTypes':
      {
        var v = {};
        v[key] = value;
        return (0,ClientApi/* addParameters */.h1)(v, false);
      }

    case '__namedExportsOrder':
    case 'decorateStory':
    case 'renderToDOM':
      {
        return null;
      }

    default:
      {
        return console.log(key + ' was not supported :( !');
      }
  }
});

/***/ }),

/***/ "./packages/cells/src/cell.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "CustomCellEditing": () => (/* binding */ CustomCellEditing),
  "CustomCells": () => (/* binding */ CustomCells),
  "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
  "default": () => (/* binding */ cell_stories)
});

// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./packages/core/dist/js/index.js
var js = __webpack_require__("./packages/core/dist/js/index.js");
;// CONCATENATED MODULE: ./packages/cells/src/cells/star-cell.tsx



const starPoints = [[50, 5], [61.23, 39.55], [97.55, 39.55], [68.16, 60.9], [79.39, 95.45], [50, 74.1], [20.61, 95.45], [31.84, 60.9], [2.45, 39.55], [38.77, 39.55]];

function pathStar(ctx, center, size) {
  let moved = false;

  for (const p of starPoints) {
    const x = (p[0] - 50) * (size / 100) + center[0];
    const y = (p[1] - 50) * (size / 100) + center[1];

    if (moved) {
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(x, y);
      moved = true;
    }
  }

  ctx.closePath();
}

const StarSVG = () => react.createElement("svg", {
  width: "100",
  height: "100",
  viewBox: "0 0 100 100",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, react.createElement("path", {
  d: "M47.1468 13.7811C48.0449 11.0172 51.9551 11.0172 52.8532 13.7812L60.5522 37.4762C60.9538 38.7123 62.1056 39.5491 63.4053 39.5491H88.3198C91.226 39.5491 92.4343 43.268 90.0831 44.9762L69.9269 59.6205C68.8755 60.3845 68.4355 61.7386 68.8371 62.9746L76.5361 86.6697C77.4342 89.4336 74.2707 91.732 71.9196 90.0238L51.7634 75.3794C50.7119 74.6155 49.2881 74.6155 48.2366 75.3795L28.0804 90.0238C25.7293 91.732 22.5659 89.4336 23.4639 86.6697L31.1629 62.9746C31.5645 61.7386 31.1245 60.3845 30.0731 59.6205L9.91686 44.9762C7.56572 43.268 8.77405 39.5491 11.6802 39.5491H36.5947C37.8944 39.5491 39.0462 38.7123 39.4478 37.4762L47.1468 13.7811Z",
  fill: "currentColor"
}));

const EditorWrap = (0,styled/* default */.Z)('div')({
  name: "EditorWrap",
  class: "e8nv6xj"
});
const renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "star-cell",
  needsHover: true,
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect,
      hoverAmount
    } = args;
    const {
      rating
    } = cell.data;
    const padX = theme.cellHorizontalPadding;
    let drawX = rect.x + padX;
    const stars = Math.min(5, Math.ceil(rating));
    drawX += 8;
    ctx.beginPath();

    for (let i = 0; i < stars; i++) {
      pathStar(ctx, [drawX, rect.y + rect.height / 2], 16);
      drawX += 18;
    }

    ctx.fillStyle = theme.textDark;
    ctx.globalAlpha = 0.6 + 0.4 * hoverAmount;
    ctx.fill();
    ctx.globalAlpha = 1;
    return true;
  },
  provideEditor: () => {
    return p => react.createElement(EditorWrap, null, [0, 1, 2, 3, 4].map(index => react.createElement("div", {
      key: index,
      className: p.value.data.rating < index + 1 ? "inactive" : "active",
      onClick: () => {
        p.onChange({ ...p.value,
          data: { ...p.value.data,
            rating: index + 1
          }
        });
      }
    }, react.createElement(StarSVG, null))));
  },
  onPaste: (val, d) => {
    const num = Number.parseInt(val);
    return { ...d,
      rating: Number.isNaN(num) ? 0 : num
    };
  }
};
/* harmony default export */ const star_cell = (renderer);

__webpack_require__("./packages/cells/src/cells/star-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/star-cell.tsx");
;// CONCATENATED MODULE: ./packages/cells/src/cells/sparkline-cell.tsx

const sparkline_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "sparkline-cell",
  needsHover: true,
  needsHoverPosition: true,
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect,
      hoverAmount,
      hoverX
    } = args;
    let {
      values,
      yAxis,
      color,
      graphKind = "line",
      displayValues
    } = cell.data;
    const [minY, maxY] = yAxis;
    if (values.length === 0) return true;
    values = values.map(x => Math.min(1, Math.max(0, (x - minY) / (maxY - minY))));
    const padX = theme.cellHorizontalPadding;
    const drawX = padX + rect.x;
    const y = rect.y + 3;
    const height = rect.height - 6;
    const width = rect.width - padX * 2;
    const delta = maxY - minY;
    const zeroY = maxY <= 0 ? y : minY >= 0 ? y + height : y + height * (maxY / delta);

    if (minY <= 0 && maxY >= 0) {
      ctx.beginPath();
      ctx.moveTo(drawX, zeroY);
      ctx.lineTo(drawX + width, zeroY);
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 1;
      ctx.strokeStyle = theme.textLight;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (graphKind === "bar") {
      var _cell$data$color;

      ctx.beginPath();
      const margin = 2;
      const spacing = (values.length - 1) * margin;
      const barWidth = (width - spacing) / values.length;
      let x = drawX;

      for (const val of values) {
        const barY = y + height - val * height;
        ctx.moveTo(x, zeroY);
        ctx.lineTo(x + barWidth, zeroY);
        ctx.lineTo(x + barWidth, barY);
        ctx.lineTo(x, barY);
        x += barWidth + margin;
      }

      ctx.fillStyle = (_cell$data$color = cell.data.color) !== null && _cell$data$color !== void 0 ? _cell$data$color : theme.accentColor;
      ctx.fill();
    } else {
      if (values.length === 1) values = [values[0], values[0]];
      ctx.beginPath();
      const xStep = (rect.width - 16) / (values.length - 1);
      const points = values.map((val, ind) => {
        return {
          x: drawX + xStep * ind,
          y: y + height - val * height
        };
      });
      ctx.moveTo(points[0].x, points[0].y);
      let i;

      for (i = 1; i < points.length - 2; i++) {
        const xControl = (points[i].x + points[i + 1].x) / 2;
        const yControl = (points[i].y + points[i + 1].y) / 2;
        ctx.quadraticCurveTo(points[i].x, points[i].y, xControl, yControl);
      }

      ctx.quadraticCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y);
      ctx.strokeStyle = color !== null && color !== void 0 ? color : theme.accentColor;
      ctx.lineWidth = 1 + hoverAmount * 0.5;
      ctx.stroke();
      ctx.lineTo(rect.x + rect.width - padX, zeroY);
      ctx.lineTo(rect.x + padX, zeroY);
      ctx.closePath();
      ctx.globalAlpha = 0.2 + 0.2 * hoverAmount;
      const grad = ctx.createLinearGradient(0, y, 0, y + height * 1.4);
      grad.addColorStop(0, color !== null && color !== void 0 ? color : theme.accentColor);
      const [r, g, b] = (0,js/* parseToRgba */.dF)(color !== null && color !== void 0 ? color : theme.accentColor);
      grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.globalAlpha = 1;

      if (hoverX !== undefined && graphKind === "line" && displayValues !== undefined) {
        ctx.beginPath();
        const closest = Math.min(values.length - 1, Math.max(0, Math.round((hoverX - padX) / xStep)));
        ctx.moveTo(drawX + closest * xStep, rect.y);
        ctx.lineTo(drawX + closest * xStep, rect.y + rect.height);
        ctx.lineWidth = 1;
        ctx.strokeStyle = theme.textLight;
        ctx.stroke();
        ctx.save();
        ctx.font = `8px ${theme.fontFamily}`;
        ctx.fillStyle = theme.textMedium;
        ctx.textBaseline = "top";
        ctx.fillText(displayValues[closest], drawX, rect.y + theme.cellVerticalPadding);
        ctx.restore();
      }
    }

    return true;
  },
  provideEditor: () => undefined,
  onPaste: (_v, d) => d
};
/* harmony default export */ const sparkline_cell = (sparkline_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/draw-fns.ts
function roundedRect(ctx, x, y, width, height, radius) {
  if (radius === 0) {
    ctx.rect(x, y, width, height);
    return;
  }

  if (typeof radius === "number") {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius
    };
  }

  radius = {
    tl: Math.min(radius.tl, height / 2, width / 2),
    tr: Math.min(radius.tr, height / 2, width / 2),
    bl: Math.min(radius.bl, height / 2, width / 2),
    br: Math.min(radius.br, height / 2, width / 2)
  };
  ctx.moveTo(x + radius.tl, y);
  ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);
  ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);
  ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);
  ctx.arcTo(x, y, x + radius.tl, y, radius.tl);
}
;// CONCATENATED MODULE: ./packages/cells/src/cells/tags-cell.tsx




const tagHeight = 20;
const innerPad = 6;

const _exp = () => p => p.tagHeight / 2;

const _exp2 = () => p => p.tagHeight;

const _exp3 = () => p => p.innerPad;

const tags_cell_EditorWrap = (0,styled/* default */.Z)('div')({
  name: "EditorWrap",
  class: "e14vzbfa",
  vars: {
    "e14vzbfa-0": [_exp(), "px"],
    "e14vzbfa-1": [_exp2(), "px"],
    "e14vzbfa-2": [_exp3(), "px"]
  }
});
const tags_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "tags-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      possibleTags,
      tags
    } = cell.data;
    const drawArea = {
      x: rect.x + theme.cellHorizontalPadding,
      y: rect.y + theme.cellVerticalPadding,
      width: rect.width - 2 * theme.cellHorizontalPadding,
      height: rect.height - 2 * theme.cellVerticalPadding
    };
    const rows = Math.max(1, Math.floor(drawArea.height / (tagHeight + innerPad)));
    let x = drawArea.x;
    let row = 1;
    let y = drawArea.y + (drawArea.height - rows * tagHeight - (rows - 1) * innerPad) / 2;

    for (const tag of tags) {
      var _possibleTags$find$co, _possibleTags$find;

      const color = (_possibleTags$find$co = (_possibleTags$find = possibleTags.find(t => t.tag === tag)) === null || _possibleTags$find === void 0 ? void 0 : _possibleTags$find.color) !== null && _possibleTags$find$co !== void 0 ? _possibleTags$find$co : theme.bgBubble;
      ctx.font = `12px ${theme.fontFamily}`;
      const metrics = (0,js/* measureTextCached */.P7)(tag, ctx);
      const width = metrics.width + innerPad * 2;
      const textY = tagHeight / 2;

      if (x !== drawArea.x && x + width > drawArea.x + drawArea.width && row < rows) {
        row++;
        y += tagHeight + innerPad;
        x = drawArea.x;
      }

      ctx.fillStyle = color;
      ctx.beginPath();
      roundedRect(ctx, x, y, width, tagHeight, tagHeight / 2);
      ctx.fill();
      ctx.fillStyle = theme.textDark;
      ctx.fillText(tag, x + innerPad, y + textY + (0,js/* getMiddleCenterBias */.aX)(ctx, `12px ${theme.fontFamily}`));
      x += width + 8;
      if (x > drawArea.x + drawArea.width && row >= rows) break;
    }

    return true;
  },
  provideEditor: () => {
    return p => {
      const {
        onChange,
        value
      } = p;
      const {
        possibleTags,
        tags,
        readonly = false
      } = value.data;
      return react.createElement(tags_cell_EditorWrap, {
        tagHeight: tagHeight,
        innerPad: innerPad,
        className: readonly ? "readonly" : ""
      }, possibleTags.map(t => {
        const selected = tags.indexOf(t.tag) !== -1;
        return react.createElement("label", {
          key: t.tag
        }, !readonly && react.createElement("input", {
          className: "gdg-input",
          type: "checkbox",
          checked: selected,
          onChange: () => {
            const newTags = selected ? tags.filter(x => x !== t.tag) : [...tags, t.tag];
            onChange({ ...p.value,
              data: { ...value.data,
                tags: newTags
              }
            });
          }
        }), react.createElement("div", {
          className: "pill " + (selected ? "selected" : "unselected"),
          style: {
            backgroundColor: selected ? t.color : undefined
          }
        }, t.tag));
      }));
    };
  },
  onPaste: (v, d) => ({ ...d,
    tags: d.possibleTags.map(x => x.tag).filter(x => v.split(",").map(s => s.trim()).includes(x))
  })
};
/* harmony default export */ const tags_cell = (tags_cell_renderer);

__webpack_require__("./packages/cells/src/cells/tags-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/tags-cell.tsx");
;// CONCATENATED MODULE: ./packages/cells/src/cells/user-profile-cell.tsx


const user_profile_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "user-profile-cell",
  draw: (args, cell) => {
    const {
      ctx,
      rect,
      theme,
      imageLoader,
      col,
      row
    } = args;
    const {
      image,
      name,
      initial,
      tint
    } = cell.data;
    const xPad = theme.cellHorizontalPadding;
    const radius = Math.min(12, rect.height / 2 - theme.cellVerticalPadding);
    const drawX = rect.x + xPad;
    const imageResult = imageLoader.loadOrGetImage(image, col, row);
    ctx.save();
    ctx.beginPath();
    ctx.arc(drawX + radius, rect.y + rect.height / 2, radius, 0, Math.PI * 2);
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = tint;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.font = `600 16px ${theme.fontFamily}`;
    const metrics = (0,js/* measureTextCached */.P7)(initial[0], ctx);
    ctx.fillText(initial[0], drawX + radius - metrics.width / 2, rect.y + rect.height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, `600 16px ${theme.fontFamily}`));

    if (imageResult !== undefined) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(drawX + radius, rect.y + rect.height / 2, radius, 0, Math.PI * 2);
      ctx.clip();
      ctx.drawImage(imageResult, drawX, rect.y + rect.height / 2 - radius, radius * 2, radius * 2);
      ctx.restore();
    }

    if (name !== undefined) {
      ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;
      ctx.fillStyle = theme.textDark;
      ctx.fillText(name, drawX + radius * 2 + xPad, rect.y + rect.height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, theme));
    }

    ctx.restore();
    return true;
  },
  provideEditor: () => p => {
    var _value$data$name;

    const {
      isHighlighted,
      onChange,
      value
    } = p;
    return react.createElement(js/* TextCellEntry */.t5, {
      highlight: isHighlighted,
      autoFocus: true,
      value: (_value$data$name = value.data.name) !== null && _value$data$name !== void 0 ? _value$data$name : "",
      onChange: e => onChange({ ...value,
        data: { ...value.data,
          name: e.target.value
        }
      })
    });
  },
  onPaste: (v, d) => ({ ...d,
    name: v
  })
};
/* harmony default export */ const user_profile_cell = (user_profile_cell_renderer);
// EXTERNAL MODULE: ./node_modules/react-select/dist/react-select.esm.js + 12 modules
var react_select_esm = __webpack_require__("./node_modules/react-select/dist/react-select.esm.js");
// EXTERNAL MODULE: ./node_modules/react-select/dist/index-a7690a33.esm.js + 2 modules
var index_a7690a33_esm = __webpack_require__("./node_modules/react-select/dist/index-a7690a33.esm.js");
;// CONCATENATED MODULE: ./packages/cells/src/cells/dropdown-cell.tsx
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }






const CustomMenu = p => {
  const {
    Menu
  } = index_a7690a33_esm.c;
  const {
    children,
    ...rest
  } = p;
  return react.createElement(Menu, rest, children);
};

const Wrap = (0,styled/* default */.Z)('div')({
  name: "Wrap",
  class: "wg6ppx4"
});
const PortalWrap = (0,styled/* default */.Z)('div')({
  name: "PortalWrap",
  class: "p7jnwoo"
});

const Editor = p => {
  const {
    value: cell,
    onFinishedEditing,
    initialValue
  } = p;
  const {
    allowedValues,
    value: valueIn
  } = cell.data;
  const [value, setValue] = react.useState(valueIn);
  const [inputValue, setInputValue] = react.useState(initialValue !== null && initialValue !== void 0 ? initialValue : "");
  const theme = (0,js/* useTheme */.Fg)();
  const values = react.useMemo(() => allowedValues.map(x => ({
    value: x,
    label: x
  })), [allowedValues]);
  return react.createElement(Wrap, null, react.createElement(react_select_esm/* default */.ZP, {
    className: "glide-select",
    inputValue: inputValue,
    onInputChange: setInputValue,
    menuPlacement: "auto",
    value: values.find(x => x.value === value),
    styles: {
      control: base => ({ ...base,
        border: 0,
        boxShadow: "none"
      })
    },
    theme: t => {
      return { ...t,
        colors: { ...t.colors,
          neutral0: theme.bgCell,
          neutral5: theme.bgCell,
          neutral10: theme.bgCell,
          neutral20: theme.bgCellMedium,
          neutral30: theme.bgCellMedium,
          neutral40: theme.bgCellMedium,
          neutral50: theme.textLight,
          neutral60: theme.textMedium,
          neutral70: theme.textMedium,
          neutral80: theme.textDark,
          neutral90: theme.textDark,
          neutral100: theme.textDark,
          primary: theme.accentColor,
          primary75: theme.accentColor,
          primary50: theme.accentColor,
          primary25: theme.accentLight
        }
      };
    },
    menuPortalTarget: document.getElementById("portal"),
    autoFocus: true,
    openMenuOnFocus: true,
    components: {
      DropdownIndicator: () => null,
      IndicatorSeparator: () => null,
      Menu: props => react.createElement(PortalWrap, null, react.createElement(CustomMenu, _extends({
        className: "click-outside-ignore"
      }, props)))
    },
    options: values,
    onChange: async e => {
      if (e === null) return;
      setValue(e.value);
      await new Promise(r => window.requestAnimationFrame(r));
      onFinishedEditing({ ...cell,
        data: { ...cell.data,
          value: e.value
        }
      });
    }
  }));
};

const dropdown_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "dropdown-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      value
    } = cell.data;
    ctx.fillStyle = theme.textDark;
    ctx.fillText(value, rect.x + theme.cellHorizontalPadding, rect.y + rect.height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, theme));
    return true;
  },
  provideEditor: () => ({
    editor: Editor,
    disablePadding: true,
    deletedValue: v => ({ ...v,
      copyData: "",
      data: { ...v.data,
        value: ""
      }
    })
  }),
  onPaste: (v, d) => ({ ...d,
    value: d.allowedValues.includes(v) ? v : d.value
  })
};
/* harmony default export */ const dropdown_cell = (dropdown_cell_renderer);

__webpack_require__("./packages/cells/src/cells/dropdown-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/dropdown-cell.tsx");
;// CONCATENATED MODULE: ./packages/cells/src/cells/article-cell.tsx


const ArticleCellEditor = react.lazy(async () => await Promise.all(/* import() */[__webpack_require__.e(296), __webpack_require__.e(858)]).then(__webpack_require__.bind(__webpack_require__, "./packages/cells/src/cells/article-cell-editor.tsx")));
const article_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "article-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      markdown
    } = cell.data;
    let data = markdown;

    if (data.includes("\n")) {
      data = data.split(/\r?\n/)[0];
    }

    const max = rect.width / 4;

    if (data.length > max) {
      data = data.slice(0, max);
    }

    ctx.fillStyle = theme.textDark;
    ctx.fillText(data, rect.x + theme.cellHorizontalPadding, rect.y + rect.height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, theme));
    return true;
  },
  provideEditor: () => ({
    editor: p => {
      return react.createElement(react.Suspense, {
        fallback: null
      }, react.createElement(ArticleCellEditor, p));
    },
    styleOverride: {
      position: "fixed",
      left: "12.5vw",
      top: "12.5vh",
      width: "75vw",
      borderRadius: "9px",
      maxWidth: "unset",
      maxHeight: "unset"
    },
    disablePadding: true
  }),
  onPaste: (val, d) => ({ ...d,
    markdown: val
  })
};
/* harmony default export */ const article_cell = (article_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/cells/range-cell.tsx



const RANGE_HEIGHT = 6;
const inputStyle = {
  marginRight: 8
};
const wrapperStyle = {
  display: "flex",
  alignItems: "center",
  flexGrow: 1
};
const range_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "range-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      min,
      max,
      value,
      label,
      measureLabel
    } = cell.data;
    const x = rect.x + theme.cellHorizontalPadding;
    const yMid = rect.y + rect.height / 2;
    const rangeSize = max - min;
    const fillRatio = (value - min) / rangeSize;
    ctx.save();
    let labelWidth = 0;

    if (label !== undefined) {
      ctx.font = `12px ${theme.fontFamily}`;
      labelWidth = (0,js/* measureTextCached */.P7)(measureLabel !== null && measureLabel !== void 0 ? measureLabel : label, ctx, `12px ${theme.fontFamily}`).width + theme.cellHorizontalPadding;
    }

    const rangeWidth = rect.width - theme.cellHorizontalPadding * 2 - labelWidth;

    if (rangeWidth >= RANGE_HEIGHT) {
      const gradient = ctx.createLinearGradient(x, yMid, x + rangeWidth, yMid);
      gradient.addColorStop(0, theme.accentColor);
      gradient.addColorStop(fillRatio, theme.accentColor);
      gradient.addColorStop(fillRatio, theme.bgBubble);
      gradient.addColorStop(1, theme.bgBubble);
      ctx.beginPath();
      ctx.fillStyle = gradient;
      roundedRect(ctx, x, yMid - RANGE_HEIGHT / 2, rangeWidth, RANGE_HEIGHT, RANGE_HEIGHT / 2);
      ctx.fill();
      ctx.beginPath();
      roundedRect(ctx, x + 0.5, yMid - RANGE_HEIGHT / 2 + 0.5, rangeWidth - 1, RANGE_HEIGHT - 1, (RANGE_HEIGHT - 1) / 2);
      ctx.strokeStyle = theme.accentLight;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    if (label !== undefined) {
      ctx.textAlign = "right";
      ctx.fillStyle = theme.textDark;
      ctx.fillText(label, rect.x + rect.width - theme.cellHorizontalPadding, yMid + (0,js/* getMiddleCenterBias */.aX)(ctx, `12px ${theme.fontFamily}`));
    }

    ctx.restore();
    return true;
  },
  provideEditor: () => {
    return p => {
      const {
        data
      } = p.value;
      const strValue = data.value.toString();
      const strMin = data.min.toString();
      const strMax = data.max.toString();
      const strStep = data.step.toString();

      const onChange = e => {
        p.onChange({ ...p.value,
          data: { ...data,
            value: Number(e.target.value)
          }
        });
      };

      return react.createElement("label", {
        style: wrapperStyle
      }, react.createElement("input", {
        style: inputStyle,
        type: "range",
        value: strValue,
        min: strMin,
        max: strMax,
        step: strStep,
        onChange: onChange
      }), strValue);
    };
  },
  onPaste: (v, d) => {
    let num = Number.parseFloat(v);
    num = Number.isNaN(num) ? d.value : Math.max(d.min, Math.min(d.max, num));
    return { ...d,
      value: num
    };
  }
};
/* harmony default export */ const range_cell = (range_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/cells/spinner-cell.tsx

const spinner_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "spinner-cell",
  draw: args => {
    const {
      ctx,
      theme,
      rect,
      requestAnimationFrame
    } = args;
    const progress = window.performance.now() % 1000 / 1000;
    const x = rect.x + rect.width / 2;
    const y = rect.y + rect.height / 2;
    ctx.arc(x, y, Math.min(12, rect.height / 6), Math.PI * 2 * progress, Math.PI * 2 * progress + Math.PI * 1.5);
    ctx.strokeStyle = theme.textMedium;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.lineWidth = 1;
    requestAnimationFrame();
    return true;
  },
  provideEditor: () => undefined
};
/* harmony default export */ const spinner_cell = (spinner_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/cells/date-picker-cell.tsx


const date_picker_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "date-picker-cell",
  draw: (args, cell) => {
    const {
      displayDate
    } = cell.data;
    (0,js/* drawTextCell */.uN)(args, displayDate, cell.contentAlign);
    return true;
  },
  provideEditor: () => p => {
    const cellData = p.value.data;
    const {
      format,
      date
    } = cellData;
    let val = "";

    if (date !== undefined) {
      val = date.toISOString();

      if (format === "date") {
        val = val.split("T")[0];
      }
    }

    return react.createElement("input", {
      style: {
        minHeight: 26,
        border: "none",
        outline: "none"
      },
      type: format,
      autoFocus: true,
      value: val,
      onChange: e => {
        var _e$target$valueAsDate;

        p.onChange({ ...p.value,
          data: { ...p.value.data,
            date: (_e$target$valueAsDate = e.target.valueAsDate) !== null && _e$target$valueAsDate !== void 0 ? _e$target$valueAsDate : undefined
          }
        });
      }
    });
  },
  onPaste: (v, d) => {
    let newDate;

    try {
      newDate = new Date(v);
    } catch {}

    return { ...d,
      date: Number.isNaN(newDate) ? undefined : newDate
    };
  }
};
/* harmony default export */ const date_picker_cell = (date_picker_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/cells/links-cell.tsx




function onClickSelect(e) {
  const useCtrl = e.cell.data.navigateOn !== "click";
  if (useCtrl !== e.ctrlKey) return undefined;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d", {
    alpha: false
  });
  if (ctx === null) return;
  const {
    posX: hoverX,
    bounds: rect,
    cell,
    theme
  } = e;
  const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
  ctx.font = font;
  const {
    links
  } = cell.data;
  const xPad = theme.cellHorizontalPadding;
  let drawX = rect.x + xPad;
  const rectHoverX = rect.x + hoverX;

  for (const [index, l] of links.entries()) {
    const needsComma = index < links.length - 1;
    const metrics = (0,js/* measureTextCached */.P7)(l.title, ctx);
    const commaMetrics = needsComma ? (0,js/* measureTextCached */.P7)(l.title + ",", ctx, font) : metrics;
    const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;

    if (isHovered) {
      return l;
    }

    drawX += commaMetrics.width + 4;
  }

  return undefined;
}

const links_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  needsHover: true,
  needsHoverPosition: true,
  isMatch: c => c.data.kind === "links-cell",
  onSelect: e => {
    if (onClickSelect(e) !== undefined) {
      e.preventDefault();
    }
  },
  onClick: e => {
    const hovered = onClickSelect(e);

    if (hovered !== undefined) {
      var _hovered$onClick;

      (_hovered$onClick = hovered.onClick) === null || _hovered$onClick === void 0 ? void 0 : _hovered$onClick.call(hovered);
      e.preventDefault();
    }

    return undefined;
  },
  draw: (args, cell) => {
    const {
      ctx,
      rect,
      theme,
      hoverX = -100,
      highlighted
    } = args;
    const {
      links,
      underlineOffset = 5
    } = cell.data;
    const xPad = theme.cellHorizontalPadding;
    let drawX = rect.x + xPad;
    const rectHoverX = rect.x + hoverX;
    const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
    const middleCenterBias = (0,js/* getMiddleCenterBias */.aX)(ctx, font);
    const drawY = rect.y + rect.height / 2 + middleCenterBias;

    for (const [index, l] of links.entries()) {
      const needsComma = index < links.length - 1;
      const metrics = (0,js/* measureTextCached */.P7)(l.title, ctx, font);
      const commaMetrics = needsComma ? (0,js/* measureTextCached */.P7)(l.title + ",", ctx, font) : metrics;
      const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;

      if (isHovered) {
        ctx.moveTo(drawX, Math.floor(drawY + underlineOffset) + 0.5);
        ctx.lineTo(drawX + metrics.width, Math.floor(drawY + underlineOffset) + 0.5);
        ctx.strokeStyle = theme.textDark;
        ctx.stroke();
        ctx.fillStyle = highlighted ? (0,js/* blend */.NH)(theme.accentLight, theme.bgCell) : theme.bgCell;
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX - 1, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX + 1, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX - 2, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX + 2, drawY);
      }

      ctx.fillStyle = theme.textDark;
      ctx.fillText(needsComma ? l.title + "," : l.title, drawX, drawY);
      drawX += commaMetrics.width + 4;
    }

    return true;
  },
  provideEditor: () => p => {
    const {
      value,
      onChange
    } = p;
    const {
      links,
      maxLinks = Number.MAX_SAFE_INTEGER
    } = value.data;
    return react.createElement(LinksCellEditorStyle, {
      onKeyDown: ignoreTab
    }, links.map((l, i) => {
      var _l$href;

      return react.createElement(LinkTitleEditor, {
        key: i,
        link: (_l$href = l.href) !== null && _l$href !== void 0 ? _l$href : "",
        title: l.title,
        focus: i === 0,
        onDelete: links.length > 1 ? () => {
          const newLinks = [...links];
          newLinks.splice(i, 1);
          onChange({ ...value,
            data: { ...value.data,
              links: newLinks
            }
          });
        } : undefined,
        onChange: (link, title) => {
          const newLinks = [...links];
          newLinks[i] = {
            href: link,
            title
          };
          onChange({ ...value,
            data: { ...value.data,
              links: newLinks
            }
          });
        }
      });
    }), react.createElement("button", {
      disabled: links.length >= maxLinks,
      className: "add-link",
      onClick: () => {
        const newLinks = [...links, {
          title: ""
        }];
        onChange({ ...value,
          data: { ...value.data,
            links: newLinks
          }
        });
      }
    }, "Add link"));
  },
  onPaste: (v, d) => {
    const split = v.split(",");
    if (d.links.some((l, i) => split[i] !== l.title)) return undefined;
    return { ...d,
      links: split.map(l => ({
        title: l
      }))
    };
  }
};
const LinksCellEditorStyle = (0,styled/* default */.Z)('div')({
  name: "LinksCellEditorStyle",
  class: "lld219p"
});

function ignoreTab(e) {
  if (e.key === "Tab") {
    e.stopPropagation();
  }
}

const LinkTitleEditor = p => {
  const {
    link,
    onChange,
    title,
    onDelete,
    focus
  } = p;
  return react.createElement("div", {
    className: "gdg-link-title-editor"
  }, react.createElement("input", {
    className: "gdg-title-input",
    value: title,
    placeholder: "Title",
    autoFocus: focus,
    onChange: e => {
      onChange(link, e.target.value);
    }
  }), react.createElement("input", {
    className: "gdg-link-input",
    value: link,
    placeholder: "URL",
    onChange: e => {
      onChange(e.target.value, title);
    }
  }), onDelete !== undefined && react.createElement("button", {
    onClick: onDelete
  }, react.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    fill: "none",
    id: "icon-import",
    xmlns: "http://www.w3.org/2000/svg"
  }, react.createElement("path", {
    d: "M3 6L5 6L21 6",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), react.createElement("path", {
    d: "M17.9019 6C18.491 6 18.9525 6.50676 18.8975 7.09334L17.67 20.1867C17.5736 21.2144 16.711 22 15.6787 22H8.32127C7.28902 22 6.42635 21.2144 6.33 20.1867L5.1025 7.09334C5.04751 6.50676 5.50898 6 6.09813 6H17.9019Z",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), react.createElement("path", {
    d: "M14.4499 10.211L13.9949 17",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), react.createElement("path", {
    d: "M9.55499 10.211L10.0049 17",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), react.createElement("path", {
    d: "M7.5 2.25H16.5",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }))));
};

/* harmony default export */ const links_cell = (links_cell_renderer);

__webpack_require__("./packages/cells/src/cells/links-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/links-cell.tsx");
;// CONCATENATED MODULE: ./packages/cells/src/cells/button-cell.tsx



function unpackColor(color, theme, hoverAmount) {
  if (typeof color === "string") {
    if (theme[color] !== undefined) return theme[color];
    return color;
  }

  let [normal, hover] = color;
  if (theme[normal] !== undefined) normal = theme[normal];
  if (theme[hover] !== undefined) hover = theme[hover];
  return (0,js/* interpolateColors */.Nz)(normal, hover, hoverAmount);
}

const button_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "button-cell",
  needsHover: true,
  onSelect: a => a.preventDefault(),
  onClick: a => {
    var _a$cell$data$onClick, _a$cell$data;

    (_a$cell$data$onClick = (_a$cell$data = a.cell.data).onClick) === null || _a$cell$data$onClick === void 0 ? void 0 : _a$cell$data$onClick.call(_a$cell$data);
    return undefined;
  },
  drawPrep: args => {
    const {
      ctx
    } = args;
    ctx.textAlign = "center";
    return {
      deprep: a => {
        a.ctx.textAlign = "start";
      }
    };
  },
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect,
      hoverAmount
    } = args;
    const {
      title,
      backgroundColor,
      color,
      borderColor,
      borderRadius
    } = cell.data;
    const x = Math.floor(rect.x + theme.cellHorizontalPadding + 1);
    const y = Math.floor(rect.y + theme.cellVerticalPadding + 1);
    const width = Math.ceil(rect.width - theme.cellHorizontalPadding * 2 - 1);
    const height = Math.ceil(rect.height - theme.cellVerticalPadding * 2 - 1);

    if (backgroundColor !== undefined) {
      ctx.beginPath();
      roundedRect(ctx, x, y, width, height, borderRadius !== null && borderRadius !== void 0 ? borderRadius : 0);
      ctx.fillStyle = unpackColor(backgroundColor, theme, hoverAmount);
      ctx.fill();
    }

    if (borderColor !== undefined) {
      ctx.beginPath();
      roundedRect(ctx, x + 0.5, y + 0.5, width - 1, height - 1, borderRadius !== null && borderRadius !== void 0 ? borderRadius : 0);
      ctx.strokeStyle = unpackColor(borderColor, theme, hoverAmount);
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.fillStyle = unpackColor(color !== null && color !== void 0 ? color : theme.accentColor, theme, hoverAmount);
    ctx.fillText(title, x + width / 2, y + height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, `${theme.baseFontStyle} ${theme.fontFamily}`));
    return true;
  },
  provideEditor: undefined
};
/* harmony default export */ const button_cell = (button_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/index.ts












const cells = [star_cell, sparkline_cell, tags_cell, user_profile_cell, dropdown_cell, article_cell, spinner_cell, range_cell, date_picker_cell, links_cell, button_cell];
function useExtraCells() {
  return (0,js/* useCustomCells */.R$)(cells);
}

// EXTERNAL MODULE: ./node_modules/lodash/range.js
var range = __webpack_require__("./node_modules/lodash/range.js");
var range_default = /*#__PURE__*/__webpack_require__.n(range);
// EXTERNAL MODULE: ./node_modules/lodash/uniq.js
var uniq = __webpack_require__("./node_modules/lodash/uniq.js");
var uniq_default = /*#__PURE__*/__webpack_require__.n(uniq);
// EXTERNAL MODULE: ./node_modules/react-resize-detector/build/index.esm.js
var index_esm = __webpack_require__("./node_modules/react-resize-detector/build/index.esm.js");
// EXTERNAL MODULE: ./node_modules/@toast-ui/editor/dist/toastui-editor.css
var toastui_editor = __webpack_require__("./node_modules/@toast-ui/editor/dist/toastui-editor.css");
// EXTERNAL MODULE: ./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./packages/core/dist/index.css
var dist = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./packages/core/dist/index.css");
;// CONCATENATED MODULE: ./packages/core/dist/index.css

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = injectStylesIntoStyleTag_default()(dist/* default */.Z, options);



/* harmony default export */ const core_dist = (dist/* default.locals */.Z.locals || {});
;// CONCATENATED MODULE: ./packages/cells/src/cell.stories.tsx
function cell_stories_extends() { cell_stories_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return cell_stories_extends.apply(this, arguments); }

var __STORY__ = "import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { DataEditor, DataEditorProps, GridCellKind } from \"@glideapps/glide-data-grid\";\nimport { DropdownCell as DropdownRenderer, useExtraCells } from \".\";\nimport type { StarCell } from \"./cells/star-cell\";\nimport type { SparklineCell } from \"./cells/sparkline-cell\";\nimport range from \"lodash/range.js\";\nimport uniq from \"lodash/uniq.js\";\nimport type { TagsCell } from \"./cells/tags-cell\";\nimport type { UserProfileCell } from \"./cells/user-profile-cell\";\nimport type { DropdownCell } from \"./cells/dropdown-cell\";\nimport type { ArticleCell } from \"./cells/article-cell-types\";\nimport type { RangeCell } from \"./cells/range-cell\";\nimport type { SpinnerCell } from \"./cells/spinner-cell\";\nimport { useResizeDetector } from \"react-resize-detector\";\n\nimport \"@toast-ui/editor/dist/toastui-editor.css\";\nimport \"@glideapps/glide-data-grid/dist/index.css\";\nimport type { DatePickerCell } from \"./cells/date-picker-cell\";\nimport type { LinksCell } from \"./cells/links-cell\";\nimport type { ButtonCell } from \"./cells/button-cell\";\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {\n    title: \"Extra Packages/Cells\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16807) % 2147483647) / 2147483647;\n}\n\nconst possibleTags = [\n    {\n        tag: \"Bug\",\n        color: \"#ff4d4d35\",\n    },\n    {\n        tag: \"Feature\",\n        color: \"#35f8ff35\",\n    },\n    {\n        tag: \"Enhancement\",\n        color: \"#48ff5735\",\n    },\n    {\n        tag: \"First Issue\",\n        color: \"#436fff35\",\n    },\n    {\n        tag: \"PR\",\n        color: \"#e0ff3235\",\n    },\n    {\n        tag: \"Assigned\",\n        color: \"#ff1eec35\",\n    },\n];\n\nexport const CustomCells: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    return (\n        <BeautifulWrapper title=\"Custom cells\" description={<Description>Some of our extension cells.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                \n                onCellEdited={(...args) => console.log(\"Edit Cell\", ...args)}\n                getCellContent={cell => {\n                    const [col, row] = cell;\n                    if (col === 0) {\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"star-cell\",\n                                label: \"Test\",\n                                rating: 4,\n                            },\n                        } as StarCell;\n                    } else if (col === 1) {\n                        num = row + 1;\n                        const values = range(0, 15).map(() => rand() * 100 - 50);\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values,\n                                displayValues: values.map(x => Math.round(x).toString()),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 2) {\n                        num = row + 1;\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values: range(0, 15).map(() => rand() * 100 - 50),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                graphKind: \"bar\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 3) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"tags-cell\",\n                                possibleTags: possibleTags,\n                                readonly: row % 2 === 0,\n                                tags: uniq([\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                ]),\n                            },\n                        } as TagsCell;\n                    } else if (col === 4) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"user-profile-cell\",\n                                image: row % 2 ? undefined : \"https://i.redd.it/aqc1hwhalsz71.jpg\",\n                                initial: \"B\",\n                                tint: \"#F1D86E\",\n                                name: row % 5 ? undefined : \"Bee bb\",\n                            },\n                        } as UserProfileCell;\n                    } else if (col === 5) {\n                        num = row + 1;\n                        rand();\n                        const d: DropdownCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"dropdown-cell\",\n                                allowedValues: [\"Good\", \"Better\", \"Best\"],\n                                value: \"Good\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 6) {\n                        num = row + 1;\n                        rand();\n                        const v = rand();\n                        const d: RangeCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"range-cell\",\n                                min: 10,\n                                max: 30,\n                                value: 10 + Math.round(v * 20),\n                                step: 1,\n                                label: `${Math.round(v * 100)}%`,\n                                measureLabel: \"100%\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 7) {\n                        num = row + 1;\n                        rand();\n                        const d: ArticleCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"article-cell\",\n                                markdown: \"## This is a test\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 8) {\n                        num = row + 1;\n                        rand();\n                        const d: SpinnerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"spinner-cell\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 9) {\n                        num = row + 1;\n                        rand();\n                        const d: DatePickerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"date-picker-cell\",\n                                date: new Date(),\n                                displayDate: new Date().toISOString(),\n                                format: \"date\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 10) {\n                        num = row + 1;\n                        rand();\n                        const d: LinksCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"links-cell\",\n                                underlineOffset: 6,\n                                links: [\n                                    {\n                                        title: \"Linky phone\",\n                                        onClick: () => alert(\"Click 1\"),\n                                    },\n                                    {\n                                        title: \"Click the linky dinky\",\n                                        onClick: () => alert(\"Click 2\"),\n                                    },\n                                ],\n                            },\n                        };\n                        return d;\n                    } else if (col === 11) {\n                        num = row + 1;\n                        rand();\n                        const d: ButtonCell = {\n                            kind: GridCellKind.Custom,\n                            cursor: \"pointer\",\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            readonly: true,\n                            data: {\n                                kind: \"button-cell\",\n                                backgroundColor: [\"transparent\", \"#6572ffee\"],\n                                color: [\"accentColor\", \"accentFg\"],\n                                borderColor: \"#6572ffa0\",\n                                borderRadius: 9,\n                                title: \"View Details\",\n                                onClick: () => window.alert(\"Button clicked\"),\n                            },\n                            themeOverride: {\n                                baseFontStyle: \"700 12px\",\n                            },\n                        };\n                        return d;\n                    }\n                    throw new Error(\"Fail\");\n                }}\n                columns={[\n                    {\n                        title: \"Stars\",\n                        width: 200,\n                    },\n                    {\n                        title: \"Sparkline\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Sparkline (bars)\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Tags\",\n                        width: 250,\n                    },\n                    {\n                        title: \"Profile\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Dropdown\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Range\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Article\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Spinner\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Date Picker\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Links\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Button\",\n                        width: 120,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CustomCellEditing: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    const data = React.useRef<string[]>([]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Custom cell editing\"\n            description={\n                <Description>\n                    Cells can be edited and responding to copy/paste using the copyData attribute.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                onCellEdited={(cell, newVal) => {\n                    if (newVal.kind !== GridCellKind.Custom) return;\n                    if (DropdownRenderer.isMatch(newVal)) {\n                        data.current[cell[1]] = newVal.data.value;\n                    }\n                }}\n                getCellsForSelection={true}\n                getCellContent={cell => {\n                    const [, row] = cell;\n                    const val = data.current[row] ?? \"A\";\n                    return {\n                        kind: GridCellKind.Custom,\n                        allowOverlay: true,\n                        copyData: val,\n                        data: {\n                            kind: \"dropdown-cell\",\n                            allowedValues: [\"A\", \"B\", \"C\"],\n                            value: val,\n                        },\n                    } as DropdownCell;\n                }}\n                columns={[\n                    {\n                        title: \"Dropdown\",\n                        width: 200,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCellEditing as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "CustomCells": {
    "startLoc": {
      "col": 38,
      "line": 170
    },
    "endLoc": {
      "col": 1,
      "line": 433
    },
    "startBody": {
      "col": 38,
      "line": 170
    },
    "endBody": {
      "col": 1,
      "line": 433
    }
  },
  "CustomCellEditing": {
    "startLoc": {
      "col": 44,
      "line": 440
    },
    "endLoc": {
      "col": 1,
      "line": 488
    },
    "startBody": {
      "col": 44,
      "line": 440
    },
    "endBody": {
      "col": 1,
      "line": 488
    }
  }
};









const SimpleWrapper = (0,styled/* default */.Z)('div')({
  name: "SimpleWrapper",
  class: "s1wvhs74"
});

const SimpleThemeWrapper = p => {
  return react.createElement(SimpleWrapper, null, react.createElement("div", {
    className: "content"
  }, p.children));
};

/* harmony default export */ const cell_stories = ({
  parameters: {
    "storySource": {
      "source": "import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { DataEditor, DataEditorProps, GridCellKind } from \"@glideapps/glide-data-grid\";\nimport { DropdownCell as DropdownRenderer, useExtraCells } from \".\";\nimport type { StarCell } from \"./cells/star-cell\";\nimport type { SparklineCell } from \"./cells/sparkline-cell\";\nimport range from \"lodash/range.js\";\nimport uniq from \"lodash/uniq.js\";\nimport type { TagsCell } from \"./cells/tags-cell\";\nimport type { UserProfileCell } from \"./cells/user-profile-cell\";\nimport type { DropdownCell } from \"./cells/dropdown-cell\";\nimport type { ArticleCell } from \"./cells/article-cell-types\";\nimport type { RangeCell } from \"./cells/range-cell\";\nimport type { SpinnerCell } from \"./cells/spinner-cell\";\nimport { useResizeDetector } from \"react-resize-detector\";\n\nimport \"@toast-ui/editor/dist/toastui-editor.css\";\nimport \"@glideapps/glide-data-grid/dist/index.css\";\nimport type { DatePickerCell } from \"./cells/date-picker-cell\";\nimport type { LinksCell } from \"./cells/links-cell\";\nimport type { ButtonCell } from \"./cells/button-cell\";\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {\n    title: \"Extra Packages/Cells\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16807) % 2147483647) / 2147483647;\n}\n\nconst possibleTags = [\n    {\n        tag: \"Bug\",\n        color: \"#ff4d4d35\",\n    },\n    {\n        tag: \"Feature\",\n        color: \"#35f8ff35\",\n    },\n    {\n        tag: \"Enhancement\",\n        color: \"#48ff5735\",\n    },\n    {\n        tag: \"First Issue\",\n        color: \"#436fff35\",\n    },\n    {\n        tag: \"PR\",\n        color: \"#e0ff3235\",\n    },\n    {\n        tag: \"Assigned\",\n        color: \"#ff1eec35\",\n    },\n];\n\nexport const CustomCells: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    return (\n        <BeautifulWrapper title=\"Custom cells\" description={<Description>Some of our extension cells.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                \n                onCellEdited={(...args) => console.log(\"Edit Cell\", ...args)}\n                getCellContent={cell => {\n                    const [col, row] = cell;\n                    if (col === 0) {\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"star-cell\",\n                                label: \"Test\",\n                                rating: 4,\n                            },\n                        } as StarCell;\n                    } else if (col === 1) {\n                        num = row + 1;\n                        const values = range(0, 15).map(() => rand() * 100 - 50);\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values,\n                                displayValues: values.map(x => Math.round(x).toString()),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 2) {\n                        num = row + 1;\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values: range(0, 15).map(() => rand() * 100 - 50),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                graphKind: \"bar\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 3) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"tags-cell\",\n                                possibleTags: possibleTags,\n                                readonly: row % 2 === 0,\n                                tags: uniq([\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                ]),\n                            },\n                        } as TagsCell;\n                    } else if (col === 4) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"user-profile-cell\",\n                                image: row % 2 ? undefined : \"https://i.redd.it/aqc1hwhalsz71.jpg\",\n                                initial: \"B\",\n                                tint: \"#F1D86E\",\n                                name: row % 5 ? undefined : \"Bee bb\",\n                            },\n                        } as UserProfileCell;\n                    } else if (col === 5) {\n                        num = row + 1;\n                        rand();\n                        const d: DropdownCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"dropdown-cell\",\n                                allowedValues: [\"Good\", \"Better\", \"Best\"],\n                                value: \"Good\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 6) {\n                        num = row + 1;\n                        rand();\n                        const v = rand();\n                        const d: RangeCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"range-cell\",\n                                min: 10,\n                                max: 30,\n                                value: 10 + Math.round(v * 20),\n                                step: 1,\n                                label: `${Math.round(v * 100)}%`,\n                                measureLabel: \"100%\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 7) {\n                        num = row + 1;\n                        rand();\n                        const d: ArticleCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"article-cell\",\n                                markdown: \"## This is a test\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 8) {\n                        num = row + 1;\n                        rand();\n                        const d: SpinnerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"spinner-cell\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 9) {\n                        num = row + 1;\n                        rand();\n                        const d: DatePickerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"date-picker-cell\",\n                                date: new Date(),\n                                displayDate: new Date().toISOString(),\n                                format: \"date\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 10) {\n                        num = row + 1;\n                        rand();\n                        const d: LinksCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"links-cell\",\n                                underlineOffset: 6,\n                                links: [\n                                    {\n                                        title: \"Linky phone\",\n                                        onClick: () => alert(\"Click 1\"),\n                                    },\n                                    {\n                                        title: \"Click the linky dinky\",\n                                        onClick: () => alert(\"Click 2\"),\n                                    },\n                                ],\n                            },\n                        };\n                        return d;\n                    } else if (col === 11) {\n                        num = row + 1;\n                        rand();\n                        const d: ButtonCell = {\n                            kind: GridCellKind.Custom,\n                            cursor: \"pointer\",\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            readonly: true,\n                            data: {\n                                kind: \"button-cell\",\n                                backgroundColor: [\"transparent\", \"#6572ffee\"],\n                                color: [\"accentColor\", \"accentFg\"],\n                                borderColor: \"#6572ffa0\",\n                                borderRadius: 9,\n                                title: \"View Details\",\n                                onClick: () => window.alert(\"Button clicked\"),\n                            },\n                            themeOverride: {\n                                baseFontStyle: \"700 12px\",\n                            },\n                        };\n                        return d;\n                    }\n                    throw new Error(\"Fail\");\n                }}\n                columns={[\n                    {\n                        title: \"Stars\",\n                        width: 200,\n                    },\n                    {\n                        title: \"Sparkline\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Sparkline (bars)\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Tags\",\n                        width: 250,\n                    },\n                    {\n                        title: \"Profile\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Dropdown\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Range\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Article\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Spinner\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Date Picker\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Links\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Button\",\n                        width: 120,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CustomCellEditing: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    const data = React.useRef<string[]>([]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Custom cell editing\"\n            description={\n                <Description>\n                    Cells can be edited and responding to copy/paste using the copyData attribute.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                onCellEdited={(cell, newVal) => {\n                    if (newVal.kind !== GridCellKind.Custom) return;\n                    if (DropdownRenderer.isMatch(newVal)) {\n                        data.current[cell[1]] = newVal.data.value;\n                    }\n                }}\n                getCellsForSelection={true}\n                getCellContent={cell => {\n                    const [, row] = cell;\n                    const val = data.current[row] ?? \"A\";\n                    return {\n                        kind: GridCellKind.Custom,\n                        allowOverlay: true,\n                        copyData: val,\n                        data: {\n                            kind: \"dropdown-cell\",\n                            allowedValues: [\"A\", \"B\", \"C\"],\n                            value: val,\n                        },\n                    } as DropdownCell;\n                }}\n                columns={[\n                    {\n                        title: \"Dropdown\",\n                        width: 200,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCellEditing as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n",
      "locationsMap": {
        "custom-cells": {
          "startLoc": {
            "col": 38,
            "line": 170
          },
          "endLoc": {
            "col": 1,
            "line": 433
          },
          "startBody": {
            "col": 38,
            "line": 170
          },
          "endBody": {
            "col": 1,
            "line": 433
          }
        },
        "custom-cell-editing": {
          "startLoc": {
            "col": 44,
            "line": 440
          },
          "endLoc": {
            "col": 1,
            "line": 488
          },
          "startBody": {
            "col": 44,
            "line": 440
          },
          "endBody": {
            "col": 1,
            "line": 488
          }
        }
      }
    }
  },
  title: "Extra Packages/Cells",
  decorators: [Story => react.createElement(SimpleThemeWrapper, null, react.createElement(Story, null))]
});
const BeautifulStyle = (0,styled/* default */.Z)('div')({
  name: "BeautifulStyle",
  class: "b16aqpip"
});

const BeautifulWrapper = p => {
  const {
    title,
    children,
    description
  } = p;
  const {
    ref,
    width,
    height
  } = (0,index_esm/* useResizeDetector */.NB)();
  return react.createElement(BeautifulStyle, null, react.createElement("h1", null, title), description, react.createElement("div", {
    className: "sizer"
  }, react.createElement("div", {
    className: "sizer-clip",
    ref: ref
  }, react.createElement("div", {
    style: {
      position: "relative",
      width: width !== null && width !== void 0 ? width : 100,
      height: height !== null && height !== void 0 ? height : 100
    }
  }, children))));
};

const Description = (0,styled/* default */.Z)('p')({
  name: "Description",
  class: "d1npx1y"
});
const defaultProps = {
  smoothScrollX: true,
  smoothScrollY: true,
  isDraggable: false,
  rowMarkers: "none",
  width: "100%"
};
let num = 1;

function rand() {
  return (num = num * 16807 % 2147483647) / 2147483647;
}

const possibleTags = [{
  tag: "Bug",
  color: "#ff4d4d35"
}, {
  tag: "Feature",
  color: "#35f8ff35"
}, {
  tag: "Enhancement",
  color: "#48ff5735"
}, {
  tag: "First Issue",
  color: "#436fff35"
}, {
  tag: "PR",
  color: "#e0ff3235"
}, {
  tag: "Assigned",
  color: "#ff1eec35"
}];
const CustomCells = () => {
  const cellProps = useExtraCells();
  return react.createElement(BeautifulWrapper, {
    title: "Custom cells",
    description: react.createElement(Description, null, "Some of our extension cells.")
  }, react.createElement(js/* DataEditor */.Nd, cell_stories_extends({}, defaultProps, cellProps, {
    onPaste: true,
    onCellEdited: function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return console.log("Edit Cell", ...args);
    },
    getCellContent: cell => {
      const [col, row] = cell;

      if (col === 0) {
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "star-cell",
            label: "Test",
            rating: 4
          }
        };
      } else if (col === 1) {
        num = row + 1;
        const values = range_default()(0, 15).map(() => rand() * 100 - 50);
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: false,
          copyData: "4",
          data: {
            kind: "sparkline-cell",
            values,
            displayValues: values.map(x => Math.round(x).toString()),
            color: row % 2 === 0 ? "#77c4c4" : "#D98466",
            yAxis: [-50, 50]
          }
        };
      } else if (col === 2) {
        num = row + 1;
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: false,
          copyData: "4",
          data: {
            kind: "sparkline-cell",
            values: range_default()(0, 15).map(() => rand() * 100 - 50),
            color: row % 2 === 0 ? "#77c4c4" : "#D98466",
            graphKind: "bar",
            yAxis: [-50, 50]
          }
        };
      } else if (col === 3) {
        num = row + 1;
        rand();
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "tags-cell",
            possibleTags: possibleTags,
            readonly: row % 2 === 0,
            tags: uniq_default()([possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag, possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag, possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag, possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag])
          }
        };
      } else if (col === 4) {
        num = row + 1;
        rand();
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "user-profile-cell",
            image: row % 2 ? undefined : "https://i.redd.it/aqc1hwhalsz71.jpg",
            initial: "B",
            tint: "#F1D86E",
            name: row % 5 ? undefined : "Bee bb"
          }
        };
      } else if (col === 5) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "dropdown-cell",
            allowedValues: ["Good", "Better", "Best"],
            value: "Good"
          }
        };
        return d;
      } else if (col === 6) {
        num = row + 1;
        rand();
        const v = rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "range-cell",
            min: 10,
            max: 30,
            value: 10 + Math.round(v * 20),
            step: 1,
            label: `${Math.round(v * 100)}%`,
            measureLabel: "100%"
          }
        };
        return d;
      } else if (col === 7) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "article-cell",
            markdown: "## This is a test"
          }
        };
        return d;
      } else if (col === 8) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "spinner-cell"
          }
        };
        return d;
      } else if (col === 9) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "date-picker-cell",
            date: new Date(),
            displayDate: new Date().toISOString(),
            format: "date"
          }
        };
        return d;
      } else if (col === 10) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "links-cell",
            underlineOffset: 6,
            links: [{
              title: "Linky phone",
              onClick: () => alert("Click 1")
            }, {
              title: "Click the linky dinky",
              onClick: () => alert("Click 2")
            }]
          }
        };
        return d;
      } else if (col === 11) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          cursor: "pointer",
          allowOverlay: true,
          copyData: "4",
          readonly: true,
          data: {
            kind: "button-cell",
            backgroundColor: ["transparent", "#6572ffee"],
            color: ["accentColor", "accentFg"],
            borderColor: "#6572ffa0",
            borderRadius: 9,
            title: "View Details",
            onClick: () => window.alert("Button clicked")
          },
          themeOverride: {
            baseFontStyle: "700 12px"
          }
        };
        return d;
      }

      throw new Error("Fail");
    },
    columns: [{
      title: "Stars",
      width: 200
    }, {
      title: "Sparkline",
      width: 150
    }, {
      title: "Sparkline (bars)",
      width: 150
    }, {
      title: "Tags",
      width: 250
    }, {
      title: "Profile",
      width: 150
    }, {
      title: "Dropdown",
      width: 150
    }, {
      title: "Range",
      width: 150
    }, {
      title: "Article",
      width: 150
    }, {
      title: "Spinner",
      width: 150
    }, {
      title: "Date Picker",
      width: 150
    }, {
      title: "Links",
      width: 150
    }, {
      title: "Button",
      width: 120
    }],
    rows: 500
  })));
};
;
CustomCells.parameters = {
  options: {
    showPanel: false
  }
};
const CustomCellEditing = () => {
  const cellProps = useExtraCells();
  const data = react.useRef([]);
  return react.createElement(BeautifulWrapper, {
    title: "Custom cell editing",
    description: react.createElement(Description, null, "Cells can be edited and responding to copy/paste using the copyData attribute.")
  }, react.createElement(js/* DataEditor */.Nd, cell_stories_extends({}, defaultProps, cellProps, {
    onPaste: true,
    onCellEdited: (cell, newVal) => {
      if (newVal.kind !== js/* GridCellKind.Custom */.p6.Custom) return;

      if (dropdown_cell.isMatch(newVal)) {
        data.current[cell[1]] = newVal.data.value;
      }
    },
    getCellsForSelection: true,
    getCellContent: cell => {
      var _data$current$row;

      const [, row] = cell;
      const val = (_data$current$row = data.current[row]) !== null && _data$current$row !== void 0 ? _data$current$row : "A";
      return {
        kind: js/* GridCellKind.Custom */.p6.Custom,
        allowOverlay: true,
        copyData: val,
        data: {
          kind: "dropdown-cell",
          allowedValues: ["A", "B", "C"],
          value: val
        }
      };
    },
    columns: [{
      title: "Dropdown",
      width: 200
    }],
    rows: 500
  })));
};
CustomCellEditing.parameters = {
  options: {
    showPanel: false
  }
};

__webpack_require__("./packages/cells/src/cell.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cell.stories.tsx");

const __namedExportsOrder = ["CustomCells", "CustomCellEditing"];

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor-async.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServerSideData": () => (/* binding */ ServerSideData),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _data_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash/range.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_range_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_chunk_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/lodash/chunk.js");
/* harmony import */ var lodash_chunk_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_chunk_js__WEBPACK_IMPORTED_MODULE_2__);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport {\n    CompactSelection,\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    Rectangle,\n    Item,\n    CellArray,\n} from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\nimport { DataEditor, DataEditorProps, DataEditorRef } from \"../data-editor\";\nimport { BeautifulWrapper, Description } from \"./utils\";\nimport range from \"lodash/range.js\";\nimport chunk from \"lodash/chunk.js\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ntype RowCallback<T> = (range: Item) => Promise<readonly T[]>;\ntype RowToCell<T> = (row: T, col: number) => GridCell;\ntype RowEditedCallback<T> = (cell: Item, newVal: EditableGridCell, rowData: T) => T | undefined;\nfunction useAsyncData<TRowType>(\n    pageSize: number,\n    maxConcurrency: number,\n    getRowData: RowCallback<TRowType>,\n    toCell: RowToCell<TRowType>,\n    onEdited: RowEditedCallback<TRowType>,\n    gridRef: React.MutableRefObject<DataEditorRef | null>\n): Pick<DataEditorProps, \"getCellContent\" | \"onVisibleRegionChanged\" | \"onCellEdited\" | \"getCellsForSelection\"> {\n    pageSize = Math.max(pageSize, 1);\n    const loadingRef = React.useRef(CompactSelection.empty());\n    const dataRef = React.useRef<TRowType[]>([]);\n\n    const [visiblePages, setVisiblePages] = React.useState<Rectangle>({ x: 0, y: 0, width: 0, height: 0 });\n    const visiblePagesRef = React.useRef(visiblePages);\n    visiblePagesRef.current = visiblePages;\n\n    const onVisibleRegionChanged: NonNullable<DataEditorProps[\"onVisibleRegionChanged\"]> = React.useCallback(r => {\n        setVisiblePages(cv => {\n            if (r.x === cv.x && r.y === cv.y && r.width === cv.width && r.height === cv.height) return cv;\n            return r;\n        });\n    }, []);\n\n    const getCellContent = React.useCallback<DataEditorProps[\"getCellContent\"]>(\n        cell => {\n            const [col, row] = cell;\n            const rowData: TRowType | undefined = dataRef.current[row];\n            if (rowData !== undefined) {\n                return toCell(rowData, col);\n            }\n            return {\n                kind: GridCellKind.Loading,\n                allowOverlay: false,\n            };\n        },\n        [toCell]\n    );\n\n    const loadPage = React.useCallback(\n        async (page: number) => {\n            loadingRef.current = loadingRef.current.add(page);\n            const startIndex = page * pageSize;\n            const d = await getRowData([startIndex, (page + 1) * pageSize]);\n\n            const vr = visiblePagesRef.current;\n\n            const damageList: { cell: [number, number] }[] = [];\n            const data = dataRef.current;\n            for (const [i, element] of d.entries()) {\n                data[i + startIndex] = element;\n                for (let col = vr.x; col <= vr.x + vr.width; col++) {\n                    damageList.push({\n                        cell: [col, i + startIndex],\n                    });\n                }\n            }\n            gridRef.current?.updateCells(damageList);\n        },\n        [getRowData, gridRef, pageSize]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (r: Rectangle): (() => Promise<CellArray>) => {\n            return async () => {\n                const firstPage = Math.max(0, Math.floor(r.y / pageSize));\n                const lastPage = Math.floor((r.y + r.height) / pageSize);\n\n                for (const pageChunk of chunk(\n                    range(firstPage, lastPage + 1).filter(i => !loadingRef.current.hasIndex(i)),\n                    maxConcurrency\n                )) {\n                    await Promise.allSettled(pageChunk.map(loadPage));\n                }\n\n                const result: GridCell[][] = [];\n\n                for (let y = r.y; y < r.y + r.height; y++) {\n                    const row: GridCell[] = [];\n                    for (let x = r.x; x < r.x + r.width; x++) {\n                        row.push(getCellContent([x, y]));\n                    }\n                    result.push(row);\n                }\n\n                return result;\n            };\n        },\n        [getCellContent, loadPage, maxConcurrency, pageSize]\n    );\n\n    React.useEffect(() => {\n        const r = visiblePages;\n        const firstPage = Math.max(0, Math.floor((r.y - pageSize / 2) / pageSize));\n        const lastPage = Math.floor((r.y + r.height + pageSize / 2) / pageSize);\n        for (const page of range(firstPage, lastPage + 1)) {\n            if (loadingRef.current.hasIndex(page)) continue;\n            void loadPage(page);\n        }\n    }, [loadPage, pageSize, visiblePages]);\n\n    const onCellEdited = React.useCallback(\n        (cell: Item, newVal: EditableGridCell) => {\n            const [, row] = cell;\n            const current = dataRef.current[row];\n            if (current === undefined) return;\n\n            const result = onEdited(cell, newVal, current);\n            if (result !== undefined) {\n                dataRef.current[row] = result;\n            }\n        },\n        [onEdited]\n    );\n\n    return {\n        getCellContent,\n        onVisibleRegionChanged,\n        onCellEdited,\n        getCellsForSelection,\n    };\n}\n\nexport const ServerSideData: React.VFC = () => {\n    const ref = React.useRef<DataEditorRef | null>(null);\n\n    const getRowData = React.useCallback(async (r: Item) => {\n        await new Promise(res => setTimeout(res, 300));\n        return range(r[0], r[1]).map(rowIndex => [`1, ${rowIndex}`, `2, ${rowIndex}`]);\n    }, []);\n\n    const columns = React.useMemo<readonly GridColumn[]>(() => {\n        return [\n            {\n                title: \"A\",\n                width: 150,\n            },\n            {\n                title: \"B\",\n                width: 200,\n            },\n        ];\n    }, []);\n\n    const args = useAsyncData<string[]>(\n        50,\n        5,\n        getRowData,\n        React.useCallback(\n            (rowData, col) => ({\n                kind: GridCellKind.Text,\n                data: rowData[col],\n                allowOverlay: true,\n                displayData: rowData[col],\n            }),\n            []\n        ),\n        React.useCallback((cell, newVal, rowData) => {\n            const [col] = cell;\n            if (newVal.kind !== GridCellKind.Text) return undefined;\n            const newRow: string[] = [...rowData];\n            newRow[col] = newVal.data;\n            return newRow;\n        }, []),\n        ref\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Server Side Data\"\n            description={\n                <Description>\n                    Glide data grid is fully ready to handle your server side data needs. This example condenses the\n                    implementation into a single custom hook and loads in pages of 50. We are using 300ms sleeps, but\n                    network transactions should work the same.\n                </Description>\n            }>\n            <DataEditor ref={ref} {...args} width=\"100%\" columns={columns} rows={3000} rowMarkers=\"both\" />\n        </BeautifulWrapper>\n    );\n};\n(ServerSideData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "ServerSideData": {
    "startLoc": {
      "col": 41,
      "line": 155
    },
    "endLoc": {
      "col": 1,
      "line": 212
    },
    "startBody": {
      "col": 41,
      "line": 155
    },
    "endBody": {
      "col": 1,
      "line": 212
    }
  }
};







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport {\n    CompactSelection,\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    Rectangle,\n    Item,\n    CellArray,\n} from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\nimport { DataEditor, DataEditorProps, DataEditorRef } from \"../data-editor\";\nimport { BeautifulWrapper, Description } from \"./utils\";\nimport range from \"lodash/range.js\";\nimport chunk from \"lodash/chunk.js\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ntype RowCallback<T> = (range: Item) => Promise<readonly T[]>;\ntype RowToCell<T> = (row: T, col: number) => GridCell;\ntype RowEditedCallback<T> = (cell: Item, newVal: EditableGridCell, rowData: T) => T | undefined;\nfunction useAsyncData<TRowType>(\n    pageSize: number,\n    maxConcurrency: number,\n    getRowData: RowCallback<TRowType>,\n    toCell: RowToCell<TRowType>,\n    onEdited: RowEditedCallback<TRowType>,\n    gridRef: React.MutableRefObject<DataEditorRef | null>\n): Pick<DataEditorProps, \"getCellContent\" | \"onVisibleRegionChanged\" | \"onCellEdited\" | \"getCellsForSelection\"> {\n    pageSize = Math.max(pageSize, 1);\n    const loadingRef = React.useRef(CompactSelection.empty());\n    const dataRef = React.useRef<TRowType[]>([]);\n\n    const [visiblePages, setVisiblePages] = React.useState<Rectangle>({ x: 0, y: 0, width: 0, height: 0 });\n    const visiblePagesRef = React.useRef(visiblePages);\n    visiblePagesRef.current = visiblePages;\n\n    const onVisibleRegionChanged: NonNullable<DataEditorProps[\"onVisibleRegionChanged\"]> = React.useCallback(r => {\n        setVisiblePages(cv => {\n            if (r.x === cv.x && r.y === cv.y && r.width === cv.width && r.height === cv.height) return cv;\n            return r;\n        });\n    }, []);\n\n    const getCellContent = React.useCallback<DataEditorProps[\"getCellContent\"]>(\n        cell => {\n            const [col, row] = cell;\n            const rowData: TRowType | undefined = dataRef.current[row];\n            if (rowData !== undefined) {\n                return toCell(rowData, col);\n            }\n            return {\n                kind: GridCellKind.Loading,\n                allowOverlay: false,\n            };\n        },\n        [toCell]\n    );\n\n    const loadPage = React.useCallback(\n        async (page: number) => {\n            loadingRef.current = loadingRef.current.add(page);\n            const startIndex = page * pageSize;\n            const d = await getRowData([startIndex, (page + 1) * pageSize]);\n\n            const vr = visiblePagesRef.current;\n\n            const damageList: { cell: [number, number] }[] = [];\n            const data = dataRef.current;\n            for (const [i, element] of d.entries()) {\n                data[i + startIndex] = element;\n                for (let col = vr.x; col <= vr.x + vr.width; col++) {\n                    damageList.push({\n                        cell: [col, i + startIndex],\n                    });\n                }\n            }\n            gridRef.current?.updateCells(damageList);\n        },\n        [getRowData, gridRef, pageSize]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (r: Rectangle): (() => Promise<CellArray>) => {\n            return async () => {\n                const firstPage = Math.max(0, Math.floor(r.y / pageSize));\n                const lastPage = Math.floor((r.y + r.height) / pageSize);\n\n                for (const pageChunk of chunk(\n                    range(firstPage, lastPage + 1).filter(i => !loadingRef.current.hasIndex(i)),\n                    maxConcurrency\n                )) {\n                    await Promise.allSettled(pageChunk.map(loadPage));\n                }\n\n                const result: GridCell[][] = [];\n\n                for (let y = r.y; y < r.y + r.height; y++) {\n                    const row: GridCell[] = [];\n                    for (let x = r.x; x < r.x + r.width; x++) {\n                        row.push(getCellContent([x, y]));\n                    }\n                    result.push(row);\n                }\n\n                return result;\n            };\n        },\n        [getCellContent, loadPage, maxConcurrency, pageSize]\n    );\n\n    React.useEffect(() => {\n        const r = visiblePages;\n        const firstPage = Math.max(0, Math.floor((r.y - pageSize / 2) / pageSize));\n        const lastPage = Math.floor((r.y + r.height + pageSize / 2) / pageSize);\n        for (const page of range(firstPage, lastPage + 1)) {\n            if (loadingRef.current.hasIndex(page)) continue;\n            void loadPage(page);\n        }\n    }, [loadPage, pageSize, visiblePages]);\n\n    const onCellEdited = React.useCallback(\n        (cell: Item, newVal: EditableGridCell) => {\n            const [, row] = cell;\n            const current = dataRef.current[row];\n            if (current === undefined) return;\n\n            const result = onEdited(cell, newVal, current);\n            if (result !== undefined) {\n                dataRef.current[row] = result;\n            }\n        },\n        [onEdited]\n    );\n\n    return {\n        getCellContent,\n        onVisibleRegionChanged,\n        onCellEdited,\n        getCellsForSelection,\n    };\n}\n\nexport const ServerSideData: React.VFC = () => {\n    const ref = React.useRef<DataEditorRef | null>(null);\n\n    const getRowData = React.useCallback(async (r: Item) => {\n        await new Promise(res => setTimeout(res, 300));\n        return range(r[0], r[1]).map(rowIndex => [`1, ${rowIndex}`, `2, ${rowIndex}`]);\n    }, []);\n\n    const columns = React.useMemo<readonly GridColumn[]>(() => {\n        return [\n            {\n                title: \"A\",\n                width: 150,\n            },\n            {\n                title: \"B\",\n                width: 200,\n            },\n        ];\n    }, []);\n\n    const args = useAsyncData<string[]>(\n        50,\n        5,\n        getRowData,\n        React.useCallback(\n            (rowData, col) => ({\n                kind: GridCellKind.Text,\n                data: rowData[col],\n                allowOverlay: true,\n                displayData: rowData[col],\n            }),\n            []\n        ),\n        React.useCallback((cell, newVal, rowData) => {\n            const [col] = cell;\n            if (newVal.kind !== GridCellKind.Text) return undefined;\n            const newRow: string[] = [...rowData];\n            newRow[col] = newVal.data;\n            return newRow;\n        }, []),\n        ref\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Server Side Data\"\n            description={\n                <Description>\n                    Glide data grid is fully ready to handle your server side data needs. This example condenses the\n                    implementation into a single custom hook and loads in pages of 50. We are using 300ms sleeps, but\n                    network transactions should work the same.\n                </Description>\n            }>\n            <DataEditor ref={ref} {...args} width=\"100%\" columns={columns} rows={3000} rowMarkers=\"both\" />\n        </BeautifulWrapper>\n    );\n};\n(ServerSideData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n",
      "locationsMap": {
        "server-side-data": {
          "startLoc": {
            "col": 41,
            "line": 155
          },
          "endLoc": {
            "col": 1,
            "line": 212
          },
          "startBody": {
            "col": 41,
            "line": 155
          },
          "endBody": {
            "col": 1,
            "line": 212
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_3__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});

function useAsyncData(pageSize, maxConcurrency, getRowData, toCell, onEdited, gridRef) {
  pageSize = Math.max(pageSize, 1);
  const loadingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .CompactSelection.empty */ .EV.empty());
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const [visiblePages, setVisiblePages] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  const visiblePagesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(visiblePages);
  visiblePagesRef.current = visiblePages;
  const onVisibleRegionChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(r => {
    setVisiblePages(cv => {
      if (r.x === cv.x && r.y === cv.y && r.width === cv.width && r.height === cv.height) return cv;
      return r;
    });
  }, []);
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const rowData = dataRef.current[row];

    if (rowData !== undefined) {
      return toCell(rowData, col);
    }

    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Loading */ .p6.Loading,
      allowOverlay: false
    };
  }, [toCell]);
  const loadPage = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async page => {
    var _gridRef$current;

    loadingRef.current = loadingRef.current.add(page);
    const startIndex = page * pageSize;
    const d = await getRowData([startIndex, (page + 1) * pageSize]);
    const vr = visiblePagesRef.current;
    const damageList = [];
    const data = dataRef.current;

    for (const [i, element] of d.entries()) {
      data[i + startIndex] = element;

      for (let col = vr.x; col <= vr.x + vr.width; col++) {
        damageList.push({
          cell: [col, i + startIndex]
        });
      }
    }

    (_gridRef$current = gridRef.current) === null || _gridRef$current === void 0 ? void 0 : _gridRef$current.updateCells(damageList);
  }, [getRowData, gridRef, pageSize]);
  const getCellsForSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(r => {
    return async () => {
      const firstPage = Math.max(0, Math.floor(r.y / pageSize));
      const lastPage = Math.floor((r.y + r.height) / pageSize);

      for (const pageChunk of lodash_chunk_js__WEBPACK_IMPORTED_MODULE_2___default()(lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default()(firstPage, lastPage + 1).filter(i => !loadingRef.current.hasIndex(i)), maxConcurrency)) {
        await Promise.allSettled(pageChunk.map(loadPage));
      }

      const result = [];

      for (let y = r.y; y < r.y + r.height; y++) {
        const row = [];

        for (let x = r.x; x < r.x + r.width; x++) {
          row.push(getCellContent([x, y]));
        }

        result.push(row);
      }

      return result;
    };
  }, [getCellContent, loadPage, maxConcurrency, pageSize]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const r = visiblePages;
    const firstPage = Math.max(0, Math.floor((r.y - pageSize / 2) / pageSize));
    const lastPage = Math.floor((r.y + r.height + pageSize / 2) / pageSize);

    for (const page of lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default()(firstPage, lastPage + 1)) {
      if (loadingRef.current.hasIndex(page)) continue;
      void loadPage(page);
    }
  }, [loadPage, pageSize, visiblePages]);
  const onCellEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newVal) => {
    const [, row] = cell;
    const current = dataRef.current[row];
    if (current === undefined) return;
    const result = onEdited(cell, newVal, current);

    if (result !== undefined) {
      dataRef.current[row] = result;
    }
  }, [onEdited]);
  return {
    getCellContent,
    onVisibleRegionChanged,
    onCellEdited,
    getCellsForSelection
  };
}

const ServerSideData = () => {
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const getRowData = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async r => {
    await new Promise(res => setTimeout(res, 300));
    return lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default()(r[0], r[1]).map(rowIndex => [`1, ${rowIndex}`, `2, ${rowIndex}`]);
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "A",
      width: 150
    }, {
      title: "B",
      width: 200
    }];
  }, []);
  const args = useAsyncData(50, 5, getRowData, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rowData, col) => ({
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
    data: rowData[col],
    allowOverlay: true,
    displayData: rowData[col]
  }), []), react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newVal, rowData) => {
    const [col] = cell;
    if (newVal.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text) return undefined;
    const newRow = [...rowData];
    newRow[col] = newVal.data;
    return newRow;
  }, []), ref);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Server Side Data",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Glide data grid is fully ready to handle your server side data needs. This example condenses the implementation into a single custom hook and loads in pages of 50. We are using 300ms sleeps, but network transactions should work the same.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({
    ref: ref
  }, args, {
    width: "100%",
    columns: columns,
    rows: 3000,
    rowMarkers: "both"
  })));
};
ServerSideData.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["ServerSideData"];

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bug70": () => (/* binding */ Bug70),
/* harmony export */   "FilterColumns": () => (/* binding */ FilterColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _storybook_addons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@storybook/addons/dist/esm/hooks.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
var __STORY__ = "import * as React from \"react\";\n\nimport { useState, useMemo } from \"@storybook/addons\";\nimport { BuilderThemeWrapper } from \"../../stories/story-utils\";\n\nimport { GridCell, GridCellKind, Item } from \"../../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor\";\nimport { styled } from \"@linaria/react\";\n\nexport default {\n    title: \"Tests/TestCases/Bugs\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <BuilderThemeWrapper width={1000} height={800}>\n                <Story />\n            </BuilderThemeWrapper>\n        ),\n    ],\n};\n\nconst bug70Gen = ([, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Number,\n    data: row,\n    displayData: row.toString(),\n});\n\nconst ignore = () => undefined;\n\nconst Bug70Style = styled.div`\n    display: flex;\n    flex-direction: column;\n\n    > a {\n        margin-bottom: 20px;\n    }\n`;\n\nexport function Bug70() {\n    const cols = [\n        { title: \"Col1\", width: 100 },\n        { title: \"Col2\", width: 100 },\n    ];\n\n    return (\n        <Bug70Style className=\"App\">\n            <p>To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab</p>\n            <a href=\"https://github.com/glideapps/glide-data-grid/issues/70\" target=\"_blank\" rel=\"noreferrer\">\n                Original report\n            </a>\n            <DataEditor\n                width={500}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={bug70Gen}\n                onCellEdited={ignore}\n            />\n        </Bug70Style>\n    );\n}\n\nconst filterColumnsGen = ([col, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Text,\n    data: `${col} - ${row}`,\n    displayData: `${col} - ${row}`,\n});\n\nconst filteringColumns = [\n    { title: \"Col AAAA\", width: 120 },\n    { title: \"Col AAA\", width: 120 },\n    { title: \"Col AA\", width: 120 },\n    { title: \"Col A\", width: 120 },\n    { title: \"Col\", width: 120 },\n];\n\nexport function FilterColumns() {\n    const [searchText, setSearchText] = useState(\"\");\n\n    const cols = useMemo(() => {\n        if (searchText === \"\") {\n            return filteringColumns;\n        }\n\n        return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));\n    }, [searchText]);\n\n    const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        setSearchText(e.target.value);\n    };\n\n    return (\n        <div>\n            <input value={searchText} onChange={onInputChange} />\n            <DataEditor\n                width={1000}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={filterColumnsGen}\n                smoothScrollX={true}\n                smoothScrollY={true}\n            />\n        </div>\n    );\n}\n";
var __LOCATIONS_MAP__ = {
  "Bug70": {
    "startLoc": {
      "col": 7,
      "line": 40
    },
    "endLoc": {
      "col": 1,
      "line": 62
    },
    "startBody": {
      "col": 7,
      "line": 40
    },
    "endBody": {
      "col": 1,
      "line": 62
    }
  },
  "FilterColumns": {
    "startLoc": {
      "col": 7,
      "line": 79
    },
    "endLoc": {
      "col": 1,
      "line": 108
    },
    "startBody": {
      "col": 7,
      "line": 79
    },
    "endBody": {
      "col": 1,
      "line": 108
    }
  }
};






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { useState, useMemo } from \"@storybook/addons\";\nimport { BuilderThemeWrapper } from \"../../stories/story-utils\";\n\nimport { GridCell, GridCellKind, Item } from \"../../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor\";\nimport { styled } from \"@linaria/react\";\n\nexport default {\n    title: \"Tests/TestCases/Bugs\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <BuilderThemeWrapper width={1000} height={800}>\n                <Story />\n            </BuilderThemeWrapper>\n        ),\n    ],\n};\n\nconst bug70Gen = ([, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Number,\n    data: row,\n    displayData: row.toString(),\n});\n\nconst ignore = () => undefined;\n\nconst Bug70Style = styled.div`\n    display: flex;\n    flex-direction: column;\n\n    > a {\n        margin-bottom: 20px;\n    }\n`;\n\nexport function Bug70() {\n    const cols = [\n        { title: \"Col1\", width: 100 },\n        { title: \"Col2\", width: 100 },\n    ];\n\n    return (\n        <Bug70Style className=\"App\">\n            <p>To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab</p>\n            <a href=\"https://github.com/glideapps/glide-data-grid/issues/70\" target=\"_blank\" rel=\"noreferrer\">\n                Original report\n            </a>\n            <DataEditor\n                width={500}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={bug70Gen}\n                onCellEdited={ignore}\n            />\n        </Bug70Style>\n    );\n}\n\nconst filterColumnsGen = ([col, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Text,\n    data: `${col} - ${row}`,\n    displayData: `${col} - ${row}`,\n});\n\nconst filteringColumns = [\n    { title: \"Col AAAA\", width: 120 },\n    { title: \"Col AAA\", width: 120 },\n    { title: \"Col AA\", width: 120 },\n    { title: \"Col A\", width: 120 },\n    { title: \"Col\", width: 120 },\n];\n\nexport function FilterColumns() {\n    const [searchText, setSearchText] = useState(\"\");\n\n    const cols = useMemo(() => {\n        if (searchText === \"\") {\n            return filteringColumns;\n        }\n\n        return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));\n    }, [searchText]);\n\n    const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        setSearchText(e.target.value);\n    };\n\n    return (\n        <div>\n            <input value={searchText} onChange={onInputChange} />\n            <DataEditor\n                width={1000}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={filterColumnsGen}\n                smoothScrollX={true}\n                smoothScrollY={true}\n            />\n        </div>\n    );\n}\n",
      "locationsMap": {
        "bug-70": {
          "startLoc": {
            "col": 7,
            "line": 40
          },
          "endLoc": {
            "col": 1,
            "line": 62
          },
          "startBody": {
            "col": 7,
            "line": 40
          },
          "endBody": {
            "col": 1,
            "line": 62
          }
        },
        "filter-columns": {
          "startLoc": {
            "col": 7,
            "line": 79
          },
          "endLoc": {
            "col": 1,
            "line": 108
          },
          "startBody": {
            "col": 7,
            "line": 79
          },
          "endBody": {
            "col": 1,
            "line": 108
          }
        }
      }
    }
  },
  title: "Tests/TestCases/Bugs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .BuilderThemeWrapper */ .j, {
    width: 1000,
    height: 800
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});

const bug70Gen = _ref => {
  let [, row] = _ref;
  return {
    allowOverlay: true,
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Number */ .p6.Number,
    data: row,
    displayData: row.toString()
  };
};

const ignore = () => undefined;

const Bug70Style = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)('div')({
  name: "Bug70Style",
  class: "b1nvh7n2"
});
const Bug70 = function Bug70() {
  const cols = [{
    title: "Col1",
    width: 100
  }, {
    title: "Col2",
    width: 100
  }];
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Bug70Style, {
    className: "App"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    href: "https://github.com/glideapps/glide-data-grid/issues/70",
    target: "_blank",
    rel: "noreferrer"
  }, "Original report"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: 500,
    height: 500,
    rows: 100,
    columns: cols,
    getCellContent: bug70Gen,
    onCellEdited: ignore
  }));
};

const filterColumnsGen = _ref2 => {
  let [col, row] = _ref2;
  return {
    allowOverlay: true,
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
    data: `${col} - ${row}`,
    displayData: `${col} - ${row}`
  };
};

const filteringColumns = [{
  title: "Col AAAA",
  width: 120
}, {
  title: "Col AAA",
  width: 120
}, {
  title: "Col AA",
  width: 120
}, {
  title: "Col A",
  width: 120
}, {
  title: "Col",
  width: 120
}];
const FilterColumns = function FilterColumns() {
  const [searchText, setSearchText] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_5__/* .useState */ .eJ)("");
  const cols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_5__/* .useMemo */ .Ye)(() => {
    if (searchText === "") {
      return filteringColumns;
    }

    return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));
  }, [searchText]);

  const onInputChange = e => {
    setSearchText(e.target.value);
  };

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    value: searchText,
    onChange: onInputChange
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: 1000,
    height: 500,
    rows: 100,
    columns: cols,
    getCellContent: filterColumnsGen,
    smoothScrollX: true,
    smoothScrollY: true
  }));
};

__webpack_require__("./packages/core/src/data-editor/stories/data-editor-repros.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx");

const __namedExportsOrder = ["Bug70", "FilterColumns"];

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanEditBoolean": () => (/* binding */ CanEditBoolean),
/* harmony export */   "Draggable": () => (/* binding */ Draggable),
/* harmony export */   "DynamicAddRemoveColumns": () => (/* binding */ DynamicAddRemoveColumns),
/* harmony export */   "GridAddNewRows": () => (/* binding */ GridAddNewRows),
/* harmony export */   "GridNoTrailingBlankRow": () => (/* binding */ GridNoTrailingBlankRow),
/* harmony export */   "GridSelectionOutOfRangeLessColumnsThanSelection": () => (/* binding */ GridSelectionOutOfRangeLessColumnsThanSelection),
/* harmony export */   "GridSelectionOutOfRangeNoColumns": () => (/* binding */ GridSelectionOutOfRangeNoColumns),
/* harmony export */   "IdealSize": () => (/* binding */ IdealSize),
/* harmony export */   "ManualControl": () => (/* binding */ ManualControl),
/* harmony export */   "MarkdownEdits": () => (/* binding */ MarkdownEdits),
/* harmony export */   "Minimal": () => (/* binding */ Minimal),
/* harmony export */   "RelationColumn": () => (/* binding */ RelationColumn),
/* harmony export */   "ResizableColumns": () => (/* binding */ ResizableColumns),
/* harmony export */   "SimpleEditable": () => (/* binding */ SimpleEditable),
/* harmony export */   "Simplenotest": () => (/* binding */ Simplenotest),
/* harmony export */   "Smooth": () => (/* binding */ Smooth),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _storybook_addons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@storybook/addons/dist/esm/hooks.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
var __STORY__ = "\nimport * as React from \"react\";\n\nimport { useState, useCallback, useMemo } from \"@storybook/addons\";\nimport { BuilderThemeWrapper } from \"../../stories/story-utils\";\n\nimport {\n    CompactSelection,\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    GridSelection,\n    Item,\n} from \"../../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor\";\n\nexport default {\n    title: \"Tests/TestCases\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <BuilderThemeWrapper width={1000} height={800}>\n                <Story />\n            </BuilderThemeWrapper>\n        ),\n    ],\n};\n\nfunction getDummyData([col, row]: Item): GridCell {\n    if (col === 0) {\n        return {\n            kind: GridCellKind.RowID,\n            data: `RowID ${col}, ${row}`,\n            allowOverlay: false,\n        };\n    }\n    if (col === 1) {\n        return {\n            kind: GridCellKind.Bubble,\n            data: [\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n            ],\n            allowOverlay: true,\n        };\n    }\n    if (col === 2) {\n        return {\n            kind: GridCellKind.Image,\n            data: [\n                \"https://i.imgur.com/5J0BftG.jpg\",\n                \"https://preview.redd.it/7jlqkp2cyap51.jpg?width=575&auto=webp&s=26fa9ed15b16fb450ee08ed1f2f0ccb5e0223581\",\n            ],\n            allowOverlay: true,\n            allowAdd: true,\n        };\n    }\n    if (col === 3) {\n        return {\n            kind: GridCellKind.Markdown,\n            data: `## Markdown has titles\n\nAnd supports newline chars and automatic wrapping text that just needs to be long enough to trigger it.\n\n\n[Google](https://google.com)\n\n- with\n- lists\n- that\n- can\n- be\n- pretty\n- long\n                    `,\n            allowOverlay: true,\n        };\n    }\n    if (col === 4) {\n        return {\n            kind: GridCellKind.Number,\n            displayData: \"$10,352\",\n            allowOverlay: true,\n            data: 10_352,\n            readonly: true,\n        };\n    }\n    if (col === 5) {\n        return {\n            kind: GridCellKind.Uri,\n            data: \"https://www.google.com\",\n            allowOverlay: true,\n        };\n    }\n    if (col === 6) {\n        return {\n            kind: GridCellKind.Boolean,\n            data: row % 3 === 0 || row % 5 === 0,\n            readonly: true,\n            allowOverlay: false,\n        };\n    }\n    if (col === 7) {\n        return {\n            kind: GridCellKind.Text,\n            // RTL test\n            displayData: `הרפתקה חדשה`,\n            data: `הרפתקה חדשה`,\n            allowOverlay: true,\n            readonly: true,\n        };\n    }\n    if (col === 8) {\n        return {\n            kind: GridCellKind.Drilldown,\n            data: [\n                {\n                    text: \"Test\",\n                    img: \"https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg\",\n                },\n                { text: \"No Image\" },\n            ],\n            allowOverlay: true,\n        };\n    }\n    return {\n        kind: GridCellKind.Text,\n        displayData: `${col}, ${row} 🦝`,\n        data: `${col}, ${row} 🦝`,\n        allowOverlay: true,\n    };\n}\n\nfunction getDummyCols() {\n    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20].map(\n        i =>\n            ({\n                title: i.toString() + \" is the longest header in the world\",\n                width: 120 + (i % 4) * 10,\n                icon: \"headerString\",\n                hasMenu: true,\n            } as GridColumn)\n    );\n}\n\nexport function Simplenotest() {\n    const [cols, setColumns] = useState(getDummyCols);\n\n    const onColumnResize = useCallback(\n        (col: GridColumn, newSize: number) => {\n            const index = cols.indexOf(col);\n            const newCols = [...cols];\n            newCols[index] = {\n                ...newCols[index],\n                width: newSize,\n            };\n            setColumns(newCols);\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            getCellsForSelection={true}\n            columns={cols}\n            rows={1000}\n            onColumnResize={onColumnResize}\n        />\n    );\n}\n\nfunction getDummyRelationColumn(): GridColumn[] {\n    return [\n        {\n            title: \"Relation\",\n            width: 360,\n            icon: \"headerString\",\n            hasMenu: true,\n        },\n    ];\n}\n\nfunction getDummyRelationData([col, row]: Item): GridCell {\n    return {\n        kind: GridCellKind.Drilldown,\n        data: [\n            {\n                text: `Image ${col}-${row}`,\n                img: \"https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg\",\n            },\n            { text: `Text ${col}-${row}` },\n            { text: `More text ${col}-${row}` },\n        ],\n        allowOverlay: true,\n    };\n}\n\nexport function RelationColumn() {\n    const [cols, setColumns] = useState(getDummyRelationColumn);\n\n    const onColumnResize = useCallback(\n        (col: GridColumn, newSize: number) => {\n            const index = cols.indexOf(col);\n            const newCols = [...cols];\n            newCols[index] = {\n                ...newCols[index],\n                width: newSize,\n            };\n            setColumns(newCols);\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyRelationData}\n            columns={cols}\n            rows={1000}\n            onColumnResize={onColumnResize}\n            smoothScrollX={true}\n            smoothScrollY={true}\n        />\n    );\n}\n\nconst columns: GridColumn[] = [\n    { title: \"Number\", width: 100, icon: \"headerArray\", overlayIcon: \"rowOwnerOverlay\" },\n    { title: \"Square\", width: 100 },\n];\n\nfunction getData([col, row]: Item): GridCell {\n    const n = Math.pow(row, col + 1);\n\n    return {\n        kind: GridCellKind.Number,\n        data: n,\n        displayData: n.toString(),\n        allowOverlay: false,\n    };\n}\n\nexport function Minimal() {\n    return <DataEditor width=\"100%\" getCellContent={getData} columns={columns} rows={1000} />;\n}\n\nexport function Smooth() {\n    const [cols, setCols] = useState(getDummyCols);\n\n    const onColumnResize = useCallback(\n        (column: GridColumn, newSize: number) => {\n            const index = cols.indexOf(column);\n            if (index !== -1) {\n                const newCol: GridColumn = {\n                    ...column,\n                    width: newSize,\n                };\n\n                const newCols = [...cols];\n                newCols.splice(index, 1, newCol);\n\n                setCols(newCols);\n            }\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            onColumnResize={onColumnResize}\n            columns={cols}\n            rows={1000}\n            smoothScrollY={true}\n            smoothScrollX={true}\n        />\n    );\n}\n\nexport function ManualControl() {\n    const [gridSelection, setGridSelection] = useState<GridSelection | undefined>(undefined);\n\n    const cb = (newVal: GridSelection) => {\n        if ((newVal.current?.cell[0] ?? 0) % 2 === 0) {\n            setGridSelection(newVal);\n        }\n    };\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            gridSelection={gridSelection}\n            onGridSelectionChange={cb}\n            getCellContent={getData}\n            columns={columns}\n            rows={1000}\n        />\n    );\n}\n\nexport function Draggable() {\n    return (\n        <DataEditor\n            width=\"100%\"\n            isDraggable={true}\n            onDragStart={args => {\n                args.setData(\"text\", \"testing\");\n            }}\n            getCellContent={getData}\n            columns={columns}\n            rows={1000}\n        />\n    );\n}\n\nexport function IdealSize() {\n    // trying to be 500x500\n    const cols: GridColumn[] = [\n        { title: \"Number\", width: 250 },\n        { title: \"Square\", width: 250 },\n    ];\n    return (\n        <div style={{ width: 500, height: 500, position: \"relative\" }}>\n            <DataEditor\n                width={500}\n                height={500}\n                isDraggable={true}\n                onDragStart={args => {\n                    args.setData(\"text\", \"testing\");\n                }}\n                getCellContent={getData}\n                columns={cols}\n                smoothScrollX={true}\n                smoothScrollY={true}\n                rowHeight={50}\n                headerHeight={50}\n                rows={9}\n            />\n        </div>\n    );\n}\n\nexport function DynamicAddRemoveColumns({ columnCount }: { columnCount: number }) {\n    // trying to be 500x500\n    const cols: GridColumn[] = [\n        { title: \"Number\", width: 250 },\n        { title: \"Square\", width: 250 },\n    ];\n\n    for (let i = 2; i < columnCount; i++) {\n        cols.push({\n            title: \"Foo\",\n            width: 250,\n        });\n    }\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            isDraggable={true}\n            getCellContent={getData}\n            columns={cols}\n            smoothScrollX={true}\n            smoothScrollY={true}\n            rowHeight={50}\n            headerHeight={50}\n            rows={9}\n        />\n    );\n}\nDynamicAddRemoveColumns.args = {\n    columnCount: 2,\n};\n\nexport function GridSelectionOutOfRangeNoColumns() {\n    const dummyCols = useMemo(\n        () => getDummyCols().map(v => ({ ...v, width: 300, title: \"Making column smaller used to crash!\" })),\n        []\n    );\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const [cols, setCols] = useState(dummyCols);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n            onColumnResize={(_col, newSize) => {\n                if (newSize > 300) {\n                    setCols(dummyCols);\n                } else {\n                    setCols([]);\n                }\n            }}\n        />\n    );\n}\n\ntype ResizableColumnsSizeMap = Record<string, number>;\n\nfunction getResizableColumnsInitSize(): ResizableColumnsSizeMap {\n    return {\n        \"resize me 0\": 120,\n        \"resize me 1\": 120,\n        \"resize me 2\": 120,\n        \"resize me 3\": 120,\n        \"resize me 4\": 120,\n        \"resize me 5\": 120,\n        \"resize me 6\": 120,\n        \"resize me 7\": 120,\n    };\n}\n\nfunction getResizableColumns(sizeMap: ResizableColumnsSizeMap): GridColumn[] {\n    return Object.entries(sizeMap).map(([title, width]) => ({\n        title,\n        width,\n        icon: \"headerString\",\n        hasMenu: true,\n    }));\n}\n\nexport function ResizableColumns() {\n    const [colSizes, setColSizes] = useState(getResizableColumnsInitSize);\n\n    const cols = useMemo(() => {\n        return getResizableColumns(colSizes);\n    }, [colSizes]);\n\n    const onColumnResize = useCallback((column: GridColumn, newSize: number) => {\n        setColSizes(prevColSizes => {\n            return {\n                ...prevColSizes,\n                [column.title]: newSize,\n            };\n        });\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={20}\n            isDraggable={false}\n            smoothScrollX={true}\n            smoothScrollY={true}\n            onColumnResize={onColumnResize}\n        />\n    );\n}\n\nexport function GridSelectionOutOfRangeLessColumnsThanSelection() {\n    const dummyCols = useMemo(\n        () => getDummyCols().map(v => ({ ...v, width: 300, title: \"Making column smaller used to crash!\" })),\n        []\n    );\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const [cols, setCols] = useState(dummyCols);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n            onColumnResize={(_col, newSize) => {\n                if (newSize > 300) {\n                    setCols(dummyCols);\n                } else {\n                    setCols([dummyCols[0]]);\n                }\n            }}\n        />\n    );\n}\n\nexport function GridAddNewRows() {\n    const cols = useMemo(getDummyCols, []);\n\n    const [rowsCount, setRowsCount] = useState(10);\n\n    const onRowAppended = useCallback(() => {\n        setRowsCount(r => r + 1);\n    }, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>(undefined);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={rowsCount}\n            onRowAppended={onRowAppended}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport function GridNoTrailingBlankRow() {\n    const cols = useMemo(getDummyCols, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>(undefined);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={100}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport function MarkdownEdits() {\n    const dummyCols: GridColumn[] = useMemo(() => {\n        return [\n            {\n                title: \"MD short\",\n                width: 50,\n            },\n            {\n                title: \"MD long\",\n                width: 50,\n            },\n        ];\n    }, []);\n\n    const dummyCells = useCallback(([col, _row]: Item) => {\n        if (col === 0) {\n            const editable: EditableGridCell = {\n                data: \"text\",\n                allowOverlay: true,\n                kind: GridCellKind.Markdown,\n            };\n            return editable;\n        } else if (col === 1) {\n            const editable: EditableGridCell = {\n                data: `text really really really long\n## H1\n\n- this\n- is\n- a\n- longer\n- example\n- to\n- test\n- scroll\n- of\n- preview\n                `,\n                allowOverlay: true,\n                kind: GridCellKind.Markdown,\n            };\n            return editable;\n        }\n        const editable: EditableGridCell = {\n            data: \"text\",\n            allowOverlay: true,\n            kind: GridCellKind.Markdown,\n        };\n        return editable;\n    }, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={dummyCells}\n            columns={dummyCols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport const CanEditBoolean = () => {\n    const [vals, setVals] = useState<[boolean | null | undefined, boolean | null | undefined]>([false, false]);\n    return (\n        <DataEditor\n            width=\"100%\"\n            columns={[\n                {\n                    title: \"Editable\",\n                    width: 100,\n                },\n                {\n                    title: \"Readonly\",\n                    width: 100,\n                },\n            ]}\n            rows={1}\n            getCellContent={([col]) => {\n                return {\n                    kind: GridCellKind.Boolean,\n                    readonly: col !== 0,\n                    allowOverlay: false,\n                    data: vals[col],\n                };\n            }}\n            onCellEdited={([col], newVal) => {\n                if (newVal.kind === GridCellKind.Boolean) {\n                    setVals(cv => {\n                        const f = [...cv];\n                        f.splice(col, 1, newVal.data);\n                        return f as [boolean, boolean];\n                    });\n                }\n            }}\n        />\n    );\n};\n\nexport const SimpleEditable = () => {\n    const [vals, setVals] = useState<[string, string][]>(() => {\n        const result: [string, string][] = [];\n        for (let i = 0; i < 2000; i++) {\n            result.push([\"Edit\", \"Me\"]);\n        }\n        return result;\n    });\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            columns={[\n                {\n                    title: \"Column A\",\n                    width: 250,\n                },\n                {\n                    title: \"Column B\",\n                    width: 250,\n                },\n            ]}\n            rows={vals.length}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: vals[row][col],\n                displayData: vals[row][col],\n            })}\n            onCellEdited={([col, row], newVal) => {\n                const newVals = [...vals];\n                const newRow: [string, string] = [...newVals[row]];\n                if (typeof newVal.data === \"string\") {\n                    newRow[col] = newVal.data;\n                }\n                newVals[row] = newRow;\n                setVals(newVals);\n            }}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "Simplenotest": {
    "startLoc": {
      "col": 7,
      "line": 155
    },
    "endLoc": {
      "col": 1,
      "line": 181
    },
    "startBody": {
      "col": 7,
      "line": 155
    },
    "endBody": {
      "col": 1,
      "line": 181
    }
  },
  "RelationColumn": {
    "startLoc": {
      "col": 7,
      "line": 209
    },
    "endLoc": {
      "col": 1,
      "line": 236
    },
    "startBody": {
      "col": 7,
      "line": 209
    },
    "endBody": {
      "col": 1,
      "line": 236
    }
  },
  "Minimal": {
    "startLoc": {
      "col": 7,
      "line": 254
    },
    "endLoc": {
      "col": 1,
      "line": 256
    },
    "startBody": {
      "col": 7,
      "line": 254
    },
    "endBody": {
      "col": 1,
      "line": 256
    }
  },
  "Smooth": {
    "startLoc": {
      "col": 7,
      "line": 258
    },
    "endLoc": {
      "col": 1,
      "line": 290
    },
    "startBody": {
      "col": 7,
      "line": 258
    },
    "endBody": {
      "col": 1,
      "line": 290
    }
  },
  "ManualControl": {
    "startLoc": {
      "col": 7,
      "line": 292
    },
    "endLoc": {
      "col": 1,
      "line": 311
    },
    "startBody": {
      "col": 7,
      "line": 292
    },
    "endBody": {
      "col": 1,
      "line": 311
    }
  },
  "Draggable": {
    "startLoc": {
      "col": 7,
      "line": 313
    },
    "endLoc": {
      "col": 1,
      "line": 326
    },
    "startBody": {
      "col": 7,
      "line": 313
    },
    "endBody": {
      "col": 1,
      "line": 326
    }
  },
  "IdealSize": {
    "startLoc": {
      "col": 7,
      "line": 328
    },
    "endLoc": {
      "col": 1,
      "line": 353
    },
    "startBody": {
      "col": 7,
      "line": 328
    },
    "endBody": {
      "col": 1,
      "line": 353
    }
  },
  "DynamicAddRemoveColumns": {
    "startLoc": {
      "col": 7,
      "line": 355
    },
    "endLoc": {
      "col": 1,
      "line": 382
    },
    "startBody": {
      "col": 7,
      "line": 355
    },
    "endBody": {
      "col": 1,
      "line": 382
    }
  },
  "GridSelectionOutOfRangeNoColumns": {
    "startLoc": {
      "col": 7,
      "line": 387
    },
    "endLoc": {
      "col": 1,
      "line": 422
    },
    "startBody": {
      "col": 7,
      "line": 387
    },
    "endBody": {
      "col": 1,
      "line": 422
    }
  },
  "ResizableColumns": {
    "startLoc": {
      "col": 7,
      "line": 448
    },
    "endLoc": {
      "col": 1,
      "line": 476
    },
    "startBody": {
      "col": 7,
      "line": 448
    },
    "endBody": {
      "col": 1,
      "line": 476
    }
  },
  "GridSelectionOutOfRangeLessColumnsThanSelection": {
    "startLoc": {
      "col": 7,
      "line": 478
    },
    "endLoc": {
      "col": 1,
      "line": 513
    },
    "startBody": {
      "col": 7,
      "line": 478
    },
    "endBody": {
      "col": 1,
      "line": 513
    }
  },
  "GridAddNewRows": {
    "startLoc": {
      "col": 7,
      "line": 515
    },
    "endLoc": {
      "col": 1,
      "line": 541
    },
    "startBody": {
      "col": 7,
      "line": 515
    },
    "endBody": {
      "col": 1,
      "line": 541
    }
  },
  "GridNoTrailingBlankRow": {
    "startLoc": {
      "col": 7,
      "line": 543
    },
    "endLoc": {
      "col": 1,
      "line": 562
    },
    "startBody": {
      "col": 7,
      "line": 543
    },
    "endBody": {
      "col": 1,
      "line": 562
    }
  },
  "MarkdownEdits": {
    "startLoc": {
      "col": 7,
      "line": 564
    },
    "endLoc": {
      "col": 1,
      "line": 635
    },
    "startBody": {
      "col": 7,
      "line": 564
    },
    "endBody": {
      "col": 1,
      "line": 635
    }
  },
  "CanEditBoolean": {
    "startLoc": {
      "col": 30,
      "line": 637
    },
    "endLoc": {
      "col": 1,
      "line": 672
    },
    "startBody": {
      "col": 30,
      "line": 637
    },
    "endBody": {
      "col": 1,
      "line": 672
    }
  },
  "SimpleEditable": {
    "startLoc": {
      "col": 30,
      "line": 674
    },
    "endLoc": {
      "col": 1,
      "line": 714
    },
    "startBody": {
      "col": 30,
      "line": 674
    },
    "endBody": {
      "col": 1,
      "line": 714
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "\nimport * as React from \"react\";\n\nimport { useState, useCallback, useMemo } from \"@storybook/addons\";\nimport { BuilderThemeWrapper } from \"../../stories/story-utils\";\n\nimport {\n    CompactSelection,\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    GridSelection,\n    Item,\n} from \"../../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor\";\n\nexport default {\n    title: \"Tests/TestCases\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <BuilderThemeWrapper width={1000} height={800}>\n                <Story />\n            </BuilderThemeWrapper>\n        ),\n    ],\n};\n\nfunction getDummyData([col, row]: Item): GridCell {\n    if (col === 0) {\n        return {\n            kind: GridCellKind.RowID,\n            data: `RowID ${col}, ${row}`,\n            allowOverlay: false,\n        };\n    }\n    if (col === 1) {\n        return {\n            kind: GridCellKind.Bubble,\n            data: [\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n            ],\n            allowOverlay: true,\n        };\n    }\n    if (col === 2) {\n        return {\n            kind: GridCellKind.Image,\n            data: [\n                \"https://i.imgur.com/5J0BftG.jpg\",\n                \"https://preview.redd.it/7jlqkp2cyap51.jpg?width=575&auto=webp&s=26fa9ed15b16fb450ee08ed1f2f0ccb5e0223581\",\n            ],\n            allowOverlay: true,\n            allowAdd: true,\n        };\n    }\n    if (col === 3) {\n        return {\n            kind: GridCellKind.Markdown,\n            data: `## Markdown has titles\n\nAnd supports newline chars and automatic wrapping text that just needs to be long enough to trigger it.\n\n\n[Google](https://google.com)\n\n- with\n- lists\n- that\n- can\n- be\n- pretty\n- long\n                    `,\n            allowOverlay: true,\n        };\n    }\n    if (col === 4) {\n        return {\n            kind: GridCellKind.Number,\n            displayData: \"$10,352\",\n            allowOverlay: true,\n            data: 10_352,\n            readonly: true,\n        };\n    }\n    if (col === 5) {\n        return {\n            kind: GridCellKind.Uri,\n            data: \"https://www.google.com\",\n            allowOverlay: true,\n        };\n    }\n    if (col === 6) {\n        return {\n            kind: GridCellKind.Boolean,\n            data: row % 3 === 0 || row % 5 === 0,\n            readonly: true,\n            allowOverlay: false,\n        };\n    }\n    if (col === 7) {\n        return {\n            kind: GridCellKind.Text,\n            // RTL test\n            displayData: `הרפתקה חדשה`,\n            data: `הרפתקה חדשה`,\n            allowOverlay: true,\n            readonly: true,\n        };\n    }\n    if (col === 8) {\n        return {\n            kind: GridCellKind.Drilldown,\n            data: [\n                {\n                    text: \"Test\",\n                    img: \"https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg\",\n                },\n                { text: \"No Image\" },\n            ],\n            allowOverlay: true,\n        };\n    }\n    return {\n        kind: GridCellKind.Text,\n        displayData: `${col}, ${row} 🦝`,\n        data: `${col}, ${row} 🦝`,\n        allowOverlay: true,\n    };\n}\n\nfunction getDummyCols() {\n    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20].map(\n        i =>\n            ({\n                title: i.toString() + \" is the longest header in the world\",\n                width: 120 + (i % 4) * 10,\n                icon: \"headerString\",\n                hasMenu: true,\n            } as GridColumn)\n    );\n}\n\nexport function Simplenotest() {\n    const [cols, setColumns] = useState(getDummyCols);\n\n    const onColumnResize = useCallback(\n        (col: GridColumn, newSize: number) => {\n            const index = cols.indexOf(col);\n            const newCols = [...cols];\n            newCols[index] = {\n                ...newCols[index],\n                width: newSize,\n            };\n            setColumns(newCols);\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            getCellsForSelection={true}\n            columns={cols}\n            rows={1000}\n            onColumnResize={onColumnResize}\n        />\n    );\n}\n\nfunction getDummyRelationColumn(): GridColumn[] {\n    return [\n        {\n            title: \"Relation\",\n            width: 360,\n            icon: \"headerString\",\n            hasMenu: true,\n        },\n    ];\n}\n\nfunction getDummyRelationData([col, row]: Item): GridCell {\n    return {\n        kind: GridCellKind.Drilldown,\n        data: [\n            {\n                text: `Image ${col}-${row}`,\n                img: \"https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg\",\n            },\n            { text: `Text ${col}-${row}` },\n            { text: `More text ${col}-${row}` },\n        ],\n        allowOverlay: true,\n    };\n}\n\nexport function RelationColumn() {\n    const [cols, setColumns] = useState(getDummyRelationColumn);\n\n    const onColumnResize = useCallback(\n        (col: GridColumn, newSize: number) => {\n            const index = cols.indexOf(col);\n            const newCols = [...cols];\n            newCols[index] = {\n                ...newCols[index],\n                width: newSize,\n            };\n            setColumns(newCols);\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyRelationData}\n            columns={cols}\n            rows={1000}\n            onColumnResize={onColumnResize}\n            smoothScrollX={true}\n            smoothScrollY={true}\n        />\n    );\n}\n\nconst columns: GridColumn[] = [\n    { title: \"Number\", width: 100, icon: \"headerArray\", overlayIcon: \"rowOwnerOverlay\" },\n    { title: \"Square\", width: 100 },\n];\n\nfunction getData([col, row]: Item): GridCell {\n    const n = Math.pow(row, col + 1);\n\n    return {\n        kind: GridCellKind.Number,\n        data: n,\n        displayData: n.toString(),\n        allowOverlay: false,\n    };\n}\n\nexport function Minimal() {\n    return <DataEditor width=\"100%\" getCellContent={getData} columns={columns} rows={1000} />;\n}\n\nexport function Smooth() {\n    const [cols, setCols] = useState(getDummyCols);\n\n    const onColumnResize = useCallback(\n        (column: GridColumn, newSize: number) => {\n            const index = cols.indexOf(column);\n            if (index !== -1) {\n                const newCol: GridColumn = {\n                    ...column,\n                    width: newSize,\n                };\n\n                const newCols = [...cols];\n                newCols.splice(index, 1, newCol);\n\n                setCols(newCols);\n            }\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            onColumnResize={onColumnResize}\n            columns={cols}\n            rows={1000}\n            smoothScrollY={true}\n            smoothScrollX={true}\n        />\n    );\n}\n\nexport function ManualControl() {\n    const [gridSelection, setGridSelection] = useState<GridSelection | undefined>(undefined);\n\n    const cb = (newVal: GridSelection) => {\n        if ((newVal.current?.cell[0] ?? 0) % 2 === 0) {\n            setGridSelection(newVal);\n        }\n    };\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            gridSelection={gridSelection}\n            onGridSelectionChange={cb}\n            getCellContent={getData}\n            columns={columns}\n            rows={1000}\n        />\n    );\n}\n\nexport function Draggable() {\n    return (\n        <DataEditor\n            width=\"100%\"\n            isDraggable={true}\n            onDragStart={args => {\n                args.setData(\"text\", \"testing\");\n            }}\n            getCellContent={getData}\n            columns={columns}\n            rows={1000}\n        />\n    );\n}\n\nexport function IdealSize() {\n    // trying to be 500x500\n    const cols: GridColumn[] = [\n        { title: \"Number\", width: 250 },\n        { title: \"Square\", width: 250 },\n    ];\n    return (\n        <div style={{ width: 500, height: 500, position: \"relative\" }}>\n            <DataEditor\n                width={500}\n                height={500}\n                isDraggable={true}\n                onDragStart={args => {\n                    args.setData(\"text\", \"testing\");\n                }}\n                getCellContent={getData}\n                columns={cols}\n                smoothScrollX={true}\n                smoothScrollY={true}\n                rowHeight={50}\n                headerHeight={50}\n                rows={9}\n            />\n        </div>\n    );\n}\n\nexport function DynamicAddRemoveColumns({ columnCount }: { columnCount: number }) {\n    // trying to be 500x500\n    const cols: GridColumn[] = [\n        { title: \"Number\", width: 250 },\n        { title: \"Square\", width: 250 },\n    ];\n\n    for (let i = 2; i < columnCount; i++) {\n        cols.push({\n            title: \"Foo\",\n            width: 250,\n        });\n    }\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            isDraggable={true}\n            getCellContent={getData}\n            columns={cols}\n            smoothScrollX={true}\n            smoothScrollY={true}\n            rowHeight={50}\n            headerHeight={50}\n            rows={9}\n        />\n    );\n}\nDynamicAddRemoveColumns.args = {\n    columnCount: 2,\n};\n\nexport function GridSelectionOutOfRangeNoColumns() {\n    const dummyCols = useMemo(\n        () => getDummyCols().map(v => ({ ...v, width: 300, title: \"Making column smaller used to crash!\" })),\n        []\n    );\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const [cols, setCols] = useState(dummyCols);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n            onColumnResize={(_col, newSize) => {\n                if (newSize > 300) {\n                    setCols(dummyCols);\n                } else {\n                    setCols([]);\n                }\n            }}\n        />\n    );\n}\n\ntype ResizableColumnsSizeMap = Record<string, number>;\n\nfunction getResizableColumnsInitSize(): ResizableColumnsSizeMap {\n    return {\n        \"resize me 0\": 120,\n        \"resize me 1\": 120,\n        \"resize me 2\": 120,\n        \"resize me 3\": 120,\n        \"resize me 4\": 120,\n        \"resize me 5\": 120,\n        \"resize me 6\": 120,\n        \"resize me 7\": 120,\n    };\n}\n\nfunction getResizableColumns(sizeMap: ResizableColumnsSizeMap): GridColumn[] {\n    return Object.entries(sizeMap).map(([title, width]) => ({\n        title,\n        width,\n        icon: \"headerString\",\n        hasMenu: true,\n    }));\n}\n\nexport function ResizableColumns() {\n    const [colSizes, setColSizes] = useState(getResizableColumnsInitSize);\n\n    const cols = useMemo(() => {\n        return getResizableColumns(colSizes);\n    }, [colSizes]);\n\n    const onColumnResize = useCallback((column: GridColumn, newSize: number) => {\n        setColSizes(prevColSizes => {\n            return {\n                ...prevColSizes,\n                [column.title]: newSize,\n            };\n        });\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={20}\n            isDraggable={false}\n            smoothScrollX={true}\n            smoothScrollY={true}\n            onColumnResize={onColumnResize}\n        />\n    );\n}\n\nexport function GridSelectionOutOfRangeLessColumnsThanSelection() {\n    const dummyCols = useMemo(\n        () => getDummyCols().map(v => ({ ...v, width: 300, title: \"Making column smaller used to crash!\" })),\n        []\n    );\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const [cols, setCols] = useState(dummyCols);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n            onColumnResize={(_col, newSize) => {\n                if (newSize > 300) {\n                    setCols(dummyCols);\n                } else {\n                    setCols([dummyCols[0]]);\n                }\n            }}\n        />\n    );\n}\n\nexport function GridAddNewRows() {\n    const cols = useMemo(getDummyCols, []);\n\n    const [rowsCount, setRowsCount] = useState(10);\n\n    const onRowAppended = useCallback(() => {\n        setRowsCount(r => r + 1);\n    }, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>(undefined);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={rowsCount}\n            onRowAppended={onRowAppended}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport function GridNoTrailingBlankRow() {\n    const cols = useMemo(getDummyCols, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>(undefined);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={100}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport function MarkdownEdits() {\n    const dummyCols: GridColumn[] = useMemo(() => {\n        return [\n            {\n                title: \"MD short\",\n                width: 50,\n            },\n            {\n                title: \"MD long\",\n                width: 50,\n            },\n        ];\n    }, []);\n\n    const dummyCells = useCallback(([col, _row]: Item) => {\n        if (col === 0) {\n            const editable: EditableGridCell = {\n                data: \"text\",\n                allowOverlay: true,\n                kind: GridCellKind.Markdown,\n            };\n            return editable;\n        } else if (col === 1) {\n            const editable: EditableGridCell = {\n                data: `text really really really long\n## H1\n\n- this\n- is\n- a\n- longer\n- example\n- to\n- test\n- scroll\n- of\n- preview\n                `,\n                allowOverlay: true,\n                kind: GridCellKind.Markdown,\n            };\n            return editable;\n        }\n        const editable: EditableGridCell = {\n            data: \"text\",\n            allowOverlay: true,\n            kind: GridCellKind.Markdown,\n        };\n        return editable;\n    }, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={dummyCells}\n            columns={dummyCols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport const CanEditBoolean = () => {\n    const [vals, setVals] = useState<[boolean | null | undefined, boolean | null | undefined]>([false, false]);\n    return (\n        <DataEditor\n            width=\"100%\"\n            columns={[\n                {\n                    title: \"Editable\",\n                    width: 100,\n                },\n                {\n                    title: \"Readonly\",\n                    width: 100,\n                },\n            ]}\n            rows={1}\n            getCellContent={([col]) => {\n                return {\n                    kind: GridCellKind.Boolean,\n                    readonly: col !== 0,\n                    allowOverlay: false,\n                    data: vals[col],\n                };\n            }}\n            onCellEdited={([col], newVal) => {\n                if (newVal.kind === GridCellKind.Boolean) {\n                    setVals(cv => {\n                        const f = [...cv];\n                        f.splice(col, 1, newVal.data);\n                        return f as [boolean, boolean];\n                    });\n                }\n            }}\n        />\n    );\n};\n\nexport const SimpleEditable = () => {\n    const [vals, setVals] = useState<[string, string][]>(() => {\n        const result: [string, string][] = [];\n        for (let i = 0; i < 2000; i++) {\n            result.push([\"Edit\", \"Me\"]);\n        }\n        return result;\n    });\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            columns={[\n                {\n                    title: \"Column A\",\n                    width: 250,\n                },\n                {\n                    title: \"Column B\",\n                    width: 250,\n                },\n            ]}\n            rows={vals.length}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: vals[row][col],\n                displayData: vals[row][col],\n            })}\n            onCellEdited={([col, row], newVal) => {\n                const newVals = [...vals];\n                const newRow: [string, string] = [...newVals[row]];\n                if (typeof newVal.data === \"string\") {\n                    newRow[col] = newVal.data;\n                }\n                newVals[row] = newRow;\n                setVals(newVals);\n            }}\n        />\n    );\n};\n",
      "locationsMap": {
        "simplenotest": {
          "startLoc": {
            "col": 7,
            "line": 155
          },
          "endLoc": {
            "col": 1,
            "line": 181
          },
          "startBody": {
            "col": 7,
            "line": 155
          },
          "endBody": {
            "col": 1,
            "line": 181
          }
        },
        "relation-column": {
          "startLoc": {
            "col": 7,
            "line": 209
          },
          "endLoc": {
            "col": 1,
            "line": 236
          },
          "startBody": {
            "col": 7,
            "line": 209
          },
          "endBody": {
            "col": 1,
            "line": 236
          }
        },
        "minimal": {
          "startLoc": {
            "col": 7,
            "line": 254
          },
          "endLoc": {
            "col": 1,
            "line": 256
          },
          "startBody": {
            "col": 7,
            "line": 254
          },
          "endBody": {
            "col": 1,
            "line": 256
          }
        },
        "smooth": {
          "startLoc": {
            "col": 7,
            "line": 258
          },
          "endLoc": {
            "col": 1,
            "line": 290
          },
          "startBody": {
            "col": 7,
            "line": 258
          },
          "endBody": {
            "col": 1,
            "line": 290
          }
        },
        "manual-control": {
          "startLoc": {
            "col": 7,
            "line": 292
          },
          "endLoc": {
            "col": 1,
            "line": 311
          },
          "startBody": {
            "col": 7,
            "line": 292
          },
          "endBody": {
            "col": 1,
            "line": 311
          }
        },
        "draggable": {
          "startLoc": {
            "col": 7,
            "line": 313
          },
          "endLoc": {
            "col": 1,
            "line": 326
          },
          "startBody": {
            "col": 7,
            "line": 313
          },
          "endBody": {
            "col": 1,
            "line": 326
          }
        },
        "ideal-size": {
          "startLoc": {
            "col": 7,
            "line": 328
          },
          "endLoc": {
            "col": 1,
            "line": 353
          },
          "startBody": {
            "col": 7,
            "line": 328
          },
          "endBody": {
            "col": 1,
            "line": 353
          }
        },
        "dynamic-add-remove-columns": {
          "startLoc": {
            "col": 7,
            "line": 355
          },
          "endLoc": {
            "col": 1,
            "line": 382
          },
          "startBody": {
            "col": 7,
            "line": 355
          },
          "endBody": {
            "col": 1,
            "line": 382
          }
        },
        "grid-selection-out-of-range-no-columns": {
          "startLoc": {
            "col": 7,
            "line": 387
          },
          "endLoc": {
            "col": 1,
            "line": 422
          },
          "startBody": {
            "col": 7,
            "line": 387
          },
          "endBody": {
            "col": 1,
            "line": 422
          }
        },
        "resizable-columns": {
          "startLoc": {
            "col": 7,
            "line": 448
          },
          "endLoc": {
            "col": 1,
            "line": 476
          },
          "startBody": {
            "col": 7,
            "line": 448
          },
          "endBody": {
            "col": 1,
            "line": 476
          }
        },
        "grid-selection-out-of-range-less-columns-than-selection": {
          "startLoc": {
            "col": 7,
            "line": 478
          },
          "endLoc": {
            "col": 1,
            "line": 513
          },
          "startBody": {
            "col": 7,
            "line": 478
          },
          "endBody": {
            "col": 1,
            "line": 513
          }
        },
        "grid-add-new-rows": {
          "startLoc": {
            "col": 7,
            "line": 515
          },
          "endLoc": {
            "col": 1,
            "line": 541
          },
          "startBody": {
            "col": 7,
            "line": 515
          },
          "endBody": {
            "col": 1,
            "line": 541
          }
        },
        "grid-no-trailing-blank-row": {
          "startLoc": {
            "col": 7,
            "line": 543
          },
          "endLoc": {
            "col": 1,
            "line": 562
          },
          "startBody": {
            "col": 7,
            "line": 543
          },
          "endBody": {
            "col": 1,
            "line": 562
          }
        },
        "markdown-edits": {
          "startLoc": {
            "col": 7,
            "line": 564
          },
          "endLoc": {
            "col": 1,
            "line": 635
          },
          "startBody": {
            "col": 7,
            "line": 564
          },
          "endBody": {
            "col": 1,
            "line": 635
          }
        },
        "can-edit-boolean": {
          "startLoc": {
            "col": 30,
            "line": 637
          },
          "endLoc": {
            "col": 1,
            "line": 672
          },
          "startBody": {
            "col": 30,
            "line": 637
          },
          "endBody": {
            "col": 1,
            "line": 672
          }
        },
        "simple-editable": {
          "startLoc": {
            "col": 30,
            "line": 674
          },
          "endLoc": {
            "col": 1,
            "line": 714
          },
          "startBody": {
            "col": 30,
            "line": 674
          },
          "endBody": {
            "col": 1,
            "line": 714
          }
        }
      }
    }
  },
  title: "Tests/TestCases",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .BuilderThemeWrapper */ .j, {
    width: 1000,
    height: 800
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});

function getDummyData(_ref) {
  let [col, row] = _ref;

  if (col === 0) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.RowID */ .p6.RowID,
      data: `RowID ${col}, ${row}`,
      allowOverlay: false
    };
  }

  if (col === 1) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Bubble */ .p6.Bubble,
      data: [`Bub ${col}`, `Bub ${row}`, `Bub ${col}`, `Bub ${row}`, `Bub ${col}`, `Bub ${row}`, `Bub ${col}`, `Bub ${row}`, `Bub ${col}`, `Bub ${row}`],
      allowOverlay: true
    };
  }

  if (col === 2) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Image */ .p6.Image,
      data: ["https://i.imgur.com/5J0BftG.jpg", "https://preview.redd.it/7jlqkp2cyap51.jpg?width=575&auto=webp&s=26fa9ed15b16fb450ee08ed1f2f0ccb5e0223581"],
      allowOverlay: true,
      allowAdd: true
    };
  }

  if (col === 3) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Markdown */ .p6.Markdown,
      data: `## Markdown has titles

And supports newline chars and automatic wrapping text that just needs to be long enough to trigger it.


[Google](https://google.com)

- with
- lists
- that
- can
- be
- pretty
- long
                    `,
      allowOverlay: true
    };
  }

  if (col === 4) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Number */ .p6.Number,
      displayData: "$10,352",
      allowOverlay: true,
      data: 10352,
      readonly: true
    };
  }

  if (col === 5) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Uri */ .p6.Uri,
      data: "https://www.google.com",
      allowOverlay: true
    };
  }

  if (col === 6) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Boolean */ .p6.Boolean,
      data: row % 3 === 0 || row % 5 === 0,
      readonly: true,
      allowOverlay: false
    };
  }

  if (col === 7) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      displayData: `הרפתקה חדשה`,
      data: `הרפתקה חדשה`,
      allowOverlay: true,
      readonly: true
    };
  }

  if (col === 8) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Drilldown */ .p6.Drilldown,
      data: [{
        text: "Test",
        img: "https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg"
      }, {
        text: "No Image"
      }],
      allowOverlay: true
    };
  }

  return {
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
    displayData: `${col}, ${row} 🦝`,
    data: `${col}, ${row} 🦝`,
    allowOverlay: true
  };
}

function getDummyCols() {
  return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20].map(i => ({
    title: i.toString() + " is the longest header in the world",
    width: 120 + i % 4 * 10,
    icon: "headerString",
    hasMenu: true
  }));
}

const Simplenotest = function Simplenotest() {
  const [cols, setColumns] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(getDummyCols);
  const onColumnResize = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)((col, newSize) => {
    const index = cols.indexOf(col);
    const newCols = [...cols];
    newCols[index] = { ...newCols[index],
      width: newSize
    };
    setColumns(newCols);
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    getCellsForSelection: true,
    columns: cols,
    rows: 1000,
    onColumnResize: onColumnResize
  });
};

function getDummyRelationColumn() {
  return [{
    title: "Relation",
    width: 360,
    icon: "headerString",
    hasMenu: true
  }];
}

function getDummyRelationData(_ref2) {
  let [col, row] = _ref2;
  return {
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Drilldown */ .p6.Drilldown,
    data: [{
      text: `Image ${col}-${row}`,
      img: "https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg"
    }, {
      text: `Text ${col}-${row}`
    }, {
      text: `More text ${col}-${row}`
    }],
    allowOverlay: true
  };
}

const RelationColumn = function RelationColumn() {
  const [cols, setColumns] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(getDummyRelationColumn);
  const onColumnResize = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)((col, newSize) => {
    const index = cols.indexOf(col);
    const newCols = [...cols];
    newCols[index] = { ...newCols[index],
      width: newSize
    };
    setColumns(newCols);
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyRelationData,
    columns: cols,
    rows: 1000,
    onColumnResize: onColumnResize,
    smoothScrollX: true,
    smoothScrollY: true
  });
};
const columns = [{
  title: "Number",
  width: 100,
  icon: "headerArray",
  overlayIcon: "rowOwnerOverlay"
}, {
  title: "Square",
  width: 100
}];

function getData(_ref3) {
  let [col, row] = _ref3;
  const n = Math.pow(row, col + 1);
  return {
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Number */ .p6.Number,
    data: n,
    displayData: n.toString(),
    allowOverlay: false
  };
}

const Minimal = function Minimal() {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getData,
    columns: columns,
    rows: 1000
  });
};
const Smooth = function Smooth() {
  const [cols, setCols] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(getDummyCols);
  const onColumnResize = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)((column, newSize) => {
    const index = cols.indexOf(column);

    if (index !== -1) {
      const newCol = { ...column,
        width: newSize
      };
      const newCols = [...cols];
      newCols.splice(index, 1, newCol);
      setCols(newCols);
    }
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    onColumnResize: onColumnResize,
    columns: cols,
    rows: 1000,
    smoothScrollY: true,
    smoothScrollX: true
  });
};
const ManualControl = function ManualControl() {
  const [gridSelection, setGridSelection] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(undefined);

  const cb = newVal => {
    var _newVal$current$cell$, _newVal$current;

    if (((_newVal$current$cell$ = (_newVal$current = newVal.current) === null || _newVal$current === void 0 ? void 0 : _newVal$current.cell[0]) !== null && _newVal$current$cell$ !== void 0 ? _newVal$current$cell$ : 0) % 2 === 0) {
      setGridSelection(newVal);
    }
  };

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    gridSelection: gridSelection,
    onGridSelectionChange: cb,
    getCellContent: getData,
    columns: columns,
    rows: 1000
  });
};
const Draggable = function Draggable() {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    isDraggable: true,
    onDragStart: args => {
      args.setData("text", "testing");
    },
    getCellContent: getData,
    columns: columns,
    rows: 1000
  });
};
const IdealSize = function IdealSize() {
  const cols = [{
    title: "Number",
    width: 250
  }, {
    title: "Square",
    width: 250
  }];
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      width: 500,
      height: 500,
      position: "relative"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: 500,
    height: 500,
    isDraggable: true,
    onDragStart: args => {
      args.setData("text", "testing");
    },
    getCellContent: getData,
    columns: cols,
    smoothScrollX: true,
    smoothScrollY: true,
    rowHeight: 50,
    headerHeight: 50,
    rows: 9
  }));
};
const DynamicAddRemoveColumns = function DynamicAddRemoveColumns(_ref4) {
  let {
    columnCount
  } = _ref4;
  const cols = [{
    title: "Number",
    width: 250
  }, {
    title: "Square",
    width: 250
  }];

  for (let i = 2; i < columnCount; i++) {
    cols.push({
      title: "Foo",
      width: 250
    });
  }

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    isDraggable: true,
    getCellContent: getData,
    columns: cols,
    smoothScrollX: true,
    smoothScrollY: true,
    rowHeight: 50,
    headerHeight: 50,
    rows: 9
  });
};
DynamicAddRemoveColumns.args = {
  columnCount: 2
};
const GridSelectionOutOfRangeNoColumns = function GridSelectionOutOfRangeNoColumns() {
  const dummyCols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(() => getDummyCols().map(v => ({ ...v,
    width: 300,
    title: "Making column smaller used to crash!"
  })), []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)({
    current: {
      cell: [2, 8],
      range: {
        width: 1,
        height: 1,
        x: 2,
        y: 8
      },
      rangeStack: []
    },
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
  });
  const [cols, setCols] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(dummyCols);
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: 1000,
    onGridSelectionChange: onSelected,
    gridSelection: selected,
    onColumnResize: (_col, newSize) => {
      if (newSize > 300) {
        setCols(dummyCols);
      } else {
        setCols([]);
      }
    }
  });
};

function getResizableColumnsInitSize() {
  return {
    "resize me 0": 120,
    "resize me 1": 120,
    "resize me 2": 120,
    "resize me 3": 120,
    "resize me 4": 120,
    "resize me 5": 120,
    "resize me 6": 120,
    "resize me 7": 120
  };
}

function getResizableColumns(sizeMap) {
  return Object.entries(sizeMap).map(_ref5 => {
    let [title, width] = _ref5;
    return {
      title,
      width,
      icon: "headerString",
      hasMenu: true
    };
  });
}

const ResizableColumns = function ResizableColumns() {
  const [colSizes, setColSizes] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(getResizableColumnsInitSize);
  const cols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(() => {
    return getResizableColumns(colSizes);
  }, [colSizes]);
  const onColumnResize = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)((column, newSize) => {
    setColSizes(prevColSizes => {
      return { ...prevColSizes,
        [column.title]: newSize
      };
    });
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: 20,
    isDraggable: false,
    smoothScrollX: true,
    smoothScrollY: true,
    onColumnResize: onColumnResize
  });
};
const GridSelectionOutOfRangeLessColumnsThanSelection = function GridSelectionOutOfRangeLessColumnsThanSelection() {
  const dummyCols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(() => getDummyCols().map(v => ({ ...v,
    width: 300,
    title: "Making column smaller used to crash!"
  })), []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)({
    current: {
      cell: [2, 8],
      range: {
        width: 1,
        height: 1,
        x: 2,
        y: 8
      },
      rangeStack: []
    },
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
  });
  const [cols, setCols] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(dummyCols);
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: 1000,
    onGridSelectionChange: onSelected,
    gridSelection: selected,
    onColumnResize: (_col, newSize) => {
      if (newSize > 300) {
        setCols(dummyCols);
      } else {
        setCols([dummyCols[0]]);
      }
    }
  });
};
const GridAddNewRows = function GridAddNewRows() {
  const cols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(getDummyCols, []);
  const [rowsCount, setRowsCount] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(10);
  const onRowAppended = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(() => {
    setRowsCount(r => r + 1);
  }, []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(undefined);
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: rowsCount,
    onRowAppended: onRowAppended,
    onGridSelectionChange: onSelected,
    gridSelection: selected
  });
};
const GridNoTrailingBlankRow = function GridNoTrailingBlankRow() {
  const cols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(getDummyCols, []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(undefined);
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: 100,
    onGridSelectionChange: onSelected,
    gridSelection: selected
  });
};
const MarkdownEdits = function MarkdownEdits() {
  const dummyCols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(() => {
    return [{
      title: "MD short",
      width: 50
    }, {
      title: "MD long",
      width: 50
    }];
  }, []);
  const dummyCells = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(_ref6 => {
    let [col, _row] = _ref6;

    if (col === 0) {
      const editable = {
        data: "text",
        allowOverlay: true,
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Markdown */ .p6.Markdown
      };
      return editable;
    } else if (col === 1) {
      const editable = {
        data: `text really really really long
## H1

- this
- is
- a
- longer
- example
- to
- test
- scroll
- of
- preview
                `,
        allowOverlay: true,
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Markdown */ .p6.Markdown
      };
      return editable;
    }

    const editable = {
      data: "text",
      allowOverlay: true,
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Markdown */ .p6.Markdown
    };
    return editable;
  }, []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)({
    current: {
      cell: [2, 8],
      range: {
        width: 1,
        height: 1,
        x: 2,
        y: 8
      },
      rangeStack: []
    },
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
  });
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: dummyCells,
    columns: dummyCols,
    rows: 1000,
    onGridSelectionChange: onSelected,
    gridSelection: selected
  });
};
const CanEditBoolean = () => {
  const [vals, setVals] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)([false, false]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    columns: [{
      title: "Editable",
      width: 100
    }, {
      title: "Readonly",
      width: 100
    }],
    rows: 1,
    getCellContent: _ref7 => {
      let [col] = _ref7;
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Boolean */ .p6.Boolean,
        readonly: col !== 0,
        allowOverlay: false,
        data: vals[col]
      };
    },
    onCellEdited: (_ref8, newVal) => {
      let [col] = _ref8;

      if (newVal.kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Boolean */ .p6.Boolean) {
        setVals(cv => {
          const f = [...cv];
          f.splice(col, 1, newVal.data);
          return f;
        });
      }
    }
  });
};
;
const SimpleEditable = () => {
  const [vals, setVals] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(() => {
    const result = [];

    for (let i = 0; i < 2000; i++) {
      result.push(["Edit", "Me"]);
    }

    return result;
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    columns: [{
      title: "Column A",
      width: 250
    }, {
      title: "Column B",
      width: 250
    }],
    rows: vals.length,
    getCellContent: _ref9 => {
      let [col, row] = _ref9;
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        allowOverlay: true,
        data: vals[row][col],
        displayData: vals[row][col]
      };
    },
    onCellEdited: (_ref10, newVal) => {
      let [col, row] = _ref10;
      const newVals = [...vals];
      const newRow = [...newVals[row]];

      if (typeof newVal.data === "string") {
        newRow[col] = newVal.data;
      }

      newVals[row] = newRow;
      setVals(newVals);
    }
  });
};
const __namedExportsOrder = ["Simplenotest", "RelationColumn", "Minimal", "Smooth", "ManualControl", "Draggable", "IdealSize", "DynamicAddRemoveColumns", "GridSelectionOutOfRangeNoColumns", "ResizableColumns", "GridSelectionOutOfRangeLessColumnsThanSelection", "GridAddNewRows", "GridNoTrailingBlankRow", "MarkdownEdits", "CanEditBoolean", "SimpleEditable"];

/***/ }),

/***/ "./packages/core/src/data-grid/data-grid.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectedCellnotest": () => (/* binding */ SelectedCellnotest),
/* harmony export */   "SelectedColumnnotest": () => (/* binding */ SelectedColumnnotest),
/* harmony export */   "SelectedRownotest": () => (/* binding */ SelectedRownotest),
/* harmony export */   "Simplenotest": () => (/* binding */ Simplenotest),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _data_grid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid.tsx");
/* harmony import */ var _data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _common_styles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/common/styles.ts");
/* harmony import */ var _cells__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/cells/index.ts");
var __STORY__ = "\nimport * as React from \"react\";\n\nimport { BuilderThemeWrapper } from \"../stories/story-utils\";\nimport DataGrid from \"./data-grid\";\nimport { CompactSelection, GridCellKind, GridSelection } from \"./data-grid-types\";\nimport { getDataEditorTheme } from \"../common/styles\";\nimport type { GetCellRendererCallback } from \"./cells/cell-types\";\nimport { CellRenderers } from \"./cells\";\n\nexport default {\n    title: \"Subcomponents/DataGrid\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <div>\n                <BuilderThemeWrapper width={1800} height={1000}>\n                    <div style={{ position: \"relative\" }}>\n                        <Story />\n                    </div>\n                </BuilderThemeWrapper>\n            </div>\n        ),\n    ],\n};\n\nconst emptyGridSelection: GridSelection = {\n    columns: CompactSelection.empty(),\n    rows: CompactSelection.empty(),\n    current: undefined,\n};\n\nconst getCellRenderer: GetCellRendererCallback = cell => {\n    if (cell.kind === GridCellKind.Custom) return undefined;\n    return CellRenderers[cell.kind] as any;\n};\n\nexport function Simplenotest() {\n    let x = 0;\n\n    const [y, setY] = React.useState(0);\n\n    React.useEffect(() => {\n        let handle = 0;\n        const cb = () => {\n            setY(cv => cv + 1);\n            handle = window.requestAnimationFrame(cb);\n        };\n\n        cb();\n\n        return () => window.cancelAnimationFrame(handle);\n    }, []);\n\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            isFocused={true}\n            cellYOffset={y}\n            isFilling={false}\n            onMouseMove={() => undefined}\n            groupHeaderHeight={0}\n            accessibilityHeight={50}\n            enableGroups={false}\n            selection={emptyGridSelection}\n            rows={100_000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\"].map(\n                t => ({\n                    title: t,\n                    width: 122 + (x += 10),\n                })\n            )}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport function SelectedCellnotest() {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            onMouseMove={() => undefined}\n            accessibilityHeight={50}\n            isFilling={false}\n            cellYOffset={0}\n            groupHeaderHeight={34}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: {\n                    cell: [2, 2],\n                    range: { x: 2, y: 2, width: 1, height: 1 },\n                    rangeStack: [],\n                },\n                columns: CompactSelection.empty(),\n                rows: CompactSelection.empty(),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport function SelectedRownotest() {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            cellYOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            groupHeaderHeight={34}\n            accessibilityHeight={50}\n            isFilling={false}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.fromSingleSelection([2, 4]),\n                columns: CompactSelection.empty(),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport const SelectedColumnnotest = () => {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            cellYOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            accessibilityHeight={50}\n            isFilling={false}\n            groupHeaderHeight={34}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.empty(),\n                columns: CompactSelection.fromSingleSelection([2, 4]),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "Simplenotest": {
    "startLoc": {
      "col": 7,
      "line": 38
    },
    "endLoc": {
      "col": 1,
      "line": 133
    },
    "startBody": {
      "col": 7,
      "line": 38
    },
    "endBody": {
      "col": 1,
      "line": 133
    }
  },
  "SelectedCellnotest": {
    "startLoc": {
      "col": 7,
      "line": 135
    },
    "endLoc": {
      "col": 1,
      "line": 221
    },
    "startBody": {
      "col": 7,
      "line": 135
    },
    "endBody": {
      "col": 1,
      "line": 221
    }
  },
  "SelectedRownotest": {
    "startLoc": {
      "col": 7,
      "line": 223
    },
    "endLoc": {
      "col": 1,
      "line": 305
    },
    "startBody": {
      "col": 7,
      "line": 223
    },
    "endBody": {
      "col": 1,
      "line": 305
    }
  },
  "SelectedColumnnotest": {
    "startLoc": {
      "col": 36,
      "line": 307
    },
    "endLoc": {
      "col": 1,
      "line": 389
    },
    "startBody": {
      "col": 36,
      "line": 307
    },
    "endBody": {
      "col": 1,
      "line": 389
    }
  }
};






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "\nimport * as React from \"react\";\n\nimport { BuilderThemeWrapper } from \"../stories/story-utils\";\nimport DataGrid from \"./data-grid\";\nimport { CompactSelection, GridCellKind, GridSelection } from \"./data-grid-types\";\nimport { getDataEditorTheme } from \"../common/styles\";\nimport type { GetCellRendererCallback } from \"./cells/cell-types\";\nimport { CellRenderers } from \"./cells\";\n\nexport default {\n    title: \"Subcomponents/DataGrid\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <div>\n                <BuilderThemeWrapper width={1800} height={1000}>\n                    <div style={{ position: \"relative\" }}>\n                        <Story />\n                    </div>\n                </BuilderThemeWrapper>\n            </div>\n        ),\n    ],\n};\n\nconst emptyGridSelection: GridSelection = {\n    columns: CompactSelection.empty(),\n    rows: CompactSelection.empty(),\n    current: undefined,\n};\n\nconst getCellRenderer: GetCellRendererCallback = cell => {\n    if (cell.kind === GridCellKind.Custom) return undefined;\n    return CellRenderers[cell.kind] as any;\n};\n\nexport function Simplenotest() {\n    let x = 0;\n\n    const [y, setY] = React.useState(0);\n\n    React.useEffect(() => {\n        let handle = 0;\n        const cb = () => {\n            setY(cv => cv + 1);\n            handle = window.requestAnimationFrame(cb);\n        };\n\n        cb();\n\n        return () => window.cancelAnimationFrame(handle);\n    }, []);\n\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            isFocused={true}\n            cellYOffset={y}\n            isFilling={false}\n            onMouseMove={() => undefined}\n            groupHeaderHeight={0}\n            accessibilityHeight={50}\n            enableGroups={false}\n            selection={emptyGridSelection}\n            rows={100_000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\"].map(\n                t => ({\n                    title: t,\n                    width: 122 + (x += 10),\n                })\n            )}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport function SelectedCellnotest() {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            onMouseMove={() => undefined}\n            accessibilityHeight={50}\n            isFilling={false}\n            cellYOffset={0}\n            groupHeaderHeight={34}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: {\n                    cell: [2, 2],\n                    range: { x: 2, y: 2, width: 1, height: 1 },\n                    rangeStack: [],\n                },\n                columns: CompactSelection.empty(),\n                rows: CompactSelection.empty(),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport function SelectedRownotest() {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            cellYOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            groupHeaderHeight={34}\n            accessibilityHeight={50}\n            isFilling={false}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.fromSingleSelection([2, 4]),\n                columns: CompactSelection.empty(),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport const SelectedColumnnotest = () => {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            cellYOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            accessibilityHeight={50}\n            isFilling={false}\n            groupHeaderHeight={34}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.empty(),\n                columns: CompactSelection.fromSingleSelection([2, 4]),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n};\n",
      "locationsMap": {
        "simplenotest": {
          "startLoc": {
            "col": 7,
            "line": 38
          },
          "endLoc": {
            "col": 1,
            "line": 133
          },
          "startBody": {
            "col": 7,
            "line": 38
          },
          "endBody": {
            "col": 1,
            "line": 133
          }
        },
        "selected-cellnotest": {
          "startLoc": {
            "col": 7,
            "line": 135
          },
          "endLoc": {
            "col": 1,
            "line": 221
          },
          "startBody": {
            "col": 7,
            "line": 135
          },
          "endBody": {
            "col": 1,
            "line": 221
          }
        },
        "selected-rownotest": {
          "startLoc": {
            "col": 7,
            "line": 223
          },
          "endLoc": {
            "col": 1,
            "line": 305
          },
          "startBody": {
            "col": 7,
            "line": 223
          },
          "endBody": {
            "col": 1,
            "line": 305
          }
        },
        "selected-columnnotest": {
          "startLoc": {
            "col": 36,
            "line": 307
          },
          "endLoc": {
            "col": 1,
            "line": 389
          },
          "startBody": {
            "col": 36,
            "line": 307
          },
          "endBody": {
            "col": 1,
            "line": 389
          }
        }
      }
    }
  },
  title: "Subcomponents/DataGrid",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .BuilderThemeWrapper */ .j, {
    width: 1800,
    height: 1000
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      position: "relative"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))))]
});
const emptyGridSelection = {
  columns: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
  rows: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
  current: undefined
};

const getCellRenderer = cell => {
  if (cell.kind === _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Custom */ .p6.Custom) return undefined;
  return _cells__WEBPACK_IMPORTED_MODULE_3__/* .CellRenderers */ .L[cell.kind];
};

const Simplenotest = function Simplenotest() {
  let x = 0;
  const [y, setY] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let handle = 0;

    const cb = () => {
      setY(cv => cv + 1);
      handle = window.requestAnimationFrame(cb);
    };

    cb();
    return () => window.cancelAnimationFrame(handle);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    width: 1800,
    height: 1000,
    cellXOffset: 0,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseMoveRaw: () => undefined,
    onMouseUp: () => undefined,
    smoothScrollX: undefined,
    smoothScrollY: undefined,
    allowResize: undefined,
    canvasRef: undefined,
    disabledRows: undefined,
    eventTargetRef: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    translateX: undefined,
    translateY: undefined,
    dragAndDropState: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    isFocused: true,
    cellYOffset: y,
    isFilling: false,
    onMouseMove: () => undefined,
    groupHeaderHeight: 0,
    accessibilityHeight: 50,
    enableGroups: false,
    selection: emptyGridSelection,
    rows: 100000,
    headerHeight: 44,
    rowHeight: 34,
    columns: ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven"].map(t => ({
      title: t,
      width: 122 + (x += 10)
    })),
    getCellContent: _ref => {
      let [col, row] = _ref;
      return {
        kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        displayData: `${col},${row} Testing things that are way too long`,
        data: `${col},${row} Testing things that are way too long`,
        allowOverlay: false,
        owned: true
      };
    },
    freezeColumns: 0,
    firstColAccessible: true,
    verticalBorder: () => true,
    trailingRowType: "none",
    isResizing: false,
    isDragging: false,
    theme: (0,_common_styles__WEBPACK_IMPORTED_MODULE_5__/* .getDataEditorTheme */ .Zu)()
  });
};
const SelectedCellnotest = function SelectedCellnotest() {
  let x = 0;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    width: 1800,
    height: 1000,
    cellXOffset: 0,
    isFocused: true,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseMoveRaw: () => undefined,
    onMouseUp: () => undefined,
    smoothScrollX: undefined,
    smoothScrollY: undefined,
    allowResize: undefined,
    canvasRef: undefined,
    disabledRows: undefined,
    eventTargetRef: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    translateX: undefined,
    translateY: undefined,
    dragAndDropState: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    onMouseMove: () => undefined,
    accessibilityHeight: 50,
    isFilling: false,
    cellYOffset: 0,
    groupHeaderHeight: 34,
    enableGroups: false,
    rows: 1000,
    headerHeight: 44,
    rowHeight: 34,
    columns: ["One", "Two", "Three", "Four", "Five", "Six", "Seven"].map(t => ({
      title: t,
      width: 122 + (x += 10)
    })),
    getCellContent: _ref2 => {
      let [col, row] = _ref2;
      return {
        kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        displayData: `${col},${row} Testing things that are way too long`,
        data: `${col},${row} Testing things that are way too long`,
        allowOverlay: false,
        owned: true
      };
    },
    selection: {
      current: {
        cell: [2, 2],
        range: {
          x: 2,
          y: 2,
          width: 1,
          height: 1
        },
        rangeStack: []
      },
      columns: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
      rows: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
    },
    freezeColumns: 0,
    firstColAccessible: true,
    verticalBorder: () => true,
    trailingRowType: "none",
    isResizing: false,
    isDragging: false,
    theme: (0,_common_styles__WEBPACK_IMPORTED_MODULE_5__/* .getDataEditorTheme */ .Zu)()
  });
};
const SelectedRownotest = function SelectedRownotest() {
  let x = 0;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    onMouseMove: () => undefined,
    width: 1800,
    height: 1000,
    cellXOffset: 0,
    cellYOffset: 0,
    isFocused: true,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseMoveRaw: () => undefined,
    onMouseUp: () => undefined,
    smoothScrollX: undefined,
    smoothScrollY: undefined,
    allowResize: undefined,
    canvasRef: undefined,
    disabledRows: undefined,
    eventTargetRef: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    translateX: undefined,
    translateY: undefined,
    dragAndDropState: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    groupHeaderHeight: 34,
    accessibilityHeight: 50,
    isFilling: false,
    enableGroups: false,
    rows: 1000,
    headerHeight: 44,
    rowHeight: 34,
    columns: ["One", "Two", "Three", "Four", "Five", "Six", "Seven"].map(t => ({
      title: t,
      width: 122 + (x += 10)
    })),
    getCellContent: _ref3 => {
      let [col, row] = _ref3;
      return {
        kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        displayData: `${col},${row} Testing things that are way too long`,
        data: `${col},${row} Testing things that are way too long`,
        allowOverlay: false,
        owned: true
      };
    },
    selection: {
      current: undefined,
      rows: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.fromSingleSelection */ .EV.fromSingleSelection([2, 4]),
      columns: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
    },
    freezeColumns: 0,
    firstColAccessible: true,
    verticalBorder: () => true,
    trailingRowType: "none",
    isResizing: false,
    isDragging: false,
    theme: (0,_common_styles__WEBPACK_IMPORTED_MODULE_5__/* .getDataEditorTheme */ .Zu)()
  });
};
const SelectedColumnnotest = () => {
  let x = 0;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    onMouseMove: () => undefined,
    width: 1800,
    height: 1000,
    cellXOffset: 0,
    cellYOffset: 0,
    isFocused: true,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseMoveRaw: () => undefined,
    onMouseUp: () => undefined,
    smoothScrollX: undefined,
    smoothScrollY: undefined,
    allowResize: undefined,
    canvasRef: undefined,
    disabledRows: undefined,
    eventTargetRef: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    translateX: undefined,
    translateY: undefined,
    dragAndDropState: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    accessibilityHeight: 50,
    isFilling: false,
    groupHeaderHeight: 34,
    enableGroups: false,
    rows: 1000,
    headerHeight: 44,
    rowHeight: 34,
    columns: ["One", "Two", "Three", "Four", "Five", "Six", "Seven"].map(t => ({
      title: t,
      width: 122 + (x += 10)
    })),
    getCellContent: _ref4 => {
      let [col, row] = _ref4;
      return {
        kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        displayData: `${col},${row} Testing things that are way too long`,
        data: `${col},${row} Testing things that are way too long`,
        allowOverlay: false,
        owned: true
      };
    },
    selection: {
      current: undefined,
      rows: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
      columns: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.fromSingleSelection */ .EV.fromSingleSelection([2, 4])
    },
    freezeColumns: 0,
    firstColAccessible: true,
    verticalBorder: () => true,
    trailingRowType: "none",
    isResizing: false,
    isDragging: false,
    theme: (0,_common_styles__WEBPACK_IMPORTED_MODULE_5__/* .getDataEditorTheme */ .Zu)()
  });
};
const __namedExportsOrder = ["Simplenotest", "SelectedCellnotest", "SelectedRownotest", "SelectedColumnnotest"];

/***/ }),

/***/ "./packages/core/src/docs/00-faq.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FAQ": () => (/* binding */ FAQ),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
var __STORY__ = "import * as React from \"react\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Marked } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const FAQ: React.VFC = () => {\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# FAQ\n\n### Nothing shows up? It crashes when I edit a cell?\n\nPlease read the [Prerequisites section in the docs](https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md).\n\n### Does it work with screen readers and other a11y tools?\n\nYes. Unfortunately none of the primary developers are accessibility users so there are likely flaws in the implementation we are not aware of. Bug reports welcome!\n\n### Does it support my data source?\n\nYes.\n\nData Grid is agnostic about the way you load/store/generate/mutate your data. What it requires is that you tell it which columns you have, how many rows, and to give it a function it can call to get the data for a cell in a specific row and column.\n\n### Does it do sorting?\n\nYes through the [glide-data-grid-source](https://www.npmjs.com/package/@glideapps/glide-data-grid-source) package.\n\n### Does it do search?\n\nYes, built in! There are examples in the storybook.\n\n### Can it filter?\n\nNothing built in yet. It is planned for the \\`glide-data-grid-source\\`.\n\n### Can it do frozen columns?\n\nYes\n\n### Can I render my own cells?\n\nYes\n\n`}\n            </Marked>\n        </DocWrapper>\n    );\n};\n(FAQ as any).storyName = \"00. FAQ\";\n";
var __LOCATIONS_MAP__ = {
  "FAQ": {
    "startLoc": {
      "col": 30,
      "line": 17
    },
    "endLoc": {
      "col": 1,
      "line": 62
    },
    "startBody": {
      "col": 30,
      "line": 17
    },
    "endBody": {
      "col": 1,
      "line": 62
    }
  }
};



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Marked } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const FAQ: React.VFC = () => {\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# FAQ\n\n### Nothing shows up? It crashes when I edit a cell?\n\nPlease read the [Prerequisites section in the docs](https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md).\n\n### Does it work with screen readers and other a11y tools?\n\nYes. Unfortunately none of the primary developers are accessibility users so there are likely flaws in the implementation we are not aware of. Bug reports welcome!\n\n### Does it support my data source?\n\nYes.\n\nData Grid is agnostic about the way you load/store/generate/mutate your data. What it requires is that you tell it which columns you have, how many rows, and to give it a function it can call to get the data for a cell in a specific row and column.\n\n### Does it do sorting?\n\nYes through the [glide-data-grid-source](https://www.npmjs.com/package/@glideapps/glide-data-grid-source) package.\n\n### Does it do search?\n\nYes, built in! There are examples in the storybook.\n\n### Can it filter?\n\nNothing built in yet. It is planned for the \\`glide-data-grid-source\\`.\n\n### Can it do frozen columns?\n\nYes\n\n### Can I render my own cells?\n\nYes\n\n`}\n            </Marked>\n        </DocWrapper>\n    );\n};\n(FAQ as any).storyName = \"00. FAQ\";\n",
      "locationsMap": {
        "faq": {
          "startLoc": {
            "col": 30,
            "line": 17
          },
          "endLoc": {
            "col": 1,
            "line": 62
          },
          "startBody": {
            "col": 30,
            "line": 17
          },
          "endBody": {
            "col": 1,
            "line": 62
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const FAQ = () => {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_2__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_2__/* .Marked */ .M2, null, `
# FAQ

### Nothing shows up? It crashes when I edit a cell?

Please read the [Prerequisites section in the docs](https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md).

### Does it work with screen readers and other a11y tools?

Yes. Unfortunately none of the primary developers are accessibility users so there are likely flaws in the implementation we are not aware of. Bug reports welcome!

### Does it support my data source?

Yes.

Data Grid is agnostic about the way you load/store/generate/mutate your data. What it requires is that you tell it which columns you have, how many rows, and to give it a function it can call to get the data for a cell in a specific row and column.

### Does it do sorting?

Yes through the [glide-data-grid-source](https://www.npmjs.com/package/@glideapps/glide-data-grid-source) package.

### Does it do search?

Yes, built in! There are examples in the storybook.

### Can it filter?

Nothing built in yet. It is planned for the \`glide-data-grid-source\`.

### Can it do frozen columns?

Yes

### Can I render my own cells?

Yes

`));
};
FAQ.storyName = "00. FAQ";
const __namedExportsOrder = ["FAQ"];

/***/ }),

/***/ "./packages/core/src/docs/01-getting-started.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GettingStarted": () => (/* binding */ GettingStarted),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
var __STORY__ = "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const GettingStarted: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: false,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const [rowMarkers, setRowMarkers] = React.useState(false);\n    const [smoothScroll, setSmoothScroll] = React.useState(false);\n    const [verticalBorder, setVerticalBorder] = React.useState(true);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Getting Started\n\nGlide data grid is a powerful but flexible library requiring very few concepts required to get started. The grid will need data, columns, and a \\`getCellContent\\` callback to convert our data into cells on demand. Because the callback is used, there is no need to pre-format the data in any particular way, so long as it can be transformed into a cell. This example uses a flat array of objects.`}\n            </Marked>\n            <Highlight>\n                {`\nconst data = [\n    {\n      \"name\": \"Hines Fowler\",\n      \"company\": \"BUZZNESS\",\n      \"email\": \"hinesfowler@buzzness.com\",\n      \"phone\": \"+1 (869) 405-3127\"\n    },\n    ...rest\n]\n`}\n            </Highlight>\n            <Marked>\n                {`\nThe columns of the data grid may contain many options, including icons, menus, theme overrides, however at their most basic they only require a \\`title\\` and an \\`id\\`. The id is technically optional but it is best not to omit it.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    {\n        title: \"Name\",\n        id: \"name\"\n    },\n    {\n        title: \"Company\",\n        id: \"company\"\n    },\n    {\n        title: \"Email\",\n        id: \"email\"\n    },\n    {\n        title: \"Phone\",\n        id: \"phone\"\n    }\n]\n`}\n            </Highlight>\n            <Marked>\n                {`\nEach column will automatically size based on its contents. If desired the sise of each column can be overridden by setting the width parameter.\n\nFinally the data grid requires a cell fetch callback. This callback should be memoized using \\`React.useCallback\\` or be a static function.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const dataRow = data[row];\n    // dumb but simple way to do this\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const d = dataRow[indexes[col]]\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: false,\n        displayData: d,\n        data: d,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n> Avoid excessive changes to the identity of the \\`getCellContent\\` callback as the grid will re-render from scratch every time it changes.\n\nThat is all the basic requirements put together.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />\n            </Wrapper>\n            <Marked>\n                {`\n# Going further\n\nThere is so much more that can be done:\n\n- Header icons\n- Smooth scrolling\n- Header menus\n- Grouping\n- Row markers\n- Freeze Columns\n- Column reordering and resizing\n- Cell spans\n- Search\n- Copy/paste support\n\nHere are a few to play with.`}\n            </Marked>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={rowMarkers} onChange={e => setRowMarkers(e.target.checked)} /> Row\n                Markers\n            </label>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={smoothScroll} onChange={e => setSmoothScroll(e.target.checked)} />{\" \"}\n                Smooth Scroll\n            </label>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={verticalBorder} onChange={e => setVerticalBorder(e.target.checked)} />{\" \"}\n                Vertical Borders\n            </label>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    verticalBorder={verticalBorder}\n                    smoothScrollX={smoothScroll}\n                    smoothScrollY={smoothScroll}\n                    rowMarkers={rowMarkers ? \"both\" : \"none\"}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(GettingStarted as any).storyName = \"01. Getting Started\";\n";
var __LOCATIONS_MAP__ = {
  "GettingStarted": {
    "startLoc": {
      "col": 41,
      "line": 132
    },
    "endLoc": {
      "col": 1,
      "line": 299
    },
    "startBody": {
      "col": 41,
      "line": 132
    },
    "endBody": {
      "col": 1,
      "line": 299
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const GettingStarted: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: false,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const [rowMarkers, setRowMarkers] = React.useState(false);\n    const [smoothScroll, setSmoothScroll] = React.useState(false);\n    const [verticalBorder, setVerticalBorder] = React.useState(true);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Getting Started\n\nGlide data grid is a powerful but flexible library requiring very few concepts required to get started. The grid will need data, columns, and a \\`getCellContent\\` callback to convert our data into cells on demand. Because the callback is used, there is no need to pre-format the data in any particular way, so long as it can be transformed into a cell. This example uses a flat array of objects.`}\n            </Marked>\n            <Highlight>\n                {`\nconst data = [\n    {\n      \"name\": \"Hines Fowler\",\n      \"company\": \"BUZZNESS\",\n      \"email\": \"hinesfowler@buzzness.com\",\n      \"phone\": \"+1 (869) 405-3127\"\n    },\n    ...rest\n]\n`}\n            </Highlight>\n            <Marked>\n                {`\nThe columns of the data grid may contain many options, including icons, menus, theme overrides, however at their most basic they only require a \\`title\\` and an \\`id\\`. The id is technically optional but it is best not to omit it.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    {\n        title: \"Name\",\n        id: \"name\"\n    },\n    {\n        title: \"Company\",\n        id: \"company\"\n    },\n    {\n        title: \"Email\",\n        id: \"email\"\n    },\n    {\n        title: \"Phone\",\n        id: \"phone\"\n    }\n]\n`}\n            </Highlight>\n            <Marked>\n                {`\nEach column will automatically size based on its contents. If desired the sise of each column can be overridden by setting the width parameter.\n\nFinally the data grid requires a cell fetch callback. This callback should be memoized using \\`React.useCallback\\` or be a static function.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const dataRow = data[row];\n    // dumb but simple way to do this\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const d = dataRow[indexes[col]]\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: false,\n        displayData: d,\n        data: d,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n> Avoid excessive changes to the identity of the \\`getCellContent\\` callback as the grid will re-render from scratch every time it changes.\n\nThat is all the basic requirements put together.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />\n            </Wrapper>\n            <Marked>\n                {`\n# Going further\n\nThere is so much more that can be done:\n\n- Header icons\n- Smooth scrolling\n- Header menus\n- Grouping\n- Row markers\n- Freeze Columns\n- Column reordering and resizing\n- Cell spans\n- Search\n- Copy/paste support\n\nHere are a few to play with.`}\n            </Marked>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={rowMarkers} onChange={e => setRowMarkers(e.target.checked)} /> Row\n                Markers\n            </label>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={smoothScroll} onChange={e => setSmoothScroll(e.target.checked)} />{\" \"}\n                Smooth Scroll\n            </label>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={verticalBorder} onChange={e => setVerticalBorder(e.target.checked)} />{\" \"}\n                Vertical Borders\n            </label>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    verticalBorder={verticalBorder}\n                    smoothScrollX={smoothScroll}\n                    smoothScrollY={smoothScroll}\n                    rowMarkers={rowMarkers ? \"both\" : \"none\"}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(GettingStarted as any).storyName = \"01. Getting Started\";\n",
      "locationsMap": {
        "getting-started": {
          "startLoc": {
            "col": 41,
            "line": 132
          },
          "endLoc": {
            "col": 1,
            "line": 299
          },
          "startBody": {
            "col": 41,
            "line": 132
          },
          "endBody": {
            "col": 1,
            "line": 299
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const GettingStarted = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: false,
      displayData: d,
      data: d
    };
  }, []);
  const [rowMarkers, setRowMarkers] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [smoothScroll, setSmoothScroll] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [verticalBorder, setVerticalBorder] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Getting Started

Glide data grid is a powerful but flexible library requiring very few concepts required to get started. The grid will need data, columns, and a \`getCellContent\` callback to convert our data into cells on demand. Because the callback is used, there is no need to pre-format the data in any particular way, so long as it can be transformed into a cell. This example uses a flat array of objects.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const data = [
    {
      "name": "Hines Fowler",
      "company": "BUZZNESS",
      "email": "hinesfowler@buzzness.com",
      "phone": "+1 (869) 405-3127"
    },
    ...rest
]
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
The columns of the data grid may contain many options, including icons, menus, theme overrides, however at their most basic they only require a \`title\` and an \`id\`. The id is technically optional but it is best not to omit it.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns: GridColumn[] = [
    {
        title: "Name",
        id: "name"
    },
    {
        title: "Company",
        id: "company"
    },
    {
        title: "Email",
        id: "email"
    },
    {
        title: "Phone",
        id: "phone"
    }
]
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
Each column will automatically size based on its contents. If desired the sise of each column can be overridden by setting the width parameter.

Finally the data grid requires a cell fetch callback. This callback should be memoized using \`React.useCallback\` or be a static function.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getContent = React.useCallback((cell: Item): GridCell => {
    const [col, row] = cell;
    const dataRow = data[row];
    // dumb but simple way to do this
    const indexes: (keyof DummyItem)[] = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]]
    return {
        kind: GridCellKind.Text,
        allowOverlay: false,
        displayData: d,
        data: d,
    };
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
> Avoid excessive changes to the identity of the \`getCellContent\` callback as the grid will re-render from scratch every time it changes.

That is all the basic requirements put together.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />;
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    columns: columns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Going further

There is so much more that can be done:

- Header icons
- Smooth scrolling
- Header menus
- Grouping
- Row markers
- Freeze Columns
- Column reordering and resizing
- Cell spans
- Search
- Copy/paste support

Here are a few to play with.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    style: {
      display: "block"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    checked: rowMarkers,
    onChange: e => setRowMarkers(e.target.checked)
  }), " Row Markers"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    style: {
      display: "block"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    checked: smoothScroll,
    onChange: e => setSmoothScroll(e.target.checked)
  }), " ", "Smooth Scroll"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    style: {
      display: "block"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    checked: verticalBorder,
    onChange: e => setVerticalBorder(e.target.checked)
  }), " ", "Vertical Borders"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    verticalBorder: verticalBorder,
    smoothScrollX: smoothScroll,
    smoothScrollY: smoothScroll,
    rowMarkers: rowMarkers ? "both" : "none",
    columns: columns,
    rows: data.length
  })));
};
GettingStarted.storyName = "01. Getting Started";
const __namedExportsOrder = ["GettingStarted"];

/***/ }),

/***/ "./packages/core/src/docs/02-editing-data.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditingData": () => (/* binding */ EditingData),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
var __STORY__ = "import * as React from \"react\";\n\nimport { EditableGridCell, GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst fixedData: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const EditingData: React.VFC = () => {\n    const dataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n        },\n    ]);\n\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = dataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const getFixedContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = fixedData[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {\n        if (newValue.kind !== GridCellKind.Text) {\n            // we only have text cells, might as well just die here.\n            return;\n        }\n\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const [col, row] = cell;\n        const key = indexes[col];\n        dataRef.current[row][key] = newValue.data;\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Editing Data\n\nEditing data is handled via callbacks. Taking the getting started example as a starting point, the \\`getContent\\` callback can be modified to allow editing.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const dataRow = data[row];\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const d = dataRow[indexes[col]];\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        readonly: false,\n        displayData: d,\n        data: d,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n\\`allowOverlay\\` has been set to true. This allows the overlay to come up. For explanatory purposes the \\`readonly\\` field is being set to false. This is the default value, setting it to true would allow the overlay to come up but not allow editing.`}\n            </Marked>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={getFixedContent} columns={columns} rows={dataRef.current.length} />\n            </Wrapper>\n            <Marked>\n                {`\n> You can see the editor now, but the data is not saved.\n\nImplementing the \\`onCellEdited\\` callback allows responding to cell edit events. Edit events pass back a mutated version of the original \\`GridCell\\` returned from \\`getContent\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {\n    if (newValue.kind !== GridCellKind.Text) {\n        // we only have text cells, might as well just die here.\n        return;\n    }\n\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const [col, row] = cell;\n    const key = indexes[col];\n    data[row][key] = newValue.data;\n}, []);`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    onCellEdited={onCellEdited}\n                    columns={columns}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(EditingData as any).storyName = \"02. Editing Data\";\n";
var __LOCATIONS_MAP__ = {
  "EditingData": {
    "startLoc": {
      "col": 38,
      "line": 132
    },
    "endLoc": {
      "col": 1,
      "line": 359
    },
    "startBody": {
      "col": 38,
      "line": 132
    },
    "endBody": {
      "col": 1,
      "line": 359
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { EditableGridCell, GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst fixedData: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const EditingData: React.VFC = () => {\n    const dataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n        },\n    ]);\n\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = dataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const getFixedContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = fixedData[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {\n        if (newValue.kind !== GridCellKind.Text) {\n            // we only have text cells, might as well just die here.\n            return;\n        }\n\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const [col, row] = cell;\n        const key = indexes[col];\n        dataRef.current[row][key] = newValue.data;\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Editing Data\n\nEditing data is handled via callbacks. Taking the getting started example as a starting point, the \\`getContent\\` callback can be modified to allow editing.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const dataRow = data[row];\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const d = dataRow[indexes[col]];\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        readonly: false,\n        displayData: d,\n        data: d,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n\\`allowOverlay\\` has been set to true. This allows the overlay to come up. For explanatory purposes the \\`readonly\\` field is being set to false. This is the default value, setting it to true would allow the overlay to come up but not allow editing.`}\n            </Marked>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={getFixedContent} columns={columns} rows={dataRef.current.length} />\n            </Wrapper>\n            <Marked>\n                {`\n> You can see the editor now, but the data is not saved.\n\nImplementing the \\`onCellEdited\\` callback allows responding to cell edit events. Edit events pass back a mutated version of the original \\`GridCell\\` returned from \\`getContent\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {\n    if (newValue.kind !== GridCellKind.Text) {\n        // we only have text cells, might as well just die here.\n        return;\n    }\n\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const [col, row] = cell;\n    const key = indexes[col];\n    data[row][key] = newValue.data;\n}, []);`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    onCellEdited={onCellEdited}\n                    columns={columns}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(EditingData as any).storyName = \"02. Editing Data\";\n",
      "locationsMap": {
        "editing-data": {
          "startLoc": {
            "col": 38,
            "line": 132
          },
          "endLoc": {
            "col": 1,
            "line": 359
          },
          "startBody": {
            "col": 38,
            "line": 132
          },
          "endBody": {
            "col": 1,
            "line": 359
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const fixedData = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const EditingData = () => {
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([{
    name: "Deidre Morris",
    company: "GONKLE",
    email: "deidremorris@gonkle.com",
    phone: "+1 (867) 507-3332"
  }, {
    name: "Sheryl Craig",
    company: "EVENTAGE",
    email: "sherylcraig@eventage.com",
    phone: "+1 (869) 520-2227"
  }, {
    name: "Lidia Bowers",
    company: "ANOCHA",
    email: "lidiabowers@anocha.com",
    phone: "+1 (808) 414-3826"
  }, {
    name: "Jones Norton",
    company: "REPETWIRE",
    email: "jonesnorton@repetwire.com",
    phone: "+1 (875) 582-3320"
  }, {
    name: "Lula Bruce",
    company: "COMDOM",
    email: "lulabruce@comdom.com",
    phone: "+1 (873) 452-2472"
  }, {
    name: "Larsen Montgomery",
    company: "SQUISH",
    email: "larsenmontgomery@squish.com",
    phone: "+1 (893) 482-3651"
  }, {
    name: "Becky Bright",
    company: "COMCUR",
    email: "beckybright@comcur.com",
    phone: "+1 (879) 494-2331"
  }, {
    name: "Charlotte Rowland",
    company: "FROLIX",
    email: "charlotterowland@frolix.com",
    phone: "+1 (861) 439-2134"
  }, {
    name: "Sonya Hensley",
    company: "GEEKETRON",
    email: "sonyahensley@geeketron.com",
    phone: "+1 (802) 553-2194"
  }, {
    name: "Stephenson Guthrie",
    company: "EXOSWITCH",
    email: "stephensonguthrie@exoswitch.com",
    phone: "+1 (903) 449-3271"
  }, {
    name: "Mcmillan Cline",
    company: "TURNLING",
    email: "mcmillancline@turnling.com",
    phone: "+1 (982) 496-2454"
  }, {
    name: "Kemp Davis",
    company: "TETRATREX",
    email: "kempdavis@tetratrex.com",
    phone: "+1 (859) 594-2982"
  }, {
    name: "Matilda Levy",
    company: "SLOFAST",
    email: "matildalevy@slofast.com",
    phone: "+1 (841) 521-2444"
  }, {
    name: "Hattie Simpson",
    company: "COMTRAK",
    email: "hattiesimpson@comtrak.com",
    phone: "+1 (962) 587-3805"
  }, {
    name: "Kinney Munoz",
    company: "IDETICA",
    email: "kinneymunoz@idetica.com",
    phone: "+1 (921) 513-2012"
  }, {
    name: "Lambert Raymond",
    company: "TURNABOUT",
    email: "lambertraymond@turnabout.com",
    phone: "+1 (919) 519-2442"
  }, {
    name: "Bryant Dunlap",
    company: "BYTREX",
    email: "bryantdunlap@bytrex.com",
    phone: "+1 (872) 583-2883"
  }]);
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = dataRef.current[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const getFixedContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = fixedData[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const onCellEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newValue) => {
    if (newValue.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text) {
      return;
    }

    const indexes = ["name", "company", "email", "phone"];
    const [col, row] = cell;
    const key = indexes[col];
    dataRef.current[row][key] = newValue.data;
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Editing Data

Editing data is handled via callbacks. Taking the getting started example as a starting point, the \`getContent\` callback can be modified to allow editing.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getContent = React.useCallback((cell: Item): GridCell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes: (keyof DummyItem)[] = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
        kind: GridCellKind.Text,
        allowOverlay: true,
        readonly: false,
        displayData: d,
        data: d,
    };
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
\`allowOverlay\` has been set to true. This allows the overlay to come up. For explanatory purposes the \`readonly\` field is being set to false. This is the default value, setting it to true would allow the overlay to come up but not allow editing.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getFixedContent,
    columns: columns,
    rows: dataRef.current.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
> You can see the editor now, but the data is not saved.

Implementing the \`onCellEdited\` callback allows responding to cell edit events. Edit events pass back a mutated version of the original \`GridCell\` returned from \`getContent\`.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {
    if (newValue.kind !== GridCellKind.Text) {
        // we only have text cells, might as well just die here.
        return;
    }

    const indexes: (keyof DummyItem)[] = ["name", "company", "email", "phone"];
    const [col, row] = cell;
    const key = indexes[col];
    data[row][key] = newValue.data;
}, []);`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    onCellEdited: onCellEdited,
    columns: columns,
    rows: dataRef.current.length
  })));
};
EditingData.storyName = "02. Editing Data";
const __namedExportsOrder = ["EditingData"];

/***/ }),

/***/ "./packages/core/src/docs/03-grid-column.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GridColumns": () => (/* binding */ GridColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
var __STORY__ = "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumnIcon, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const GridColumns: React.VFC = () => {\n    const basicGetCellContent = React.useCallback((cell: Item): GridCell => {\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: false,\n            displayData: cell.toString(),\n            data: cell.toString(),\n        };\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return [\n            {\n                title: \"First\",\n                width: 150,\n            },\n            {\n                title: \"Second\",\n                width: 150,\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Basic usage\n\n> The \\`GridColumn[]\\` passed to the \\`DataEditor\\` in the \\`columns\\` property should be memoized to avoid excessive re-rendering. These samples may not do this for the sake of brevity.\n\nThere are only two mandatory properties for each \\`GridColumn\\`: \\`title\\` and \\`id\\`. The id should be a stable id and not the index of the column. Additionally a \\`width\\` property can be provided which represents the width of the column in pixels. If a width is provided the id may be omited. This may change in a future version.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"First\", id: \"first\", width: 150 },\n    { title: \"Second\", id: \"second\", width: 150 }\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={basicGetCellContent} columns={cols} rows={50} />\n            </Wrapper>\n\n            <Marked>\n                {`\n# Header icons\n\nDefault header icons are available. They can also be reaplced by passing a new map to the \\`headerIcons\\` property.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"Name\", id: \"name\", width: 250, icon: GridColumnIcon.HeaderString, \n      overlayIcon: GridColumnIcon.RowOwnerOverlay \n    },\n    { title: \"Age\", id: \"age\", width: 100, icon: GridColumnIcon.HeaderNumber },\n    { title: \"Avatar\", id: \"avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={basicGetCellContent}\n                    columns={[\n                        {\n                            title: \"Name\",\n                            width: 250,\n                            icon: GridColumnIcon.HeaderString,\n                            overlayIcon: GridColumnIcon.RowOwnerOverlay,\n                        },\n                        { title: \"Age\", width: 120, icon: GridColumnIcon.HeaderNumber },\n                        { title: \"Avatar\", width: 100, icon: GridColumnIcon.HeaderImage },\n                    ]}\n                    rows={50}\n                />\n            </Wrapper>\n\n            <Marked>\n                {`\n# Header theming\n\nHeaders can be provided with individual theme overrides which themes both the header and its column cells.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"Name\", id=\"name\", width: 250, icon: GridColumnIcon.HeaderString },\n    { title: \"Age\", id=\"age\", width: 100, icon: GridColumnIcon.HeaderNumber, themeOverride: {\n        bgIconHeader: \"#00967d\",\n        textDark: \"#00c5a4\",\n        textHeader: \"#00c5a4\",\n    } },\n    { title: \"Avatar\", id=\"avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={basicGetCellContent}\n                    columns={[\n                        { title: \"Name\", width: 250, icon: GridColumnIcon.HeaderString },\n                        {\n                            title: \"Age\",\n                            width: 100,\n                            icon: GridColumnIcon.HeaderNumber,\n                            themeOverride: {\n                                bgIconHeader: \"#00967d\",\n                                textDark: \"#00c5a4\",\n                                textHeader: \"#00c5a4\",\n                            },\n                        },\n                        { title: \"Avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n                    ]}\n                    rows={50}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(GridColumns as any).storyName = \"03. Grid Columns\";\n";
var __LOCATIONS_MAP__ = {
  "GridColumns": {
    "startLoc": {
      "col": 38,
      "line": 20
    },
    "endLoc": {
      "col": 1,
      "line": 146
    },
    "startBody": {
      "col": 38,
      "line": 20
    },
    "endBody": {
      "col": 1,
      "line": 146
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumnIcon, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const GridColumns: React.VFC = () => {\n    const basicGetCellContent = React.useCallback((cell: Item): GridCell => {\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: false,\n            displayData: cell.toString(),\n            data: cell.toString(),\n        };\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return [\n            {\n                title: \"First\",\n                width: 150,\n            },\n            {\n                title: \"Second\",\n                width: 150,\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Basic usage\n\n> The \\`GridColumn[]\\` passed to the \\`DataEditor\\` in the \\`columns\\` property should be memoized to avoid excessive re-rendering. These samples may not do this for the sake of brevity.\n\nThere are only two mandatory properties for each \\`GridColumn\\`: \\`title\\` and \\`id\\`. The id should be a stable id and not the index of the column. Additionally a \\`width\\` property can be provided which represents the width of the column in pixels. If a width is provided the id may be omited. This may change in a future version.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"First\", id: \"first\", width: 150 },\n    { title: \"Second\", id: \"second\", width: 150 }\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={basicGetCellContent} columns={cols} rows={50} />\n            </Wrapper>\n\n            <Marked>\n                {`\n# Header icons\n\nDefault header icons are available. They can also be reaplced by passing a new map to the \\`headerIcons\\` property.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"Name\", id: \"name\", width: 250, icon: GridColumnIcon.HeaderString, \n      overlayIcon: GridColumnIcon.RowOwnerOverlay \n    },\n    { title: \"Age\", id: \"age\", width: 100, icon: GridColumnIcon.HeaderNumber },\n    { title: \"Avatar\", id: \"avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={basicGetCellContent}\n                    columns={[\n                        {\n                            title: \"Name\",\n                            width: 250,\n                            icon: GridColumnIcon.HeaderString,\n                            overlayIcon: GridColumnIcon.RowOwnerOverlay,\n                        },\n                        { title: \"Age\", width: 120, icon: GridColumnIcon.HeaderNumber },\n                        { title: \"Avatar\", width: 100, icon: GridColumnIcon.HeaderImage },\n                    ]}\n                    rows={50}\n                />\n            </Wrapper>\n\n            <Marked>\n                {`\n# Header theming\n\nHeaders can be provided with individual theme overrides which themes both the header and its column cells.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"Name\", id=\"name\", width: 250, icon: GridColumnIcon.HeaderString },\n    { title: \"Age\", id=\"age\", width: 100, icon: GridColumnIcon.HeaderNumber, themeOverride: {\n        bgIconHeader: \"#00967d\",\n        textDark: \"#00c5a4\",\n        textHeader: \"#00c5a4\",\n    } },\n    { title: \"Avatar\", id=\"avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={basicGetCellContent}\n                    columns={[\n                        { title: \"Name\", width: 250, icon: GridColumnIcon.HeaderString },\n                        {\n                            title: \"Age\",\n                            width: 100,\n                            icon: GridColumnIcon.HeaderNumber,\n                            themeOverride: {\n                                bgIconHeader: \"#00967d\",\n                                textDark: \"#00c5a4\",\n                                textHeader: \"#00c5a4\",\n                            },\n                        },\n                        { title: \"Avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n                    ]}\n                    rows={50}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(GridColumns as any).storyName = \"03. Grid Columns\";\n",
      "locationsMap": {
        "grid-columns": {
          "startLoc": {
            "col": 38,
            "line": 20
          },
          "endLoc": {
            "col": 1,
            "line": 146
          },
          "startBody": {
            "col": 38,
            "line": 20
          },
          "endBody": {
            "col": 1,
            "line": 146
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const GridColumns = () => {
  const basicGetCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: false,
      displayData: cell.toString(),
      data: cell.toString()
    };
  }, []);
  const cols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "First",
      width: 150
    }, {
      title: "Second",
      width: 150
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Basic usage

> The \`GridColumn[]\` passed to the \`DataEditor\` in the \`columns\` property should be memoized to avoid excessive re-rendering. These samples may not do this for the sake of brevity.

There are only two mandatory properties for each \`GridColumn\`: \`title\` and \`id\`. The id should be a stable id and not the index of the column. Additionally a \`width\` property can be provided which represents the width of the column in pixels. If a width is provided the id may be omited. This may change in a future version.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns: GridColumn[] = [
    { title: "First", id: "first", width: 150 },
    { title: "Second", id: "second", width: 150 }
];

<DataEditor {...rest} columns={columns} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: basicGetCellContent,
    columns: cols,
    rows: 50
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Header icons

Default header icons are available. They can also be reaplced by passing a new map to the \`headerIcons\` property.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns: GridColumn[] = [
    { title: "Name", id: "name", width: 250, icon: GridColumnIcon.HeaderString, 
      overlayIcon: GridColumnIcon.RowOwnerOverlay 
    },
    { title: "Age", id: "age", width: 100, icon: GridColumnIcon.HeaderNumber },
    { title: "Avatar", id: "avatar", width: 80, icon: GridColumnIcon.HeaderImage },
];

<DataEditor {...rest} columns={columns} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: basicGetCellContent,
    columns: [{
      title: "Name",
      width: 250,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
      overlayIcon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.RowOwnerOverlay */ .PE.RowOwnerOverlay
    }, {
      title: "Age",
      width: 120,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderNumber */ .PE.HeaderNumber
    }, {
      title: "Avatar",
      width: 100,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderImage */ .PE.HeaderImage
    }],
    rows: 50
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Header theming

Headers can be provided with individual theme overrides which themes both the header and its column cells.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns: GridColumn[] = [
    { title: "Name", id="name", width: 250, icon: GridColumnIcon.HeaderString },
    { title: "Age", id="age", width: 100, icon: GridColumnIcon.HeaderNumber, themeOverride: {
        bgIconHeader: "#00967d",
        textDark: "#00c5a4",
        textHeader: "#00c5a4",
    } },
    { title: "Avatar", id="avatar", width: 80, icon: GridColumnIcon.HeaderImage },
];

<DataEditor {...rest} columns={columns} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: basicGetCellContent,
    columns: [{
      title: "Name",
      width: 250,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderString */ .PE.HeaderString
    }, {
      title: "Age",
      width: 100,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderNumber */ .PE.HeaderNumber,
      themeOverride: {
        bgIconHeader: "#00967d",
        textDark: "#00c5a4",
        textHeader: "#00c5a4"
      }
    }, {
      title: "Avatar",
      width: 80,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderImage */ .PE.HeaderImage
    }],
    rows: 50
  })));
};
GridColumns.storyName = "03. Grid Columns";
const __namedExportsOrder = ["GridColumns"];

/***/ }),

/***/ "./packages/core/src/docs/04-streaming-data.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StreamingData": () => (/* binding */ StreamingData),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
var __STORY__ = "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor, DataEditorRef } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n    update: number;\n}\n\nexport const StreamingData: React.VFC = () => {\n    const highlightDataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n            update: 0,\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n            update: 0,\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n            update: 0,\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n            update: 0,\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n            update: 0,\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n            update: 0,\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n            update: 0,\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n            update: 0,\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n            update: 0,\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n            update: 0,\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n            update: 0,\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n            update: 0,\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n            update: 0,\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n            update: 0,\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n            update: 0,\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n            update: 0,\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n            update: 0,\n        },\n    ]);\n\n    const dataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n            update: 0,\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n            update: 0,\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n            update: 0,\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n            update: 0,\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n            update: 0,\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n            update: 0,\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n            update: 0,\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n            update: 0,\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n            update: 0,\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n            update: 0,\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n            update: 0,\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n            update: 0,\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n            update: 0,\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n            update: 0,\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n            update: 0,\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n            update: 0,\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n            update: 0,\n        },\n    ]);\n\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = dataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d as string,\n            data: d as string,\n        };\n    }, []);\n\n    const getContentHighlighted = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = highlightDataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d as string,\n            data: d as string,\n            lastUpdated: dataRow.update,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const ref = React.useRef<DataEditorRef | null>(null);\n\n    const onButtonClick = () => {\n        // Swap the emails of 2 random people\n        const randomRow1 = Math.floor(Math.random() * dataRef.current.length);\n        const randomRow2 = Math.floor(Math.random() * dataRef.current.length);\n\n        const temp = dataRef.current[randomRow1].email;\n        dataRef.current[randomRow1].email = dataRef.current[randomRow2].email;\n        dataRef.current[randomRow2].email = temp;\n\n        ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r] })));\n    };\n\n    const onHighlightButtonClick = () => {\n        // Swap the emails of 2 random people\n        const randomRow1 = Math.floor(Math.random() * highlightDataRef.current.length);\n        const randomRow2 = Math.floor(Math.random() * highlightDataRef.current.length);\n\n        const temp = highlightDataRef.current[randomRow1].email;\n        highlightDataRef.current[randomRow1].email = highlightDataRef.current[randomRow2].email;\n        highlightDataRef.current[randomRow2].email = temp;\n\n        highlightDataRef.current[randomRow1].update = performance.now();\n        highlightDataRef.current[randomRow2].update = performance.now();\n\n        ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r] })));\n    };\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Streaming Data\n\n> Glide Data Grid is capable of streaming hundreds of thousands of updates per second. You won't need that, but every millisecond the grid doesn't take is another millisecond your app has to process data and remain responsive.\n\nStreaming data is done as a two step process.\n\n1. Update the data backing store.\n2. Inform the Glide Data Grid of the changed data.\n\nThe Grid does not care of the data is coming down over the wire or being generated locally. Informing the grid of changes to the data is done by calling the \\`updateCells\\` function on a bound ref.`}\n            </Marked>\n            <Highlight>\n                {`\nconst ref = React.useRef<DataEditorRef | null>(null);\n\nreturn <DataEditor {...rest} ref={ref} />\n`}\n            </Highlight>\n            <Marked>\n                {`\nData can now be updated by calling mutating the backing store and using the ref to update cells.`}\n            </Marked>\n            <Highlight>\n                {`\nconst onButtonClick = () => {\n    // Swap the emails of 2 random people\n    const randomRow1 = Math.floor(Math.random()*data.length);\n    const randomRow2 = Math.floor(Math.random()*data.length);\n\n    const temp = data[randomRow1].email;\n    data[randomRow1].email = data[randomRow2].email;\n    data[randomRow2].email = temp;\n\n    ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r]})));\n}\n`}\n            </Highlight>\n            <button onClick={onButtonClick}>Swappy Swappy</button>\n            <Wrapper height={400}>\n                <DataEditor ref={ref} getCellContent={getContent} columns={columns} rows={dataRef.current.length} />\n            </Wrapper>\n            <Marked>\n                {`\n## Showing updates\n        \nIf \\`getContent\\` is updated to also return the last time a cell was updated the data grid will highlight cells as they update.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const data = fetchDataFromBackend(col, row);\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        displayData: data.value,\n        data: data.value,\n        lastUpdated: data.updatedAt,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n> Note that timestamps are based on performance.now() and not Date.now(). This is to ensure that timestamps always increase monotonically and nothing weird will happen if the clock adjusts.`}\n            </Marked>\n            <button style={{ marginTop: 16 }} onClick={onHighlightButtonClick}>\n                Swapity Swap Swap\n            </button>\n            <Wrapper height={600}>\n                <DataEditor\n                    ref={ref}\n                    getCellContent={getContentHighlighted}\n                    columns={columns}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(StreamingData as any).storyName = \"04. Streaming Data\";\n";
var __LOCATIONS_MAP__ = {
  "StreamingData": {
    "startLoc": {
      "col": 40,
      "line": 28
    },
    "endLoc": {
      "col": 1,
      "line": 433
    },
    "startBody": {
      "col": 40,
      "line": 28
    },
    "endBody": {
      "col": 1,
      "line": 433
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor, DataEditorRef } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n    update: number;\n}\n\nexport const StreamingData: React.VFC = () => {\n    const highlightDataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n            update: 0,\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n            update: 0,\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n            update: 0,\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n            update: 0,\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n            update: 0,\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n            update: 0,\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n            update: 0,\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n            update: 0,\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n            update: 0,\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n            update: 0,\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n            update: 0,\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n            update: 0,\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n            update: 0,\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n            update: 0,\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n            update: 0,\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n            update: 0,\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n            update: 0,\n        },\n    ]);\n\n    const dataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n            update: 0,\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n            update: 0,\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n            update: 0,\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n            update: 0,\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n            update: 0,\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n            update: 0,\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n            update: 0,\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n            update: 0,\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n            update: 0,\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n            update: 0,\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n            update: 0,\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n            update: 0,\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n            update: 0,\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n            update: 0,\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n            update: 0,\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n            update: 0,\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n            update: 0,\n        },\n    ]);\n\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = dataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d as string,\n            data: d as string,\n        };\n    }, []);\n\n    const getContentHighlighted = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = highlightDataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d as string,\n            data: d as string,\n            lastUpdated: dataRow.update,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const ref = React.useRef<DataEditorRef | null>(null);\n\n    const onButtonClick = () => {\n        // Swap the emails of 2 random people\n        const randomRow1 = Math.floor(Math.random() * dataRef.current.length);\n        const randomRow2 = Math.floor(Math.random() * dataRef.current.length);\n\n        const temp = dataRef.current[randomRow1].email;\n        dataRef.current[randomRow1].email = dataRef.current[randomRow2].email;\n        dataRef.current[randomRow2].email = temp;\n\n        ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r] })));\n    };\n\n    const onHighlightButtonClick = () => {\n        // Swap the emails of 2 random people\n        const randomRow1 = Math.floor(Math.random() * highlightDataRef.current.length);\n        const randomRow2 = Math.floor(Math.random() * highlightDataRef.current.length);\n\n        const temp = highlightDataRef.current[randomRow1].email;\n        highlightDataRef.current[randomRow1].email = highlightDataRef.current[randomRow2].email;\n        highlightDataRef.current[randomRow2].email = temp;\n\n        highlightDataRef.current[randomRow1].update = performance.now();\n        highlightDataRef.current[randomRow2].update = performance.now();\n\n        ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r] })));\n    };\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Streaming Data\n\n> Glide Data Grid is capable of streaming hundreds of thousands of updates per second. You won't need that, but every millisecond the grid doesn't take is another millisecond your app has to process data and remain responsive.\n\nStreaming data is done as a two step process.\n\n1. Update the data backing store.\n2. Inform the Glide Data Grid of the changed data.\n\nThe Grid does not care of the data is coming down over the wire or being generated locally. Informing the grid of changes to the data is done by calling the \\`updateCells\\` function on a bound ref.`}\n            </Marked>\n            <Highlight>\n                {`\nconst ref = React.useRef<DataEditorRef | null>(null);\n\nreturn <DataEditor {...rest} ref={ref} />\n`}\n            </Highlight>\n            <Marked>\n                {`\nData can now be updated by calling mutating the backing store and using the ref to update cells.`}\n            </Marked>\n            <Highlight>\n                {`\nconst onButtonClick = () => {\n    // Swap the emails of 2 random people\n    const randomRow1 = Math.floor(Math.random()*data.length);\n    const randomRow2 = Math.floor(Math.random()*data.length);\n\n    const temp = data[randomRow1].email;\n    data[randomRow1].email = data[randomRow2].email;\n    data[randomRow2].email = temp;\n\n    ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r]})));\n}\n`}\n            </Highlight>\n            <button onClick={onButtonClick}>Swappy Swappy</button>\n            <Wrapper height={400}>\n                <DataEditor ref={ref} getCellContent={getContent} columns={columns} rows={dataRef.current.length} />\n            </Wrapper>\n            <Marked>\n                {`\n## Showing updates\n        \nIf \\`getContent\\` is updated to also return the last time a cell was updated the data grid will highlight cells as they update.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const data = fetchDataFromBackend(col, row);\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        displayData: data.value,\n        data: data.value,\n        lastUpdated: data.updatedAt,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n> Note that timestamps are based on performance.now() and not Date.now(). This is to ensure that timestamps always increase monotonically and nothing weird will happen if the clock adjusts.`}\n            </Marked>\n            <button style={{ marginTop: 16 }} onClick={onHighlightButtonClick}>\n                Swapity Swap Swap\n            </button>\n            <Wrapper height={600}>\n                <DataEditor\n                    ref={ref}\n                    getCellContent={getContentHighlighted}\n                    columns={columns}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(StreamingData as any).storyName = \"04. Streaming Data\";\n",
      "locationsMap": {
        "streaming-data": {
          "startLoc": {
            "col": 40,
            "line": 28
          },
          "endLoc": {
            "col": 1,
            "line": 433
          },
          "startBody": {
            "col": 40,
            "line": 28
          },
          "endBody": {
            "col": 1,
            "line": 433
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const StreamingData = () => {
  const highlightDataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([{
    name: "Deidre Morris",
    company: "GONKLE",
    email: "deidremorris@gonkle.com",
    phone: "+1 (867) 507-3332",
    update: 0
  }, {
    name: "Sheryl Craig",
    company: "EVENTAGE",
    email: "sherylcraig@eventage.com",
    phone: "+1 (869) 520-2227",
    update: 0
  }, {
    name: "Lidia Bowers",
    company: "ANOCHA",
    email: "lidiabowers@anocha.com",
    phone: "+1 (808) 414-3826",
    update: 0
  }, {
    name: "Jones Norton",
    company: "REPETWIRE",
    email: "jonesnorton@repetwire.com",
    phone: "+1 (875) 582-3320",
    update: 0
  }, {
    name: "Lula Bruce",
    company: "COMDOM",
    email: "lulabruce@comdom.com",
    phone: "+1 (873) 452-2472",
    update: 0
  }, {
    name: "Larsen Montgomery",
    company: "SQUISH",
    email: "larsenmontgomery@squish.com",
    phone: "+1 (893) 482-3651",
    update: 0
  }, {
    name: "Becky Bright",
    company: "COMCUR",
    email: "beckybright@comcur.com",
    phone: "+1 (879) 494-2331",
    update: 0
  }, {
    name: "Charlotte Rowland",
    company: "FROLIX",
    email: "charlotterowland@frolix.com",
    phone: "+1 (861) 439-2134",
    update: 0
  }, {
    name: "Sonya Hensley",
    company: "GEEKETRON",
    email: "sonyahensley@geeketron.com",
    phone: "+1 (802) 553-2194",
    update: 0
  }, {
    name: "Stephenson Guthrie",
    company: "EXOSWITCH",
    email: "stephensonguthrie@exoswitch.com",
    phone: "+1 (903) 449-3271",
    update: 0
  }, {
    name: "Mcmillan Cline",
    company: "TURNLING",
    email: "mcmillancline@turnling.com",
    phone: "+1 (982) 496-2454",
    update: 0
  }, {
    name: "Kemp Davis",
    company: "TETRATREX",
    email: "kempdavis@tetratrex.com",
    phone: "+1 (859) 594-2982",
    update: 0
  }, {
    name: "Matilda Levy",
    company: "SLOFAST",
    email: "matildalevy@slofast.com",
    phone: "+1 (841) 521-2444",
    update: 0
  }, {
    name: "Hattie Simpson",
    company: "COMTRAK",
    email: "hattiesimpson@comtrak.com",
    phone: "+1 (962) 587-3805",
    update: 0
  }, {
    name: "Kinney Munoz",
    company: "IDETICA",
    email: "kinneymunoz@idetica.com",
    phone: "+1 (921) 513-2012",
    update: 0
  }, {
    name: "Lambert Raymond",
    company: "TURNABOUT",
    email: "lambertraymond@turnabout.com",
    phone: "+1 (919) 519-2442",
    update: 0
  }, {
    name: "Bryant Dunlap",
    company: "BYTREX",
    email: "bryantdunlap@bytrex.com",
    phone: "+1 (872) 583-2883",
    update: 0
  }]);
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([{
    name: "Deidre Morris",
    company: "GONKLE",
    email: "deidremorris@gonkle.com",
    phone: "+1 (867) 507-3332",
    update: 0
  }, {
    name: "Sheryl Craig",
    company: "EVENTAGE",
    email: "sherylcraig@eventage.com",
    phone: "+1 (869) 520-2227",
    update: 0
  }, {
    name: "Lidia Bowers",
    company: "ANOCHA",
    email: "lidiabowers@anocha.com",
    phone: "+1 (808) 414-3826",
    update: 0
  }, {
    name: "Jones Norton",
    company: "REPETWIRE",
    email: "jonesnorton@repetwire.com",
    phone: "+1 (875) 582-3320",
    update: 0
  }, {
    name: "Lula Bruce",
    company: "COMDOM",
    email: "lulabruce@comdom.com",
    phone: "+1 (873) 452-2472",
    update: 0
  }, {
    name: "Larsen Montgomery",
    company: "SQUISH",
    email: "larsenmontgomery@squish.com",
    phone: "+1 (893) 482-3651",
    update: 0
  }, {
    name: "Becky Bright",
    company: "COMCUR",
    email: "beckybright@comcur.com",
    phone: "+1 (879) 494-2331",
    update: 0
  }, {
    name: "Charlotte Rowland",
    company: "FROLIX",
    email: "charlotterowland@frolix.com",
    phone: "+1 (861) 439-2134",
    update: 0
  }, {
    name: "Sonya Hensley",
    company: "GEEKETRON",
    email: "sonyahensley@geeketron.com",
    phone: "+1 (802) 553-2194",
    update: 0
  }, {
    name: "Stephenson Guthrie",
    company: "EXOSWITCH",
    email: "stephensonguthrie@exoswitch.com",
    phone: "+1 (903) 449-3271",
    update: 0
  }, {
    name: "Mcmillan Cline",
    company: "TURNLING",
    email: "mcmillancline@turnling.com",
    phone: "+1 (982) 496-2454",
    update: 0
  }, {
    name: "Kemp Davis",
    company: "TETRATREX",
    email: "kempdavis@tetratrex.com",
    phone: "+1 (859) 594-2982",
    update: 0
  }, {
    name: "Matilda Levy",
    company: "SLOFAST",
    email: "matildalevy@slofast.com",
    phone: "+1 (841) 521-2444",
    update: 0
  }, {
    name: "Hattie Simpson",
    company: "COMTRAK",
    email: "hattiesimpson@comtrak.com",
    phone: "+1 (962) 587-3805",
    update: 0
  }, {
    name: "Kinney Munoz",
    company: "IDETICA",
    email: "kinneymunoz@idetica.com",
    phone: "+1 (921) 513-2012",
    update: 0
  }, {
    name: "Lambert Raymond",
    company: "TURNABOUT",
    email: "lambertraymond@turnabout.com",
    phone: "+1 (919) 519-2442",
    update: 0
  }, {
    name: "Bryant Dunlap",
    company: "BYTREX",
    email: "bryantdunlap@bytrex.com",
    phone: "+1 (872) 583-2883",
    update: 0
  }]);
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = dataRef.current[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const getContentHighlighted = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = highlightDataRef.current[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d,
      lastUpdated: dataRow.update
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);

  const onButtonClick = () => {
    var _ref$current;

    const randomRow1 = Math.floor(Math.random() * dataRef.current.length);
    const randomRow2 = Math.floor(Math.random() * dataRef.current.length);
    const temp = dataRef.current[randomRow1].email;
    dataRef.current[randomRow1].email = dataRef.current[randomRow2].email;
    dataRef.current[randomRow2].email = temp;
    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.updateCells([randomRow1, randomRow2].map(r => ({
      cell: [2, r]
    })));
  };

  const onHighlightButtonClick = () => {
    var _ref$current2;

    const randomRow1 = Math.floor(Math.random() * highlightDataRef.current.length);
    const randomRow2 = Math.floor(Math.random() * highlightDataRef.current.length);
    const temp = highlightDataRef.current[randomRow1].email;
    highlightDataRef.current[randomRow1].email = highlightDataRef.current[randomRow2].email;
    highlightDataRef.current[randomRow2].email = temp;
    highlightDataRef.current[randomRow1].update = performance.now();
    highlightDataRef.current[randomRow2].update = performance.now();
    (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.updateCells([randomRow1, randomRow2].map(r => ({
      cell: [2, r]
    })));
  };

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Streaming Data

> Glide Data Grid is capable of streaming hundreds of thousands of updates per second. You won't need that, but every millisecond the grid doesn't take is another millisecond your app has to process data and remain responsive.

Streaming data is done as a two step process.

1. Update the data backing store.
2. Inform the Glide Data Grid of the changed data.

The Grid does not care of the data is coming down over the wire or being generated locally. Informing the grid of changes to the data is done by calling the \`updateCells\` function on a bound ref.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const ref = React.useRef<DataEditorRef | null>(null);

return <DataEditor {...rest} ref={ref} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
Data can now be updated by calling mutating the backing store and using the ref to update cells.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const onButtonClick = () => {
    // Swap the emails of 2 random people
    const randomRow1 = Math.floor(Math.random()*data.length);
    const randomRow2 = Math.floor(Math.random()*data.length);

    const temp = data[randomRow1].email;
    data[randomRow1].email = data[randomRow2].email;
    data[randomRow2].email = temp;

    ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r]})));
}
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    onClick: onButtonClick
  }, "Swappy Swappy"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 400
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    ref: ref,
    getCellContent: getContent,
    columns: columns,
    rows: dataRef.current.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
## Showing updates
        
If \`getContent\` is updated to also return the last time a cell was updated the data grid will highlight cells as they update.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getContent = React.useCallback((cell: Item): GridCell => {
    const [col, row] = cell;
    const data = fetchDataFromBackend(col, row);
    return {
        kind: GridCellKind.Text,
        allowOverlay: true,
        displayData: data.value,
        data: data.value,
        lastUpdated: data.updatedAt,
    };
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
> Note that timestamps are based on performance.now() and not Date.now(). This is to ensure that timestamps always increase monotonically and nothing weird will happen if the clock adjusts.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    style: {
      marginTop: 16
    },
    onClick: onHighlightButtonClick
  }, "Swapity Swap Swap"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 600
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    ref: ref,
    getCellContent: getContentHighlighted,
    columns: columns,
    rows: dataRef.current.length
  })));
};
StreamingData.storyName = "04. Streaming Data";
const __namedExportsOrder = ["StreamingData"];

/***/ }),

/***/ "./packages/core/src/docs/06-search.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Search": () => (/* binding */ Search),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
var __STORY__ = "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Search: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const [showSearch, setShowSearch] = React.useState(false);\n    const onSearchClose = React.useCallback(() => setShowSearch(false), []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Search\n\nSearch is a controlled property in Glide Data Grid. Triggering the search interface is up to the application but once triggered search is handled interally on the data grid. Search always depends on a properly implemented \\`getCellsForSelection\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst [showSearch, setShowSearch] = React.useState(false);\nconst onSearchClose = React.useCallback(() => setShowSearch(false), []);\n\nreturn <DataEditor {...rest} showSearch={showSearch} getCellsForSelection={true} onSearchClose={onSearchClose}  />\n`}\n            </Highlight>\n            <button onClick={() => setShowSearch(true)}>Show Search</button>\n            <Wrapper height={200}>\n                <DataEditor\n                    showSearch={showSearch}\n                    onSearchClose={onSearchClose}\n                    getCellContent={getContent}\n                    getCellsForSelection={true}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>\n                {`\n# Automatic Search\n\nSearch can also be handled by the data grid automatically if you enable the search keybinding.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor {...rest} keybindings={{search: true}} getCellsForSelection={true}  />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    keybindings={{ search: true }}\n                    getCellContent={getContent}\n                    getCellsForSelection={true}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Search as any).storyName = \"06. Search\";\n";
var __LOCATIONS_MAP__ = {
  "Search": {
    "startLoc": {
      "col": 33,
      "line": 132
    },
    "endLoc": {
      "col": 1,
      "line": 219
    },
    "startBody": {
      "col": 33,
      "line": 132
    },
    "endBody": {
      "col": 1,
      "line": 219
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Search: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const [showSearch, setShowSearch] = React.useState(false);\n    const onSearchClose = React.useCallback(() => setShowSearch(false), []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Search\n\nSearch is a controlled property in Glide Data Grid. Triggering the search interface is up to the application but once triggered search is handled interally on the data grid. Search always depends on a properly implemented \\`getCellsForSelection\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst [showSearch, setShowSearch] = React.useState(false);\nconst onSearchClose = React.useCallback(() => setShowSearch(false), []);\n\nreturn <DataEditor {...rest} showSearch={showSearch} getCellsForSelection={true} onSearchClose={onSearchClose}  />\n`}\n            </Highlight>\n            <button onClick={() => setShowSearch(true)}>Show Search</button>\n            <Wrapper height={200}>\n                <DataEditor\n                    showSearch={showSearch}\n                    onSearchClose={onSearchClose}\n                    getCellContent={getContent}\n                    getCellsForSelection={true}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>\n                {`\n# Automatic Search\n\nSearch can also be handled by the data grid automatically if you enable the search keybinding.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor {...rest} keybindings={{search: true}} getCellsForSelection={true}  />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    keybindings={{ search: true }}\n                    getCellContent={getContent}\n                    getCellsForSelection={true}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Search as any).storyName = \"06. Search\";\n",
      "locationsMap": {
        "search": {
          "startLoc": {
            "col": 33,
            "line": 132
          },
          "endLoc": {
            "col": 1,
            "line": 219
          },
          "startBody": {
            "col": 33,
            "line": 132
          },
          "endBody": {
            "col": 1,
            "line": 219
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const Search = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  const [showSearch, setShowSearch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const onSearchClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => setShowSearch(false), []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Search

Search is a controlled property in Glide Data Grid. Triggering the search interface is up to the application but once triggered search is handled interally on the data grid. Search always depends on a properly implemented \`getCellsForSelection\`.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const [showSearch, setShowSearch] = React.useState(false);
const onSearchClose = React.useCallback(() => setShowSearch(false), []);

return <DataEditor {...rest} showSearch={showSearch} getCellsForSelection={true} onSearchClose={onSearchClose}  />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    onClick: () => setShowSearch(true)
  }, "Show Search"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    showSearch: showSearch,
    onSearchClose: onSearchClose,
    getCellContent: getContent,
    getCellsForSelection: true,
    columns: columns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Automatic Search

Search can also be handled by the data grid automatically if you enable the search keybinding.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor {...rest} keybindings={{search: true}} getCellsForSelection={true}  />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    keybindings: {
      search: true
    },
    getCellContent: getContent,
    getCellsForSelection: true,
    columns: columns,
    rows: data.length
  })));
};
Search.storyName = "06. Search";
const __namedExportsOrder = ["Search"];

/***/ }),

/***/ "./packages/core/src/docs/07-column-grouping.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColumnGrouping": () => (/* binding */ ColumnGrouping),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
var __STORY__ = "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const ColumnGrouping: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n                group: \"Core\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n                group: \"Core\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n                group: \"Extra\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n                group: \"Extra\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Column Grouping\n\nColumns can be grouped by assinging them a group. Easy peasy.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n            group: \"Core\",\n        },\n        {\n            title: \"Company\",\n            id: \"company\",\n            group: \"Core\",\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n            group: \"Extra\",\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n            group: \"Extra\",\n        },\n    ];\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={500}>\n                <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(ColumnGrouping as any).storyName = \"07. Column Grouping\";\n";
var __LOCATIONS_MAP__ = {
  "ColumnGrouping": {
    "startLoc": {
      "col": 41,
      "line": 132
    },
    "endLoc": {
      "col": 1,
      "line": 212
    },
    "startBody": {
      "col": 41,
      "line": 132
    },
    "endBody": {
      "col": 1,
      "line": 212
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const ColumnGrouping: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n                group: \"Core\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n                group: \"Core\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n                group: \"Extra\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n                group: \"Extra\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Column Grouping\n\nColumns can be grouped by assinging them a group. Easy peasy.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n            group: \"Core\",\n        },\n        {\n            title: \"Company\",\n            id: \"company\",\n            group: \"Core\",\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n            group: \"Extra\",\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n            group: \"Extra\",\n        },\n    ];\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={500}>\n                <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(ColumnGrouping as any).storyName = \"07. Column Grouping\";\n",
      "locationsMap": {
        "column-grouping": {
          "startLoc": {
            "col": 41,
            "line": 132
          },
          "endLoc": {
            "col": 1,
            "line": 212
          },
          "startBody": {
            "col": 41,
            "line": 132
          },
          "endBody": {
            "col": 1,
            "line": 212
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const ColumnGrouping = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name",
      group: "Core"
    }, {
      title: "Company",
      id: "company",
      group: "Core"
    }, {
      title: "Email",
      id: "email",
      group: "Extra"
    }, {
      title: "Phone",
      id: "phone",
      group: "Extra"
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Column Grouping

Columns can be grouped by assinging them a group. Easy peasy.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns = React.useMemo<GridColumn[]>(() => {
    return [
        {
            title: "Name",
            id: "name",
            group: "Core",
        },
        {
            title: "Company",
            id: "company",
            group: "Core",
        },
        {
            title: "Email",
            id: "email",
            group: "Extra",
        },
        {
            title: "Phone",
            id: "phone",
            group: "Extra",
        },
    ];
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 500
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    columns: columns,
    rows: data.length
  })));
};
ColumnGrouping.storyName = "07. Column Grouping";
const __namedExportsOrder = ["ColumnGrouping"];

/***/ }),

/***/ "./packages/core/src/docs/08-theming.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Theming": () => (/* binding */ Theming),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
var __STORY__ = "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\nimport type { Theme } from \"../common/styles\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Theming: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const getContentThemed = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n\n        let theme: Partial<Theme> | undefined = undefined;\n\n        if (col === 1 && row === 1) {\n            theme = {\n                textDark: \"#FF0000\",\n            };\n        }\n\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n            themeOverride: theme,\n        };\n    }, []);\n\n    const getRowThemeOverride = React.useCallback((row: number): Partial<Theme> | undefined => {\n        if (row % 2 === 0) {\n            return {\n                bgCell: \"#F9FDFF\",\n            };\n        }\n        return undefined;\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const themeColumns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                themeOverride: {\n                    textDark: \"#225588\",\n                    baseFontStyle: \"600 13px\",\n                },\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Theming\n\nTheming the Glide Data Grid is a cascaded through 5 levels\n\n0. Default theme\n1. Global\n2. Group\n3. Column\n4. Row\n5. Cell\n\nAt each level parts of the theme can be overridden. This example will pro\n\n## Global Theming\n\nThe global theme is provided by the DataEditor by default and can be overriden by setting the \\`theme\\` prop. All themes contain the following properties.\n\n| Property | CSS Variable | Type | Description |\n|---|---|---|----|\n| accentColor | --gdg-accent-color | string | The primary accent color of the grid. This will show up in focus rings and selected rows/headers. |\n| accentFg | --gdg-accent-fg | string | A foreground color which works well on top of the accent color. |\n| accentLight | --gdg-accent-light | string | A lighter version of the accent color used to hint selection. |\n| textDark | --gdg-text-dark | string | The standard text color. |\n| textMedium | --gdg-text-medium | string | A lighter text color used for non-editable data in some cases. |\n| textLight | --gdg-text-light | string | An even lighter text color |\n| textBubble | --gdg-text-bubble | string | The text color used in bubbles |\n| bgIconHeader | --gdg-bg-icon-header | string | The background color for header icons |\n| fgIconHeader | --gdg-fg-icon-header | string | The foreground color for header icons |\n| textHeader | --gdg-text-header | string | The header text color |\n| textGroupHeader | --gdg-text-group-header | string \\\\| undefined | The group header text color, if none provided the \\`textHeader\\` is used instead. |\n| textHeaderSelected | --gdg-text-header-selected | string | The text color used for selected headers |\n| bgCell | --gdg-bg-cell | string | The primary background color of the data grid. |\n| bgCellMedium | --gdg-bg-cell-medium | string | Used for disabled or otherwise off colored cells. |\n| bgHeader | --gdg-bg-header | string | The header background color |\n| bgHeaderHasFocus | --gdg-bg-header-has | string | The header background color when its column contains the selected cell |\n| bgHeaderHovered | --gdg-bg-header-hovered | string | The header background color when it is hovered |\n| bgBubble | --gdg-bg-bubble | string | The background color used in bubbles |\n| bgBubbleSelected | --gdg-bg-bubble-selected | string | The background color used in bubbles when the cell is selected |\n| bgSearchResult | --gdg-bg-search-result | string | The background color used for cells which match the search string |\n| borderColor | --gdg-border-color | string | The color of all vertical borders and horizontal borders if a horizontal override is not provided |\n| horizontalBorderColor | --gdg-horizontal-border-color | string \\\\| undefined | The horizontal border color override |\n| drilldownBorder | --gdg-drilldown-border | string | The ring color of a drilldown cell |\n| linkColor | --gdg-link-color | string | What color to render links |\n| cellHorizontalPadding | --gdg-cell-horizontal-padding | number | The internal horizontal padding size of a cell. |\n| cellVerticalPadding | --gdg-cell-vertical-padding | number | The internal vertical padding size of a cell. |\n| headerFontStyle | --gdg-header-font-style | string | The font style of the header. e.g. \\`bold 15px\\` |\n| baseFontStyle | --gdg-base-font-style | string | The font style used for cells by default, e.g. \\`13px\\` |\n| fontFamily | --gdg-font-family | string | The font family used by the data grid. |\n| editorFontSize | --gdg-editor-font-size | string | The font size used by overlay editors. |\n| lineHeight | None | number | A unitless scaler which defines the height of a line of text relative to the ink size. |\n\nIf an option is missing from any theme it will be filled in with the default theme.\n`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor \n        theme={{\n          bgCell: \"#F2F9FF\"\n        }} \n        getCellContent={getContent} columns={columns} rows={data.length} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>\n                {`### Column themes\nThemes can be applied at the column level as well by setting the \\`themeOverride\\` on the \\`GridColumn\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n        },\n        {\n            title: \"Company\",\n            themeOverride: {\n                textDark: \"#225588\",\n                baseFontStyle: \"600 13px\",\n            },\n            id: \"company\",\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n        },\n    ];\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getCellContent={getContent}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>{`### Row themes`}</Marked>\n            <Highlight>\n                {`\nconst getRowThemeOverride = React.useCallback((row: number): Partial<Theme> | undefined => {\n    if (row % 2 === 0) {\n        return {\n            bgCell: \"#F9FDFF\"\n        }\n    }\n    return undefined;\n}, []);\n\nreturn <DataEditor {...rest} getRowThemeOverride={getRowThemeOverride} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getRowThemeOverride={getRowThemeOverride}\n                    getCellContent={getContent}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>{`### Cell themes`}</Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    let theme: Partial<Theme> | undefined = undefined;\n    if (col === 1 && row === 1) {\n        theme = {\n            textDark: \"#FF0000\",\n        }\n    }\n    \n    const d = getDataForCell(col, row);\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        displayData: d,\n        data: d,\n        themeOverride: theme\n    };\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getRowThemeOverride={getRowThemeOverride}\n                    getCellContent={getContentThemed}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Theming as any).storyName = \"08. Theming\";\n";
var __LOCATIONS_MAP__ = {
  "Theming": {
    "startLoc": {
      "col": 34,
      "line": 133
    },
    "endLoc": {
      "col": 1,
      "line": 405
    },
    "startBody": {
      "col": 34,
      "line": 133
    },
    "endBody": {
      "col": 1,
      "line": 405
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\nimport type { Theme } from \"../common/styles\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Theming: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const getContentThemed = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n\n        let theme: Partial<Theme> | undefined = undefined;\n\n        if (col === 1 && row === 1) {\n            theme = {\n                textDark: \"#FF0000\",\n            };\n        }\n\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n            themeOverride: theme,\n        };\n    }, []);\n\n    const getRowThemeOverride = React.useCallback((row: number): Partial<Theme> | undefined => {\n        if (row % 2 === 0) {\n            return {\n                bgCell: \"#F9FDFF\",\n            };\n        }\n        return undefined;\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const themeColumns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                themeOverride: {\n                    textDark: \"#225588\",\n                    baseFontStyle: \"600 13px\",\n                },\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Theming\n\nTheming the Glide Data Grid is a cascaded through 5 levels\n\n0. Default theme\n1. Global\n2. Group\n3. Column\n4. Row\n5. Cell\n\nAt each level parts of the theme can be overridden. This example will pro\n\n## Global Theming\n\nThe global theme is provided by the DataEditor by default and can be overriden by setting the \\`theme\\` prop. All themes contain the following properties.\n\n| Property | CSS Variable | Type | Description |\n|---|---|---|----|\n| accentColor | --gdg-accent-color | string | The primary accent color of the grid. This will show up in focus rings and selected rows/headers. |\n| accentFg | --gdg-accent-fg | string | A foreground color which works well on top of the accent color. |\n| accentLight | --gdg-accent-light | string | A lighter version of the accent color used to hint selection. |\n| textDark | --gdg-text-dark | string | The standard text color. |\n| textMedium | --gdg-text-medium | string | A lighter text color used for non-editable data in some cases. |\n| textLight | --gdg-text-light | string | An even lighter text color |\n| textBubble | --gdg-text-bubble | string | The text color used in bubbles |\n| bgIconHeader | --gdg-bg-icon-header | string | The background color for header icons |\n| fgIconHeader | --gdg-fg-icon-header | string | The foreground color for header icons |\n| textHeader | --gdg-text-header | string | The header text color |\n| textGroupHeader | --gdg-text-group-header | string \\\\| undefined | The group header text color, if none provided the \\`textHeader\\` is used instead. |\n| textHeaderSelected | --gdg-text-header-selected | string | The text color used for selected headers |\n| bgCell | --gdg-bg-cell | string | The primary background color of the data grid. |\n| bgCellMedium | --gdg-bg-cell-medium | string | Used for disabled or otherwise off colored cells. |\n| bgHeader | --gdg-bg-header | string | The header background color |\n| bgHeaderHasFocus | --gdg-bg-header-has | string | The header background color when its column contains the selected cell |\n| bgHeaderHovered | --gdg-bg-header-hovered | string | The header background color when it is hovered |\n| bgBubble | --gdg-bg-bubble | string | The background color used in bubbles |\n| bgBubbleSelected | --gdg-bg-bubble-selected | string | The background color used in bubbles when the cell is selected |\n| bgSearchResult | --gdg-bg-search-result | string | The background color used for cells which match the search string |\n| borderColor | --gdg-border-color | string | The color of all vertical borders and horizontal borders if a horizontal override is not provided |\n| horizontalBorderColor | --gdg-horizontal-border-color | string \\\\| undefined | The horizontal border color override |\n| drilldownBorder | --gdg-drilldown-border | string | The ring color of a drilldown cell |\n| linkColor | --gdg-link-color | string | What color to render links |\n| cellHorizontalPadding | --gdg-cell-horizontal-padding | number | The internal horizontal padding size of a cell. |\n| cellVerticalPadding | --gdg-cell-vertical-padding | number | The internal vertical padding size of a cell. |\n| headerFontStyle | --gdg-header-font-style | string | The font style of the header. e.g. \\`bold 15px\\` |\n| baseFontStyle | --gdg-base-font-style | string | The font style used for cells by default, e.g. \\`13px\\` |\n| fontFamily | --gdg-font-family | string | The font family used by the data grid. |\n| editorFontSize | --gdg-editor-font-size | string | The font size used by overlay editors. |\n| lineHeight | None | number | A unitless scaler which defines the height of a line of text relative to the ink size. |\n\nIf an option is missing from any theme it will be filled in with the default theme.\n`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor \n        theme={{\n          bgCell: \"#F2F9FF\"\n        }} \n        getCellContent={getContent} columns={columns} rows={data.length} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>\n                {`### Column themes\nThemes can be applied at the column level as well by setting the \\`themeOverride\\` on the \\`GridColumn\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n        },\n        {\n            title: \"Company\",\n            themeOverride: {\n                textDark: \"#225588\",\n                baseFontStyle: \"600 13px\",\n            },\n            id: \"company\",\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n        },\n    ];\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getCellContent={getContent}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>{`### Row themes`}</Marked>\n            <Highlight>\n                {`\nconst getRowThemeOverride = React.useCallback((row: number): Partial<Theme> | undefined => {\n    if (row % 2 === 0) {\n        return {\n            bgCell: \"#F9FDFF\"\n        }\n    }\n    return undefined;\n}, []);\n\nreturn <DataEditor {...rest} getRowThemeOverride={getRowThemeOverride} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getRowThemeOverride={getRowThemeOverride}\n                    getCellContent={getContent}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>{`### Cell themes`}</Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    let theme: Partial<Theme> | undefined = undefined;\n    if (col === 1 && row === 1) {\n        theme = {\n            textDark: \"#FF0000\",\n        }\n    }\n    \n    const d = getDataForCell(col, row);\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        displayData: d,\n        data: d,\n        themeOverride: theme\n    };\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getRowThemeOverride={getRowThemeOverride}\n                    getCellContent={getContentThemed}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Theming as any).storyName = \"08. Theming\";\n",
      "locationsMap": {
        "theming": {
          "startLoc": {
            "col": 34,
            "line": 133
          },
          "endLoc": {
            "col": 1,
            "line": 405
          },
          "startBody": {
            "col": 34,
            "line": 133
          },
          "endBody": {
            "col": 1,
            "line": 405
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const Theming = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const getContentThemed = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    let theme = undefined;

    if (col === 1 && row === 1) {
      theme = {
        textDark: "#FF0000"
      };
    }

    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d,
      themeOverride: theme
    };
  }, []);
  const getRowThemeOverride = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(row => {
    if (row % 2 === 0) {
      return {
        bgCell: "#F9FDFF"
      };
    }

    return undefined;
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  const themeColumns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      themeOverride: {
        textDark: "#225588",
        baseFontStyle: "600 13px"
      },
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Theming

Theming the Glide Data Grid is a cascaded through 5 levels

0. Default theme
1. Global
2. Group
3. Column
4. Row
5. Cell

At each level parts of the theme can be overridden. This example will pro

## Global Theming

The global theme is provided by the DataEditor by default and can be overriden by setting the \`theme\` prop. All themes contain the following properties.

| Property | CSS Variable | Type | Description |
|---|---|---|----|
| accentColor | --gdg-accent-color | string | The primary accent color of the grid. This will show up in focus rings and selected rows/headers. |
| accentFg | --gdg-accent-fg | string | A foreground color which works well on top of the accent color. |
| accentLight | --gdg-accent-light | string | A lighter version of the accent color used to hint selection. |
| textDark | --gdg-text-dark | string | The standard text color. |
| textMedium | --gdg-text-medium | string | A lighter text color used for non-editable data in some cases. |
| textLight | --gdg-text-light | string | An even lighter text color |
| textBubble | --gdg-text-bubble | string | The text color used in bubbles |
| bgIconHeader | --gdg-bg-icon-header | string | The background color for header icons |
| fgIconHeader | --gdg-fg-icon-header | string | The foreground color for header icons |
| textHeader | --gdg-text-header | string | The header text color |
| textGroupHeader | --gdg-text-group-header | string \\| undefined | The group header text color, if none provided the \`textHeader\` is used instead. |
| textHeaderSelected | --gdg-text-header-selected | string | The text color used for selected headers |
| bgCell | --gdg-bg-cell | string | The primary background color of the data grid. |
| bgCellMedium | --gdg-bg-cell-medium | string | Used for disabled or otherwise off colored cells. |
| bgHeader | --gdg-bg-header | string | The header background color |
| bgHeaderHasFocus | --gdg-bg-header-has | string | The header background color when its column contains the selected cell |
| bgHeaderHovered | --gdg-bg-header-hovered | string | The header background color when it is hovered |
| bgBubble | --gdg-bg-bubble | string | The background color used in bubbles |
| bgBubbleSelected | --gdg-bg-bubble-selected | string | The background color used in bubbles when the cell is selected |
| bgSearchResult | --gdg-bg-search-result | string | The background color used for cells which match the search string |
| borderColor | --gdg-border-color | string | The color of all vertical borders and horizontal borders if a horizontal override is not provided |
| horizontalBorderColor | --gdg-horizontal-border-color | string \\| undefined | The horizontal border color override |
| drilldownBorder | --gdg-drilldown-border | string | The ring color of a drilldown cell |
| linkColor | --gdg-link-color | string | What color to render links |
| cellHorizontalPadding | --gdg-cell-horizontal-padding | number | The internal horizontal padding size of a cell. |
| cellVerticalPadding | --gdg-cell-vertical-padding | number | The internal vertical padding size of a cell. |
| headerFontStyle | --gdg-header-font-style | string | The font style of the header. e.g. \`bold 15px\` |
| baseFontStyle | --gdg-base-font-style | string | The font style used for cells by default, e.g. \`13px\` |
| fontFamily | --gdg-font-family | string | The font family used by the data grid. |
| editorFontSize | --gdg-editor-font-size | string | The font size used by overlay editors. |
| lineHeight | None | number | A unitless scaler which defines the height of a line of text relative to the ink size. |

If an option is missing from any theme it will be filled in with the default theme.
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor 
        theme={{
          bgCell: "#F2F9FF"
        }} 
        getCellContent={getContent} columns={columns} rows={data.length} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    theme: {
      bgCell: "#F2F9FF"
    },
    getCellContent: getContent,
    columns: columns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `### Column themes
Themes can be applied at the column level as well by setting the \`themeOverride\` on the \`GridColumn\`.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns = React.useMemo<GridColumn[]>(() => {
    return [
        {
            title: "Name",
            id: "name",
        },
        {
            title: "Company",
            themeOverride: {
                textDark: "#225588",
                baseFontStyle: "600 13px",
            },
            id: "company",
        },
        {
            title: "Email",
            id: "email",
        },
        {
            title: "Phone",
            id: "phone",
        },
    ];
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    theme: {
      bgCell: "#F2F9FF"
    },
    getCellContent: getContent,
    columns: themeColumns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `### Row themes`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getRowThemeOverride = React.useCallback((row: number): Partial<Theme> | undefined => {
    if (row % 2 === 0) {
        return {
            bgCell: "#F9FDFF"
        }
    }
    return undefined;
}, []);

return <DataEditor {...rest} getRowThemeOverride={getRowThemeOverride} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    theme: {
      bgCell: "#F2F9FF"
    },
    getRowThemeOverride: getRowThemeOverride,
    getCellContent: getContent,
    columns: themeColumns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `### Cell themes`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getContent = React.useCallback((cell: Item): GridCell => {
    let theme: Partial<Theme> | undefined = undefined;
    if (col === 1 && row === 1) {
        theme = {
            textDark: "#FF0000",
        }
    }
    
    const d = getDataForCell(col, row);
    return {
        kind: GridCellKind.Text,
        allowOverlay: true,
        displayData: d,
        data: d,
        themeOverride: theme
    };
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    theme: {
      bgCell: "#F2F9FF"
    },
    getRowThemeOverride: getRowThemeOverride,
    getCellContent: getContentThemed,
    columns: themeColumns,
    rows: data.length
  })));
};
Theming.storyName = "08. Theming";
const __namedExportsOrder = ["Theming"];

/***/ }),

/***/ "./packages/core/src/docs/09-menus.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Menus": () => (/* binding */ Menus),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
/* harmony import */ var react_laag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/react-laag/dist/react-laag.esm.js");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item, Rectangle } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\nimport { useLayer } from \"react-laag\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Menus: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n                hasMenu: true,\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n                hasMenu: true,\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n                hasMenu: true,\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n                hasMenu: true,\n            },\n        ];\n    }, []);\n\n    const onHeaderMenuClickedStage1 = React.useCallback((col: number, position: Rectangle) => {\n        window.alert(\"Header menu clicked \" + col + JSON.stringify(position));\n    }, []);\n\n    const [showMenu, setShowMenu] = React.useState<{ bounds: Rectangle; col: number }>();\n\n    const onHeaderMenuClickedStage2 = React.useCallback((col: number, bounds: Rectangle) => {\n        setShowMenu({ col, bounds });\n    }, []);\n\n    const { renderLayer, layerProps } = useLayer({\n        isOpen: showMenu !== undefined,\n        triggerOffset: 4,\n        onOutsideClick: () => setShowMenu(undefined),\n        trigger: {\n            getBounds: () => ({\n                bottom: (showMenu?.bounds.y ?? 0) + (showMenu?.bounds.height ?? 0),\n                height: showMenu?.bounds.height ?? 0,\n                left: showMenu?.bounds.x ?? 0,\n                right: (showMenu?.bounds.x ?? 0) + (showMenu?.bounds.width ?? 0),\n                top: showMenu?.bounds.y ?? 0,\n                width: showMenu?.bounds.width ?? 0,\n            }),\n        },\n        placement: \"bottom-start\",\n        auto: true,\n        possiblePlacements: [\"bottom-start\", \"bottom-end\"],\n    });\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Menus\n\nGlide Data Grid doesn't come with built in menus. Instead it is evented and ready to work with whatever menus you want \nto use. Let's learn how to add basic menus using [react-laag](https://www.react-laag.com/). Adding menu drop down indicators to headers is as simple\nas passing a bool and listening to click events using \\`onHeaderMenuClick\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n            hasMenu: true,\n        },\n        {\n            title: \"Company\",\n            id: \"company\",\n            hasMenu: true,\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n            hasMenu: true,\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n            hasMenu: true,\n        },\n    ];\n}, []);\n\nconst onHeaderMenuClick = React.useCallback((col: number, position: Rectangle) => {\n    window.alert(\"Header menu clicked \" + col + JSON.stringify(position));\n}, []);\n\nreturn <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                    onHeaderMenuClick={onHeaderMenuClickedStage1}\n                />\n            </Wrapper>\n            <Marked>\n                {`\nThe provided coordinates are in page space. This makes it trivial to use [react-laag](https://www.react-laag.com/) to create a basic menu. Some \nstyling would go a long way here.`}\n            </Marked>\n            <Highlight>\n                {`\nconst [showMenu, setShowMenu] = React.useState<{ bounds: Rectangle; col: number }>();\n\nconst onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\n    setShowMenu({ col, bounds });\n}, []);\n\nconst { renderLayer, layerProps } = useLayer({\n    isOpen: showMenu !== undefined,\n    triggerOffset: 4,\n    onOutsideClick: () => setShowMenu(undefined),\n    trigger: {\n        getBounds: () => ({\n            bottom: (showMenu?.bounds.y ?? 0) + (showMenu?.bounds.height ?? 0),\n            height: showMenu?.bounds.height ?? 0,\n            left: showMenu?.bounds.x ?? 0,\n            right: (showMenu?.bounds.x ?? 0) + (showMenu?.bounds.width ?? 0),\n            top: showMenu?.bounds.y ?? 0,\n            width: showMenu?.bounds.width ?? 0,\n        }),\n    },\n    placement: \"bottom-start\",\n    auto: true,\n    possiblePlacements: [\"bottom-start\", \"bottom-end\"],\n    });\n\nreturn <>\n    <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />\n    {showMenu !== undefined &&\n        renderLayer(\n            <div\n                {...layerProps}\n                style={{\n                    ...layerProps.style,\n                    width: 300,\n                    padding: 4,\n                    borderRadius: 8,\n                    backgroundColor: \"white\",\n                    border: \"1px solid black\",\n                }}>\n                <ul>\n                    <li>Item 1</li>\n                    <li>Item 2</li>\n                    <li>Item 3</li>\n                </ul>\n            </div>\n        )}\n</>;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                    onHeaderMenuClick={onHeaderMenuClickedStage2}\n                />\n                {showMenu !== undefined &&\n                    renderLayer(\n                        <div\n                            {...layerProps}\n                            style={{\n                                ...layerProps.style,\n                                width: 300,\n                                padding: 4,\n                                borderRadius: 8,\n                                backgroundColor: \"white\",\n                                border: \"1px solid black\",\n                            }}>\n                            <ul>\n                                <li>Item 1</li>\n                                <li>Item 2</li>\n                                <li>Item 3</li>\n                            </ul>\n                        </div>\n                    )}\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Menus as any).storyName = \"09. Menus\";\n";
var __LOCATIONS_MAP__ = {
  "Menus": {
    "startLoc": {
      "col": 32,
      "line": 133
    },
    "endLoc": {
      "col": 1,
      "line": 338
    },
    "startBody": {
      "col": 32,
      "line": 133
    },
    "endBody": {
      "col": 1,
      "line": 338
    }
  }
};






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item, Rectangle } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\nimport { useLayer } from \"react-laag\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Menus: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n                hasMenu: true,\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n                hasMenu: true,\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n                hasMenu: true,\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n                hasMenu: true,\n            },\n        ];\n    }, []);\n\n    const onHeaderMenuClickedStage1 = React.useCallback((col: number, position: Rectangle) => {\n        window.alert(\"Header menu clicked \" + col + JSON.stringify(position));\n    }, []);\n\n    const [showMenu, setShowMenu] = React.useState<{ bounds: Rectangle; col: number }>();\n\n    const onHeaderMenuClickedStage2 = React.useCallback((col: number, bounds: Rectangle) => {\n        setShowMenu({ col, bounds });\n    }, []);\n\n    const { renderLayer, layerProps } = useLayer({\n        isOpen: showMenu !== undefined,\n        triggerOffset: 4,\n        onOutsideClick: () => setShowMenu(undefined),\n        trigger: {\n            getBounds: () => ({\n                bottom: (showMenu?.bounds.y ?? 0) + (showMenu?.bounds.height ?? 0),\n                height: showMenu?.bounds.height ?? 0,\n                left: showMenu?.bounds.x ?? 0,\n                right: (showMenu?.bounds.x ?? 0) + (showMenu?.bounds.width ?? 0),\n                top: showMenu?.bounds.y ?? 0,\n                width: showMenu?.bounds.width ?? 0,\n            }),\n        },\n        placement: \"bottom-start\",\n        auto: true,\n        possiblePlacements: [\"bottom-start\", \"bottom-end\"],\n    });\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Menus\n\nGlide Data Grid doesn't come with built in menus. Instead it is evented and ready to work with whatever menus you want \nto use. Let's learn how to add basic menus using [react-laag](https://www.react-laag.com/). Adding menu drop down indicators to headers is as simple\nas passing a bool and listening to click events using \\`onHeaderMenuClick\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n            hasMenu: true,\n        },\n        {\n            title: \"Company\",\n            id: \"company\",\n            hasMenu: true,\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n            hasMenu: true,\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n            hasMenu: true,\n        },\n    ];\n}, []);\n\nconst onHeaderMenuClick = React.useCallback((col: number, position: Rectangle) => {\n    window.alert(\"Header menu clicked \" + col + JSON.stringify(position));\n}, []);\n\nreturn <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                    onHeaderMenuClick={onHeaderMenuClickedStage1}\n                />\n            </Wrapper>\n            <Marked>\n                {`\nThe provided coordinates are in page space. This makes it trivial to use [react-laag](https://www.react-laag.com/) to create a basic menu. Some \nstyling would go a long way here.`}\n            </Marked>\n            <Highlight>\n                {`\nconst [showMenu, setShowMenu] = React.useState<{ bounds: Rectangle; col: number }>();\n\nconst onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\n    setShowMenu({ col, bounds });\n}, []);\n\nconst { renderLayer, layerProps } = useLayer({\n    isOpen: showMenu !== undefined,\n    triggerOffset: 4,\n    onOutsideClick: () => setShowMenu(undefined),\n    trigger: {\n        getBounds: () => ({\n            bottom: (showMenu?.bounds.y ?? 0) + (showMenu?.bounds.height ?? 0),\n            height: showMenu?.bounds.height ?? 0,\n            left: showMenu?.bounds.x ?? 0,\n            right: (showMenu?.bounds.x ?? 0) + (showMenu?.bounds.width ?? 0),\n            top: showMenu?.bounds.y ?? 0,\n            width: showMenu?.bounds.width ?? 0,\n        }),\n    },\n    placement: \"bottom-start\",\n    auto: true,\n    possiblePlacements: [\"bottom-start\", \"bottom-end\"],\n    });\n\nreturn <>\n    <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />\n    {showMenu !== undefined &&\n        renderLayer(\n            <div\n                {...layerProps}\n                style={{\n                    ...layerProps.style,\n                    width: 300,\n                    padding: 4,\n                    borderRadius: 8,\n                    backgroundColor: \"white\",\n                    border: \"1px solid black\",\n                }}>\n                <ul>\n                    <li>Item 1</li>\n                    <li>Item 2</li>\n                    <li>Item 3</li>\n                </ul>\n            </div>\n        )}\n</>;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                    onHeaderMenuClick={onHeaderMenuClickedStage2}\n                />\n                {showMenu !== undefined &&\n                    renderLayer(\n                        <div\n                            {...layerProps}\n                            style={{\n                                ...layerProps.style,\n                                width: 300,\n                                padding: 4,\n                                borderRadius: 8,\n                                backgroundColor: \"white\",\n                                border: \"1px solid black\",\n                            }}>\n                            <ul>\n                                <li>Item 1</li>\n                                <li>Item 2</li>\n                                <li>Item 3</li>\n                            </ul>\n                        </div>\n                    )}\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Menus as any).storyName = \"09. Menus\";\n",
      "locationsMap": {
        "menus": {
          "startLoc": {
            "col": 32,
            "line": 133
          },
          "endLoc": {
            "col": 1,
            "line": 338
          },
          "startBody": {
            "col": 32,
            "line": 133
          },
          "endBody": {
            "col": 1,
            "line": 338
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const Menus = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name",
      hasMenu: true
    }, {
      title: "Company",
      id: "company",
      hasMenu: true
    }, {
      title: "Email",
      id: "email",
      hasMenu: true
    }, {
      title: "Phone",
      id: "phone",
      hasMenu: true
    }];
  }, []);
  const onHeaderMenuClickedStage1 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, position) => {
    window.alert("Header menu clicked " + col + JSON.stringify(position));
  }, []);
  const [showMenu, setShowMenu] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const onHeaderMenuClickedStage2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, bounds) => {
    setShowMenu({
      col,
      bounds
    });
  }, []);
  const {
    renderLayer,
    layerProps
  } = (0,react_laag__WEBPACK_IMPORTED_MODULE_3__/* .useLayer */ .sJ)({
    isOpen: showMenu !== undefined,
    triggerOffset: 4,
    onOutsideClick: () => setShowMenu(undefined),
    trigger: {
      getBounds: () => {
        var _showMenu$bounds$y, _showMenu$bounds$heig, _showMenu$bounds$heig2, _showMenu$bounds$x, _showMenu$bounds$x2, _showMenu$bounds$widt, _showMenu$bounds$y2, _showMenu$bounds$widt2;

        return {
          bottom: ((_showMenu$bounds$y = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.y) !== null && _showMenu$bounds$y !== void 0 ? _showMenu$bounds$y : 0) + ((_showMenu$bounds$heig = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.height) !== null && _showMenu$bounds$heig !== void 0 ? _showMenu$bounds$heig : 0),
          height: (_showMenu$bounds$heig2 = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.height) !== null && _showMenu$bounds$heig2 !== void 0 ? _showMenu$bounds$heig2 : 0,
          left: (_showMenu$bounds$x = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.x) !== null && _showMenu$bounds$x !== void 0 ? _showMenu$bounds$x : 0,
          right: ((_showMenu$bounds$x2 = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.x) !== null && _showMenu$bounds$x2 !== void 0 ? _showMenu$bounds$x2 : 0) + ((_showMenu$bounds$widt = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.width) !== null && _showMenu$bounds$widt !== void 0 ? _showMenu$bounds$widt : 0),
          top: (_showMenu$bounds$y2 = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.y) !== null && _showMenu$bounds$y2 !== void 0 ? _showMenu$bounds$y2 : 0,
          width: (_showMenu$bounds$widt2 = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.width) !== null && _showMenu$bounds$widt2 !== void 0 ? _showMenu$bounds$widt2 : 0
        };
      }
    },
    placement: "bottom-start",
    auto: true,
    possiblePlacements: ["bottom-start", "bottom-end"]
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Marked */ .M2, null, `
# Menus

Glide Data Grid doesn't come with built in menus. Instead it is evented and ready to work with whatever menus you want 
to use. Let's learn how to add basic menus using [react-laag](https://www.react-laag.com/). Adding menu drop down indicators to headers is as simple
as passing a bool and listening to click events using \`onHeaderMenuClick\`.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Highlight */ .y$, null, `
const columns = React.useMemo<GridColumn[]>(() => {
    return [
        {
            title: "Name",
            id: "name",
            hasMenu: true,
        },
        {
            title: "Company",
            id: "company",
            hasMenu: true,
        },
        {
            title: "Email",
            id: "email",
            hasMenu: true,
        },
        {
            title: "Phone",
            id: "phone",
            hasMenu: true,
        },
    ];
}, []);

const onHeaderMenuClick = React.useCallback((col: number, position: Rectangle) => {
    window.alert("Header menu clicked " + col + JSON.stringify(position));
}, []);

return <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />;
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__/* .DataEditor */ .N, {
    getCellContent: getContent,
    columns: columns,
    rows: data.length,
    onHeaderMenuClick: onHeaderMenuClickedStage1
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Marked */ .M2, null, `
The provided coordinates are in page space. This makes it trivial to use [react-laag](https://www.react-laag.com/) to create a basic menu. Some 
styling would go a long way here.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Highlight */ .y$, null, `
const [showMenu, setShowMenu] = React.useState<{ bounds: Rectangle; col: number }>();

const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {
    setShowMenu({ col, bounds });
}, []);

const { renderLayer, layerProps } = useLayer({
    isOpen: showMenu !== undefined,
    triggerOffset: 4,
    onOutsideClick: () => setShowMenu(undefined),
    trigger: {
        getBounds: () => ({
            bottom: (showMenu?.bounds.y ?? 0) + (showMenu?.bounds.height ?? 0),
            height: showMenu?.bounds.height ?? 0,
            left: showMenu?.bounds.x ?? 0,
            right: (showMenu?.bounds.x ?? 0) + (showMenu?.bounds.width ?? 0),
            top: showMenu?.bounds.y ?? 0,
            width: showMenu?.bounds.width ?? 0,
        }),
    },
    placement: "bottom-start",
    auto: true,
    possiblePlacements: ["bottom-start", "bottom-end"],
    });

return <>
    <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />
    {showMenu !== undefined &&
        renderLayer(
            <div
                {...layerProps}
                style={{
                    ...layerProps.style,
                    width: 300,
                    padding: 4,
                    borderRadius: 8,
                    backgroundColor: "white",
                    border: "1px solid black",
                }}>
                <ul>
                    <li>Item 1</li>
                    <li>Item 2</li>
                    <li>Item 3</li>
                </ul>
            </div>
        )}
</>;
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__/* .DataEditor */ .N, {
    getCellContent: getContent,
    columns: columns,
    rows: data.length,
    onHeaderMenuClick: onHeaderMenuClickedStage2
  }), showMenu !== undefined && renderLayer(react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", _extends({}, layerProps, {
    style: { ...layerProps.style,
      width: 300,
      padding: 4,
      borderRadius: 8,
      backgroundColor: "white",
      border: "1px solid black"
    }
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, "Item 1"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, "Item 2"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, "Item 3"))))));
};
Menus.storyName = "09. Menus";
const __namedExportsOrder = ["Menus"];

/***/ }),

/***/ "./packages/core/src/docs/examples/add-column.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddColumns": () => (/* binding */ AddColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Add and remove columns\"\n                    description={\n                        <>\n                            <Description>You can add and remove columns at your disposal</Description>\n                            <MoreInfo>Use the story&apos;s controls to change the number of columns</MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface AddColumnsProps {\n    columnsCount: number;\n}\n\nexport const AddColumns: React.FC<AddColumnsProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(p.columnsCount);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"number\"\n            getCellContent={getCellContent}\n            experimental={{ strict: true }}\n            columns={cols}\n            rows={10_000}\n        />\n    );\n};\n(AddColumns as any).args = {\n    columnsCount: 10,\n};\n(AddColumns as any).argTypes = {\n    columnsCount: {\n        control: {\n            type: \"range\",\n            min: 2,\n            max: 200,\n        },\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "AddColumns": {
    "startLoc": {
      "col": 53,
      "line": 37
    },
    "endLoc": {
      "col": 1,
      "line": 50
    },
    "startBody": {
      "col": 53,
      "line": 37
    },
    "endBody": {
      "col": 1,
      "line": 50
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Add and remove columns\"\n                    description={\n                        <>\n                            <Description>You can add and remove columns at your disposal</Description>\n                            <MoreInfo>Use the story&apos;s controls to change the number of columns</MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface AddColumnsProps {\n    columnsCount: number;\n}\n\nexport const AddColumns: React.FC<AddColumnsProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(p.columnsCount);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"number\"\n            getCellContent={getCellContent}\n            experimental={{ strict: true }}\n            columns={cols}\n            rows={10_000}\n        />\n    );\n};\n(AddColumns as any).args = {\n    columnsCount: 10,\n};\n(AddColumns as any).argTypes = {\n    columnsCount: {\n        control: {\n            type: \"range\",\n            min: 2,\n            max: 200,\n        },\n    },\n};\n",
      "locationsMap": {
        "add-columns": {
          "startLoc": {
            "col": 53,
            "line": 37
          },
          "endLoc": {
            "col": 1,
            "line": 50
          },
          "startBody": {
            "col": 53,
            "line": 37
          },
          "endBody": {
            "col": 1,
            "line": 50
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Add and remove columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can add and remove columns at your disposal"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Use the story's controls to change the number of columns"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const AddColumns = p => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(p.columnsCount);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowMarkers: "number",
    getCellContent: getCellContent,
    experimental: {
      strict: true
    },
    columns: cols,
    rows: 10000
  }));
};
AddColumns.args = {
  columnsCount: 10
};
AddColumns.argTypes = {
  columnsCount: {
    control: {
      type: "range",
      min: 2,
      max: 200
    }
  }
};
const __namedExportsOrder = ["AddColumns"];

/***/ }),

/***/ "./packages/core/src/docs/examples/add-data-to-middle.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddDataToMiddle": () => (/* binding */ AddDataToMiddle),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Add data to middle\"\n                    description={\n                        <>\n                            <Description>\n                                You can return a different location to have the new row append take place.\n                            </Description>\n                            <MoreInfo>\n                                Note that <KeyName>insertIndex</KeyName> is zero-based while the number column on the\n                                left side of the grid is one-based, so inserting at index &quot;4&quot; creates a new\n                                row at &quot;5&quot;\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface AddDataToMiddleProps {\n    insertIndex: number;\n}\nexport const AddDataToMiddle: React.FC<AddDataToMiddleProps> = p => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const index = p.insertIndex;\n    const onRowAppended = React.useCallback(async () => {\n        // shift rows below index down\n        for (let y = numRows; y > index; y--) {\n            for (let x = 0; x < 6; x++) {\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\n            }\n        }\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, index]);\n            setCellValueRaw([c, index], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n        return index;\n    }, [getCellContent, numRows, setCellValueRaw, index]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onCellEdited={setCellValue}\n            trailingRowOptions={{\n                hint: \"New row...\",\n                sticky: true,\n                tint: true,\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n        />\n    );\n};\n(AddDataToMiddle as any).args = {\n    insertIndex: 10,\n};\n(AddDataToMiddle as any).argTypes = {\n    insertIndex: {\n        control: {\n            type: \"range\",\n            min: 1,\n            max: 48,\n        },\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "AddDataToMiddle": {
    "startLoc": {
      "col": 63,
      "line": 44
    },
    "endLoc": {
      "col": 1,
      "line": 81
    },
    "startBody": {
      "col": 63,
      "line": 44
    },
    "endBody": {
      "col": 1,
      "line": 81
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Add data to middle\"\n                    description={\n                        <>\n                            <Description>\n                                You can return a different location to have the new row append take place.\n                            </Description>\n                            <MoreInfo>\n                                Note that <KeyName>insertIndex</KeyName> is zero-based while the number column on the\n                                left side of the grid is one-based, so inserting at index &quot;4&quot; creates a new\n                                row at &quot;5&quot;\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface AddDataToMiddleProps {\n    insertIndex: number;\n}\nexport const AddDataToMiddle: React.FC<AddDataToMiddleProps> = p => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const index = p.insertIndex;\n    const onRowAppended = React.useCallback(async () => {\n        // shift rows below index down\n        for (let y = numRows; y > index; y--) {\n            for (let x = 0; x < 6; x++) {\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\n            }\n        }\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, index]);\n            setCellValueRaw([c, index], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n        return index;\n    }, [getCellContent, numRows, setCellValueRaw, index]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onCellEdited={setCellValue}\n            trailingRowOptions={{\n                hint: \"New row...\",\n                sticky: true,\n                tint: true,\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n        />\n    );\n};\n(AddDataToMiddle as any).args = {\n    insertIndex: 10,\n};\n(AddDataToMiddle as any).argTypes = {\n    insertIndex: {\n        control: {\n            type: \"range\",\n            min: 1,\n            max: 48,\n        },\n    },\n};\n",
      "locationsMap": {
        "add-data-to-middle": {
          "startLoc": {
            "col": 63,
            "line": 44
          },
          "endLoc": {
            "col": 1,
            "line": 81
          },
          "startBody": {
            "col": 63,
            "line": 44
          },
          "endBody": {
            "col": 1,
            "line": 81
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Add data to middle",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can return a different location to have the new row append take place."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Note that ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "insertIndex"), " is zero-based while the number column on the left side of the grid is one-based, so inserting at index \"4\" creates a new row at \"5\""))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const AddDataToMiddle = p => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const index = p.insertIndex;
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {
    for (let y = numRows; y > index; y--) {
      for (let x = 0; x < 6; x++) {
        setCellValueRaw([x, y], getCellContent([x, y - 1]));
      }
    }

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, index]);
      setCellValueRaw([c, index], (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .clearCell */ .MP)(cell));
    }

    setNumRows(cv => cv + 1);
    return index;
  }, [getCellContent, numRows, setCellValueRaw, index]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      hint: "New row...",
      sticky: true,
      tint: true
    },
    rows: numRows,
    onRowAppended: onRowAppended
  }));
};
AddDataToMiddle.args = {
  insertIndex: 10
};
AddDataToMiddle.argTypes = {
  insertIndex: {
    control: {
      type: "range",
      min: 1,
      max: 48
    }
  }
};
const __namedExportsOrder = ["AddDataToMiddle"];

/***/ }),

/***/ "./packages/core/src/docs/examples/add-data-to-top.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddDataToTop": () => (/* binding */ AddDataToTop),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    useMockDataGenerator,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Add data\"\n                    description={\n                        <>\n                            <Description>\n                                You can return a different location to have the new row append take place.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AddDataToTop: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(async () => {\n        // shift all of the existing cells down\n        for (let y = numRows; y > 0; y--) {\n            for (let x = 0; x < 6; x++) {\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\n            }\n        }\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, 0]);\n            setCellValueRaw([c, 0], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n        return \"top\" as const;\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onCellEdited={setCellValue}\n            trailingRowOptions={{\n                hint: \"New row...\",\n                sticky: true,\n                tint: true,\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "AddDataToTop": {
    "startLoc": {
      "col": 39,
      "line": 34
    },
    "endLoc": {
      "col": 1,
      "line": 70
    },
    "startBody": {
      "col": 39,
      "line": 34
    },
    "endBody": {
      "col": 1,
      "line": 70
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    useMockDataGenerator,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Add data\"\n                    description={\n                        <>\n                            <Description>\n                                You can return a different location to have the new row append take place.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AddDataToTop: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(async () => {\n        // shift all of the existing cells down\n        for (let y = numRows; y > 0; y--) {\n            for (let x = 0; x < 6; x++) {\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\n            }\n        }\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, 0]);\n            setCellValueRaw([c, 0], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n        return \"top\" as const;\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onCellEdited={setCellValue}\n            trailingRowOptions={{\n                hint: \"New row...\",\n                sticky: true,\n                tint: true,\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n        />\n    );\n};\n",
      "locationsMap": {
        "add-data-to-top": {
          "startLoc": {
            "col": 39,
            "line": 34
          },
          "endLoc": {
            "col": 1,
            "line": 70
          },
          "startBody": {
            "col": 39,
            "line": 34
          },
          "endBody": {
            "col": 1,
            "line": 70
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Add data",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can return a different location to have the new row append take place."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const AddDataToTop = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {
    for (let y = numRows; y > 0; y--) {
      for (let x = 0; x < 6; x++) {
        setCellValueRaw([x, y], getCellContent([x, y - 1]));
      }
    }

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, 0]);
      setCellValueRaw([c, 0], (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .clearCell */ .MP)(cell));
    }

    setNumRows(cv => cv + 1);
    return "top";
  }, [getCellContent, numRows, setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      hint: "New row...",
      sticky: true,
      tint: true
    },
    rows: numRows,
    onRowAppended: onRowAppended
  }));
};
const __namedExportsOrder = ["AddDataToTop"];

/***/ }),

/***/ "./packages/core/src/docs/examples/add-data.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddData": () => (/* binding */ AddData),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Add data\"\n                    description={\n                        <>\n                            <Description>Data can be added by clicking on the trailing row.</Description>\n                            <MoreInfo>\n                                Keyboard is also supported, just navigate past the last row and press{\" \"}\n                                <KeyName>Enter</KeyName>\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AddData: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        // our data source is a mock source that pre-fills data, so we are just clearing this here. You should not\n        // need to do this.\n        for (let c = 0; c < cols.length; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        // Tell the data grid there is another row\n        setNumRows(cv => cv + 1);\n    }, [cols.length, getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onPaste={true} // we want to allow paste to just call onCellEdited\n            onCellEdited={setCellValue} // Sets the mock cell content\n            trailingRowOptions={{\n                // How to get the trailing row to look right\n                sticky: true,\n                tint: true,\n                hint: \"New row...\",\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "AddData": {
    "startLoc": {
      "col": 34,
      "line": 38
    },
    "endLoc": {
      "col": 1,
      "line": 73
    },
    "startBody": {
      "col": 34,
      "line": 38
    },
    "endBody": {
      "col": 1,
      "line": 73
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Add data\"\n                    description={\n                        <>\n                            <Description>Data can be added by clicking on the trailing row.</Description>\n                            <MoreInfo>\n                                Keyboard is also supported, just navigate past the last row and press{\" \"}\n                                <KeyName>Enter</KeyName>\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AddData: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        // our data source is a mock source that pre-fills data, so we are just clearing this here. You should not\n        // need to do this.\n        for (let c = 0; c < cols.length; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        // Tell the data grid there is another row\n        setNumRows(cv => cv + 1);\n    }, [cols.length, getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onPaste={true} // we want to allow paste to just call onCellEdited\n            onCellEdited={setCellValue} // Sets the mock cell content\n            trailingRowOptions={{\n                // How to get the trailing row to look right\n                sticky: true,\n                tint: true,\n                hint: \"New row...\",\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n        />\n    );\n};\n",
      "locationsMap": {
        "add-data": {
          "startLoc": {
            "col": 34,
            "line": 38
          },
          "endLoc": {
            "col": 1,
            "line": 73
          },
          "startBody": {
            "col": 34,
            "line": 38
          },
          "endBody": {
            "col": 1,
            "line": 73
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Add data",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Data can be added by clicking on the trailing row."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Keyboard is also supported, just navigate past the last row and press", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "Enter")))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const AddData = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;

    for (let c = 0; c < cols.length; c++) {
      const cell = getCellContent([c, newRow]);
      setCellValueRaw([c, newRow], (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .clearCell */ .MP)(cell));
    }

    setNumRows(cv => cv + 1);
  }, [cols.length, getCellContent, numRows, setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    onPaste: true,
    onCellEdited: setCellValue,
    trailingRowOptions: {
      sticky: true,
      tint: true,
      hint: "New row..."
    },
    rows: numRows,
    onRowAppended: onRowAppended
  }));
};
const __namedExportsOrder = ["AddData"];

/***/ }),

/***/ "./packages/core/src/docs/examples/all-cell-kinds.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AllCellKinds": () => (/* binding */ AllCellKinds),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Lotsa cell kinds\"\n                    description={\n                        <Description>\n                            Data grid supports plenty cell kinds. Anything under <PropName>GridCellKind</PropName>.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AllCellKinds: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            onCellEdited={setCellValue}\n            // rowHeight={55}\n            onColumnResize={onColumnResize}\n            highlightRegions={[\n                {\n                    color: \"#ff00ff33\",\n                    range: {\n                        x: 1,\n                        y: 1,\n                        width: 3,\n                        height: 3,\n                    },\n                },\n            ]}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "AllCellKinds": {
    "startLoc": {
      "col": 39,
      "line": 32
    },
    "endLoc": {
      "col": 1,
      "line": 57
    },
    "startBody": {
      "col": 39,
      "line": 32
    },
    "endBody": {
      "col": 1,
      "line": 57
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Lotsa cell kinds\"\n                    description={\n                        <Description>\n                            Data grid supports plenty cell kinds. Anything under <PropName>GridCellKind</PropName>.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AllCellKinds: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            onCellEdited={setCellValue}\n            // rowHeight={55}\n            onColumnResize={onColumnResize}\n            highlightRegions={[\n                {\n                    color: \"#ff00ff33\",\n                    range: {\n                        x: 1,\n                        y: 1,\n                        width: 3,\n                        height: 3,\n                    },\n                },\n            ]}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "all-cell-kinds": {
          "startLoc": {
            "col": 39,
            "line": 32
          },
          "endLoc": {
            "col": 1,
            "line": 57
          },
          "startBody": {
            "col": 39,
            "line": 32
          },
          "endBody": {
            "col": 1,
            "line": 57
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Lotsa cell kinds",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Data grid supports plenty cell kinds. Anything under ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "GridCellKind"), ".")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const AllCellKinds = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    highlightRegions: [{
      color: "#ff00ff33",
      range: {
        x: 1,
        y: 1,
        width: 3,
        height: 3
      }
    }],
    rows: 1000
  }));
};
const __namedExportsOrder = ["AllCellKinds"];

/***/ }),

/***/ "./packages/core/src/docs/examples/append-row-handle.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppendRowHandle": () => (/* binding */ AppendRowHandle),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor, DataEditorRef } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AppendRowHandle: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const onClick = React.useCallback(() => {\n        void ref.current?.appendRow(3, false);\n    }, [ref]);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"appendRow Ref\"\n            description={\n                <>\n                    <Description>\n                        Adding data can also be triggered from outside of <PropName>DataEditor</PropName>\n                    </Description>\n                    <MoreInfo>\n                        By calling <PropName>appendRow</PropName> on a <PropName>ref</PropName> to your grid, you can\n                        trigger the append elsewhere, like this <KeyName onClick={onClick}>Append</KeyName> button\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "AppendRowHandle": {
    "startLoc": {
      "col": 42,
      "line": 27
    },
    "endLoc": {
      "col": 1,
      "line": 78
    },
    "startBody": {
      "col": 42,
      "line": 27
    },
    "endBody": {
      "col": 1,
      "line": 78
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor, DataEditorRef } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AppendRowHandle: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const onClick = React.useCallback(() => {\n        void ref.current?.appendRow(3, false);\n    }, [ref]);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"appendRow Ref\"\n            description={\n                <>\n                    <Description>\n                        Adding data can also be triggered from outside of <PropName>DataEditor</PropName>\n                    </Description>\n                    <MoreInfo>\n                        By calling <PropName>appendRow</PropName> on a <PropName>ref</PropName> to your grid, you can\n                        trigger the append elsewhere, like this <KeyName onClick={onClick}>Append</KeyName> button\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n",
      "locationsMap": {
        "append-row-handle": {
          "startLoc": {
            "col": 42,
            "line": 27
          },
          "endLoc": {
            "col": 1,
            "line": 78
          },
          "startBody": {
            "col": 42,
            "line": 27
          },
          "endBody": {
            "col": 1,
            "line": 78
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const AppendRowHandle = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const onClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _ref$current;

    void ((_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.appendRow(3, false));
  }, [ref]);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, newRow]);
      setCellValueRaw([c, newRow], (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .clearCell */ .MP)(cell));
    }

    setNumRows(cv => cv + 1);
  }, [getCellContent, numRows, setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "appendRow Ref",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Adding data can also be triggered from outside of ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "DataEditor")), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "By calling ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "appendRow"), " on a ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "ref"), " to your grid, you can trigger the append elsewhere, like this ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, {
      onClick: onClick
    }, "Append"), " button"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    ref: ref,
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      hint: "New row...",
      sticky: true,
      tint: true
    },
    rows: numRows,
    onRowAppended: onRowAppended
  })));
};
const __namedExportsOrder = ["AppendRowHandle"];

/***/ }),

/***/ "./packages/core/src/docs/examples/automatic-row-markers.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutomaticRowMarkers": () => (/* binding */ AutomaticRowMarkers),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AutomaticRowMarkers: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const dataEditor = (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers={\"checkbox-visible\"}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={1000}\n        />\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Automatic Row Markers\"\n            description={\n                <>\n                    <Description>\n                        You can enable row markers with rich selection behavior using the{\" \"}\n                        <PropName>rowMarkers</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        Use <KeyName>⇧</KeyName> + click to make range selections, and <KeyName>Ctrl</KeyName> (\n                        <KeyName>⌘</KeyName> on Mac) + click to add/remove individual rows.\n                    </MoreInfo>\n                </>\n            }>\n            {dataEditor}\n        </BeautifulWrapper>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "AutomaticRowMarkers": {
    "startLoc": {
      "col": 46,
      "line": 26
    },
    "endLoc": {
      "col": 1,
      "line": 57
    },
    "startBody": {
      "col": 46,
      "line": 26
    },
    "endBody": {
      "col": 1,
      "line": 57
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const AutomaticRowMarkers: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const dataEditor = (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers={\"checkbox-visible\"}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={1000}\n        />\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Automatic Row Markers\"\n            description={\n                <>\n                    <Description>\n                        You can enable row markers with rich selection behavior using the{\" \"}\n                        <PropName>rowMarkers</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        Use <KeyName>⇧</KeyName> + click to make range selections, and <KeyName>Ctrl</KeyName> (\n                        <KeyName>⌘</KeyName> on Mac) + click to add/remove individual rows.\n                    </MoreInfo>\n                </>\n            }>\n            {dataEditor}\n        </BeautifulWrapper>\n    );\n};\n",
      "locationsMap": {
        "automatic-row-markers": {
          "startLoc": {
            "col": 46,
            "line": 26
          },
          "endLoc": {
            "col": 1,
            "line": 57
          },
          "startBody": {
            "col": 46,
            "line": 26
          },
          "endBody": {
            "col": 1,
            "line": 57
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const AutomaticRowMarkers = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6);
  const dataEditor = react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowMarkers: "checkbox-visible",
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  }));
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Automatic Row Markers",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can enable row markers with rich selection behavior using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "rowMarkers"), " prop."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Use ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "\u21E7"), " + click to make range selections, and ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "Ctrl"), " (", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "\u2318"), " on Mac) + click to add/remove individual rows."))
  }, dataEditor);
};
const __namedExportsOrder = ["AutomaticRowMarkers"];

/***/ }),

/***/ "./packages/core/src/docs/examples/built-in-search.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BuiltInSearch": () => (/* binding */ BuiltInSearch),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/common/utils.tsx");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { useEventListener } from \"../../common/utils\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    KeyName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { GridSelection } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Search is easy\"\n                    description={\n                        <>\n                            <Description>\n                                Search for any data in your grid by setting <PropName>showSearch</PropName>.\n                            </Description>\n                            <MoreInfo>\n                                In this story, <KeyName>Ctrl</KeyName> (<KeyName>⌘</KeyName> on Mac) +{\" \"}\n                                <KeyName>f</KeyName> toggles the search bar. Make sure you&apos;re focused on the Data\n                                Grid!\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const BuiltInSearch: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [showSearch, setShowSearch] = React.useState(false);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        rows: CompactSelection.empty(),\n        columns: CompactSelection.empty(),\n    });\n\n    useEventListener(\n        \"keydown\",\n        React.useCallback(event => {\n            if ((event.ctrlKey || event.metaKey) && event.code === \"KeyF\") {\n                setShowSearch(cv => !cv);\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        }, []),\n        window,\n        false,\n        true\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            getCellsForSelection={true}\n            gridSelection={selection}\n            onGridSelectionChange={setSelection}\n            columns={cols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            showSearch={showSearch}\n            onSearchClose={() => setShowSearch(false)}\n            rows={10_000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "BuiltInSearch": {
    "startLoc": {
      "col": 40,
      "line": 44
    },
    "endLoc": {
      "col": 1,
      "line": 83
    },
    "startBody": {
      "col": 40,
      "line": 44
    },
    "endBody": {
      "col": 1,
      "line": 83
    }
  }
};






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { useEventListener } from \"../../common/utils\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    KeyName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { GridSelection } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Search is easy\"\n                    description={\n                        <>\n                            <Description>\n                                Search for any data in your grid by setting <PropName>showSearch</PropName>.\n                            </Description>\n                            <MoreInfo>\n                                In this story, <KeyName>Ctrl</KeyName> (<KeyName>⌘</KeyName> on Mac) +{\" \"}\n                                <KeyName>f</KeyName> toggles the search bar. Make sure you&apos;re focused on the Data\n                                Grid!\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const BuiltInSearch: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [showSearch, setShowSearch] = React.useState(false);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        rows: CompactSelection.empty(),\n        columns: CompactSelection.empty(),\n    });\n\n    useEventListener(\n        \"keydown\",\n        React.useCallback(event => {\n            if ((event.ctrlKey || event.metaKey) && event.code === \"KeyF\") {\n                setShowSearch(cv => !cv);\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        }, []),\n        window,\n        false,\n        true\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            getCellsForSelection={true}\n            gridSelection={selection}\n            onGridSelectionChange={setSelection}\n            columns={cols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            showSearch={showSearch}\n            onSearchClose={() => setShowSearch(false)}\n            rows={10_000}\n        />\n    );\n};\n",
      "locationsMap": {
        "built-in-search": {
          "startLoc": {
            "col": 40,
            "line": 44
          },
          "endLoc": {
            "col": 1,
            "line": 83
          },
          "startBody": {
            "col": 40,
            "line": 44
          },
          "endBody": {
            "col": 1,
            "line": 83
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Search is easy",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Search for any data in your grid by setting ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "showSearch"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "In this story, ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "Ctrl"), " (", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "\u2318"), " on Mac) +", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "f"), " toggles the search bar. Make sure you're focused on the Data Grid!"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const BuiltInSearch = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const [showSearch, setShowSearch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [selection, setSelection] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty(),
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty()
  });
  (0,_common_utils__WEBPACK_IMPORTED_MODULE_4__/* .useEventListener */ .OR)("keydown", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    if ((event.ctrlKey || event.metaKey) && event.code === "KeyF") {
      setShowSearch(cv => !cv);
      event.stopPropagation();
      event.preventDefault();
    }
  }, []), window, false, true);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    getCellsForSelection: true,
    gridSelection: selection,
    onGridSelectionChange: setSelection,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    showSearch: showSearch,
    onSearchClose: () => setShowSearch(false),
    rows: 10000
  }));
};
const __namedExportsOrder = ["BuiltInSearch"];

/***/ }),

/***/ "./packages/core/src/docs/examples/cell-activated-event.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellActivatedEvent": () => (/* binding */ CellActivatedEvent),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    KeyName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { Item } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const CellActivatedEvent: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [lastActivated, setLastActivated] = React.useState<Item | undefined>(undefined);\n\n    const onCellActivated = React.useCallback((cell: Item) => {\n        setLastActivated(cell);\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Cell Activated event\"\n            description={\n                <>\n                    <Description>\n                        When you tap <KeyName>Enter</KeyName>, <KeyName>Space</KeyName> or double click a cell, that\n                        cell is activated. You can track this with <PropName>onCellActivated</PropName>.\n                    </Description>\n                    <MoreInfo>\n                        Last activated cell:{\" \"}\n                        {lastActivated === undefined ? \"none\" : `(${lastActivated[0]}, ${lastActivated[1]})`}\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                //initialSize={[849, 967]}\n                //scrollOffsetY={10_000}\n                getCellsForSelection={true}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                onCellActivated={onCellActivated}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "CellActivatedEvent": {
    "startLoc": {
      "col": 45,
      "line": 27
    },
    "endLoc": {
      "col": 1,
      "line": 65
    },
    "startBody": {
      "col": 45,
      "line": 27
    },
    "endBody": {
      "col": 1,
      "line": 65
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    KeyName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { Item } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const CellActivatedEvent: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [lastActivated, setLastActivated] = React.useState<Item | undefined>(undefined);\n\n    const onCellActivated = React.useCallback((cell: Item) => {\n        setLastActivated(cell);\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Cell Activated event\"\n            description={\n                <>\n                    <Description>\n                        When you tap <KeyName>Enter</KeyName>, <KeyName>Space</KeyName> or double click a cell, that\n                        cell is activated. You can track this with <PropName>onCellActivated</PropName>.\n                    </Description>\n                    <MoreInfo>\n                        Last activated cell:{\" \"}\n                        {lastActivated === undefined ? \"none\" : `(${lastActivated[0]}, ${lastActivated[1]})`}\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                //initialSize={[849, 967]}\n                //scrollOffsetY={10_000}\n                getCellsForSelection={true}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                onCellActivated={onCellActivated}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n",
      "locationsMap": {
        "cell-activated-event": {
          "startLoc": {
            "col": 45,
            "line": 27
          },
          "endLoc": {
            "col": 1,
            "line": 65
          },
          "startBody": {
            "col": 45,
            "line": 27
          },
          "endBody": {
            "col": 1,
            "line": 65
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const CellActivatedEvent = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const [lastActivated, setLastActivated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);
  const onCellActivated = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    setLastActivated(cell);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Cell Activated event",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "When you tap ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "Enter"), ", ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "Space"), " or double click a cell, that cell is activated. You can track this with ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onCellActivated"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Last activated cell:", " ", lastActivated === undefined ? "none" : `(${lastActivated[0]}, ${lastActivated[1]})`))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    getCellsForSelection: true,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    onCellActivated: onCellActivated,
    rows: 10000
  })));
};
const __namedExportsOrder = ["CellActivatedEvent"];

/***/ }),

/***/ "./packages/core/src/docs/examples/column-group-collapse.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColumnGroupCollapse": () => (/* binding */ ColumnGroupCollapse),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { GridColumn, GroupHeaderClickedEventArgs } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Group collapse\"\n                    description={\n                        <>\n                            <Description>\n                                Through clever usage of <PropName>onGroupHeaderClicked</PropName> you can implement\n                                group collapsing. This is a very basic version however it is possible to go much\n                                further.\n                            </Description>\n                            <MoreInfo>\n                                Cells under a certain size will not attempt to render to save some frames.\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nfunction useCollapsableColumnGroups(cols: readonly GridColumn[]) {\n    const [collapsed, setCollapsed] = React.useState<readonly string[]>([]);\n\n    const onGroupHeaderClicked = React.useCallback(\n        (colIndex: number, args: GroupHeaderClickedEventArgs) => {\n            const group = cols[colIndex].group ?? \"\";\n            setCollapsed(cv => (cv.includes(group) ? cv.filter(g => g !== group) : [...cv, group]));\n            args.preventDefault();\n        },\n        [cols]\n    );\n\n    const [selectedColumns, setSelectedColumns] = React.useState<CompactSelection>(CompactSelection.empty());\n\n    const setCols = React.useCallback((newVal: CompactSelection, trigger: string) => {\n        if (trigger === \"group\") return;\n\n        setSelectedColumns(newVal);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        return cols.map(c => {\n            if (!collapsed.includes(c.group ?? \"\"))\n                return {\n                    ...c,\n                    hasMenu: true,\n                };\n            return {\n                ...c,\n                width: 8,\n                hasMenu: true,\n            };\n        });\n    }, [collapsed, cols]);\n\n    return {\n        columns,\n        onGroupHeaderClicked,\n        selectedColumns,\n        onSelectedColumnsChange: setCols,\n    };\n}\n\nexport const ColumnGroupCollapse: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\n\n    const groupHeaderArgs = useCollapsableColumnGroups(cols);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            {...groupHeaderArgs}\n            getCellContent={getCellContent}\n            groupHeaderHeight={24}\n            rows={1000}\n            rowMarkers=\"both\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ColumnGroupCollapse": {
    "startLoc": {
      "col": 46,
      "line": 85
    },
    "endLoc": {
      "col": 1,
      "line": 100
    },
    "startBody": {
      "col": 46,
      "line": 85
    },
    "endBody": {
      "col": 1,
      "line": 100
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { GridColumn, GroupHeaderClickedEventArgs } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Group collapse\"\n                    description={\n                        <>\n                            <Description>\n                                Through clever usage of <PropName>onGroupHeaderClicked</PropName> you can implement\n                                group collapsing. This is a very basic version however it is possible to go much\n                                further.\n                            </Description>\n                            <MoreInfo>\n                                Cells under a certain size will not attempt to render to save some frames.\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nfunction useCollapsableColumnGroups(cols: readonly GridColumn[]) {\n    const [collapsed, setCollapsed] = React.useState<readonly string[]>([]);\n\n    const onGroupHeaderClicked = React.useCallback(\n        (colIndex: number, args: GroupHeaderClickedEventArgs) => {\n            const group = cols[colIndex].group ?? \"\";\n            setCollapsed(cv => (cv.includes(group) ? cv.filter(g => g !== group) : [...cv, group]));\n            args.preventDefault();\n        },\n        [cols]\n    );\n\n    const [selectedColumns, setSelectedColumns] = React.useState<CompactSelection>(CompactSelection.empty());\n\n    const setCols = React.useCallback((newVal: CompactSelection, trigger: string) => {\n        if (trigger === \"group\") return;\n\n        setSelectedColumns(newVal);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        return cols.map(c => {\n            if (!collapsed.includes(c.group ?? \"\"))\n                return {\n                    ...c,\n                    hasMenu: true,\n                };\n            return {\n                ...c,\n                width: 8,\n                hasMenu: true,\n            };\n        });\n    }, [collapsed, cols]);\n\n    return {\n        columns,\n        onGroupHeaderClicked,\n        selectedColumns,\n        onSelectedColumnsChange: setCols,\n    };\n}\n\nexport const ColumnGroupCollapse: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\n\n    const groupHeaderArgs = useCollapsableColumnGroups(cols);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            {...groupHeaderArgs}\n            getCellContent={getCellContent}\n            groupHeaderHeight={24}\n            rows={1000}\n            rowMarkers=\"both\"\n        />\n    );\n};\n",
      "locationsMap": {
        "column-group-collapse": {
          "startLoc": {
            "col": 46,
            "line": 85
          },
          "endLoc": {
            "col": 1,
            "line": 100
          },
          "startBody": {
            "col": 46,
            "line": 85
          },
          "endBody": {
            "col": 1,
            "line": 100
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Group collapse",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Through clever usage of ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onGroupHeaderClicked"), " you can implement group collapsing. This is a very basic version however it is possible to go much further."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Cells under a certain size will not attempt to render to save some frames."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});

function useCollapsableColumnGroups(cols) {
  const [collapsed, setCollapsed] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  const onGroupHeaderClicked = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((colIndex, args) => {
    var _cols$colIndex$group;

    const group = (_cols$colIndex$group = cols[colIndex].group) !== null && _cols$colIndex$group !== void 0 ? _cols$colIndex$group : "";
    setCollapsed(cv => cv.includes(group) ? cv.filter(g => g !== group) : [...cv, group]);
    args.preventDefault();
  }, [cols]);
  const [selectedColumns, setSelectedColumns] = react__WEBPACK_IMPORTED_MODULE_0__.useState(_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty());
  const setCols = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal, trigger) => {
    if (trigger === "group") return;
    setSelectedColumns(newVal);
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return cols.map(c => {
      var _c$group;

      if (!collapsed.includes((_c$group = c.group) !== null && _c$group !== void 0 ? _c$group : "")) return { ...c,
        hasMenu: true
      };
      return { ...c,
        width: 8,
        hasMenu: true
      };
    });
  }, [collapsed, cols]);
  return {
    columns,
    onGroupHeaderClicked,
    selectedColumns,
    onSelectedColumnsChange: setCols
  };
}

const ColumnGroupCollapse = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100, true, true);
  const groupHeaderArgs = useCollapsableColumnGroups(cols);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, groupHeaderArgs, {
    getCellContent: getCellContent,
    groupHeaderHeight: 24,
    rows: 1000,
    rowMarkers: "both"
  }));
};
const __namedExportsOrder = ["ColumnGroupCollapse"];

/***/ }),

/***/ "./packages/core/src/docs/examples/column-groups.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColumnGroups": () => (/* binding */ ColumnGroups),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridColumnIcon } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Column Grouping\"\n                    description={\n                        <Description>\n                            Columns in the data grid may be grouped by setting their <PropName>group</PropName>{\" \"}\n                            property.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ColumnGroups: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(20, true, true);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            onGroupHeaderRenamed={(x, y) => window.alert(`Please rename group ${x} to ${y}`)}\n            columns={cols}\n            rows={1000}\n            getGroupDetails={g => ({\n                name: g,\n                icon: g === \"\" ? undefined : GridColumnIcon.HeaderCode,\n            })}\n            rowMarkers=\"both\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ColumnGroups": {
    "startLoc": {
      "col": 39,
      "line": 34
    },
    "endLoc": {
      "col": 1,
      "line": 51
    },
    "startBody": {
      "col": 39,
      "line": 34
    },
    "endBody": {
      "col": 1,
      "line": 51
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridColumnIcon } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Column Grouping\"\n                    description={\n                        <Description>\n                            Columns in the data grid may be grouped by setting their <PropName>group</PropName>{\" \"}\n                            property.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ColumnGroups: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(20, true, true);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            onGroupHeaderRenamed={(x, y) => window.alert(`Please rename group ${x} to ${y}`)}\n            columns={cols}\n            rows={1000}\n            getGroupDetails={g => ({\n                name: g,\n                icon: g === \"\" ? undefined : GridColumnIcon.HeaderCode,\n            })}\n            rowMarkers=\"both\"\n        />\n    );\n};\n",
      "locationsMap": {
        "column-groups": {
          "startLoc": {
            "col": 39,
            "line": 34
          },
          "endLoc": {
            "col": 1,
            "line": 51
          },
          "startBody": {
            "col": 39,
            "line": 34
          },
          "endBody": {
            "col": 1,
            "line": 51
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Column Grouping",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Columns in the data grid may be grouped by setting their ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "group"), " ", "property.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const ColumnGroups = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(20, true, true);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    onGroupHeaderRenamed: (x, y) => window.alert(`Please rename group ${x} to ${y}`),
    columns: cols,
    rows: 1000,
    getGroupDetails: g => ({
      name: g,
      icon: g === "" ? undefined : _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderCode */ .PE.HeaderCode
    }),
    rowMarkers: "both"
  }));
};
const __namedExportsOrder = ["ColumnGroups"];

/***/ }),

/***/ "./packages/core/src/docs/examples/content-alignment.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContentAlignment": () => (/* binding */ ContentAlignment),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Content Alignment\"\n                    description={\n                        <Description>\n                            You can customize the content alignment by setting <PropName>contentAlign</PropName> of a\n                            cell to <PropName>left</PropName>, <PropName>right</PropName> or <PropName>center</PropName>\n                            .\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ContentAlignment: React.VFC = () => {\n    const { cols, getCellContent } = useAllMockedKinds();\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            const [col, _row] = cell;\n            if (col === 3) {\n                return {\n                    ...getCellContent(cell),\n                    contentAlign: \"center\",\n                };\n            }\n            if (col === 4) {\n                return {\n                    ...getCellContent(cell),\n                    contentAlign: \"right\",\n                };\n            }\n            return getCellContent(cell);\n        },\n        [getCellContent]\n    );\n\n    return <DataEditor {...defaultProps} getCellContent={mangledGetCellContent} columns={cols} rows={300} />;\n};\n";
var __LOCATIONS_MAP__ = {
  "ContentAlignment": {
    "startLoc": {
      "col": 43,
      "line": 34
    },
    "endLoc": {
      "col": 1,
      "line": 58
    },
    "startBody": {
      "col": 43,
      "line": 34
    },
    "endBody": {
      "col": 1,
      "line": 58
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Content Alignment\"\n                    description={\n                        <Description>\n                            You can customize the content alignment by setting <PropName>contentAlign</PropName> of a\n                            cell to <PropName>left</PropName>, <PropName>right</PropName> or <PropName>center</PropName>\n                            .\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ContentAlignment: React.VFC = () => {\n    const { cols, getCellContent } = useAllMockedKinds();\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            const [col, _row] = cell;\n            if (col === 3) {\n                return {\n                    ...getCellContent(cell),\n                    contentAlign: \"center\",\n                };\n            }\n            if (col === 4) {\n                return {\n                    ...getCellContent(cell),\n                    contentAlign: \"right\",\n                };\n            }\n            return getCellContent(cell);\n        },\n        [getCellContent]\n    );\n\n    return <DataEditor {...defaultProps} getCellContent={mangledGetCellContent} columns={cols} rows={300} />;\n};\n",
      "locationsMap": {
        "content-alignment": {
          "startLoc": {
            "col": 43,
            "line": 34
          },
          "endLoc": {
            "col": 1,
            "line": 58
          },
          "startBody": {
            "col": 43,
            "line": 34
          },
          "endBody": {
            "col": 1,
            "line": 58
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Content Alignment",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can customize the content alignment by setting ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "contentAlign"), " of a cell to ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "left"), ", ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "right"), " or ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "center"), ".")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const ContentAlignment = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const mangledGetCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, _row] = cell;

    if (col === 3) {
      return { ...getCellContent(cell),
        contentAlign: "center"
      };
    }

    if (col === 4) {
      return { ...getCellContent(cell),
        contentAlign: "right"
      };
    }

    return getCellContent(cell);
  }, [getCellContent]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: mangledGetCellContent,
    columns: cols,
    rows: 300
  }));
};
const __namedExportsOrder = ["ContentAlignment"];

/***/ }),

/***/ "./packages/core/src/docs/examples/controlled-selection.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ControlledSelection": () => (/* binding */ ControlledSelection),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { GridSelection } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ControlledSelection: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(30, true, true);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    return (\n        <BeautifulWrapper\n            title=\"Controlled Selection\"\n            description={\n                <Description>\n                    The selection of the grid can be controlled via <PropName>GridSelection</PropName> and{\" \"}\n                    <PropName>onGridSelectionChange</PropName>.\n                    <input\n                        type=\"range\"\n                        min={0}\n                        max={29}\n                        value={selection.current?.cell[0] ?? 0}\n                        onChange={e => {\n                            const newCol = e.target.valueAsNumber;\n                            setSelection(cv => ({\n                                ...cv,\n                                current: {\n                                    cell: [newCol, cv.current?.cell[1] ?? 0],\n                                    range: {\n                                        x: newCol,\n                                        y: cv.current?.cell[1] ?? 0,\n                                        width: 1,\n                                        height: 1,\n                                    },\n                                    rangeStack: [],\n                                },\n                            }));\n                        }}\n                    />\n                    <input\n                        type=\"range\"\n                        min={0}\n                        max={99}\n                        value={selection.current?.cell[1] ?? 0}\n                        onChange={e => {\n                            const newRow = e.target.valueAsNumber;\n                            setSelection(cv => ({\n                                ...cv,\n                                current: {\n                                    cell: [cv.current?.cell[0] ?? 0, newRow],\n                                    range: {\n                                        x: cv.current?.cell[0] ?? 0,\n                                        y: newRow,\n                                        width: 1,\n                                        height: 1,\n                                    },\n                                    rangeStack: [],\n                                },\n                            }));\n                        }}\n                    />\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                gridSelection={selection}\n                onGridSelectionChange={setSelection}\n                columns={cols}\n                rows={100}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ControlledSelection": {
    "startLoc": {
      "col": 46,
      "line": 26
    },
    "endLoc": {
      "col": 1,
      "line": 98
    },
    "startBody": {
      "col": 46,
      "line": 26
    },
    "endBody": {
      "col": 1,
      "line": 98
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { GridSelection } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ControlledSelection: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(30, true, true);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    return (\n        <BeautifulWrapper\n            title=\"Controlled Selection\"\n            description={\n                <Description>\n                    The selection of the grid can be controlled via <PropName>GridSelection</PropName> and{\" \"}\n                    <PropName>onGridSelectionChange</PropName>.\n                    <input\n                        type=\"range\"\n                        min={0}\n                        max={29}\n                        value={selection.current?.cell[0] ?? 0}\n                        onChange={e => {\n                            const newCol = e.target.valueAsNumber;\n                            setSelection(cv => ({\n                                ...cv,\n                                current: {\n                                    cell: [newCol, cv.current?.cell[1] ?? 0],\n                                    range: {\n                                        x: newCol,\n                                        y: cv.current?.cell[1] ?? 0,\n                                        width: 1,\n                                        height: 1,\n                                    },\n                                    rangeStack: [],\n                                },\n                            }));\n                        }}\n                    />\n                    <input\n                        type=\"range\"\n                        min={0}\n                        max={99}\n                        value={selection.current?.cell[1] ?? 0}\n                        onChange={e => {\n                            const newRow = e.target.valueAsNumber;\n                            setSelection(cv => ({\n                                ...cv,\n                                current: {\n                                    cell: [cv.current?.cell[0] ?? 0, newRow],\n                                    range: {\n                                        x: cv.current?.cell[0] ?? 0,\n                                        y: newRow,\n                                        width: 1,\n                                        height: 1,\n                                    },\n                                    rangeStack: [],\n                                },\n                            }));\n                        }}\n                    />\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                gridSelection={selection}\n                onGridSelectionChange={setSelection}\n                columns={cols}\n                rows={100}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n",
      "locationsMap": {
        "controlled-selection": {
          "startLoc": {
            "col": 46,
            "line": 26
          },
          "endLoc": {
            "col": 1,
            "line": 98
          },
          "startBody": {
            "col": 46,
            "line": 26
          },
          "endBody": {
            "col": 1,
            "line": 98
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const ControlledSelection = () => {
  var _selection$current$ce, _selection$current, _selection$current$ce2, _selection$current2;

  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(30, true, true);
  const [selection, setSelection] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty()
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Controlled Selection",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "The selection of the grid can be controlled via ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "GridSelection"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onGridSelectionChange"), ".", react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      type: "range",
      min: 0,
      max: 29,
      value: (_selection$current$ce = (_selection$current = selection.current) === null || _selection$current === void 0 ? void 0 : _selection$current.cell[0]) !== null && _selection$current$ce !== void 0 ? _selection$current$ce : 0,
      onChange: e => {
        const newCol = e.target.valueAsNumber;
        setSelection(cv => {
          var _cv$current$cell$, _cv$current, _cv$current$cell$2, _cv$current2;

          return { ...cv,
            current: {
              cell: [newCol, (_cv$current$cell$ = (_cv$current = cv.current) === null || _cv$current === void 0 ? void 0 : _cv$current.cell[1]) !== null && _cv$current$cell$ !== void 0 ? _cv$current$cell$ : 0],
              range: {
                x: newCol,
                y: (_cv$current$cell$2 = (_cv$current2 = cv.current) === null || _cv$current2 === void 0 ? void 0 : _cv$current2.cell[1]) !== null && _cv$current$cell$2 !== void 0 ? _cv$current$cell$2 : 0,
                width: 1,
                height: 1
              },
              rangeStack: []
            }
          };
        });
      }
    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      type: "range",
      min: 0,
      max: 99,
      value: (_selection$current$ce2 = (_selection$current2 = selection.current) === null || _selection$current2 === void 0 ? void 0 : _selection$current2.cell[1]) !== null && _selection$current$ce2 !== void 0 ? _selection$current$ce2 : 0,
      onChange: e => {
        const newRow = e.target.valueAsNumber;
        setSelection(cv => {
          var _cv$current$cell$3, _cv$current3, _cv$current$cell$4, _cv$current4;

          return { ...cv,
            current: {
              cell: [(_cv$current$cell$3 = (_cv$current3 = cv.current) === null || _cv$current3 === void 0 ? void 0 : _cv$current3.cell[0]) !== null && _cv$current$cell$3 !== void 0 ? _cv$current$cell$3 : 0, newRow],
              range: {
                x: (_cv$current$cell$4 = (_cv$current4 = cv.current) === null || _cv$current4 === void 0 ? void 0 : _cv$current4.cell[0]) !== null && _cv$current$cell$4 !== void 0 ? _cv$current$cell$4 : 0,
                y: newRow,
                width: 1,
                height: 1
              },
              rangeStack: []
            }
          };
        });
      }
    }))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    gridSelection: selection,
    onGridSelectionChange: setSelection,
    columns: cols,
    rows: 100,
    rowMarkers: "both"
  })));
};
const __namedExportsOrder = ["ControlledSelection"];

/***/ }),

/***/ "./packages/core/src/docs/examples/copy-support.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CopySupport": () => (/* binding */ CopySupport),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Copy support\"\n                    description={\n                        <>\n                            <Description>\n                                Large amounts of data can be copied and customized using{\" \"}\n                                <PropName>getCellsForSelection</PropName>.\n                            </Description>\n                            <MoreInfo>\n                                The data is copied into a format ready to be pasted into Excel or Google Sheets\n                            </MoreInfo>\n                            <textarea\n                                placeholder=\"Copy something below and paste it here...\"\n                                style={{\n                                    width: \"100%\",\n                                    marginBottom: 20,\n                                    borderRadius: 9,\n                                    minHeight: 200,\n                                    padding: 10,\n                                }}\n                            />\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const CopySupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useMockDataGenerator(10, false);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            rowMarkers=\"both\"\n            columns={cols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            rows={400}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "CopySupport": {
    "startLoc": {
      "col": 38,
      "line": 49
    },
    "endLoc": {
      "col": 1,
      "line": 63
    },
    "startBody": {
      "col": 38,
      "line": 49
    },
    "endBody": {
      "col": 1,
      "line": 63
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Copy support\"\n                    description={\n                        <>\n                            <Description>\n                                Large amounts of data can be copied and customized using{\" \"}\n                                <PropName>getCellsForSelection</PropName>.\n                            </Description>\n                            <MoreInfo>\n                                The data is copied into a format ready to be pasted into Excel or Google Sheets\n                            </MoreInfo>\n                            <textarea\n                                placeholder=\"Copy something below and paste it here...\"\n                                style={{\n                                    width: \"100%\",\n                                    marginBottom: 20,\n                                    borderRadius: 9,\n                                    minHeight: 200,\n                                    padding: 10,\n                                }}\n                            />\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const CopySupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useMockDataGenerator(10, false);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            rowMarkers=\"both\"\n            columns={cols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            rows={400}\n        />\n    );\n};\n",
      "locationsMap": {
        "copy-support": {
          "startLoc": {
            "col": 38,
            "line": 49
          },
          "endLoc": {
            "col": 1,
            "line": 63
          },
          "startBody": {
            "col": 38,
            "line": 49
          },
          "endBody": {
            "col": 1,
            "line": 63
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Copy support",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Large amounts of data can be copied and customized using", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "getCellsForSelection"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "The data is copied into a format ready to be pasted into Excel or Google Sheets"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
      placeholder: "Copy something below and paste it here...",
      style: {
        width: "100%",
        marginBottom: 20,
        borderRadius: 9,
        minHeight: 200,
        padding: 10
      }
    }))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const CopySupport = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(10, false);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    rowMarkers: "both",
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 400
  }));
};
const __namedExportsOrder = ["CopySupport"];

/***/ }),

/***/ "./packages/core/src/docs/examples/custom-header-icons.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomHeaderIcons": () => (/* binding */ CustomHeaderIcons),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { SpriteMap } from \"../../data-grid/data-grid-sprites\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Custom header icons\"\n                    description={\n                        <>\n                            <Description>\n                                You can provide overrides for the default icons by passing the{\" \"}\n                                <PropName>headerIcons</PropName> prop.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const CustomHeaderIcons: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        const c = [...cols];\n        c[3] = {\n            ...c[3],\n            title: \"CUSTOM ICON\",\n            icon: \"custom\",\n            width: 200,\n        };\n        return c;\n    }, [cols]);\n\n    const headerIcons = React.useMemo<SpriteMap>(() => {\n        return {\n            custom: p => `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <rect x=\"2.00015\" y=\"2\" width=\"16\" height=\"16\" rx=\"4\" fill=\"${p.bgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.69759 6.00977C4.23735 6.00977 3.86426 6.38286 3.86426 6.8431C3.86426 7.30334 4.23735 7.67643 4.69759 7.67643H8.86426C9.3245 7.67643 9.69759 7.30334 9.69759 6.8431C9.69759 6.38286 9.32449 6.00977 8.86426 6.00977H4.69759Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.61426 4.76009C7.61426 4.29985 7.24116 3.92676 6.78092 3.92676C6.32069 3.92676 5.94759 4.29985 5.94759 4.76009L5.94759 8.92676C5.94759 9.387 6.32069 9.76009 6.78092 9.76009C7.24116 9.76009 7.61426 9.38699 7.61426 8.92676L7.61426 4.76009Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M11.0336 6.00977C10.5734 6.00977 10.2003 6.38286 10.2003 6.8431C10.2003 7.30334 10.5734 7.67643 11.0336 7.67643H15.2003C15.6605 7.67643 16.0336 7.30334 16.0336 6.8431C16.0336 6.38286 15.6605 6.00977 15.2003 6.00977H11.0336Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.89704 10.9916C5.5716 10.6662 5.04397 10.6662 4.71853 10.9916C4.39309 11.317 4.39309 11.8447 4.71853 12.1701L7.66481 15.1164C7.99024 15.4418 8.51788 15.4418 8.84332 15.1164C9.16876 14.791 9.16876 14.2633 8.84332 13.9379L5.89704 10.9916Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.84332 12.1703C9.16875 11.8449 9.16875 11.3172 8.84332 10.9918C8.51788 10.6664 7.99024 10.6664 7.6648 10.9918L4.71853 13.9381C4.39309 14.2635 4.39309 14.7912 4.71853 15.1166C5.04396 15.442 5.5716 15.442 5.89704 15.1166L8.84332 12.1703Z\" fill=\"${p.fgColor}\"/>\n                <path d=\"M10.2003 11.804C10.2003 11.3438 10.5734 10.9707 11.0336 10.9707H15.2003C15.6605 10.9707 16.0336 11.3438 16.0336 11.804C16.0336 12.2643 15.6605 12.6374 15.2003 12.6374H11.0336C10.5734 12.6374 10.2003 12.2643 10.2003 11.804Z\" fill=\"${p.fgColor}\"/>\n                <path d=\"M10.2003 14.304C10.2003 13.8438 10.5734 13.4707 11.0336 13.4707H15.2003C15.6605 13.4707 16.0336 13.8438 16.0336 14.304C16.0336 14.7643 15.6605 15.1374 15.2003 15.1374H11.0336C10.5734 15.1374 10.2003 14.7643 10.2003 14.304Z\" fill=\"${p.fgColor}\"/>\n            </svg>`,\n        };\n    }, []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={realCols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            headerIcons={headerIcons}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "CustomHeaderIcons": {
    "startLoc": {
      "col": 44,
      "line": 36
    },
    "endLoc": {
      "col": 1,
      "line": 76
    },
    "startBody": {
      "col": 44,
      "line": 36
    },
    "endBody": {
      "col": 1,
      "line": 76
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { SpriteMap } from \"../../data-grid/data-grid-sprites\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Custom header icons\"\n                    description={\n                        <>\n                            <Description>\n                                You can provide overrides for the default icons by passing the{\" \"}\n                                <PropName>headerIcons</PropName> prop.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const CustomHeaderIcons: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        const c = [...cols];\n        c[3] = {\n            ...c[3],\n            title: \"CUSTOM ICON\",\n            icon: \"custom\",\n            width: 200,\n        };\n        return c;\n    }, [cols]);\n\n    const headerIcons = React.useMemo<SpriteMap>(() => {\n        return {\n            custom: p => `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <rect x=\"2.00015\" y=\"2\" width=\"16\" height=\"16\" rx=\"4\" fill=\"${p.bgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.69759 6.00977C4.23735 6.00977 3.86426 6.38286 3.86426 6.8431C3.86426 7.30334 4.23735 7.67643 4.69759 7.67643H8.86426C9.3245 7.67643 9.69759 7.30334 9.69759 6.8431C9.69759 6.38286 9.32449 6.00977 8.86426 6.00977H4.69759Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.61426 4.76009C7.61426 4.29985 7.24116 3.92676 6.78092 3.92676C6.32069 3.92676 5.94759 4.29985 5.94759 4.76009L5.94759 8.92676C5.94759 9.387 6.32069 9.76009 6.78092 9.76009C7.24116 9.76009 7.61426 9.38699 7.61426 8.92676L7.61426 4.76009Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M11.0336 6.00977C10.5734 6.00977 10.2003 6.38286 10.2003 6.8431C10.2003 7.30334 10.5734 7.67643 11.0336 7.67643H15.2003C15.6605 7.67643 16.0336 7.30334 16.0336 6.8431C16.0336 6.38286 15.6605 6.00977 15.2003 6.00977H11.0336Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.89704 10.9916C5.5716 10.6662 5.04397 10.6662 4.71853 10.9916C4.39309 11.317 4.39309 11.8447 4.71853 12.1701L7.66481 15.1164C7.99024 15.4418 8.51788 15.4418 8.84332 15.1164C9.16876 14.791 9.16876 14.2633 8.84332 13.9379L5.89704 10.9916Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.84332 12.1703C9.16875 11.8449 9.16875 11.3172 8.84332 10.9918C8.51788 10.6664 7.99024 10.6664 7.6648 10.9918L4.71853 13.9381C4.39309 14.2635 4.39309 14.7912 4.71853 15.1166C5.04396 15.442 5.5716 15.442 5.89704 15.1166L8.84332 12.1703Z\" fill=\"${p.fgColor}\"/>\n                <path d=\"M10.2003 11.804C10.2003 11.3438 10.5734 10.9707 11.0336 10.9707H15.2003C15.6605 10.9707 16.0336 11.3438 16.0336 11.804C16.0336 12.2643 15.6605 12.6374 15.2003 12.6374H11.0336C10.5734 12.6374 10.2003 12.2643 10.2003 11.804Z\" fill=\"${p.fgColor}\"/>\n                <path d=\"M10.2003 14.304C10.2003 13.8438 10.5734 13.4707 11.0336 13.4707H15.2003C15.6605 13.4707 16.0336 13.8438 16.0336 14.304C16.0336 14.7643 15.6605 15.1374 15.2003 15.1374H11.0336C10.5734 15.1374 10.2003 14.7643 10.2003 14.304Z\" fill=\"${p.fgColor}\"/>\n            </svg>`,\n        };\n    }, []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={realCols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            headerIcons={headerIcons}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "custom-header-icons": {
          "startLoc": {
            "col": 44,
            "line": 36
          },
          "endLoc": {
            "col": 1,
            "line": 76
          },
          "startBody": {
            "col": 44,
            "line": 36
          },
          "endBody": {
            "col": 1,
            "line": 76
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Custom header icons",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can provide overrides for the default icons by passing the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "headerIcons"), " prop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const CustomHeaderIcons = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const realCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const c = [...cols];
    c[3] = { ...c[3],
      title: "CUSTOM ICON",
      icon: "custom",
      width: 200
    };
    return c;
  }, [cols]);
  const headerIcons = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      custom: p => `<svg width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="2.00015" y="2" width="16" height="16" rx="4" fill="${p.bgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M4.69759 6.00977C4.23735 6.00977 3.86426 6.38286 3.86426 6.8431C3.86426 7.30334 4.23735 7.67643 4.69759 7.67643H8.86426C9.3245 7.67643 9.69759 7.30334 9.69759 6.8431C9.69759 6.38286 9.32449 6.00977 8.86426 6.00977H4.69759Z" fill="${p.fgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M7.61426 4.76009C7.61426 4.29985 7.24116 3.92676 6.78092 3.92676C6.32069 3.92676 5.94759 4.29985 5.94759 4.76009L5.94759 8.92676C5.94759 9.387 6.32069 9.76009 6.78092 9.76009C7.24116 9.76009 7.61426 9.38699 7.61426 8.92676L7.61426 4.76009Z" fill="${p.fgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M11.0336 6.00977C10.5734 6.00977 10.2003 6.38286 10.2003 6.8431C10.2003 7.30334 10.5734 7.67643 11.0336 7.67643H15.2003C15.6605 7.67643 16.0336 7.30334 16.0336 6.8431C16.0336 6.38286 15.6605 6.00977 15.2003 6.00977H11.0336Z" fill="${p.fgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M5.89704 10.9916C5.5716 10.6662 5.04397 10.6662 4.71853 10.9916C4.39309 11.317 4.39309 11.8447 4.71853 12.1701L7.66481 15.1164C7.99024 15.4418 8.51788 15.4418 8.84332 15.1164C9.16876 14.791 9.16876 14.2633 8.84332 13.9379L5.89704 10.9916Z" fill="${p.fgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M8.84332 12.1703C9.16875 11.8449 9.16875 11.3172 8.84332 10.9918C8.51788 10.6664 7.99024 10.6664 7.6648 10.9918L4.71853 13.9381C4.39309 14.2635 4.39309 14.7912 4.71853 15.1166C5.04396 15.442 5.5716 15.442 5.89704 15.1166L8.84332 12.1703Z" fill="${p.fgColor}"/>
                <path d="M10.2003 11.804C10.2003 11.3438 10.5734 10.9707 11.0336 10.9707H15.2003C15.6605 10.9707 16.0336 11.3438 16.0336 11.804C16.0336 12.2643 15.6605 12.6374 15.2003 12.6374H11.0336C10.5734 12.6374 10.2003 12.2643 10.2003 11.804Z" fill="${p.fgColor}"/>
                <path d="M10.2003 14.304C10.2003 13.8438 10.5734 13.4707 11.0336 13.4707H15.2003C15.6605 13.4707 16.0336 13.8438 16.0336 14.304C16.0336 14.7643 15.6605 15.1374 15.2003 15.1374H11.0336C10.5734 15.1374 10.2003 14.7643 10.2003 14.304Z" fill="${p.fgColor}"/>
            </svg>`
    };
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: realCols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    headerIcons: headerIcons,
    rows: 1000
  }));
};
const __namedExportsOrder = ["CustomHeaderIcons"];

/***/ }),

/***/ "./packages/core/src/docs/examples/custom-header.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomHeader": () => (/* binding */ CustomHeader),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport type { DrawHeaderCallback } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Custom Header\"\n                    description={<Description>Make it as fancy as you like.</Description>}>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const CustomHeader: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    const drawHeader: DrawHeaderCallback = React.useCallback(args => {\n        const { ctx, rect } = args;\n        ctx.rect(rect.x, rect.y, rect.width, rect.height);\n        const lg = ctx.createLinearGradient(0, rect.y, 0, rect.y + rect.height);\n        lg.addColorStop(0, \"#ff00d934\");\n        lg.addColorStop(1, \"#00a2ff34\");\n        ctx.fillStyle = lg;\n        ctx.fill();\n        return false;\n    }, []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            drawHeader={drawHeader}\n            rows={3000}\n            rowMarkers=\"both\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "CustomHeader": {
    "startLoc": {
      "col": 39,
      "line": 23
    },
    "endLoc": {
      "col": 1,
      "line": 47
    },
    "startBody": {
      "col": 39,
      "line": 23
    },
    "endBody": {
      "col": 1,
      "line": 47
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport type { DrawHeaderCallback } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Custom Header\"\n                    description={<Description>Make it as fancy as you like.</Description>}>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const CustomHeader: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    const drawHeader: DrawHeaderCallback = React.useCallback(args => {\n        const { ctx, rect } = args;\n        ctx.rect(rect.x, rect.y, rect.width, rect.height);\n        const lg = ctx.createLinearGradient(0, rect.y, 0, rect.y + rect.height);\n        lg.addColorStop(0, \"#ff00d934\");\n        lg.addColorStop(1, \"#00a2ff34\");\n        ctx.fillStyle = lg;\n        ctx.fill();\n        return false;\n    }, []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            drawHeader={drawHeader}\n            rows={3000}\n            rowMarkers=\"both\"\n        />\n    );\n};\n",
      "locationsMap": {
        "custom-header": {
          "startLoc": {
            "col": 39,
            "line": 23
          },
          "endLoc": {
            "col": 1,
            "line": 47
          },
          "startBody": {
            "col": 39,
            "line": 23
          },
          "endBody": {
            "col": 1,
            "line": 47
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Custom Header",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Make it as fancy as you like.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const CustomHeader = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(1000, true, true);
  const drawHeader = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const {
      ctx,
      rect
    } = args;
    ctx.rect(rect.x, rect.y, rect.width, rect.height);
    const lg = ctx.createLinearGradient(0, rect.y, 0, rect.y + rect.height);
    lg.addColorStop(0, "#ff00d934");
    lg.addColorStop(1, "#00a2ff34");
    ctx.fillStyle = lg;
    ctx.fill();
    return false;
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    drawHeader: drawHeader,
    rows: 3000,
    rowMarkers: "both"
  }));
};
const __namedExportsOrder = ["CustomHeader"];

/***/ }),

/***/ "./packages/core/src/docs/examples/drag-source.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DragSource": () => (/* binding */ DragSource),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Drag source\"\n                    description={\n                        <>\n                            <Description>\n                                Setting the <PropName>isDraggable</PropName> prop can allow for more granular control\n                                over what is draggable in the grid via HTML drag and drop.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const DragSource: React.VFC<{ isDraggable: boolean | \"header\" | \"cell\" }> = p => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(200);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers=\"both\"\n            rows={5000}\n            onRowMoved={(s, e) => window.alert(`Moved row ${s} to ${e}`)}\n            onColumnMoved={(s, e) => window.alert(`Moved col ${s} to ${e}`)}\n            onColumnResize={onColumnResize}\n            isDraggable={p.isDraggable}\n            onDragStart={e => {\n                e.setData(\"text/plain\", \"Drag data here!\");\n            }}\n        />\n    );\n};\n(DragSource as any).argTypes = {\n    isDraggable: {\n        control: { type: \"select\", options: [true, false, \"cell\", \"header\"] },\n    },\n};\n(DragSource as any).args = {\n    isDraggable: false,\n};\n";
var __LOCATIONS_MAP__ = {
  "DragSource": {
    "startLoc": {
      "col": 83,
      "line": 35
    },
    "endLoc": {
      "col": 1,
      "line": 54
    },
    "startBody": {
      "col": 83,
      "line": 35
    },
    "endBody": {
      "col": 1,
      "line": 54
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Drag source\"\n                    description={\n                        <>\n                            <Description>\n                                Setting the <PropName>isDraggable</PropName> prop can allow for more granular control\n                                over what is draggable in the grid via HTML drag and drop.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const DragSource: React.VFC<{ isDraggable: boolean | \"header\" | \"cell\" }> = p => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(200);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers=\"both\"\n            rows={5000}\n            onRowMoved={(s, e) => window.alert(`Moved row ${s} to ${e}`)}\n            onColumnMoved={(s, e) => window.alert(`Moved col ${s} to ${e}`)}\n            onColumnResize={onColumnResize}\n            isDraggable={p.isDraggable}\n            onDragStart={e => {\n                e.setData(\"text/plain\", \"Drag data here!\");\n            }}\n        />\n    );\n};\n(DragSource as any).argTypes = {\n    isDraggable: {\n        control: { type: \"select\", options: [true, false, \"cell\", \"header\"] },\n    },\n};\n(DragSource as any).args = {\n    isDraggable: false,\n};\n",
      "locationsMap": {
        "drag-source": {
          "startLoc": {
            "col": 83,
            "line": 35
          },
          "endLoc": {
            "col": 1,
            "line": 54
          },
          "startBody": {
            "col": 83,
            "line": 35
          },
          "endBody": {
            "col": 1,
            "line": 54
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Drag source",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "isDraggable"), " prop can allow for more granular control over what is draggable in the grid via HTML drag and drop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const DragSource = p => {
  const {
    cols,
    getCellContent,
    onColumnResize
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(200);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    rows: 5000,
    onRowMoved: (s, e) => window.alert(`Moved row ${s} to ${e}`),
    onColumnMoved: (s, e) => window.alert(`Moved col ${s} to ${e}`),
    onColumnResize: onColumnResize,
    isDraggable: p.isDraggable,
    onDragStart: e => {
      e.setData("text/plain", "Drag data here!");
    }
  }));
};
DragSource.argTypes = {
  isDraggable: {
    control: {
      type: "select",
      options: [true, false, "cell", "header"]
    }
  }
};
DragSource.args = {
  isDraggable: false
};
const __namedExportsOrder = ["DragSource"];

/***/ }),

/***/ "./packages/core/src/docs/examples/draw-custom-cells.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawCustomCells": () => (/* binding */ DrawCustomCells),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Draw custom cells\"\n                    description={\n                        <Description>\n                            You can draw custom cell contents however you want using the{\" \"}\n                            <PropName>drawCustomCell</PropName> prop\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const DrawCustomCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            drawCell={args => {\n                const { cell, rect, ctx } = args;\n                if (cell.kind !== GridCellKind.Text) return false;\n\n                const hasX = cell.displayData.toLowerCase().includes(\"x\"); // all my x's live in texas\n\n                ctx.save();\n                const { x, y, width, height } = rect;\n                const data = cell.displayData;\n\n                ctx.fillStyle = hasX ? \"#bfffcd\" : \"#ffe6e6\";\n                ctx.fillRect(x + 1, y + 1, width - 1, height - 1);\n\n                ctx.fillStyle = hasX ? \"#0fc035\" : \"#e01e1e\";\n                ctx.font = \"bold 14px sans-serif\";\n                ctx.fillText(data, x + 8 + 0.5, y + height / 2 + 4.5);\n                ctx.restore();\n\n                return true;\n            }}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "DrawCustomCells": {
    "startLoc": {
      "col": 42,
      "line": 34
    },
    "endLoc": {
      "col": 1,
      "line": 65
    },
    "startBody": {
      "col": 42,
      "line": 34
    },
    "endBody": {
      "col": 1,
      "line": 65
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Draw custom cells\"\n                    description={\n                        <Description>\n                            You can draw custom cell contents however you want using the{\" \"}\n                            <PropName>drawCustomCell</PropName> prop\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const DrawCustomCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            drawCell={args => {\n                const { cell, rect, ctx } = args;\n                if (cell.kind !== GridCellKind.Text) return false;\n\n                const hasX = cell.displayData.toLowerCase().includes(\"x\"); // all my x's live in texas\n\n                ctx.save();\n                const { x, y, width, height } = rect;\n                const data = cell.displayData;\n\n                ctx.fillStyle = hasX ? \"#bfffcd\" : \"#ffe6e6\";\n                ctx.fillRect(x + 1, y + 1, width - 1, height - 1);\n\n                ctx.fillStyle = hasX ? \"#0fc035\" : \"#e01e1e\";\n                ctx.font = \"bold 14px sans-serif\";\n                ctx.fillText(data, x + 8 + 0.5, y + height / 2 + 4.5);\n                ctx.restore();\n\n                return true;\n            }}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "draw-custom-cells": {
          "startLoc": {
            "col": 42,
            "line": 34
          },
          "endLoc": {
            "col": 1,
            "line": 65
          },
          "startBody": {
            "col": 42,
            "line": 34
          },
          "endBody": {
            "col": 1,
            "line": 65
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Draw custom cells",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can draw custom cell contents however you want using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "drawCustomCell"), " prop")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const DrawCustomCells = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    drawCell: args => {
      const {
        cell,
        rect,
        ctx
      } = args;
      if (cell.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text) return false;
      const hasX = cell.displayData.toLowerCase().includes("x");
      ctx.save();
      const {
        x,
        y,
        width,
        height
      } = rect;
      const data = cell.displayData;
      ctx.fillStyle = hasX ? "#bfffcd" : "#ffe6e6";
      ctx.fillRect(x + 1, y + 1, width - 1, height - 1);
      ctx.fillStyle = hasX ? "#0fc035" : "#e01e1e";
      ctx.font = "bold 14px sans-serif";
      ctx.fillText(data, x + 8 + 0.5, y + height / 2 + 4.5);
      ctx.restore();
      return true;
    },
    rows: 1000
  }));
};
const __namedExportsOrder = ["DrawCustomCells"];

/***/ }),

/***/ "./packages/core/src/docs/examples/drop-events.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DropEvents": () => (/* binding */ DropEvents),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor, DataEditorProps } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { Item } from \"../../data-grid/data-grid-types\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\n// A few supported mime types for drag and drop into cells.\nconst SUPPORTED_IMAGE_TYPES = new Set([\"image/png\", \"image/gif\", \"image/bmp\", \"image/jpeg\"]);\n\nexport const DropEvents: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [highlights, setHighlights] = React.useState<DataEditorProps[\"highlightRegions\"]>([]);\n\n    const [lastDropCell, setLastDropCell] = React.useState<Item | undefined>();\n\n    const onDrop = React.useCallback(\n        (cell: Item, dataTransfer: DataTransfer | null) => {\n            setHighlights([]);\n\n            if (dataTransfer === null) {\n                return;\n            }\n\n            const { files } = dataTransfer;\n            // This only supports one image, for simplicity.\n            if (files.length !== 1) {\n                return;\n            }\n\n            const [file] = files;\n            if (!SUPPORTED_IMAGE_TYPES.has(file.type)) {\n                return;\n            }\n\n            const imgUrl = URL.createObjectURL(file);\n\n            setCellValue(\n                cell,\n                {\n                    kind: GridCellKind.Image,\n                    data: [imgUrl],\n                    allowOverlay: true,\n                    allowAdd: false,\n                },\n                true,\n                true\n            );\n\n            setLastDropCell(cell);\n        },\n        [setCellValue]\n    );\n\n    const onDragOverCell = React.useCallback(\n        (cell: Item, dataTransfer: DataTransfer | null) => {\n            if (dataTransfer === null) {\n                return;\n            }\n\n            const { items } = dataTransfer;\n            // This only supports one image, for simplicity.\n            if (items.length !== 1) {\n                return;\n            }\n\n            const [item] = items;\n            if (!SUPPORTED_IMAGE_TYPES.has(item.type)) {\n                return;\n            }\n\n            const [col, row] = cell;\n            if (getCellContent(cell).kind === GridCellKind.Image) {\n                setHighlights([\n                    {\n                        color: \"#44BB0022\",\n                        range: {\n                            x: col,\n                            y: row,\n                            width: 1,\n                            height: 1,\n                        },\n                    },\n                ]);\n            } else {\n                setHighlights([]);\n            }\n        },\n        [getCellContent]\n    );\n\n    const onDragLeave = React.useCallback(() => {\n        setHighlights([]);\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Drop events\"\n            description={\n                <>\n                    <Description>\n                        You can drag and drop into cells by using <PropName>onDragOverCell</PropName> and{\" \"}\n                        <PropName>onDrop</PropName>.\n                    </Description>\n\n                    <div>\n                        {lastDropCell === undefined ? (\n                            <MoreInfo>Nothing dropped, yet</MoreInfo>\n                        ) : (\n                            <>\n                                <MoreInfo>\n                                    You last dropped in cell <PropName>{JSON.stringify(lastDropCell)}</PropName>\n                                </MoreInfo>\n                            </>\n                        )}\n                    </div>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n                onDrop={onDrop}\n                onDragOverCell={onDragOverCell}\n                onDragLeave={onDragLeave}\n                highlightRegions={highlights}\n                rowMarkers=\"none\"\n            />\n        </BeautifulWrapper>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "DropEvents": {
    "startLoc": {
      "col": 37,
      "line": 30
    },
    "endLoc": {
      "col": 1,
      "line": 154
    },
    "startBody": {
      "col": 37,
      "line": 30
    },
    "endBody": {
      "col": 1,
      "line": 154
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor, DataEditorProps } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { Item } from \"../../data-grid/data-grid-types\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\n// A few supported mime types for drag and drop into cells.\nconst SUPPORTED_IMAGE_TYPES = new Set([\"image/png\", \"image/gif\", \"image/bmp\", \"image/jpeg\"]);\n\nexport const DropEvents: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [highlights, setHighlights] = React.useState<DataEditorProps[\"highlightRegions\"]>([]);\n\n    const [lastDropCell, setLastDropCell] = React.useState<Item | undefined>();\n\n    const onDrop = React.useCallback(\n        (cell: Item, dataTransfer: DataTransfer | null) => {\n            setHighlights([]);\n\n            if (dataTransfer === null) {\n                return;\n            }\n\n            const { files } = dataTransfer;\n            // This only supports one image, for simplicity.\n            if (files.length !== 1) {\n                return;\n            }\n\n            const [file] = files;\n            if (!SUPPORTED_IMAGE_TYPES.has(file.type)) {\n                return;\n            }\n\n            const imgUrl = URL.createObjectURL(file);\n\n            setCellValue(\n                cell,\n                {\n                    kind: GridCellKind.Image,\n                    data: [imgUrl],\n                    allowOverlay: true,\n                    allowAdd: false,\n                },\n                true,\n                true\n            );\n\n            setLastDropCell(cell);\n        },\n        [setCellValue]\n    );\n\n    const onDragOverCell = React.useCallback(\n        (cell: Item, dataTransfer: DataTransfer | null) => {\n            if (dataTransfer === null) {\n                return;\n            }\n\n            const { items } = dataTransfer;\n            // This only supports one image, for simplicity.\n            if (items.length !== 1) {\n                return;\n            }\n\n            const [item] = items;\n            if (!SUPPORTED_IMAGE_TYPES.has(item.type)) {\n                return;\n            }\n\n            const [col, row] = cell;\n            if (getCellContent(cell).kind === GridCellKind.Image) {\n                setHighlights([\n                    {\n                        color: \"#44BB0022\",\n                        range: {\n                            x: col,\n                            y: row,\n                            width: 1,\n                            height: 1,\n                        },\n                    },\n                ]);\n            } else {\n                setHighlights([]);\n            }\n        },\n        [getCellContent]\n    );\n\n    const onDragLeave = React.useCallback(() => {\n        setHighlights([]);\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Drop events\"\n            description={\n                <>\n                    <Description>\n                        You can drag and drop into cells by using <PropName>onDragOverCell</PropName> and{\" \"}\n                        <PropName>onDrop</PropName>.\n                    </Description>\n\n                    <div>\n                        {lastDropCell === undefined ? (\n                            <MoreInfo>Nothing dropped, yet</MoreInfo>\n                        ) : (\n                            <>\n                                <MoreInfo>\n                                    You last dropped in cell <PropName>{JSON.stringify(lastDropCell)}</PropName>\n                                </MoreInfo>\n                            </>\n                        )}\n                    </div>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n                onDrop={onDrop}\n                onDragOverCell={onDragOverCell}\n                onDragLeave={onDragLeave}\n                highlightRegions={highlights}\n                rowMarkers=\"none\"\n            />\n        </BeautifulWrapper>\n    );\n};\n",
      "locationsMap": {
        "drop-events": {
          "startLoc": {
            "col": 37,
            "line": 30
          },
          "endLoc": {
            "col": 1,
            "line": 154
          },
          "startBody": {
            "col": 37,
            "line": 30
          },
          "endBody": {
            "col": 1,
            "line": 154
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const SUPPORTED_IMAGE_TYPES = new Set(["image/png", "image/gif", "image/bmp", "image/jpeg"]);
const DropEvents = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const [highlights, setHighlights] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  const [lastDropCell, setLastDropCell] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const onDrop = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, dataTransfer) => {
    setHighlights([]);

    if (dataTransfer === null) {
      return;
    }

    const {
      files
    } = dataTransfer;

    if (files.length !== 1) {
      return;
    }

    const [file] = files;

    if (!SUPPORTED_IMAGE_TYPES.has(file.type)) {
      return;
    }

    const imgUrl = URL.createObjectURL(file);
    setCellValue(cell, {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Image */ .p6.Image,
      data: [imgUrl],
      allowOverlay: true,
      allowAdd: false
    }, true, true);
    setLastDropCell(cell);
  }, [setCellValue]);
  const onDragOverCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, dataTransfer) => {
    if (dataTransfer === null) {
      return;
    }

    const {
      items
    } = dataTransfer;

    if (items.length !== 1) {
      return;
    }

    const [item] = items;

    if (!SUPPORTED_IMAGE_TYPES.has(item.type)) {
      return;
    }

    const [col, row] = cell;

    if (getCellContent(cell).kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Image */ .p6.Image) {
      setHighlights([{
        color: "#44BB0022",
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }]);
    } else {
      setHighlights([]);
    }
  }, [getCellContent]);
  const onDragLeave = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setHighlights([]);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Drop events",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can drag and drop into cells by using ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onDragOverCell"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onDrop"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, lastDropCell === undefined ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Nothing dropped, yet") : react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "You last dropped in cell ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, JSON.stringify(lastDropCell))))))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 1000,
    onDrop: onDrop,
    onDragOverCell: onDragOverCell,
    onDragLeave: onDragLeave,
    highlightRegions: highlights,
    rowMarkers: "none"
  })));
};
const __namedExportsOrder = ["DropEvents"];

/***/ }),

/***/ "./packages/core/src/docs/examples/fill-handle.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FillHandle": () => (/* binding */ FillHandle),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Fill handle\"\n                    description={\n                        <>\n                            <Description>Fill handles can be used to downfill data with the mouse.</Description>\n                            <MoreInfo>\n                                Just click and drag, the top row will be copied down. Enable using the{\" \"}\n                                <PropName>fillHandle</PropName> prop.\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const FillHandle: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\n        i => {\n            let val = getCellContent(i);\n            if (i[0] === 1 && val.kind === GridCellKind.Text) {\n                val = {\n                    ...val,\n                    readonly: true,\n                };\n            }\n\n            return val;\n        },\n        [getCellContent]\n    );\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContentMangled}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onPaste={true}\n            fillHandle={true}\n            keybindings={{ downFill: true, rightFill: true }}\n            onCellEdited={setCellValue}\n            trailingRowOptions={{\n                sticky: true,\n                tint: true,\n                hint: \"New row...\",\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "FillHandle": {
    "startLoc": {
      "col": 37,
      "line": 39
    },
    "endLoc": {
      "col": 1,
      "line": 87
    },
    "startBody": {
      "col": 37,
      "line": 39
    },
    "endBody": {
      "col": 1,
      "line": 87
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n    clearCell,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Fill handle\"\n                    description={\n                        <>\n                            <Description>Fill handles can be used to downfill data with the mouse.</Description>\n                            <MoreInfo>\n                                Just click and drag, the top row will be copied down. Enable using the{\" \"}\n                                <PropName>fillHandle</PropName> prop.\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const FillHandle: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\n        i => {\n            let val = getCellContent(i);\n            if (i[0] === 1 && val.kind === GridCellKind.Text) {\n                val = {\n                    ...val,\n                    readonly: true,\n                };\n            }\n\n            return val;\n        },\n        [getCellContent]\n    );\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContentMangled}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onPaste={true}\n            fillHandle={true}\n            keybindings={{ downFill: true, rightFill: true }}\n            onCellEdited={setCellValue}\n            trailingRowOptions={{\n                sticky: true,\n                tint: true,\n                hint: \"New row...\",\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n        />\n    );\n};\n",
      "locationsMap": {
        "fill-handle": {
          "startLoc": {
            "col": 37,
            "line": 39
          },
          "endLoc": {
            "col": 1,
            "line": 87
          },
          "startBody": {
            "col": 37,
            "line": 39
          },
          "endBody": {
            "col": 1,
            "line": 87
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Fill handle",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Fill handles can be used to downfill data with the mouse."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Just click and drag, the top row will be copied down. Enable using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "fillHandle"), " prop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const FillHandle = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const getCellContentMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(i => {
    let val = getCellContent(i);

    if (i[0] === 1 && val.kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text) {
      val = { ...val,
        readonly: true
      };
    }

    return val;
  }, [getCellContent]);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, newRow]);
      setCellValueRaw([c, newRow], (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .clearCell */ .MP)(cell));
    }

    setNumRows(cv => cv + 1);
  }, [getCellContent, numRows, setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContentMangled,
    columns: cols,
    rowMarkers: "both",
    onPaste: true,
    fillHandle: true,
    keybindings: {
      downFill: true,
      rightFill: true
    },
    onCellEdited: setCellValue,
    trailingRowOptions: {
      sticky: true,
      tint: true,
      hint: "New row..."
    },
    rows: numRows,
    onRowAppended: onRowAppended
  }));
};
const __namedExportsOrder = ["FillHandle"];

/***/ }),

/***/ "./packages/core/src/docs/examples/freeze-columns.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FreezeColumns": () => (/* binding */ FreezeColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Freeze columns\"\n                    description={\n                        <Description>\n                            Columns at the start of your grid can be frozen in place by settings{\" \"}\n                            <PropName>freezeColumns</PropName> to a number greater than 0.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const FreezeColumns: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"both\"\n            freezeColumns={1}\n            getCellContent={getCellContent}\n            columns={cols}\n            verticalBorder={c => c > 0}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "FreezeColumns": {
    "startLoc": {
      "col": 40,
      "line": 33
    },
    "endLoc": {
      "col": 1,
      "line": 47
    },
    "startBody": {
      "col": 40,
      "line": 33
    },
    "endBody": {
      "col": 1,
      "line": 47
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Freeze columns\"\n                    description={\n                        <Description>\n                            Columns at the start of your grid can be frozen in place by settings{\" \"}\n                            <PropName>freezeColumns</PropName> to a number greater than 0.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const FreezeColumns: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"both\"\n            freezeColumns={1}\n            getCellContent={getCellContent}\n            columns={cols}\n            verticalBorder={c => c > 0}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "freeze-columns": {
          "startLoc": {
            "col": 40,
            "line": 33
          },
          "endLoc": {
            "col": 1,
            "line": 47
          },
          "startBody": {
            "col": 40,
            "line": 33
          },
          "endBody": {
            "col": 1,
            "line": 47
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Freeze columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Columns at the start of your grid can be frozen in place by settings", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "freezeColumns"), " to a number greater than 0.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const FreezeColumns = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowMarkers: "both",
    freezeColumns: 1,
    getCellContent: getCellContent,
    columns: cols,
    verticalBorder: c => c > 0,
    rows: 1000
  }));
};
const __namedExportsOrder = ["FreezeColumns"];

/***/ }),

/***/ "./packages/core/src/docs/examples/header-menus.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HeaderMenus": () => (/* binding */ HeaderMenus),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react_laag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/react-laag/dist/react-laag.esm.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import { styled } from \"@linaria/react\";\nimport React from \"react\";\nimport { useLayer } from \"react-laag\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, defaultProps, useAllMockedKinds } from \"../../data-editor/stories/utils\";\nimport type { Rectangle } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Header menus\"\n                    description={\n                        <>\n                            <Description>\n                                Headers on the data grid can be configured to support menus. We provide the events and\n                                the triangle, you provide the menu.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst SimpleMenu = styled.div`\n    width: 175px;\n    padding: 8px 0;\n    border-radius: 6px;\n    box-shadow: 0px 0px 1px rgba(62, 65, 86, 0.7), 0px 6px 12px rgba(62, 65, 86, 0.35);\n\n    display: flex;\n    flex-direction: column;\n\n    background-color: white;\n    font-size: 13px;\n    font-weight: 600;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\",\n        \"Helvetica Neue\", sans-serif;\n\n    .danger {\n        color: rgba(255, 40, 40, 0.8);\n        :hover {\n            color: rgba(255, 40, 40, 1);\n        }\n    }\n\n    > div {\n        padding: 6px 8px;\n        color: rgba(0, 0, 0, 0.7);\n        :hover {\n            background-color: rgba(0, 0, 0, 0.05);\n            color: rgba(0, 0, 0, 0.9);\n        }\n        transition: background-color 100ms;\n        cursor: pointer;\n    }\n`;\n\nexport const HeaderMenus: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        return cols.map(c => ({\n            ...c,\n            hasMenu: true,\n        }));\n    }, [cols]);\n\n    const [menu, setMenu] =\n        React.useState<{\n            col: number;\n            bounds: Rectangle;\n        }>();\n\n    const isOpen = menu !== undefined;\n\n    const { layerProps, renderLayer } = useLayer({\n        isOpen,\n        auto: true,\n        placement: \"bottom-end\",\n        triggerOffset: 2,\n        onOutsideClick: () => setMenu(undefined),\n        trigger: {\n            getBounds: () => ({\n                left: menu?.bounds.x ?? 0,\n                top: menu?.bounds.y ?? 0,\n                width: menu?.bounds.width ?? 0,\n                height: menu?.bounds.height ?? 0,\n                right: (menu?.bounds.x ?? 0) + (menu?.bounds.width ?? 0),\n                bottom: (menu?.bounds.y ?? 0) + (menu?.bounds.height ?? 0),\n            }),\n        },\n    });\n\n    const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\n        setMenu({ col, bounds });\n    }, []);\n\n    const onHeaderClicked = React.useCallback(() => {\n        \n        console.log(\"Header clicked\");\n    }, []);\n\n    return (\n        <>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                onHeaderMenuClick={onHeaderMenuClick}\n                onHeaderClicked={onHeaderClicked}\n                columns={realCols}\n                onCellContextMenu={(_, e) => e.preventDefault()}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n            />\n            {isOpen &&\n                renderLayer(\n                    <SimpleMenu {...layerProps}>\n                        <div onClick={() => setMenu(undefined)}>These do nothing</div>\n                        <div onClick={() => setMenu(undefined)}>Add column right</div>\n                        <div onClick={() => setMenu(undefined)}>Add column left</div>\n                        <div className=\"danger\" onClick={() => setMenu(undefined)}>\n                            Delete\n                        </div>\n                    </SimpleMenu>\n                )}\n        </>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "HeaderMenus": {
    "startLoc": {
      "col": 38,
      "line": 66
    },
    "endLoc": {
      "col": 1,
      "line": 137
    },
    "startBody": {
      "col": 38,
      "line": 66
    },
    "endBody": {
      "col": 1,
      "line": 137
    }
  }
};






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import { styled } from \"@linaria/react\";\nimport React from \"react\";\nimport { useLayer } from \"react-laag\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, defaultProps, useAllMockedKinds } from \"../../data-editor/stories/utils\";\nimport type { Rectangle } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Header menus\"\n                    description={\n                        <>\n                            <Description>\n                                Headers on the data grid can be configured to support menus. We provide the events and\n                                the triangle, you provide the menu.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst SimpleMenu = styled.div`\n    width: 175px;\n    padding: 8px 0;\n    border-radius: 6px;\n    box-shadow: 0px 0px 1px rgba(62, 65, 86, 0.7), 0px 6px 12px rgba(62, 65, 86, 0.35);\n\n    display: flex;\n    flex-direction: column;\n\n    background-color: white;\n    font-size: 13px;\n    font-weight: 600;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\",\n        \"Helvetica Neue\", sans-serif;\n\n    .danger {\n        color: rgba(255, 40, 40, 0.8);\n        :hover {\n            color: rgba(255, 40, 40, 1);\n        }\n    }\n\n    > div {\n        padding: 6px 8px;\n        color: rgba(0, 0, 0, 0.7);\n        :hover {\n            background-color: rgba(0, 0, 0, 0.05);\n            color: rgba(0, 0, 0, 0.9);\n        }\n        transition: background-color 100ms;\n        cursor: pointer;\n    }\n`;\n\nexport const HeaderMenus: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        return cols.map(c => ({\n            ...c,\n            hasMenu: true,\n        }));\n    }, [cols]);\n\n    const [menu, setMenu] =\n        React.useState<{\n            col: number;\n            bounds: Rectangle;\n        }>();\n\n    const isOpen = menu !== undefined;\n\n    const { layerProps, renderLayer } = useLayer({\n        isOpen,\n        auto: true,\n        placement: \"bottom-end\",\n        triggerOffset: 2,\n        onOutsideClick: () => setMenu(undefined),\n        trigger: {\n            getBounds: () => ({\n                left: menu?.bounds.x ?? 0,\n                top: menu?.bounds.y ?? 0,\n                width: menu?.bounds.width ?? 0,\n                height: menu?.bounds.height ?? 0,\n                right: (menu?.bounds.x ?? 0) + (menu?.bounds.width ?? 0),\n                bottom: (menu?.bounds.y ?? 0) + (menu?.bounds.height ?? 0),\n            }),\n        },\n    });\n\n    const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\n        setMenu({ col, bounds });\n    }, []);\n\n    const onHeaderClicked = React.useCallback(() => {\n        \n        console.log(\"Header clicked\");\n    }, []);\n\n    return (\n        <>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                onHeaderMenuClick={onHeaderMenuClick}\n                onHeaderClicked={onHeaderClicked}\n                columns={realCols}\n                onCellContextMenu={(_, e) => e.preventDefault()}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n            />\n            {isOpen &&\n                renderLayer(\n                    <SimpleMenu {...layerProps}>\n                        <div onClick={() => setMenu(undefined)}>These do nothing</div>\n                        <div onClick={() => setMenu(undefined)}>Add column right</div>\n                        <div onClick={() => setMenu(undefined)}>Add column left</div>\n                        <div className=\"danger\" onClick={() => setMenu(undefined)}>\n                            Delete\n                        </div>\n                    </SimpleMenu>\n                )}\n        </>\n    );\n};\n",
      "locationsMap": {
        "header-menus": {
          "startLoc": {
            "col": 38,
            "line": 66
          },
          "endLoc": {
            "col": 1,
            "line": 137
          },
          "startBody": {
            "col": 38,
            "line": 66
          },
          "endBody": {
            "col": 1,
            "line": 137
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Header menus",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Headers on the data grid can be configured to support menus. We provide the events and the triangle, you provide the menu."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const SimpleMenu = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)('div')({
  name: "SimpleMenu",
  class: "s7szcfi"
});
const HeaderMenus = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const realCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return cols.map(c => ({ ...c,
      hasMenu: true
    }));
  }, [cols]);
  const [menu, setMenu] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const isOpen = menu !== undefined;
  const {
    layerProps,
    renderLayer
  } = (0,react_laag__WEBPACK_IMPORTED_MODULE_4__/* .useLayer */ .sJ)({
    isOpen,
    auto: true,
    placement: "bottom-end",
    triggerOffset: 2,
    onOutsideClick: () => setMenu(undefined),
    trigger: {
      getBounds: () => {
        var _menu$bounds$x, _menu$bounds$y, _menu$bounds$width, _menu$bounds$height, _menu$bounds$x2, _menu$bounds$width2, _menu$bounds$y2, _menu$bounds$height2;

        return {
          left: (_menu$bounds$x = menu === null || menu === void 0 ? void 0 : menu.bounds.x) !== null && _menu$bounds$x !== void 0 ? _menu$bounds$x : 0,
          top: (_menu$bounds$y = menu === null || menu === void 0 ? void 0 : menu.bounds.y) !== null && _menu$bounds$y !== void 0 ? _menu$bounds$y : 0,
          width: (_menu$bounds$width = menu === null || menu === void 0 ? void 0 : menu.bounds.width) !== null && _menu$bounds$width !== void 0 ? _menu$bounds$width : 0,
          height: (_menu$bounds$height = menu === null || menu === void 0 ? void 0 : menu.bounds.height) !== null && _menu$bounds$height !== void 0 ? _menu$bounds$height : 0,
          right: ((_menu$bounds$x2 = menu === null || menu === void 0 ? void 0 : menu.bounds.x) !== null && _menu$bounds$x2 !== void 0 ? _menu$bounds$x2 : 0) + ((_menu$bounds$width2 = menu === null || menu === void 0 ? void 0 : menu.bounds.width) !== null && _menu$bounds$width2 !== void 0 ? _menu$bounds$width2 : 0),
          bottom: ((_menu$bounds$y2 = menu === null || menu === void 0 ? void 0 : menu.bounds.y) !== null && _menu$bounds$y2 !== void 0 ? _menu$bounds$y2 : 0) + ((_menu$bounds$height2 = menu === null || menu === void 0 ? void 0 : menu.bounds.height) !== null && _menu$bounds$height2 !== void 0 ? _menu$bounds$height2 : 0)
        };
      }
    }
  });
  const onHeaderMenuClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, bounds) => {
    setMenu({
      col,
      bounds
    });
  }, []);
  const onHeaderClicked = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    console.log("Header clicked");
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    onHeaderMenuClick: onHeaderMenuClick,
    onHeaderClicked: onHeaderClicked,
    columns: realCols,
    onCellContextMenu: (_, e) => e.preventDefault(),
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 1000
  })), isOpen && renderLayer(react__WEBPACK_IMPORTED_MODULE_0__.createElement(SimpleMenu, layerProps, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    onClick: () => setMenu(undefined)
  }, "These do nothing"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    onClick: () => setMenu(undefined)
  }, "Add column right"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    onClick: () => setMenu(undefined)
  }, "Add column left"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "danger",
    onClick: () => setMenu(undefined)
  }, "Delete"))));
};

__webpack_require__("./packages/core/src/docs/examples/header-menus.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/examples/header-menus.stories.tsx");

const __namedExportsOrder = ["HeaderMenus"];

/***/ }),

/***/ "./packages/core/src/docs/examples/highlight-cells.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HighlightCells": () => (/* binding */ HighlightCells),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor, DataEditorProps } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { GridSelection } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"HighlightCells\"\n                    description={\n                        <Description>\n                            The <PropName>highlightRegions</PropName> prop can be set to provide additional hinting or\n                            context for the current selection.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const HighlightCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    const [gridSelection, setGridSelection] = React.useState<GridSelection>({\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const highlights = React.useMemo<DataEditorProps[\"highlightRegions\"]>(() => {\n        if (gridSelection.current === undefined) return undefined;\n        const [col, row] = gridSelection.current.cell;\n        return [\n            {\n                color: \"#44BB0022\",\n                range: {\n                    x: col + 2,\n                    y: row,\n                    width: 10,\n                    height: 10,\n                },\n                style: \"solid\",\n            },\n            {\n                color: \"#b000b021\",\n                range: {\n                    x: col,\n                    y: row + 2,\n                    width: 1,\n                    height: 1,\n                },\n            },\n        ];\n    }, [gridSelection]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"both\"\n            freezeColumns={1}\n            highlightRegions={highlights}\n            gridSelection={gridSelection}\n            onGridSelectionChange={setGridSelection}\n            getCellContent={getCellContent}\n            columns={cols}\n            verticalBorder={c => c > 0}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "HighlightCells": {
    "startLoc": {
      "col": 41,
      "line": 35
    },
    "endLoc": {
      "col": 1,
      "line": 83
    },
    "startBody": {
      "col": 41,
      "line": 35
    },
    "endBody": {
      "col": 1,
      "line": 83
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor, DataEditorProps } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { GridSelection } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"HighlightCells\"\n                    description={\n                        <Description>\n                            The <PropName>highlightRegions</PropName> prop can be set to provide additional hinting or\n                            context for the current selection.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const HighlightCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    const [gridSelection, setGridSelection] = React.useState<GridSelection>({\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const highlights = React.useMemo<DataEditorProps[\"highlightRegions\"]>(() => {\n        if (gridSelection.current === undefined) return undefined;\n        const [col, row] = gridSelection.current.cell;\n        return [\n            {\n                color: \"#44BB0022\",\n                range: {\n                    x: col + 2,\n                    y: row,\n                    width: 10,\n                    height: 10,\n                },\n                style: \"solid\",\n            },\n            {\n                color: \"#b000b021\",\n                range: {\n                    x: col,\n                    y: row + 2,\n                    width: 1,\n                    height: 1,\n                },\n            },\n        ];\n    }, [gridSelection]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"both\"\n            freezeColumns={1}\n            highlightRegions={highlights}\n            gridSelection={gridSelection}\n            onGridSelectionChange={setGridSelection}\n            getCellContent={getCellContent}\n            columns={cols}\n            verticalBorder={c => c > 0}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "highlight-cells": {
          "startLoc": {
            "col": 41,
            "line": 35
          },
          "endLoc": {
            "col": 1,
            "line": 83
          },
          "startBody": {
            "col": 41,
            "line": 35
          },
          "endBody": {
            "col": 1,
            "line": 83
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "HighlightCells",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "The ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "highlightRegions"), " prop can be set to provide additional hinting or context for the current selection.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const HighlightCells = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100);
  const [gridSelection, setGridSelection] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty()
  });
  const highlights = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (gridSelection.current === undefined) return undefined;
    const [col, row] = gridSelection.current.cell;
    return [{
      color: "#44BB0022",
      range: {
        x: col + 2,
        y: row,
        width: 10,
        height: 10
      },
      style: "solid"
    }, {
      color: "#b000b021",
      range: {
        x: col,
        y: row + 2,
        width: 1,
        height: 1
      }
    }];
  }, [gridSelection]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowMarkers: "both",
    freezeColumns: 1,
    highlightRegions: highlights,
    gridSelection: gridSelection,
    onGridSelectionChange: setGridSelection,
    getCellContent: getCellContent,
    columns: cols,
    verticalBorder: c => c > 0,
    rows: 1000
  }));
};
const __namedExportsOrder = ["HighlightCells"];

/***/ }),

/***/ "./packages/core/src/docs/examples/imperative-scroll.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImperativeScroll": () => (/* binding */ ImperativeScroll),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor, DataEditorRef } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface ImperativeScrollProps {\n    paddingY: number;\n    paddingX: number;\n    vAlign?: \"start\" | \"center\" | \"end\";\n    hAlign?: \"start\" | \"center\" | \"end\";\n}\n\nexport const ImperativeScroll: React.VFC<ImperativeScrollProps> = p => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const onClick = () => {\n        ref.current?.scrollTo(4, 99, \"both\", p.paddingX, p.paddingY, {\n            vAlign: p.vAlign,\n            hAlign: p.hAlign,\n        });\n    };\n\n    return (\n        <BeautifulWrapper\n            title=\"Imperative scrolling\"\n            description={\n                <>\n                    <Description>\n                        You can imperatively scroll to a cell by calling <PropName>scrollTo</PropName> on a DataEditor\n                        ref.\n                    </Description>\n                    <MoreInfo>\n                        Click <button onClick={onClick}>Here</button> to scroll to column 4 row 100\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                rowMarkers=\"clickable-number\"\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ImperativeScroll as any).args = {\n    paddingY: 0,\n    paddingX: 0,\n    vAlign: \"start\",\n    hAlign: \"start\",\n};\n(ImperativeScroll as any).argTypes = {\n    paddingY: 0,\n    paddingX: 0,\n    vAlign: {\n        control: { type: \"select\", options: [\"start\", \"center\", \"end\", undefined] },\n    },\n    hAlign: {\n        control: { type: \"select\", options: [\"start\", \"center\", \"end\", undefined] },\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "ImperativeScroll": {
    "startLoc": {
      "col": 66,
      "line": 32
    },
    "endLoc": {
      "col": 1,
      "line": 70
    },
    "startBody": {
      "col": 66,
      "line": 32
    },
    "endBody": {
      "col": 1,
      "line": 70
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor, DataEditorRef } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface ImperativeScrollProps {\n    paddingY: number;\n    paddingX: number;\n    vAlign?: \"start\" | \"center\" | \"end\";\n    hAlign?: \"start\" | \"center\" | \"end\";\n}\n\nexport const ImperativeScroll: React.VFC<ImperativeScrollProps> = p => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const onClick = () => {\n        ref.current?.scrollTo(4, 99, \"both\", p.paddingX, p.paddingY, {\n            vAlign: p.vAlign,\n            hAlign: p.hAlign,\n        });\n    };\n\n    return (\n        <BeautifulWrapper\n            title=\"Imperative scrolling\"\n            description={\n                <>\n                    <Description>\n                        You can imperatively scroll to a cell by calling <PropName>scrollTo</PropName> on a DataEditor\n                        ref.\n                    </Description>\n                    <MoreInfo>\n                        Click <button onClick={onClick}>Here</button> to scroll to column 4 row 100\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                rowMarkers=\"clickable-number\"\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ImperativeScroll as any).args = {\n    paddingY: 0,\n    paddingX: 0,\n    vAlign: \"start\",\n    hAlign: \"start\",\n};\n(ImperativeScroll as any).argTypes = {\n    paddingY: 0,\n    paddingX: 0,\n    vAlign: {\n        control: { type: \"select\", options: [\"start\", \"center\", \"end\", undefined] },\n    },\n    hAlign: {\n        control: { type: \"select\", options: [\"start\", \"center\", \"end\", undefined] },\n    },\n};\n",
      "locationsMap": {
        "imperative-scroll": {
          "startLoc": {
            "col": 66,
            "line": 32
          },
          "endLoc": {
            "col": 1,
            "line": 70
          },
          "startBody": {
            "col": 66,
            "line": 32
          },
          "endBody": {
            "col": 1,
            "line": 70
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const ImperativeScroll = p => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);

  const onClick = () => {
    var _ref$current;

    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.scrollTo(4, 99, "both", p.paddingX, p.paddingY, {
      vAlign: p.vAlign,
      hAlign: p.hAlign
    });
  };

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Imperative scrolling",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can imperatively scroll to a cell by calling ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "scrollTo"), " on a DataEditor ref."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Click ", react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: onClick
    }, "Here"), " to scroll to column 4 row 100"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    ref: ref,
    rowMarkers: "clickable-number",
    getCellContent: getCellContent,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 10000
  })));
};
ImperativeScroll.args = {
  paddingY: 0,
  paddingX: 0,
  vAlign: "start",
  hAlign: "start"
};
ImperativeScroll.argTypes = {
  paddingY: 0,
  paddingX: 0,
  vAlign: {
    control: {
      type: "select",
      options: ["start", "center", "end", undefined]
    }
  },
  hAlign: {
    control: {
      type: "select",
      options: ["start", "center", "end", undefined]
    }
  }
};
const __namedExportsOrder = ["ImperativeScroll"];

/***/ }),

/***/ "./packages/core/src/docs/examples/input-blending.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InputBlending": () => (/* binding */ InputBlending),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Input blending\"\n                    description={\n                        <Description>\n                            Input blending can be enabled or disable between row, column, and range selections.\n                            Multi-selections can also be enabled or disabled with the same level of granularity.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface InputBlendingGridProps {\n    rangeBlending: \"mixed\" | \"exclusive\";\n    columnBlending: \"mixed\" | \"exclusive\";\n    rowBlending: \"mixed\" | \"exclusive\";\n    rangeMultiSelect: \"none\" | \"cell\" | \"rect\" | \"multi-cell\" | \"multi-rect\";\n    columnMultiSelect: \"none\" | \"single\" | \"multi\";\n    rowMultiSelect: \"none\" | \"single\" | \"multi\";\n}\n\nexport const InputBlending: React.FC<InputBlendingGridProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(30);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers={p.rowMultiSelect === \"none\" ? \"number\" : \"both\"}\n            keybindings={{\n                clear: true,\n                copy: true,\n                downFill: true,\n                rightFill: true,\n                pageDown: true,\n                pageUp: true,\n                paste: true,\n                search: true,\n                selectAll: true,\n                selectColumn: true,\n                selectRow: true,\n            }}\n            getCellsForSelection={true}\n            rangeSelect={p.rangeMultiSelect}\n            columnSelect={p.columnMultiSelect}\n            rowSelect={p.rowMultiSelect}\n            rangeSelectionBlending={p.rangeBlending}\n            columnSelectionBlending={p.columnBlending}\n            rowSelectionBlending={p.rowBlending}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={10_000}\n        />\n    );\n};\n(InputBlending as any).args = {\n    rangeBlending: \"mixed\",\n    columnBlending: \"mixed\",\n    rowBlending: \"mixed\",\n    rangeMultiSelect: \"rect\",\n    columnMultiSelect: \"multi\",\n    rowMultiSelect: \"multi\",\n};\n(InputBlending as any).argTypes = {\n    rangeBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    columnBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    rowBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    rangeMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"cell\", \"rect\", \"multi-cell\", \"multi-rect\"] },\n    },\n    columnMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"single\", \"multi\"] },\n    },\n    rowMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"single\", \"multi\"] },\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "InputBlending": {
    "startLoc": {
      "col": 63,
      "line": 36
    },
    "endLoc": {
      "col": 1,
      "line": 68
    },
    "startBody": {
      "col": 63,
      "line": 36
    },
    "endBody": {
      "col": 1,
      "line": 68
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Input blending\"\n                    description={\n                        <Description>\n                            Input blending can be enabled or disable between row, column, and range selections.\n                            Multi-selections can also be enabled or disabled with the same level of granularity.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface InputBlendingGridProps {\n    rangeBlending: \"mixed\" | \"exclusive\";\n    columnBlending: \"mixed\" | \"exclusive\";\n    rowBlending: \"mixed\" | \"exclusive\";\n    rangeMultiSelect: \"none\" | \"cell\" | \"rect\" | \"multi-cell\" | \"multi-rect\";\n    columnMultiSelect: \"none\" | \"single\" | \"multi\";\n    rowMultiSelect: \"none\" | \"single\" | \"multi\";\n}\n\nexport const InputBlending: React.FC<InputBlendingGridProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(30);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers={p.rowMultiSelect === \"none\" ? \"number\" : \"both\"}\n            keybindings={{\n                clear: true,\n                copy: true,\n                downFill: true,\n                rightFill: true,\n                pageDown: true,\n                pageUp: true,\n                paste: true,\n                search: true,\n                selectAll: true,\n                selectColumn: true,\n                selectRow: true,\n            }}\n            getCellsForSelection={true}\n            rangeSelect={p.rangeMultiSelect}\n            columnSelect={p.columnMultiSelect}\n            rowSelect={p.rowMultiSelect}\n            rangeSelectionBlending={p.rangeBlending}\n            columnSelectionBlending={p.columnBlending}\n            rowSelectionBlending={p.rowBlending}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={10_000}\n        />\n    );\n};\n(InputBlending as any).args = {\n    rangeBlending: \"mixed\",\n    columnBlending: \"mixed\",\n    rowBlending: \"mixed\",\n    rangeMultiSelect: \"rect\",\n    columnMultiSelect: \"multi\",\n    rowMultiSelect: \"multi\",\n};\n(InputBlending as any).argTypes = {\n    rangeBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    columnBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    rowBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    rangeMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"cell\", \"rect\", \"multi-cell\", \"multi-rect\"] },\n    },\n    columnMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"single\", \"multi\"] },\n    },\n    rowMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"single\", \"multi\"] },\n    },\n};\n",
      "locationsMap": {
        "input-blending": {
          "startLoc": {
            "col": 63,
            "line": 36
          },
          "endLoc": {
            "col": 1,
            "line": 68
          },
          "startBody": {
            "col": 63,
            "line": 36
          },
          "endBody": {
            "col": 1,
            "line": 68
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Input blending",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Input blending can be enabled or disable between row, column, and range selections. Multi-selections can also be enabled or disabled with the same level of granularity.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const InputBlending = p => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(30);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowMarkers: p.rowMultiSelect === "none" ? "number" : "both",
    keybindings: {
      clear: true,
      copy: true,
      downFill: true,
      rightFill: true,
      pageDown: true,
      pageUp: true,
      paste: true,
      search: true,
      selectAll: true,
      selectColumn: true,
      selectRow: true
    },
    getCellsForSelection: true,
    rangeSelect: p.rangeMultiSelect,
    columnSelect: p.columnMultiSelect,
    rowSelect: p.rowMultiSelect,
    rangeSelectionBlending: p.rangeBlending,
    columnSelectionBlending: p.columnBlending,
    rowSelectionBlending: p.rowBlending,
    getCellContent: getCellContent,
    columns: cols,
    rows: 10000
  }));
};
InputBlending.args = {
  rangeBlending: "mixed",
  columnBlending: "mixed",
  rowBlending: "mixed",
  rangeMultiSelect: "rect",
  columnMultiSelect: "multi",
  rowMultiSelect: "multi"
};
InputBlending.argTypes = {
  rangeBlending: {
    control: {
      type: "select",
      options: ["mixed", "exclusive"]
    }
  },
  columnBlending: {
    control: {
      type: "select",
      options: ["mixed", "exclusive"]
    }
  },
  rowBlending: {
    control: {
      type: "select",
      options: ["mixed", "exclusive"]
    }
  },
  rangeMultiSelect: {
    control: {
      type: "select",
      options: ["none", "cell", "rect", "multi-cell", "multi-rect"]
    }
  },
  columnMultiSelect: {
    control: {
      type: "select",
      options: ["none", "single", "multi"]
    }
  },
  rowMultiSelect: {
    control: {
      type: "select",
      options: ["none", "single", "multi"]
    }
  }
};
const __namedExportsOrder = ["InputBlending"];

/***/ }),

/***/ "./packages/core/src/docs/examples/layout-integration.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayoutIntegration": () => (/* binding */ LayoutIntegration),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { Description, useMockDataGenerator, defaultProps, BeautifulStyle } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulStyle>\n                    <h1>Layout Integration</h1>\n                    <Description>Trying the grid in different situations</Description>\n                    <Story />\n                </BeautifulStyle>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const LayoutIntegration: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    return (\n        <>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10}\n                rowMarkers=\"both\"\n                height={200}\n            />\n            <DataEditor {...defaultProps} getCellContent={getCellContent} columns={cols} rows={10} rowMarkers=\"both\" />\n            <div style={{ display: \"flex\", height: \"300px\" }}>\n                <DataEditor\n                    {...defaultProps}\n                    getCellContent={getCellContent}\n                    columns={cols}\n                    rows={10}\n                    rowMarkers=\"both\"\n                />\n                <div style={{ flexShrink: 0 }}>This is some text what happens here?</div>\n            </div>\n        </>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "LayoutIntegration": {
    "startLoc": {
      "col": 44,
      "line": 22
    },
    "endLoc": {
      "col": 1,
      "line": 48
    },
    "startBody": {
      "col": 44,
      "line": 22
    },
    "endBody": {
      "col": 1,
      "line": 48
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { Description, useMockDataGenerator, defaultProps, BeautifulStyle } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulStyle>\n                    <h1>Layout Integration</h1>\n                    <Description>Trying the grid in different situations</Description>\n                    <Story />\n                </BeautifulStyle>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const LayoutIntegration: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    return (\n        <>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10}\n                rowMarkers=\"both\"\n                height={200}\n            />\n            <DataEditor {...defaultProps} getCellContent={getCellContent} columns={cols} rows={10} rowMarkers=\"both\" />\n            <div style={{ display: \"flex\", height: \"300px\" }}>\n                <DataEditor\n                    {...defaultProps}\n                    getCellContent={getCellContent}\n                    columns={cols}\n                    rows={10}\n                    rowMarkers=\"both\"\n                />\n                <div style={{ flexShrink: 0 }}>This is some text what happens here?</div>\n            </div>\n        </>\n    );\n};\n",
      "locationsMap": {
        "layout-integration": {
          "startLoc": {
            "col": 44,
            "line": 22
          },
          "endLoc": {
            "col": 1,
            "line": 48
          },
          "startBody": {
            "col": 44,
            "line": 22
          },
          "endBody": {
            "col": 1,
            "line": 48
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulStyle */ .xl, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", null, "Layout Integration"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Trying the grid in different situations"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const LayoutIntegration = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(1000, true, true);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 10,
    rowMarkers: "both",
    height: 200
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 10,
    rowMarkers: "both"
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      display: "flex",
      height: "300px"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 10,
    rowMarkers: "both"
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      flexShrink: 0
    }
  }, "This is some text what happens here?")));
};
const __namedExportsOrder = ["LayoutIntegration"];

/***/ }),

/***/ "./packages/core/src/docs/examples/minimap.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Minimap": () => (/* binding */ Minimap),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Minimap\"\n                    description={\n                        <Description>\n                            A minimap can be enabled by setting the <PropName>showMinimap</PropName> property.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const Minimap: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            showMinimap={true}\n            rows={3000}\n            rowMarkers=\"both\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "Minimap": {
    "startLoc": {
      "col": 34,
      "line": 32
    },
    "endLoc": {
      "col": 1,
      "line": 45
    },
    "startBody": {
      "col": 34,
      "line": 32
    },
    "endBody": {
      "col": 1,
      "line": 45
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Minimap\"\n                    description={\n                        <Description>\n                            A minimap can be enabled by setting the <PropName>showMinimap</PropName> property.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const Minimap: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            showMinimap={true}\n            rows={3000}\n            rowMarkers=\"both\"\n        />\n    );\n};\n",
      "locationsMap": {
        "minimap": {
          "startLoc": {
            "col": 34,
            "line": 32
          },
          "endLoc": {
            "col": 1,
            "line": 45
          },
          "startBody": {
            "col": 34,
            "line": 32
          },
          "endBody": {
            "col": 1,
            "line": 45
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Minimap",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "A minimap can be enabled by setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "showMinimap"), " property.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const Minimap = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(1000, true, true);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    showMinimap: true,
    rows: 3000,
    rowMarkers: "both"
  }));
};
const __namedExportsOrder = ["Minimap"];

/***/ }),

/***/ "./packages/core/src/docs/examples/multi-select-columns.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiSelectColumns": () => (/* binding */ MultiSelectColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Multi select columns\"\n                    description={\n                        <>\n                            <Description>\n                                You can select multiple columns by using the <PropName>selectedColumns</PropName> and{\" \"}\n                                <PropName>onSelectedColumnsChange</PropName> props\n                            </Description>\n                            <MoreInfo>\n                                Here you can multi select columns by using <KeyName>Ctrl</KeyName> (on Windows) or{\" \"}\n                                <KeyName>⌘</KeyName> (on Mac)\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const MultiSelectColumns: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    return (\n        <DataEditor {...defaultProps} getCellContent={getCellContent} rowMarkers=\"both\" columns={cols} rows={100_000} />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "MultiSelectColumns": {
    "startLoc": {
      "col": 45,
      "line": 41
    },
    "endLoc": {
      "col": 1,
      "line": 47
    },
    "startBody": {
      "col": 45,
      "line": 41
    },
    "endBody": {
      "col": 1,
      "line": 47
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Multi select columns\"\n                    description={\n                        <>\n                            <Description>\n                                You can select multiple columns by using the <PropName>selectedColumns</PropName> and{\" \"}\n                                <PropName>onSelectedColumnsChange</PropName> props\n                            </Description>\n                            <MoreInfo>\n                                Here you can multi select columns by using <KeyName>Ctrl</KeyName> (on Windows) or{\" \"}\n                                <KeyName>⌘</KeyName> (on Mac)\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const MultiSelectColumns: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    return (\n        <DataEditor {...defaultProps} getCellContent={getCellContent} rowMarkers=\"both\" columns={cols} rows={100_000} />\n    );\n};\n",
      "locationsMap": {
        "multi-select-columns": {
          "startLoc": {
            "col": 45,
            "line": 41
          },
          "endLoc": {
            "col": 1,
            "line": 47
          },
          "startBody": {
            "col": 45,
            "line": 41
          },
          "endBody": {
            "col": 1,
            "line": 47
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Multi select columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can select multiple columns by using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "selectedColumns"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onSelectedColumnsChange"), " props"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Here you can multi select columns by using ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "Ctrl"), " (on Windows) or", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, "\u2318"), " (on Mac)"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const MultiSelectColumns = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    rowMarkers: "both",
    columns: cols,
    rows: 100000
  }));
};
const __namedExportsOrder = ["MultiSelectColumns"];

/***/ }),

/***/ "./packages/core/src/docs/examples/new-column-button.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NewColumnButton": () => (/* binding */ NewColumnButton),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n    ColumnAddButton,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"New column button\"\n                    description={\n                        <Description>\n                            A new column button can be created using the <PropName>rightElement</PropName>.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const NewColumnButton: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(10, true);\n\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={columns}\n            rightElement={\n                <ColumnAddButton>\n                    <button onClick={() => window.alert(\"Add a column!\")}>+</button>\n                </ColumnAddButton>\n            }\n            rightElementProps={{\n                fill: false,\n                sticky: false,\n            }}\n            rows={3000}\n            rowMarkers=\"both\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "NewColumnButton": {
    "startLoc": {
      "col": 42,
      "line": 33
    },
    "endLoc": {
      "col": 1,
      "line": 56
    },
    "startBody": {
      "col": 42,
      "line": 33
    },
    "endBody": {
      "col": 1,
      "line": 56
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n    ColumnAddButton,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"New column button\"\n                    description={\n                        <Description>\n                            A new column button can be created using the <PropName>rightElement</PropName>.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const NewColumnButton: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(10, true);\n\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={columns}\n            rightElement={\n                <ColumnAddButton>\n                    <button onClick={() => window.alert(\"Add a column!\")}>+</button>\n                </ColumnAddButton>\n            }\n            rightElementProps={{\n                fill: false,\n                sticky: false,\n            }}\n            rows={3000}\n            rowMarkers=\"both\"\n        />\n    );\n};\n",
      "locationsMap": {
        "new-column-button": {
          "startLoc": {
            "col": 42,
            "line": 33
          },
          "endLoc": {
            "col": 1,
            "line": 56
          },
          "startBody": {
            "col": 42,
            "line": 33
          },
          "endBody": {
            "col": 1,
            "line": 56
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "New column button",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "A new column button can be created using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "rightElement"), ".")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const NewColumnButton = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(10, true);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => cols.map(c => ({ ...c,
    grow: 1
  })), [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: columns,
    rightElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .ColumnAddButton */ .YE, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: () => window.alert("Add a column!")
    }, "+")),
    rightElementProps: {
      fill: false,
      sticky: false
    },
    rows: 3000,
    rowMarkers: "both"
  }));
};
const __namedExportsOrder = ["NewColumnButton"];

/***/ }),

/***/ "./packages/core/src/docs/examples/observe-visible-region.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObserveVisibleRegion": () => (/* binding */ ObserveVisibleRegion),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { Rectangle } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ObserveVisibleRegion: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    const [visibleRegion, setVisibleRegion] = React.useState<Rectangle>({ x: 0, y: 0, width: 0, height: 0 });\n\n    return (\n        <BeautifulWrapper\n            title=\"Observe Visible Region\"\n            description={\n                <>\n                    <Description>\n                        The visible region can be observed using <PropName>onVisibleRegionChanged</PropName>\n                    </Description>\n                    <MoreInfo>\n                        Then current visible region is x:<KeyName>{visibleRegion.x}</KeyName> y:\n                        <KeyName>{visibleRegion.y}</KeyName> width:\n                        <KeyName>{visibleRegion.width}</KeyName> height:<KeyName>{visibleRegion.height}</KeyName>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n                onVisibleRegionChanged={setVisibleRegion}\n            />\n        </BeautifulWrapper>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ObserveVisibleRegion": {
    "startLoc": {
      "col": 47,
      "line": 27
    },
    "endLoc": {
      "col": 1,
      "line": 56
    },
    "startBody": {
      "col": 47,
      "line": 27
    },
    "endBody": {
      "col": 1,
      "line": 56
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { Rectangle } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ObserveVisibleRegion: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    const [visibleRegion, setVisibleRegion] = React.useState<Rectangle>({ x: 0, y: 0, width: 0, height: 0 });\n\n    return (\n        <BeautifulWrapper\n            title=\"Observe Visible Region\"\n            description={\n                <>\n                    <Description>\n                        The visible region can be observed using <PropName>onVisibleRegionChanged</PropName>\n                    </Description>\n                    <MoreInfo>\n                        Then current visible region is x:<KeyName>{visibleRegion.x}</KeyName> y:\n                        <KeyName>{visibleRegion.y}</KeyName> width:\n                        <KeyName>{visibleRegion.width}</KeyName> height:<KeyName>{visibleRegion.height}</KeyName>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n                onVisibleRegionChanged={setVisibleRegion}\n            />\n        </BeautifulWrapper>\n    );\n};\n",
      "locationsMap": {
        "observe-visible-region": {
          "startLoc": {
            "col": 47,
            "line": 27
          },
          "endLoc": {
            "col": 1,
            "line": 56
          },
          "startBody": {
            "col": 47,
            "line": 27
          },
          "endBody": {
            "col": 1,
            "line": 56
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const ObserveVisibleRegion = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100);
  const [visibleRegion, setVisibleRegion] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Observe Visible Region",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "The visible region can be observed using ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onVisibleRegionChanged")), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Then current visible region is x:", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, visibleRegion.x), " y:", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, visibleRegion.y), " width:", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, visibleRegion.width), " height:", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, null, visibleRegion.height)))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000,
    onVisibleRegionChanged: setVisibleRegion
  })));
};
const __namedExportsOrder = ["ObserveVisibleRegion"];

/***/ }),

/***/ "./packages/core/src/docs/examples/one-hundred-thousand-columns.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OneHundredThousandCols": () => (/* binding */ OneHundredThousandCols),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"One Hundred Thousand Columns\"\n                    description={\n                        <Description>\n                            Data grid supports way more columns than you will ever need. Also this is rendering 10\n                            million cells but that&apos;s not important.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const OneHundredThousandCols: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100_000);\n\n    return <DataEditor {...defaultProps} getCellContent={getCellContent} columns={cols} rows={1000} />;\n};\n";
var __LOCATIONS_MAP__ = {
  "OneHundredThousandCols": {
    "startLoc": {
      "col": 49,
      "line": 27
    },
    "endLoc": {
      "col": 1,
      "line": 31
    },
    "startBody": {
      "col": 49,
      "line": 27
    },
    "endBody": {
      "col": 1,
      "line": 31
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"One Hundred Thousand Columns\"\n                    description={\n                        <Description>\n                            Data grid supports way more columns than you will ever need. Also this is rendering 10\n                            million cells but that&apos;s not important.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const OneHundredThousandCols: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100_000);\n\n    return <DataEditor {...defaultProps} getCellContent={getCellContent} columns={cols} rows={1000} />;\n};\n",
      "locationsMap": {
        "one-hundred-thousand-cols": {
          "startLoc": {
            "col": 49,
            "line": 27
          },
          "endLoc": {
            "col": 1,
            "line": 31
          },
          "startBody": {
            "col": 49,
            "line": 27
          },
          "endBody": {
            "col": 1,
            "line": 31
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "One Hundred Thousand Columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Data grid supports way more columns than you will ever need. Also this is rendering 10 million cells but that's not important.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const OneHundredThousandCols = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100000);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  }));
};
const __namedExportsOrder = ["OneHundredThousandCols"];

/***/ }),

/***/ "./packages/core/src/docs/examples/one-million-rows.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OneMillionRows": () => (/* binding */ OneMillionRows),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"One Million Rows\"\n                    description={\n                        <Description>Data grid supports over 1 million rows. Your limit is mostly RAM.</Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const OneMillionRows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [rows, setRows] = React.useState(1_000_000);\n\n    React.useEffect(() => {\n        window.setTimeout(() => setRows(5), 3000);\n    }, []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            height=\"100%\"\n            getCellContent={getCellContent}\n            columns={cols}\n            rowHeight={31}\n            rows={rows}\n            rowMarkers=\"number\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "OneMillionRows": {
    "startLoc": {
      "col": 41,
      "line": 24
    },
    "endLoc": {
      "col": 1,
      "line": 44
    },
    "startBody": {
      "col": 41,
      "line": 24
    },
    "endBody": {
      "col": 1,
      "line": 44
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"One Million Rows\"\n                    description={\n                        <Description>Data grid supports over 1 million rows. Your limit is mostly RAM.</Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const OneMillionRows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [rows, setRows] = React.useState(1_000_000);\n\n    React.useEffect(() => {\n        window.setTimeout(() => setRows(5), 3000);\n    }, []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            height=\"100%\"\n            getCellContent={getCellContent}\n            columns={cols}\n            rowHeight={31}\n            rows={rows}\n            rowMarkers=\"number\"\n        />\n    );\n};\n",
      "locationsMap": {
        "one-million-rows": {
          "startLoc": {
            "col": 41,
            "line": 24
          },
          "endLoc": {
            "col": 1,
            "line": 44
          },
          "startBody": {
            "col": 41,
            "line": 24
          },
          "endBody": {
            "col": 1,
            "line": 44
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "One Million Rows",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Data grid supports over 1 million rows. Your limit is mostly RAM.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const OneMillionRows = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6);
  const [rows, setRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(1000000);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    window.setTimeout(() => setRows(5), 3000);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    height: "100%",
    getCellContent: getCellContent,
    columns: cols,
    rowHeight: 31,
    rows: rows,
    rowMarkers: "number"
  }));
};
const __namedExportsOrder = ["OneMillionRows"];

/***/ }),

/***/ "./packages/core/src/docs/examples/overscroll.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Overscroll": () => (/* binding */ Overscroll),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Overscroll\"\n                    description={\n                        <>\n                            <Description>\n                                You can allocate extra space at the ends of the grid by setting the{\" \"}\n                                <PropName>overscrollX</PropName> and <PropName>overscrollY</PropName> props\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface OverscrollProps {\n    overscrollX: number;\n    overscrollY: number;\n}\n\nexport const Overscroll: React.VFC<OverscrollProps> = p => {\n    const { overscrollX, overscrollY } = p;\n    const { cols, getCellContent } = useMockDataGenerator(20);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            overscrollX={overscrollX}\n            overscrollY={overscrollY}\n            rows={50}\n        />\n    );\n};\n(Overscroll as any).argTypes = {\n    overscrollX: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n    overscrollY: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n};\n(Overscroll as any).args = {\n    overscrollX: 200,\n    overscrollY: 200,\n};\n";
var __LOCATIONS_MAP__ = {
  "Overscroll": {
    "startLoc": {
      "col": 54,
      "line": 40
    },
    "endLoc": {
      "col": 1,
      "line": 54
    },
    "startBody": {
      "col": 54,
      "line": 40
    },
    "endBody": {
      "col": 1,
      "line": 54
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Overscroll\"\n                    description={\n                        <>\n                            <Description>\n                                You can allocate extra space at the ends of the grid by setting the{\" \"}\n                                <PropName>overscrollX</PropName> and <PropName>overscrollY</PropName> props\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface OverscrollProps {\n    overscrollX: number;\n    overscrollY: number;\n}\n\nexport const Overscroll: React.VFC<OverscrollProps> = p => {\n    const { overscrollX, overscrollY } = p;\n    const { cols, getCellContent } = useMockDataGenerator(20);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            overscrollX={overscrollX}\n            overscrollY={overscrollY}\n            rows={50}\n        />\n    );\n};\n(Overscroll as any).argTypes = {\n    overscrollX: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n    overscrollY: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n};\n(Overscroll as any).args = {\n    overscrollX: 200,\n    overscrollY: 200,\n};\n",
      "locationsMap": {
        "overscroll": {
          "startLoc": {
            "col": 54,
            "line": 40
          },
          "endLoc": {
            "col": 1,
            "line": 54
          },
          "startBody": {
            "col": 54,
            "line": 40
          },
          "endBody": {
            "col": 1,
            "line": 54
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Overscroll",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can allocate extra space at the ends of the grid by setting the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "overscrollX"), " and ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "overscrollY"), " props"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const Overscroll = p => {
  const {
    overscrollX,
    overscrollY
  } = p;
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(20);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    overscrollX: overscrollX,
    overscrollY: overscrollY,
    rows: 50
  }));
};
Overscroll.argTypes = {
  overscrollX: {
    control: {
      type: "range",
      min: 0,
      max: 600
    }
  },
  overscrollY: {
    control: {
      type: "range",
      min: 0,
      max: 600
    }
  }
};
Overscroll.args = {
  overscrollX: 200,
  overscrollY: 200
};
const __namedExportsOrder = ["Overscroll"];

/***/ }),

/***/ "./packages/core/src/docs/examples/padding.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Padding": () => (/* binding */ Padding),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Padding\"\n                    description={\n                        <>\n                            <Description>\n                                You can add padding at the ends of the grid by setting the{\" \"}\n                                <PropName>paddingRight</PropName> and <PropName>paddingBottom</PropName> props\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface PaddingProps {\n    paddingRight: number;\n    paddingBottom: number;\n}\n\nexport const Padding: React.VFC<PaddingProps> = p => {\n    const { paddingRight, paddingBottom } = p;\n    const { cols, getCellContent } = useMockDataGenerator(20);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            experimental={{ paddingRight, paddingBottom }}\n            rows={50}\n        />\n    );\n};\n(Padding as any).argTypes = {\n    paddingRight: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n    paddingBottom: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n};\n(Padding as any).args = {\n    paddingRight: 200,\n    paddingBottom: 200,\n};\n";
var __LOCATIONS_MAP__ = {
  "Padding": {
    "startLoc": {
      "col": 48,
      "line": 40
    },
    "endLoc": {
      "col": 1,
      "line": 54
    },
    "startBody": {
      "col": 48,
      "line": 40
    },
    "endBody": {
      "col": 1,
      "line": 54
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Padding\"\n                    description={\n                        <>\n                            <Description>\n                                You can add padding at the ends of the grid by setting the{\" \"}\n                                <PropName>paddingRight</PropName> and <PropName>paddingBottom</PropName> props\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface PaddingProps {\n    paddingRight: number;\n    paddingBottom: number;\n}\n\nexport const Padding: React.VFC<PaddingProps> = p => {\n    const { paddingRight, paddingBottom } = p;\n    const { cols, getCellContent } = useMockDataGenerator(20);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            experimental={{ paddingRight, paddingBottom }}\n            rows={50}\n        />\n    );\n};\n(Padding as any).argTypes = {\n    paddingRight: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n    paddingBottom: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n};\n(Padding as any).args = {\n    paddingRight: 200,\n    paddingBottom: 200,\n};\n",
      "locationsMap": {
        "padding": {
          "startLoc": {
            "col": 48,
            "line": 40
          },
          "endLoc": {
            "col": 1,
            "line": 54
          },
          "startBody": {
            "col": 48,
            "line": 40
          },
          "endBody": {
            "col": 1,
            "line": 54
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Padding",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can add padding at the ends of the grid by setting the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "paddingRight"), " and ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "paddingBottom"), " props"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const Padding = p => {
  const {
    paddingRight,
    paddingBottom
  } = p;
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(20);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    experimental: {
      paddingRight,
      paddingBottom
    },
    rows: 50
  }));
};
Padding.argTypes = {
  paddingRight: {
    control: {
      type: "range",
      min: 0,
      max: 600
    }
  },
  paddingBottom: {
    control: {
      type: "range",
      min: 0,
      max: 600
    }
  }
};
Padding.args = {
  paddingRight: 200,
  paddingBottom: 200
};
const __namedExportsOrder = ["Padding"];

/***/ }),

/***/ "./packages/core/src/docs/examples/paste-support.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PasteSupport": () => (/* binding */ PasteSupport),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Paste support\"\n                    description={\n                        <>\n                            <Description>\n                                The data grid can handle paste automatically by returning true from{\" \"}\n                                <PropName>onPaste</PropName>. You can also return false and handle paste yourself. If\n                                paste is undefined the DataEditor will do its best to paste to the current cell.\n                            </Description>\n                            <MoreInfo>\n                                Paste supports the copy format of Google Sheets and Excel. Below is an example of data\n                                copied from excel with some escaped text.\n                            </MoreInfo>\n                            <textarea\n                                value={`Sunday\tDogs\thttps://google.com\nMonday\tCats\thttps://google.com\nTuesday\tTurtles\thttps://google.com\nWednesday\tBears\thttps://google.com\nThursday\t\"L  ions\"\thttps://google.com\nFriday\tPigs\thttps://google.com\nSaturday\t\"Turkeys and some \"\"quotes\"\" and\na new line char \"\"more quotes\"\" plus a tab  .\"\thttps://google.com`}\n                                style={{\n                                    width: \"100%\",\n                                    marginBottom: 20,\n                                    borderRadius: 9,\n                                    minHeight: 200,\n                                    padding: 10,\n                                }}\n                            />\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const PasteSupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useMockDataGenerator(50, false);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            rowMarkers=\"both\"\n            columns={cols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            onPaste={true}\n            rows={400}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "PasteSupport": {
    "startLoc": {
      "col": 39,
      "line": 58
    },
    "endLoc": {
      "col": 1,
      "line": 73
    },
    "startBody": {
      "col": 39,
      "line": 58
    },
    "endBody": {
      "col": 1,
      "line": 73
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Paste support\"\n                    description={\n                        <>\n                            <Description>\n                                The data grid can handle paste automatically by returning true from{\" \"}\n                                <PropName>onPaste</PropName>. You can also return false and handle paste yourself. If\n                                paste is undefined the DataEditor will do its best to paste to the current cell.\n                            </Description>\n                            <MoreInfo>\n                                Paste supports the copy format of Google Sheets and Excel. Below is an example of data\n                                copied from excel with some escaped text.\n                            </MoreInfo>\n                            <textarea\n                                value={`Sunday\tDogs\thttps://google.com\nMonday\tCats\thttps://google.com\nTuesday\tTurtles\thttps://google.com\nWednesday\tBears\thttps://google.com\nThursday\t\"L  ions\"\thttps://google.com\nFriday\tPigs\thttps://google.com\nSaturday\t\"Turkeys and some \"\"quotes\"\" and\na new line char \"\"more quotes\"\" plus a tab  .\"\thttps://google.com`}\n                                style={{\n                                    width: \"100%\",\n                                    marginBottom: 20,\n                                    borderRadius: 9,\n                                    minHeight: 200,\n                                    padding: 10,\n                                }}\n                            />\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const PasteSupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useMockDataGenerator(50, false);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            rowMarkers=\"both\"\n            columns={cols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            onPaste={true}\n            rows={400}\n        />\n    );\n};\n",
      "locationsMap": {
        "paste-support": {
          "startLoc": {
            "col": 39,
            "line": 58
          },
          "endLoc": {
            "col": 1,
            "line": 73
          },
          "startBody": {
            "col": 39,
            "line": 58
          },
          "endBody": {
            "col": 1,
            "line": 73
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Paste support",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "The data grid can handle paste automatically by returning true from", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onPaste"), ". You can also return false and handle paste yourself. If paste is undefined the DataEditor will do its best to paste to the current cell."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Paste supports the copy format of Google Sheets and Excel. Below is an example of data copied from excel with some escaped text."), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
      value: `Sunday	Dogs	https://google.com
Monday	Cats	https://google.com
Tuesday	Turtles	https://google.com
Wednesday	Bears	https://google.com
Thursday	"L  ions"	https://google.com
Friday	Pigs	https://google.com
Saturday	"Turkeys and some ""quotes"" and
a new line char ""more quotes"" plus a tab  ."	https://google.com`,
      style: {
        width: "100%",
        marginBottom: 20,
        borderRadius: 9,
        minHeight: 200,
        padding: 10
      }
    }))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const PasteSupport = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(50, false);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    rowMarkers: "both",
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    onPaste: true,
    rows: 400
  }));
};
const __namedExportsOrder = ["PasteSupport"];

/***/ }),

/***/ "./packages/core/src/docs/examples/prevent-diagonal-scroll.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PreventDiagonalScroll": () => (/* binding */ PreventDiagonalScroll),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Prevent Diagonal Scroll\"\n                    description={\n                        <>\n                            <Description>\n                                Diagonal scrolling can be prevented by setting{\" \"}\n                                <PropName>preventDiagonalScrolling</PropName>.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const PreventDiagonalScroll: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(200);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            preventDiagonalScrolling={true}\n            rows={5000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "PreventDiagonalScroll": {
    "startLoc": {
      "col": 48,
      "line": 35
    },
    "endLoc": {
      "col": 1,
      "line": 47
    },
    "startBody": {
      "col": 48,
      "line": 35
    },
    "endBody": {
      "col": 1,
      "line": 47
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Prevent Diagonal Scroll\"\n                    description={\n                        <>\n                            <Description>\n                                Diagonal scrolling can be prevented by setting{\" \"}\n                                <PropName>preventDiagonalScrolling</PropName>.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const PreventDiagonalScroll: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(200);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            preventDiagonalScrolling={true}\n            rows={5000}\n        />\n    );\n};\n",
      "locationsMap": {
        "prevent-diagonal-scroll": {
          "startLoc": {
            "col": 48,
            "line": 35
          },
          "endLoc": {
            "col": 1,
            "line": 47
          },
          "startBody": {
            "col": 48,
            "line": 35
          },
          "endBody": {
            "col": 1,
            "line": 47
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Prevent Diagonal Scroll",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Diagonal scrolling can be prevented by setting", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "preventDiagonalScrolling"), "."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const PreventDiagonalScroll = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(200);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    preventDiagonalScrolling: true,
    rows: 5000
  }));
};
const __namedExportsOrder = ["PreventDiagonalScroll"];

/***/ }),

/***/ "./packages/core/src/docs/examples/rapid-updates.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RapidUpdates": () => (/* binding */ RapidUpdates),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor, DataEditorRef } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { Item } from \"../../data-grid/data-grid-types\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16_807) % 2_147_483_647);\n}\n\nexport const RapidUpdates: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw } = useMockDataGenerator(100);\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const countRef = React.useRef(0);\n    const displayCountRef = React.useRef<HTMLElement>(null);\n\n    React.useEffect(() => {\n        let rafID = 0;\n\n        const sendUpdate = () => {\n            const cells: {\n                cell: Item;\n            }[] = [];\n            const now = performance.now();\n            for (let x = 0; x < 5000; x++) {\n                const col = Math.max(10, rand() % 100);\n                const row = rand() % 10_000;\n\n                setCellValueRaw([col, row], {\n                    kind: GridCellKind.Text,\n                    data: x.toString(),\n                    displayData: `${x}k`,\n                    themeOverride:\n                        x % 5 !== 0\n                            ? {\n                                  bgCell: \"#f2fff4\",\n                                  textDark: \"#00d41c\",\n                              }\n                            : {\n                                  bgCell: \"#fff6f6\",\n                                  textDark: \"#d40000\",\n                              },\n                    allowOverlay: true,\n                    lastUpdated: now,\n                });\n                cells.push({ cell: [col, row] });\n            }\n            countRef.current += 5000;\n            if (displayCountRef.current !== null) {\n                displayCountRef.current.textContent = `${countRef.current}`;\n            }\n\n            ref.current?.updateCells(cells);\n\n            rafID = window.requestAnimationFrame(sendUpdate);\n        };\n\n        sendUpdate();\n\n        return () => {\n            cancelAnimationFrame(rafID);\n        };\n    }, [setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Rapid updating\"\n            description={\n                <>\n                    <Description>\n                        Data grid can support many thousands of updates per seconds. The data grid can easily update\n                        data faster than a human can read it, more importantly the faster the data grid can update, the\n                        more time your code can spend doing more valuable work.\n                    </Description>\n                    <MoreInfo>\n                        Updates processed: <KeyName ref={displayCountRef} /> We could do this faster but we wrote a\n                        really crappy data store for this demo which is actually slowing down the data grid.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor {...defaultProps} ref={ref} getCellContent={getCellContent} columns={cols} rows={10_000} />\n        </BeautifulWrapper>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "RapidUpdates": {
    "startLoc": {
      "col": 39,
      "line": 32
    },
    "endLoc": {
      "col": 1,
      "line": 107
    },
    "startBody": {
      "col": 39,
      "line": 32
    },
    "endBody": {
      "col": 1,
      "line": 107
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor, DataEditorRef } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    useMockDataGenerator,\n    KeyName,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { Item } from \"../../data-grid/data-grid-types\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16_807) % 2_147_483_647);\n}\n\nexport const RapidUpdates: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw } = useMockDataGenerator(100);\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const countRef = React.useRef(0);\n    const displayCountRef = React.useRef<HTMLElement>(null);\n\n    React.useEffect(() => {\n        let rafID = 0;\n\n        const sendUpdate = () => {\n            const cells: {\n                cell: Item;\n            }[] = [];\n            const now = performance.now();\n            for (let x = 0; x < 5000; x++) {\n                const col = Math.max(10, rand() % 100);\n                const row = rand() % 10_000;\n\n                setCellValueRaw([col, row], {\n                    kind: GridCellKind.Text,\n                    data: x.toString(),\n                    displayData: `${x}k`,\n                    themeOverride:\n                        x % 5 !== 0\n                            ? {\n                                  bgCell: \"#f2fff4\",\n                                  textDark: \"#00d41c\",\n                              }\n                            : {\n                                  bgCell: \"#fff6f6\",\n                                  textDark: \"#d40000\",\n                              },\n                    allowOverlay: true,\n                    lastUpdated: now,\n                });\n                cells.push({ cell: [col, row] });\n            }\n            countRef.current += 5000;\n            if (displayCountRef.current !== null) {\n                displayCountRef.current.textContent = `${countRef.current}`;\n            }\n\n            ref.current?.updateCells(cells);\n\n            rafID = window.requestAnimationFrame(sendUpdate);\n        };\n\n        sendUpdate();\n\n        return () => {\n            cancelAnimationFrame(rafID);\n        };\n    }, [setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Rapid updating\"\n            description={\n                <>\n                    <Description>\n                        Data grid can support many thousands of updates per seconds. The data grid can easily update\n                        data faster than a human can read it, more importantly the faster the data grid can update, the\n                        more time your code can spend doing more valuable work.\n                    </Description>\n                    <MoreInfo>\n                        Updates processed: <KeyName ref={displayCountRef} /> We could do this faster but we wrote a\n                        really crappy data store for this demo which is actually slowing down the data grid.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor {...defaultProps} ref={ref} getCellContent={getCellContent} columns={cols} rows={10_000} />\n        </BeautifulWrapper>\n    );\n};\n",
      "locationsMap": {
        "rapid-updates": {
          "startLoc": {
            "col": 39,
            "line": 32
          },
          "endLoc": {
            "col": 1,
            "line": 107
          },
          "startBody": {
            "col": 39,
            "line": 32
          },
          "endBody": {
            "col": 1,
            "line": 107
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
let num = 1;

function rand() {
  return num = num * 16807 % 2147483647;
}

const RapidUpdates = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100);
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const countRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const displayCountRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let rafID = 0;

    const sendUpdate = () => {
      var _ref$current;

      const cells = [];
      const now = performance.now();

      for (let x = 0; x < 5000; x++) {
        const col = Math.max(10, rand() % 100);
        const row = rand() % 10000;
        setCellValueRaw([col, row], {
          kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
          data: x.toString(),
          displayData: `${x}k`,
          themeOverride: x % 5 !== 0 ? {
            bgCell: "#f2fff4",
            textDark: "#00d41c"
          } : {
            bgCell: "#fff6f6",
            textDark: "#d40000"
          },
          allowOverlay: true,
          lastUpdated: now
        });
        cells.push({
          cell: [col, row]
        });
      }

      countRef.current += 5000;

      if (displayCountRef.current !== null) {
        displayCountRef.current.textContent = `${countRef.current}`;
      }

      (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.updateCells(cells);
      rafID = window.requestAnimationFrame(sendUpdate);
    };

    sendUpdate();
    return () => {
      cancelAnimationFrame(rafID);
    };
  }, [setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Rapid updating",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Data grid can support many thousands of updates per seconds. The data grid can easily update data faster than a human can read it, more importantly the faster the data grid can update, the more time your code can spend doing more valuable work."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Updates processed: ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .KeyName */ .et, {
      ref: displayCountRef
    }), " We could do this faster but we wrote a really crappy data store for this demo which is actually slowing down the data grid."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    ref: ref,
    getCellContent: getCellContent,
    columns: cols,
    rows: 10000
  })));
};
const __namedExportsOrder = ["RapidUpdates"];

/***/ }),

/***/ "./packages/core/src/docs/examples/rearrange-columns.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RearrangeColumns": () => (/* binding */ RearrangeColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { Item, GridCell } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Rearrange Columns\"\n                    description={\n                        <Description>\n                            Columns can be rearranged by drag and dropping, as long as you respond to the{\" \"}\n                            <PropName>onColumnMoved</PropName> callback.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const RearrangeColumns: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(60);\n\n    // This is a dirty hack because the mock generator doesn't really support changing this. In a real data source\n    // you should track indexes properly\n    const [sortableCols, setSortableCols] = React.useState(cols);\n\n    const onColMoved = React.useCallback((startIndex: number, endIndex: number): void => {\n        setSortableCols(old => {\n            const newCols = [...old];\n            const [toMove] = newCols.splice(startIndex, 1);\n            newCols.splice(endIndex, 0, toMove);\n            return newCols;\n        });\n    }, []);\n\n    const getCellContentMangled = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            const remappedCol = cols.findIndex(c => c.title === sortableCols[col].title);\n            return getCellContent([remappedCol, row]);\n        },\n        [cols, getCellContent, sortableCols]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            freezeColumns={1}\n            rowMarkers=\"both\"\n            getCellContent={getCellContentMangled}\n            columns={sortableCols}\n            onColumnMoved={onColMoved}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "RearrangeColumns": {
    "startLoc": {
      "col": 43,
      "line": 34
    },
    "endLoc": {
      "col": 1,
      "line": 69
    },
    "startBody": {
      "col": 43,
      "line": 34
    },
    "endBody": {
      "col": 1,
      "line": 69
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { Item, GridCell } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Rearrange Columns\"\n                    description={\n                        <Description>\n                            Columns can be rearranged by drag and dropping, as long as you respond to the{\" \"}\n                            <PropName>onColumnMoved</PropName> callback.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const RearrangeColumns: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(60);\n\n    // This is a dirty hack because the mock generator doesn't really support changing this. In a real data source\n    // you should track indexes properly\n    const [sortableCols, setSortableCols] = React.useState(cols);\n\n    const onColMoved = React.useCallback((startIndex: number, endIndex: number): void => {\n        setSortableCols(old => {\n            const newCols = [...old];\n            const [toMove] = newCols.splice(startIndex, 1);\n            newCols.splice(endIndex, 0, toMove);\n            return newCols;\n        });\n    }, []);\n\n    const getCellContentMangled = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            const remappedCol = cols.findIndex(c => c.title === sortableCols[col].title);\n            return getCellContent([remappedCol, row]);\n        },\n        [cols, getCellContent, sortableCols]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            freezeColumns={1}\n            rowMarkers=\"both\"\n            getCellContent={getCellContentMangled}\n            columns={sortableCols}\n            onColumnMoved={onColMoved}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "rearrange-columns": {
          "startLoc": {
            "col": 43,
            "line": 34
          },
          "endLoc": {
            "col": 1,
            "line": 69
          },
          "startBody": {
            "col": 43,
            "line": 34
          },
          "endBody": {
            "col": 1,
            "line": 69
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Rearrange Columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Columns can be rearranged by drag and dropping, as long as you respond to the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onColumnMoved"), " callback.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const RearrangeColumns = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60);
  const [sortableCols, setSortableCols] = react__WEBPACK_IMPORTED_MODULE_0__.useState(cols);
  const onColMoved = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((startIndex, endIndex) => {
    setSortableCols(old => {
      const newCols = [...old];
      const [toMove] = newCols.splice(startIndex, 1);
      newCols.splice(endIndex, 0, toMove);
      return newCols;
    });
  }, []);
  const getCellContentMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {
    let [col, row] = _ref;
    const remappedCol = cols.findIndex(c => c.title === sortableCols[col].title);
    return getCellContent([remappedCol, row]);
  }, [cols, getCellContent, sortableCols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    freezeColumns: 1,
    rowMarkers: "both",
    getCellContent: getCellContentMangled,
    columns: sortableCols,
    onColumnMoved: onColMoved,
    rows: 1000
  }));
};
const __namedExportsOrder = ["RearrangeColumns"];

/***/ }),

/***/ "./packages/core/src/docs/examples/reorder-rows.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReorderRows": () => (/* binding */ ReorderRows),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import { range } from \"lodash\";\nimport React from \"react\";\nimport { DataEditor, DataEditorProps } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, PropName, defaultProps } from \"../../data-editor/stories/utils\";\nimport type { GridColumn } from \"../../data-grid/data-grid-types\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Reorder Rows\"\n                    description={\n                        <>\n                            <Description>\n                                Rows can be re-arranged by using the <PropName>onRowMoved</PropName> callback. When set\n                                the first row can be used to drag and drop.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ReorderRows: React.VFC = () => {\n    const cols = React.useMemo<GridColumn[]>(\n        () => [\n            {\n                title: \"Col A\",\n                width: 150,\n            },\n            {\n                title: \"Col B\",\n                width: 150,\n            },\n        ],\n        []\n    );\n\n    const [rowData, setRowData] = React.useState(() => {\n        return range(0, 50).map(x => [`A: ${x}`, `B: ${x}`]);\n    });\n\n    const getCellContent = React.useCallback<DataEditorProps[\"getCellContent\"]>(\n        ([col, row]) => {\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: false,\n                data: rowData[row][col],\n                displayData: rowData[row][col],\n            };\n        },\n        [rowData]\n    );\n\n    const reorderRows = React.useCallback((from: number, to: number) => {\n        setRowData(cv => {\n            const d = [...cv];\n            const removed = d.splice(from, 1);\n            d.splice(to, 0, ...removed);\n            return d;\n        });\n    }, []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers={\"both\"}\n            onRowMoved={reorderRows}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={50}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ReorderRows": {
    "startLoc": {
      "col": 38,
      "line": 32
    },
    "endLoc": {
      "col": 1,
      "line": 82
    },
    "startBody": {
      "col": 38,
      "line": 32
    },
    "endBody": {
      "col": 1,
      "line": 82
    }
  }
};






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import { range } from \"lodash\";\nimport React from \"react\";\nimport { DataEditor, DataEditorProps } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, PropName, defaultProps } from \"../../data-editor/stories/utils\";\nimport type { GridColumn } from \"../../data-grid/data-grid-types\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Reorder Rows\"\n                    description={\n                        <>\n                            <Description>\n                                Rows can be re-arranged by using the <PropName>onRowMoved</PropName> callback. When set\n                                the first row can be used to drag and drop.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ReorderRows: React.VFC = () => {\n    const cols = React.useMemo<GridColumn[]>(\n        () => [\n            {\n                title: \"Col A\",\n                width: 150,\n            },\n            {\n                title: \"Col B\",\n                width: 150,\n            },\n        ],\n        []\n    );\n\n    const [rowData, setRowData] = React.useState(() => {\n        return range(0, 50).map(x => [`A: ${x}`, `B: ${x}`]);\n    });\n\n    const getCellContent = React.useCallback<DataEditorProps[\"getCellContent\"]>(\n        ([col, row]) => {\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: false,\n                data: rowData[row][col],\n                displayData: rowData[row][col],\n            };\n        },\n        [rowData]\n    );\n\n    const reorderRows = React.useCallback((from: number, to: number) => {\n        setRowData(cv => {\n            const d = [...cv];\n            const removed = d.splice(from, 1);\n            d.splice(to, 0, ...removed);\n            return d;\n        });\n    }, []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers={\"both\"}\n            onRowMoved={reorderRows}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={50}\n        />\n    );\n};\n",
      "locationsMap": {
        "reorder-rows": {
          "startLoc": {
            "col": 38,
            "line": 32
          },
          "endLoc": {
            "col": 1,
            "line": 82
          },
          "startBody": {
            "col": 38,
            "line": 32
          },
          "endBody": {
            "col": 1,
            "line": 82
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_1__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_2__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_1__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_3__/* .BeautifulWrapper */ .m, {
    title: "Reorder Rows",
    description: react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_1__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_3__/* .Description */ .dk, null, "Rows can be re-arranged by using the ", react__WEBPACK_IMPORTED_MODULE_1__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_3__/* .PropName */ .Gi, null, "onRowMoved"), " callback. When set the first row can be used to drag and drop."))
  }, react__WEBPACK_IMPORTED_MODULE_1__.createElement(Story, null)))]
});
const ReorderRows = () => {
  const cols = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => [{
    title: "Col A",
    width: 150
  }, {
    title: "Col B",
    width: 150
  }], []);
  const [rowData, setRowData] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => {
    return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.range)(0, 50).map(x => [`A: ${x}`, `B: ${x}`]);
  });
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(_ref => {
    let [col, row] = _ref;
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: false,
      data: rowData[row][col],
      displayData: rowData[row][col]
    };
  }, [rowData]);
  const reorderRows = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((from, to) => {
    setRowData(cv => {
      const d = [...cv];
      const removed = d.splice(from, 1);
      d.splice(to, 0, ...removed);
      return d;
    });
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_1__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_3__/* .defaultProps */ .lG, {
    rowMarkers: "both",
    onRowMoved: reorderRows,
    getCellContent: getCellContent,
    columns: cols,
    rows: 50
  }));
};
const __namedExportsOrder = ["ReorderRows"];

/***/ }),

/***/ "./packages/core/src/docs/examples/resizable-columns.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResizableColumns": () => (/* binding */ ResizableColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Resizable columns\"\n                    description={\n                        <>\n                            <Description>\n                                You can resize columns by dragging their edges, as long as you respond to the{\" \"}\n                                <PropName>onColumnResize</PropName> prop.\n                            </Description>\n                            <MoreInfo>\n                                By setting the <PropName>overscrollX</PropName> property extra space can be allocated at\n                                the end of the grid to allow for easier resizing of the final column. You can highlight\n                                multiple columns to resize them all at once.\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ResizableColumns: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(60);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers=\"both\"\n            overscrollX={200}\n            overscrollY={200}\n            maxColumnAutoWidth={500}\n            maxColumnWidth={2000}\n            rows={50}\n            scaleToRem={true}\n            theme={{\n                baseFontStyle: \"0.8125rem\",\n                headerFontStyle: \"600 0.8125rem\",\n                editorFontSize: \"0.8125rem\",\n            }}\n            onColumnResize={onColumnResize}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ResizableColumns": {
    "startLoc": {
      "col": 43,
      "line": 41
    },
    "endLoc": {
      "col": 1,
      "line": 64
    },
    "startBody": {
      "col": 43,
      "line": 41
    },
    "endBody": {
      "col": 1,
      "line": 64
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Resizable columns\"\n                    description={\n                        <>\n                            <Description>\n                                You can resize columns by dragging their edges, as long as you respond to the{\" \"}\n                                <PropName>onColumnResize</PropName> prop.\n                            </Description>\n                            <MoreInfo>\n                                By setting the <PropName>overscrollX</PropName> property extra space can be allocated at\n                                the end of the grid to allow for easier resizing of the final column. You can highlight\n                                multiple columns to resize them all at once.\n                            </MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ResizableColumns: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(60);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers=\"both\"\n            overscrollX={200}\n            overscrollY={200}\n            maxColumnAutoWidth={500}\n            maxColumnWidth={2000}\n            rows={50}\n            scaleToRem={true}\n            theme={{\n                baseFontStyle: \"0.8125rem\",\n                headerFontStyle: \"600 0.8125rem\",\n                editorFontSize: \"0.8125rem\",\n            }}\n            onColumnResize={onColumnResize}\n        />\n    );\n};\n",
      "locationsMap": {
        "resizable-columns": {
          "startLoc": {
            "col": 43,
            "line": 41
          },
          "endLoc": {
            "col": 1,
            "line": 64
          },
          "startBody": {
            "col": 43,
            "line": 41
          },
          "endBody": {
            "col": 1,
            "line": 64
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Resizable columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can resize columns by dragging their edges, as long as you respond to the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onColumnResize"), " prop."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "By setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "overscrollX"), " property extra space can be allocated at the end of the grid to allow for easier resizing of the final column. You can highlight multiple columns to resize them all at once."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const ResizableColumns = () => {
  const {
    cols,
    getCellContent,
    onColumnResize
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    overscrollX: 200,
    overscrollY: 200,
    maxColumnAutoWidth: 500,
    maxColumnWidth: 2000,
    rows: 50,
    scaleToRem: true,
    theme: {
      baseFontStyle: "0.8125rem",
      headerFontStyle: "600 0.8125rem",
      editorFontSize: "0.8125rem"
    },
    onColumnResize: onColumnResize
  }));
};
const __namedExportsOrder = ["ResizableColumns"];

/***/ }),

/***/ "./packages/core/src/docs/examples/right-element.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RightElement": () => (/* binding */ RightElement),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Right Element\"\n                    description={\n                        <Description>\n                            A DOM element may be added as a trailer to the grid by using the{\" \"}\n                            <PropName>rightElement</PropName> prop.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const RightElement: React.VFC = () => {\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(8, false);\n\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\n\n    const [numRows, setNumRows] = React.useState(300);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        setNumRows(cv => cv + 1);\n        for (let c = 0; c < 6; c++) {\n            setCellValue([c, newRow], {\n                displayData: \"\",\n                data: \"\",\n            } as any);\n        }\n    }, [numRows, setCellValue]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={columns}\n            rowMarkers={\"both\"}\n            onCellEdited={setCellValue}\n            trailingRowOptions={{\n                hint: \"New row...\",\n                sticky: true,\n                tint: true,\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n            rightElementProps={{ sticky: true }}\n            rightElement={\n                <div\n                    style={{\n                        height: \"100%\",\n                        padding: \"20px 20px 40px 20px\",\n                        width: 200,\n                        color: \"black\",\n                        whiteSpace: \"pre-wrap\",\n                        backgroundColor: \"rgba(240, 240, 250, 0.2)\",\n                        display: \"flex\",\n                        justifyContent: \"center\",\n                        alignItems: \"center\",\n                        boxShadow: \"0 0 10px rgba(0, 0, 0, 0.15)\",\n                        backdropFilter: \"blur(12px)\",\n                    }}>\n                    This is a real DOM element. You can put whatever you want here. You can also size it as big as you\n                    want. {\"\\n\\n\"}It also does not have to be sticky.\n                </div>\n            }\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "RightElement": {
    "startLoc": {
      "col": 39,
      "line": 33
    },
    "endLoc": {
      "col": 1,
      "line": 87
    },
    "startBody": {
      "col": 39,
      "line": 33
    },
    "endBody": {
      "col": 1,
      "line": 87
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Right Element\"\n                    description={\n                        <Description>\n                            A DOM element may be added as a trailer to the grid by using the{\" \"}\n                            <PropName>rightElement</PropName> prop.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const RightElement: React.VFC = () => {\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(8, false);\n\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\n\n    const [numRows, setNumRows] = React.useState(300);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        setNumRows(cv => cv + 1);\n        for (let c = 0; c < 6; c++) {\n            setCellValue([c, newRow], {\n                displayData: \"\",\n                data: \"\",\n            } as any);\n        }\n    }, [numRows, setCellValue]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={columns}\n            rowMarkers={\"both\"}\n            onCellEdited={setCellValue}\n            trailingRowOptions={{\n                hint: \"New row...\",\n                sticky: true,\n                tint: true,\n            }}\n            rows={numRows}\n            onRowAppended={onRowAppended}\n            rightElementProps={{ sticky: true }}\n            rightElement={\n                <div\n                    style={{\n                        height: \"100%\",\n                        padding: \"20px 20px 40px 20px\",\n                        width: 200,\n                        color: \"black\",\n                        whiteSpace: \"pre-wrap\",\n                        backgroundColor: \"rgba(240, 240, 250, 0.2)\",\n                        display: \"flex\",\n                        justifyContent: \"center\",\n                        alignItems: \"center\",\n                        boxShadow: \"0 0 10px rgba(0, 0, 0, 0.15)\",\n                        backdropFilter: \"blur(12px)\",\n                    }}>\n                    This is a real DOM element. You can put whatever you want here. You can also size it as big as you\n                    want. {\"\\n\\n\"}It also does not have to be sticky.\n                </div>\n            }\n        />\n    );\n};\n",
      "locationsMap": {
        "right-element": {
          "startLoc": {
            "col": 39,
            "line": 33
          },
          "endLoc": {
            "col": 1,
            "line": 87
          },
          "startBody": {
            "col": 39,
            "line": 33
          },
          "endBody": {
            "col": 1,
            "line": 87
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Right Element",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "A DOM element may be added as a trailer to the grid by using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "rightElement"), " prop.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const RightElement = () => {
  const {
    cols,
    getCellContent,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(8, false);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => cols.map(c => ({ ...c,
    grow: 1
  })), [cols]);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(300);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;
    setNumRows(cv => cv + 1);

    for (let c = 0; c < 6; c++) {
      setCellValue([c, newRow], {
        displayData: "",
        data: ""
      });
    }
  }, [numRows, setCellValue]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: columns,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      hint: "New row...",
      sticky: true,
      tint: true
    },
    rows: numRows,
    onRowAppended: onRowAppended,
    rightElementProps: {
      sticky: true
    },
    rightElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      style: {
        height: "100%",
        padding: "20px 20px 40px 20px",
        width: 200,
        color: "black",
        whiteSpace: "pre-wrap",
        backgroundColor: "rgba(240, 240, 250, 0.2)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        boxShadow: "0 0 10px rgba(0, 0, 0, 0.15)",
        backdropFilter: "blur(12px)"
      }
    }, "This is a real DOM element. You can put whatever you want here. You can also size it as big as you want. ", "\n\n", "It also does not have to be sticky.")
  }));
};
const __namedExportsOrder = ["RightElement"];

/***/ }),

/***/ "./packages/core/src/docs/examples/right-to-left.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RightToLeft": () => (/* binding */ RightToLeft),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Right \"\n                    description={\n                        <>\n                            <Description>\n                                The data editor automatically detects RTL in text cells and respects it.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const RightToLeft: React.VFC = () => {\n    const { cols, getCellContent, setCellValue, onColumnResize } = useMockDataGenerator(60, false);\n\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\n        item => {\n            const [col, _row] = item;\n            if (col !== 0) return getCellContent(item);\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: \"אני גדעון, מומחה לאפליקציות גלייד.\",\n                displayData: \"אני גדעון, מומחה לאפליקציות גלייד.\",\n                allowWrapping: true,\n            };\n        },\n        [getCellContent]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContentMangled}\n            columns={cols}\n            onColumnResize={onColumnResize}\n            getCellsForSelection={true}\n            rowMarkers={\"both\"}\n            onPaste={true}\n            onCellEdited={setCellValue}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "RightToLeft": {
    "startLoc": {
      "col": 38,
      "line": 29
    },
    "endLoc": {
      "col": 1,
      "line": 60
    },
    "startBody": {
      "col": 38,
      "line": 29
    },
    "endBody": {
      "col": 1,
      "line": 60
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Right \"\n                    description={\n                        <>\n                            <Description>\n                                The data editor automatically detects RTL in text cells and respects it.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const RightToLeft: React.VFC = () => {\n    const { cols, getCellContent, setCellValue, onColumnResize } = useMockDataGenerator(60, false);\n\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\n        item => {\n            const [col, _row] = item;\n            if (col !== 0) return getCellContent(item);\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: \"אני גדעון, מומחה לאפליקציות גלייד.\",\n                displayData: \"אני גדעון, מומחה לאפליקציות גלייד.\",\n                allowWrapping: true,\n            };\n        },\n        [getCellContent]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContentMangled}\n            columns={cols}\n            onColumnResize={onColumnResize}\n            getCellsForSelection={true}\n            rowMarkers={\"both\"}\n            onPaste={true}\n            onCellEdited={setCellValue}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "right-to-left": {
          "startLoc": {
            "col": 38,
            "line": 29
          },
          "endLoc": {
            "col": 1,
            "line": 60
          },
          "startBody": {
            "col": 38,
            "line": 29
          },
          "endBody": {
            "col": 1,
            "line": 60
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Right ",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "The data editor automatically detects RTL in text cells and respects it."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const RightToLeft = () => {
  const {
    cols,
    getCellContent,
    setCellValue,
    onColumnResize
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60, false);
  const getCellContentMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(item => {
    const [col, _row] = item;
    if (col !== 0) return getCellContent(item);
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      data: "אני גדעון, מומחה לאפליקציות גלייד.",
      displayData: "אני גדעון, מומחה לאפליקציות גלייד.",
      allowWrapping: true
    };
  }, [getCellContent]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContentMangled,
    columns: cols,
    onColumnResize: onColumnResize,
    getCellsForSelection: true,
    rowMarkers: "both",
    onPaste: true,
    onCellEdited: setCellValue,
    rows: 1000
  }));
};
const __namedExportsOrder = ["RightToLeft"];

/***/ }),

/***/ "./packages/core/src/docs/examples/row-and-header-sizes.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RowAndHeaderSizes": () => (/* binding */ RowAndHeaderSizes),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Row and Header sizes\"\n                    description={\n                        <>\n                            <Description>\n                                The row size can be controlled with <PropName>rowHeight</PropName> and the header size\n                                with <PropName>headerHeight</PropName>.\n                            </Description>\n                            <MoreInfo>Use the story&apos;s controls to resize them</MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface RowAndHeaderSizesProps {\n    rowHeight: number;\n    headerHeight: number;\n}\nexport const RowAndHeaderSizes: React.VFC<RowAndHeaderSizesProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowHeight={p.rowHeight}\n            headerHeight={p.headerHeight}\n            rowMarkers={\"number\"}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={1000}\n        />\n    );\n};\n(RowAndHeaderSizes as any).args = {\n    rowHeight: 34,\n    headerHeight: 34,\n};\n(RowAndHeaderSizes as any).argTypes = {\n    rowHeight: {\n        control: {\n            type: \"range\",\n            min: 20,\n            max: 200,\n        },\n    },\n    headerHeight: {\n        control: {\n            type: \"range\",\n            min: 20,\n            max: 200,\n        },\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "RowAndHeaderSizes": {
    "startLoc": {
      "col": 68,
      "line": 41
    },
    "endLoc": {
      "col": 1,
      "line": 55
    },
    "startBody": {
      "col": 68,
      "line": 41
    },
    "endBody": {
      "col": 1,
      "line": 55
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Row and Header sizes\"\n                    description={\n                        <>\n                            <Description>\n                                The row size can be controlled with <PropName>rowHeight</PropName> and the header size\n                                with <PropName>headerHeight</PropName>.\n                            </Description>\n                            <MoreInfo>Use the story&apos;s controls to resize them</MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface RowAndHeaderSizesProps {\n    rowHeight: number;\n    headerHeight: number;\n}\nexport const RowAndHeaderSizes: React.VFC<RowAndHeaderSizesProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowHeight={p.rowHeight}\n            headerHeight={p.headerHeight}\n            rowMarkers={\"number\"}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={1000}\n        />\n    );\n};\n(RowAndHeaderSizes as any).args = {\n    rowHeight: 34,\n    headerHeight: 34,\n};\n(RowAndHeaderSizes as any).argTypes = {\n    rowHeight: {\n        control: {\n            type: \"range\",\n            min: 20,\n            max: 200,\n        },\n    },\n    headerHeight: {\n        control: {\n            type: \"range\",\n            min: 20,\n            max: 200,\n        },\n    },\n};\n",
      "locationsMap": {
        "row-and-header-sizes": {
          "startLoc": {
            "col": 68,
            "line": 41
          },
          "endLoc": {
            "col": 1,
            "line": 55
          },
          "startBody": {
            "col": 68,
            "line": 41
          },
          "endBody": {
            "col": 1,
            "line": 55
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Row and Header sizes",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "The row size can be controlled with ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "rowHeight"), " and the header size with ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "headerHeight"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Use the story's controls to resize them"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const RowAndHeaderSizes = p => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowHeight: p.rowHeight,
    headerHeight: p.headerHeight,
    rowMarkers: "number",
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  }));
};
RowAndHeaderSizes.args = {
  rowHeight: 34,
  headerHeight: 34
};
RowAndHeaderSizes.argTypes = {
  rowHeight: {
    control: {
      type: "range",
      min: 20,
      max: 200
    }
  },
  headerHeight: {
    control: {
      type: "range",
      min: 20,
      max: 200
    }
  }
};
const __namedExportsOrder = ["RowAndHeaderSizes"];

/***/ }),

/***/ "./packages/core/src/docs/examples/row-hover.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RowHover": () => (/* binding */ RowHover),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { GetRowThemeCallback } from \"../../data-grid/data-grid-render\";\nimport type { GridMouseEventArgs } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Row Hover Effect\"\n                    description={\n                        <Description>\n                            Through careful usage of the <PropName>onItemHovered</PropName> callback it is possible to\n                            easily create a row hover effect.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const RowHover: React.VFC = () => {\n    const { cols, getCellContent } = useAllMockedKinds();\n\n    const [hoverRow, setHoverRow] = React.useState<number | undefined>(undefined);\n\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\n        const [_, row] = args.location;\n        setHoverRow(args.kind !== \"cell\" ? undefined : row);\n    }, []);\n\n    const getRowThemeOverride = React.useCallback<GetRowThemeCallback>(\n        row => {\n            if (row !== hoverRow) return undefined;\n            return {\n                bgCell: \"#f7f7f7\",\n                bgCellMedium: \"#f0f0f0\",\n            };\n        },\n        [hoverRow]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"both\"\n            onItemHovered={onItemHovered}\n            getCellContent={getCellContent}\n            getRowThemeOverride={getRowThemeOverride}\n            columns={cols}\n            rows={300}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "RowHover": {
    "startLoc": {
      "col": 35,
      "line": 35
    },
    "endLoc": {
      "col": 1,
      "line": 67
    },
    "startBody": {
      "col": 35,
      "line": 35
    },
    "endBody": {
      "col": 1,
      "line": 67
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport type { GetRowThemeCallback } from \"../../data-grid/data-grid-render\";\nimport type { GridMouseEventArgs } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Row Hover Effect\"\n                    description={\n                        <Description>\n                            Through careful usage of the <PropName>onItemHovered</PropName> callback it is possible to\n                            easily create a row hover effect.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const RowHover: React.VFC = () => {\n    const { cols, getCellContent } = useAllMockedKinds();\n\n    const [hoverRow, setHoverRow] = React.useState<number | undefined>(undefined);\n\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\n        const [_, row] = args.location;\n        setHoverRow(args.kind !== \"cell\" ? undefined : row);\n    }, []);\n\n    const getRowThemeOverride = React.useCallback<GetRowThemeCallback>(\n        row => {\n            if (row !== hoverRow) return undefined;\n            return {\n                bgCell: \"#f7f7f7\",\n                bgCellMedium: \"#f0f0f0\",\n            };\n        },\n        [hoverRow]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"both\"\n            onItemHovered={onItemHovered}\n            getCellContent={getCellContent}\n            getRowThemeOverride={getRowThemeOverride}\n            columns={cols}\n            rows={300}\n        />\n    );\n};\n",
      "locationsMap": {
        "row-hover": {
          "startLoc": {
            "col": 35,
            "line": 35
          },
          "endLoc": {
            "col": 1,
            "line": 67
          },
          "startBody": {
            "col": 35,
            "line": 35
          },
          "endBody": {
            "col": 1,
            "line": 67
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Row Hover Effect",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Through careful usage of the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onItemHovered"), " callback it is possible to easily create a row hover effect.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const RowHover = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const [hoverRow, setHoverRow] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);
  const onItemHovered = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const [_, row] = args.location;
    setHoverRow(args.kind !== "cell" ? undefined : row);
  }, []);
  const getRowThemeOverride = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(row => {
    if (row !== hoverRow) return undefined;
    return {
      bgCell: "#f7f7f7",
      bgCellMedium: "#f0f0f0"
    };
  }, [hoverRow]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowMarkers: "both",
    onItemHovered: onItemHovered,
    getCellContent: getCellContent,
    getRowThemeOverride: getRowThemeOverride,
    columns: cols,
    rows: 300
  }));
};
const __namedExportsOrder = ["RowHover"];

/***/ }),

/***/ "./packages/core/src/docs/examples/scaled-view.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScaledView": () => (/* binding */ ScaledView),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Scaled view\"\n                    description={<Description>The data editor supports being scaled.</Description>}\n                    scale=\"0.5\">\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ScaledView: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(60);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers=\"both\"\n            rows={500}\n            onColumnResize={onColumnResize}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ScaledView": {
    "startLoc": {
      "col": 37,
      "line": 23
    },
    "endLoc": {
      "col": 1,
      "line": 36
    },
    "startBody": {
      "col": 37,
      "line": 23
    },
    "endBody": {
      "col": 1,
      "line": 36
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Scaled view\"\n                    description={<Description>The data editor supports being scaled.</Description>}\n                    scale=\"0.5\">\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ScaledView: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(60);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers=\"both\"\n            rows={500}\n            onColumnResize={onColumnResize}\n        />\n    );\n};\n",
      "locationsMap": {
        "scaled-view": {
          "startLoc": {
            "col": 37,
            "line": 23
          },
          "endLoc": {
            "col": 1,
            "line": 36
          },
          "startBody": {
            "col": 37,
            "line": 23
          },
          "endBody": {
            "col": 1,
            "line": 36
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Scaled view",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "The data editor supports being scaled."),
    scale: "0.5"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const ScaledView = () => {
  const {
    cols,
    getCellContent,
    onColumnResize
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    rows: 500,
    onColumnResize: onColumnResize
  }));
};
const __namedExportsOrder = ["ScaledView"];

/***/ }),

/***/ "./packages/core/src/docs/examples/scroll-shadows.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollShadows": () => (/* binding */ ScrollShadows),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport type { Theme } from \"../../common/styles\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport type { GridSelection } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Scroll Shadows\"\n                    description={\n                        <>\n                            <Description>\n                                You can enable and disable the horizontal/vertical scroll shadows.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ScrollShadows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        rows: CompactSelection.empty(),\n        columns: CompactSelection.empty(),\n    });\n\n    const onSelectionChange = React.useCallback((newSel: GridSelection) => {\n        let newRows = CompactSelection.empty();\n        if (newSel.current !== undefined) {\n            newRows = newRows.add([newSel.current.range.y, newSel.current.range.y + newSel.current.range.height]);\n        }\n        for (const b of newSel.current?.rangeStack ?? []) {\n            newRows = newRows.add([b.y, b.y + b.height]);\n        }\n        setSelection({\n            ...newSel,\n            rows: newRows,\n        });\n    }, []);\n\n    const theme = React.useMemo<Partial<Theme>>(\n        () => ({\n            accentLight: \"#b1f6ff\",\n            horizontalBorderColor: \"transparent\",\n            headerBottomBorderColor: \"rgba(115, 116, 131, 0.16)\",\n        }),\n        []\n    );\n\n    const getRowThemeOverride = React.useCallback(row => (row % 2 === 0 ? undefined : { bgCell: \"#f5f5f6\" }), []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers={\"number\"}\n            gridSelection={selection}\n            onGridSelectionChange={onSelectionChange}\n            fixedShadowX={false}\n            headerHeight={26}\n            drawFocusRing={false}\n            rowHeight={22}\n            fixedShadowY={false}\n            getRowThemeOverride={getRowThemeOverride}\n            verticalBorder={false}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={1000}\n            theme={theme}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ScrollShadows": {
    "startLoc": {
      "col": 40,
      "line": 31
    },
    "endLoc": {
      "col": 1,
      "line": 83
    },
    "startBody": {
      "col": 40,
      "line": 31
    },
    "endBody": {
      "col": 1,
      "line": 83
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport type { Theme } from \"../../common/styles\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport type { GridSelection } from \"../../data-grid/data-grid-types\";\nimport { CompactSelection } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Scroll Shadows\"\n                    description={\n                        <>\n                            <Description>\n                                You can enable and disable the horizontal/vertical scroll shadows.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ScrollShadows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        rows: CompactSelection.empty(),\n        columns: CompactSelection.empty(),\n    });\n\n    const onSelectionChange = React.useCallback((newSel: GridSelection) => {\n        let newRows = CompactSelection.empty();\n        if (newSel.current !== undefined) {\n            newRows = newRows.add([newSel.current.range.y, newSel.current.range.y + newSel.current.range.height]);\n        }\n        for (const b of newSel.current?.rangeStack ?? []) {\n            newRows = newRows.add([b.y, b.y + b.height]);\n        }\n        setSelection({\n            ...newSel,\n            rows: newRows,\n        });\n    }, []);\n\n    const theme = React.useMemo<Partial<Theme>>(\n        () => ({\n            accentLight: \"#b1f6ff\",\n            horizontalBorderColor: \"transparent\",\n            headerBottomBorderColor: \"rgba(115, 116, 131, 0.16)\",\n        }),\n        []\n    );\n\n    const getRowThemeOverride = React.useCallback(row => (row % 2 === 0 ? undefined : { bgCell: \"#f5f5f6\" }), []);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers={\"number\"}\n            gridSelection={selection}\n            onGridSelectionChange={onSelectionChange}\n            fixedShadowX={false}\n            headerHeight={26}\n            drawFocusRing={false}\n            rowHeight={22}\n            fixedShadowY={false}\n            getRowThemeOverride={getRowThemeOverride}\n            verticalBorder={false}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={1000}\n            theme={theme}\n        />\n    );\n};\n",
      "locationsMap": {
        "scroll-shadows": {
          "startLoc": {
            "col": 40,
            "line": 31
          },
          "endLoc": {
            "col": 1,
            "line": 83
          },
          "startBody": {
            "col": 40,
            "line": 31
          },
          "endBody": {
            "col": 1,
            "line": 83
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Scroll Shadows",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can enable and disable the horizontal/vertical scroll shadows."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const ScrollShadows = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6);
  const [selection, setSelection] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty(),
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty()
  });
  const onSelectionChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newSel => {
    let newRows = _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .CompactSelection.empty */ .EV.empty();

    if (newSel.current !== undefined) {
      newRows = newRows.add([newSel.current.range.y, newSel.current.range.y + newSel.current.range.height]);
    }

    for (const b of (_newSel$current$range = (_newSel$current = newSel.current) === null || _newSel$current === void 0 ? void 0 : _newSel$current.rangeStack) !== null && _newSel$current$range !== void 0 ? _newSel$current$range : []) {
      var _newSel$current$range, _newSel$current;

      newRows = newRows.add([b.y, b.y + b.height]);
    }

    setSelection({ ...newSel,
      rows: newRows
    });
  }, []);
  const theme = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    accentLight: "#b1f6ff",
    horizontalBorderColor: "transparent",
    headerBottomBorderColor: "rgba(115, 116, 131, 0.16)"
  }), []);
  const getRowThemeOverride = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(row => row % 2 === 0 ? undefined : {
    bgCell: "#f5f5f6"
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowMarkers: "number",
    gridSelection: selection,
    onGridSelectionChange: onSelectionChange,
    fixedShadowX: false,
    headerHeight: 26,
    drawFocusRing: false,
    rowHeight: 22,
    fixedShadowY: false,
    getRowThemeOverride: getRowThemeOverride,
    verticalBorder: false,
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000,
    theme: theme
  }));
};
const __namedExportsOrder = ["ScrollShadows"];

/***/ }),

/***/ "./packages/core/src/docs/examples/silly-numbers.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SillyNumbers": () => (/* binding */ SillyNumbers),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"100 Million Rows\"\n                    description={\n                        <Description>\n                            100 million rows is silly. Once we cross about 33 million pixels in height we can no longer\n                            trust the browser to scroll accurately.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const SillyNumbers: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowHeight={31}\n            rows={100_000_000}\n            rowMarkers=\"number\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "SillyNumbers": {
    "startLoc": {
      "col": 39,
      "line": 27
    },
    "endLoc": {
      "col": 1,
      "line": 40
    },
    "startBody": {
      "col": 39,
      "line": 27
    },
    "endBody": {
      "col": 1,
      "line": 40
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"100 Million Rows\"\n                    description={\n                        <Description>\n                            100 million rows is silly. Once we cross about 33 million pixels in height we can no longer\n                            trust the browser to scroll accurately.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const SillyNumbers: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowHeight={31}\n            rows={100_000_000}\n            rowMarkers=\"number\"\n        />\n    );\n};\n",
      "locationsMap": {
        "silly-numbers": {
          "startLoc": {
            "col": 39,
            "line": 27
          },
          "endLoc": {
            "col": 1,
            "line": 40
          },
          "startBody": {
            "col": 39,
            "line": 27
          },
          "endBody": {
            "col": 1,
            "line": 40
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "100 Million Rows",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "100 million rows is silly. Once we cross about 33 million pixels in height we can no longer trust the browser to scroll accurately.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const SillyNumbers = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowHeight: 31,
    rows: 100000000,
    rowMarkers: "number"
  }));
};
const __namedExportsOrder = ["SillyNumbers"];

/***/ }),

/***/ "./packages/core/src/docs/examples/small-editable-grid.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SmallEditableGrid": () => (/* binding */ SmallEditableGrid),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Editable Grid\"\n                    description={\n                        <Description>\n                            Data grid supports overlay editors for changing values. There are bespoke editors for\n                            numbers, strings, images, booleans, markdown, and uri.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const SmallEditableGrid = () => {\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(6, false);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            rowMarkers=\"both\"\n            columns={cols}\n            rows={20}\n            onCellEdited={setCellValue}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "SmallEditableGrid": {
    "startLoc": {
      "col": 33,
      "line": 27
    },
    "endLoc": {
      "col": 1,
      "line": 40
    },
    "startBody": {
      "col": 33,
      "line": 27
    },
    "endBody": {
      "col": 1,
      "line": 40
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Editable Grid\"\n                    description={\n                        <Description>\n                            Data grid supports overlay editors for changing values. There are bespoke editors for\n                            numbers, strings, images, booleans, markdown, and uri.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const SmallEditableGrid = () => {\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(6, false);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            rowMarkers=\"both\"\n            columns={cols}\n            rows={20}\n            onCellEdited={setCellValue}\n        />\n    );\n};\n",
      "locationsMap": {
        "small-editable-grid": {
          "startLoc": {
            "col": 33,
            "line": 27
          },
          "endLoc": {
            "col": 1,
            "line": 40
          },
          "startBody": {
            "col": 33,
            "line": 27
          },
          "endBody": {
            "col": 1,
            "line": 40
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Editable Grid",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Data grid supports overlay editors for changing values. There are bespoke editors for numbers, strings, images, booleans, markdown, and uri.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const SmallEditableGrid = () => {
  const {
    cols,
    getCellContent,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6, false);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    rowMarkers: "both",
    columns: cols,
    rows: 20,
    onCellEdited: setCellValue
  }));
};
const __namedExportsOrder = ["SmallEditableGrid"];

/***/ }),

/***/ "./packages/core/src/docs/examples/smooth-scrolling-grid.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SmoothScrollingGrid": () => (/* binding */ SmoothScrollingGrid),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Smooth scrolling\"\n                    description={\n                        <Description>\n                            You can enable smooth scrolling with the <PropName>smoothScrollX</PropName> and{\" \"}\n                            <PropName>smoothScrollY</PropName> props. Disabling smooth scrolling can dramatically\n                            increase performance and improve visual stability during rapid scrolling.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface SmoothScrollingGridProps {\n    smoothScrollX: boolean;\n    smoothScrollY: boolean;\n}\n\nexport const SmoothScrollingGrid: React.FC<SmoothScrollingGridProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(30);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            smoothScrollX={p.smoothScrollX}\n            smoothScrollY={p.smoothScrollY}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={10_000}\n        />\n    );\n};\n(SmoothScrollingGrid as any).args = {\n    smoothScrollX: false,\n    smoothScrollY: false,\n};\n";
var __LOCATIONS_MAP__ = {
  "SmoothScrollingGrid": {
    "startLoc": {
      "col": 71,
      "line": 39
    },
    "endLoc": {
      "col": 1,
      "line": 52
    },
    "startBody": {
      "col": 71,
      "line": 39
    },
    "endBody": {
      "col": 1,
      "line": 52
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Smooth scrolling\"\n                    description={\n                        <Description>\n                            You can enable smooth scrolling with the <PropName>smoothScrollX</PropName> and{\" \"}\n                            <PropName>smoothScrollY</PropName> props. Disabling smooth scrolling can dramatically\n                            increase performance and improve visual stability during rapid scrolling.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface SmoothScrollingGridProps {\n    smoothScrollX: boolean;\n    smoothScrollY: boolean;\n}\n\nexport const SmoothScrollingGrid: React.FC<SmoothScrollingGridProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(30);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            smoothScrollX={p.smoothScrollX}\n            smoothScrollY={p.smoothScrollY}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={10_000}\n        />\n    );\n};\n(SmoothScrollingGrid as any).args = {\n    smoothScrollX: false,\n    smoothScrollY: false,\n};\n",
      "locationsMap": {
        "smooth-scrolling-grid": {
          "startLoc": {
            "col": 71,
            "line": 39
          },
          "endLoc": {
            "col": 1,
            "line": 52
          },
          "startBody": {
            "col": 71,
            "line": 39
          },
          "endBody": {
            "col": 1,
            "line": 52
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Smooth scrolling",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can enable smooth scrolling with the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "smoothScrollX"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "smoothScrollY"), " props. Disabling smooth scrolling can dramatically increase performance and improve visual stability during rapid scrolling.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const SmoothScrollingGrid = p => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(30);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    getCellContent: getCellContent,
    columns: cols,
    rows: 10000
  }));
};
SmoothScrollingGrid.args = {
  smoothScrollX: false,
  smoothScrollY: false
};
const __namedExportsOrder = ["SmoothScrollingGrid"];

/***/ }),

/***/ "./packages/core/src/docs/examples/span-cell.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpanCell": () => (/* binding */ SpanCell),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "\nimport React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport type { Rectangle, CellArray, GridCell } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Spans\"\n                    description={\n                        <Description>\n                            By setting the <PropName>span</PropName> of a cell you can create spans in your grid. All\n                            cells within a span must return consistent data for defined behavior.\n                            <MoreInfo>\n                                Spans will always be split if they span frozen and non-frozen columns. By default\n                                selections are always expanded to include a span. This can be disabled using the{\" \"}\n                                <PropName>spanRangeBehavior</PropName> prop.\n                            </MoreInfo>\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const SpanCell: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            const [col, row] = cell;\n            if (row === 6 && col >= 3 && col <= 4) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: false,\n                    data: \"Span Cell that is very long and will go past the cell limits\",\n                    span: [3, 4],\n                    displayData: \"Span Cell that is very long and will go past the cell limits\",\n                };\n            }\n            if (row === 5) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: false,\n                    data: \"Span Cell that is very long and will go past the cell limits\",\n                    span: [0, 99],\n                    displayData: \"Span Cell that is very long and will go past the cell limits\",\n                };\n            }\n            return getCellContent(cell);\n        },\n        [getCellContent]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (selection: Rectangle): CellArray => {\n            const result: GridCell[][] = [];\n\n            for (let y = selection.y; y < selection.y + selection.height; y++) {\n                const row: GridCell[] = [];\n                for (let x = selection.x; x < selection.x + selection.width; x++) {\n                    row.push(mangledGetCellContent([x, y]));\n                }\n                result.push(row);\n            }\n\n            return result;\n        },\n        [mangledGetCellContent]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={mangledGetCellContent}\n            getCellsForSelection={getCellsForSelection}\n            columns={cols}\n            freezeColumns={2}\n            rows={300}\n            rowMarkers=\"both\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "SpanCell": {
    "startLoc": {
      "col": 35,
      "line": 42
    },
    "endLoc": {
      "col": 1,
      "line": 99
    },
    "startBody": {
      "col": 35,
      "line": 42
    },
    "endBody": {
      "col": 1,
      "line": 99
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "\nimport React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport type { Rectangle, CellArray, GridCell } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Spans\"\n                    description={\n                        <Description>\n                            By setting the <PropName>span</PropName> of a cell you can create spans in your grid. All\n                            cells within a span must return consistent data for defined behavior.\n                            <MoreInfo>\n                                Spans will always be split if they span frozen and non-frozen columns. By default\n                                selections are always expanded to include a span. This can be disabled using the{\" \"}\n                                <PropName>spanRangeBehavior</PropName> prop.\n                            </MoreInfo>\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const SpanCell: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            const [col, row] = cell;\n            if (row === 6 && col >= 3 && col <= 4) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: false,\n                    data: \"Span Cell that is very long and will go past the cell limits\",\n                    span: [3, 4],\n                    displayData: \"Span Cell that is very long and will go past the cell limits\",\n                };\n            }\n            if (row === 5) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: false,\n                    data: \"Span Cell that is very long and will go past the cell limits\",\n                    span: [0, 99],\n                    displayData: \"Span Cell that is very long and will go past the cell limits\",\n                };\n            }\n            return getCellContent(cell);\n        },\n        [getCellContent]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (selection: Rectangle): CellArray => {\n            const result: GridCell[][] = [];\n\n            for (let y = selection.y; y < selection.y + selection.height; y++) {\n                const row: GridCell[] = [];\n                for (let x = selection.x; x < selection.x + selection.width; x++) {\n                    row.push(mangledGetCellContent([x, y]));\n                }\n                result.push(row);\n            }\n\n            return result;\n        },\n        [mangledGetCellContent]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={mangledGetCellContent}\n            getCellsForSelection={getCellsForSelection}\n            columns={cols}\n            freezeColumns={2}\n            rows={300}\n            rowMarkers=\"both\"\n        />\n    );\n};\n",
      "locationsMap": {
        "span-cell": {
          "startLoc": {
            "col": 35,
            "line": 42
          },
          "endLoc": {
            "col": 1,
            "line": 99
          },
          "startBody": {
            "col": 35,
            "line": 42
          },
          "endBody": {
            "col": 1,
            "line": 99
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Spans",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "By setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "span"), " of a cell you can create spans in your grid. All cells within a span must return consistent data for defined behavior.", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "Spans will always be split if they span frozen and non-frozen columns. By default selections are always expanded to include a span. This can be disabled using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "spanRangeBehavior"), " prop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const SpanCell = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100, true, true);
  const mangledGetCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;

    if (row === 6 && col >= 3 && col <= 4) {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
        allowOverlay: false,
        data: "Span Cell that is very long and will go past the cell limits",
        span: [3, 4],
        displayData: "Span Cell that is very long and will go past the cell limits"
      };
    }

    if (row === 5) {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
        allowOverlay: false,
        data: "Span Cell that is very long and will go past the cell limits",
        span: [0, 99],
        displayData: "Span Cell that is very long and will go past the cell limits"
      };
    }

    return getCellContent(cell);
  }, [getCellContent]);
  const getCellsForSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(selection => {
    const result = [];

    for (let y = selection.y; y < selection.y + selection.height; y++) {
      const row = [];

      for (let x = selection.x; x < selection.x + selection.width; x++) {
        row.push(mangledGetCellContent([x, y]));
      }

      result.push(row);
    }

    return result;
  }, [mangledGetCellContent]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: mangledGetCellContent,
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    freezeColumns: 2,
    rows: 300,
    rowMarkers: "both"
  }));
};
const __namedExportsOrder = ["SpanCell"];

/***/ }),

/***/ "./packages/core/src/docs/examples/stretch-column-size.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StretchColumnSize": () => (/* binding */ StretchColumnSize),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Column Grow\"\n                    description={\n                        <Description>\n                            Columns in the data grid may be set to grow to fill space by setting the{\" \"}\n                            <PropName>grow</PropName> prop.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const StretchColumnSize: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(5, true, true);\n\n    const hasResized = React.useRef(new Set<number>());\n\n    const columns = React.useMemo(() => {\n        return cols.map((x, i) => ({ ...x, grow: hasResized.current.has(i) ? undefined : (5 + i) / 5 }));\n    }, [cols]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={columns}\n            rows={1000}\n            onColumnResize={(col, _newSize, colIndex, newSizeWithGrow) => {\n                hasResized.current.add(colIndex);\n                onColumnResize(col, newSizeWithGrow);\n            }}\n            rowMarkers=\"both\"\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "StretchColumnSize": {
    "startLoc": {
      "col": 44,
      "line": 33
    },
    "endLoc": {
      "col": 1,
      "line": 55
    },
    "startBody": {
      "col": 44,
      "line": 33
    },
    "endBody": {
      "col": 1,
      "line": 55
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Column Grow\"\n                    description={\n                        <Description>\n                            Columns in the data grid may be set to grow to fill space by setting the{\" \"}\n                            <PropName>grow</PropName> prop.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const StretchColumnSize: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(5, true, true);\n\n    const hasResized = React.useRef(new Set<number>());\n\n    const columns = React.useMemo(() => {\n        return cols.map((x, i) => ({ ...x, grow: hasResized.current.has(i) ? undefined : (5 + i) / 5 }));\n    }, [cols]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={columns}\n            rows={1000}\n            onColumnResize={(col, _newSize, colIndex, newSizeWithGrow) => {\n                hasResized.current.add(colIndex);\n                onColumnResize(col, newSizeWithGrow);\n            }}\n            rowMarkers=\"both\"\n        />\n    );\n};\n",
      "locationsMap": {
        "stretch-column-size": {
          "startLoc": {
            "col": 44,
            "line": 33
          },
          "endLoc": {
            "col": 1,
            "line": 55
          },
          "startBody": {
            "col": 44,
            "line": 33
          },
          "endBody": {
            "col": 1,
            "line": 55
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Column Grow",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Columns in the data grid may be set to grow to fill space by setting the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "grow"), " prop.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const StretchColumnSize = () => {
  const {
    cols,
    getCellContent,
    onColumnResize
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(5, true, true);
  const hasResized = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Set());
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return cols.map((x, i) => ({ ...x,
      grow: hasResized.current.has(i) ? undefined : (5 + i) / 5
    }));
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: columns,
    rows: 1000,
    onColumnResize: (col, _newSize, colIndex, newSizeWithGrow) => {
      hasResized.current.add(colIndex);
      onColumnResize(col, newSizeWithGrow);
    },
    rowMarkers: "both"
  }));
};
const __namedExportsOrder = ["StretchColumnSize"];

/***/ }),

/***/ "./packages/core/src/docs/examples/ten-million-cells.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TenMillionCells": () => (/* binding */ TenMillionCells),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Ten Million Cells\"\n                    description={<Description>Data grid supports over 10 million cells. Go nuts with it.</Description>}>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const TenMillionCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"number\"\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={100_000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "TenMillionCells": {
    "startLoc": {
      "col": 42,
      "line": 22
    },
    "endLoc": {
      "col": 1,
      "line": 34
    },
    "startBody": {
      "col": 42,
      "line": 22
    },
    "endBody": {
      "col": 1,
      "line": 34
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, useMockDataGenerator, defaultProps } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Ten Million Cells\"\n                    description={<Description>Data grid supports over 10 million cells. Go nuts with it.</Description>}>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const TenMillionCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowMarkers=\"number\"\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={100_000}\n        />\n    );\n};\n",
      "locationsMap": {
        "ten-million-cells": {
          "startLoc": {
            "col": 42,
            "line": 22
          },
          "endLoc": {
            "col": 1,
            "line": 34
          },
          "startBody": {
            "col": 42,
            "line": 22
          },
          "endBody": {
            "col": 1,
            "line": 34
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Ten Million Cells",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Data grid supports over 10 million cells. Go nuts with it.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const TenMillionCells = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(100);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowMarkers: "number",
    getCellContent: getCellContent,
    columns: cols,
    rows: 100000
  }));
};
const __namedExportsOrder = ["TenMillionCells"];

/***/ }),

/***/ "./packages/core/src/docs/examples/theme-per-column.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThemePerColumn": () => (/* binding */ ThemePerColumn),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, defaultProps, useAllMockedKinds } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Theme per column\"\n                    description={\n                        <>\n                            <Description>\n                                Each column can provide theme overrides for rendering that column.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ThemePerColumn: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        const c = [...cols];\n        c[3] = {\n            ...c[3],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n                baseFontStyle: \"600 13px\",\n            },\n        };\n        c[4] = {\n            ...c[4],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n                baseFontStyle: \"600 13px\",\n            },\n        };\n        c[9] = {\n            ...c[9],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n            },\n        };\n        c[10] = {\n            ...c[10],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n            },\n        };\n        return c;\n    }, [cols]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={realCols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ThemePerColumn": {
    "startLoc": {
      "col": 41,
      "line": 28
    },
    "endLoc": {
      "col": 1,
      "line": 88
    },
    "startBody": {
      "col": 41,
      "line": 28
    },
    "endBody": {
      "col": 1,
      "line": 88
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport { BeautifulWrapper, Description, defaultProps, useAllMockedKinds } from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Theme per column\"\n                    description={\n                        <>\n                            <Description>\n                                Each column can provide theme overrides for rendering that column.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ThemePerColumn: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        const c = [...cols];\n        c[3] = {\n            ...c[3],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n                baseFontStyle: \"600 13px\",\n            },\n        };\n        c[4] = {\n            ...c[4],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n                baseFontStyle: \"600 13px\",\n            },\n        };\n        c[9] = {\n            ...c[9],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n            },\n        };\n        c[10] = {\n            ...c[10],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n            },\n        };\n        return c;\n    }, [cols]);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={realCols}\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "theme-per-column": {
          "startLoc": {
            "col": 41,
            "line": 28
          },
          "endLoc": {
            "col": 1,
            "line": 88
          },
          "startBody": {
            "col": 41,
            "line": 28
          },
          "endBody": {
            "col": 1,
            "line": 88
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Theme per column",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Each column can provide theme overrides for rendering that column."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const ThemePerColumn = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const realCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const c = [...cols];
    c[3] = { ...c[3],
      themeOverride: {
        textDark: "#009CA6",
        bgIconHeader: "#009CA6",
        accentColor: "#009CA6",
        accentLight: "#009CA620",
        fgIconHeader: "#FFFFFF",
        baseFontStyle: "600 13px"
      }
    };
    c[4] = { ...c[4],
      themeOverride: {
        textDark: "#009CA6",
        bgIconHeader: "#009CA6",
        accentColor: "#009CA6",
        accentLight: "#009CA620",
        fgIconHeader: "#FFFFFF",
        baseFontStyle: "600 13px"
      }
    };
    c[9] = { ...c[9],
      themeOverride: {
        textDark: "#009CA6",
        bgIconHeader: "#009CA6",
        accentColor: "#009CA6",
        accentLight: "#009CA620",
        fgIconHeader: "#FFFFFF"
      }
    };
    c[10] = { ...c[10],
      themeOverride: {
        textDark: "#009CA6",
        bgIconHeader: "#009CA6",
        accentColor: "#009CA6",
        accentLight: "#009CA620",
        fgIconHeader: "#FFFFFF"
      }
    };
    return c;
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: realCols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 1000
  }));
};
const __namedExportsOrder = ["ThemePerColumn"];

/***/ }),

/***/ "./packages/core/src/docs/examples/theme-per-row.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThemePerRow": () => (/* binding */ ThemePerRow),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Theme per row\"\n                    description={\n                        <>\n                            <Description>\n                                Each row can provide theme overrides for rendering that row using the{\" \"}\n                                <PropName>getRowThemeOverride</PropName> callback.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ThemePerRow: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useMockDataGenerator(5);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            trailingRowOptions={{\n                sticky: true,\n                tint: true,\n            }}\n            onRowAppended={() => undefined}\n            getRowThemeOverride={i =>\n                i % 2 === 0\n                    ? undefined\n                    : {\n                          bgCell: \"#f0f8ff\",\n                          borderColor: \"#3f90e0\",\n                      }\n            }\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            rows={1_000_000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ThemePerRow": {
    "startLoc": {
      "col": 38,
      "line": 35
    },
    "endLoc": {
      "col": 1,
      "line": 61
    },
    "startBody": {
      "col": 38,
      "line": 35
    },
    "endBody": {
      "col": 1,
      "line": 61
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Theme per row\"\n                    description={\n                        <>\n                            <Description>\n                                Each row can provide theme overrides for rendering that row using the{\" \"}\n                                <PropName>getRowThemeOverride</PropName> callback.\n                            </Description>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ThemePerRow: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useMockDataGenerator(5);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            trailingRowOptions={{\n                sticky: true,\n                tint: true,\n            }}\n            onRowAppended={() => undefined}\n            getRowThemeOverride={i =>\n                i % 2 === 0\n                    ? undefined\n                    : {\n                          bgCell: \"#f0f8ff\",\n                          borderColor: \"#3f90e0\",\n                      }\n            }\n            onCellEdited={setCellValue}\n            onColumnResize={onColumnResize}\n            rows={1_000_000}\n        />\n    );\n};\n",
      "locationsMap": {
        "theme-per-row": {
          "startLoc": {
            "col": 38,
            "line": 35
          },
          "endLoc": {
            "col": 1,
            "line": 61
          },
          "startBody": {
            "col": 38,
            "line": 35
          },
          "endBody": {
            "col": 1,
            "line": 61
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Theme per row",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Each row can provide theme overrides for rendering that row using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "getRowThemeOverride"), " callback."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const ThemePerRow = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(5);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    trailingRowOptions: {
      sticky: true,
      tint: true
    },
    onRowAppended: () => undefined,
    getRowThemeOverride: i => i % 2 === 0 ? undefined : {
      bgCell: "#f0f8ff",
      borderColor: "#3f90e0"
    },
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 1000000
  }));
};
const __namedExportsOrder = ["ThemePerRow"];

/***/ }),

/***/ "./packages/core/src/docs/examples/theme-support.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThemeSupport": () => (/* binding */ ThemeSupport),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport type { Theme } from \"../../common/styles\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst darkTheme = {\n    accentColor: \"#8c96ff\",\n    accentLight: \"rgba(202, 206, 255, 0.253)\",\n\n    textDark: \"#ffffff\",\n    textMedium: \"#b8b8b8\",\n    textLight: \"#a0a0a0\",\n    textBubble: \"#ffffff\",\n\n    bgIconHeader: \"#b8b8b8\",\n    fgIconHeader: \"#000000\",\n    textHeader: \"#a1a1a1\",\n    textHeaderSelected: \"#000000\",\n\n    bgCell: \"#16161b\",\n    bgCellMedium: \"#202027\",\n    bgHeader: \"#212121\",\n    bgHeaderHasFocus: \"#474747\",\n    bgHeaderHovered: \"#404040\",\n\n    bgBubble: \"#212121\",\n    bgBubbleSelected: \"#000000\",\n\n    bgSearchResult: \"#423c24\",\n\n    borderColor: \"rgba(225,225,225,0.2)\",\n    drilldownBorder: \"rgba(225,225,225,0.4)\",\n\n    linkColor: \"#4F5DFF\",\n\n    headerFontStyle: \"bold 14px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst hotdogStand = {\n    accentColor: \"#8c96ff\",\n    accentLight: \"rgba(202, 206, 255, 0.253)\",\n\n    textDark: \"#ffffff\",\n    textMedium: \"rgba(255, 255, 255, 0.9)\",\n    textLight: \"rgba(255, 255, 255, 0.7)\",\n    textBubble: \"#000000\",\n\n    bgIconHeader: \"#880000\",\n    fgIconHeader: \"#ff5555\",\n    textHeader: \"rgba(0, 0, 0, 0.9)\",\n    textHeaderSelected: \"#000000\",\n\n    bgCell: \"#ff0000\",\n    bgCellMedium: \"#ff4d4d\",\n    bgHeader: \"#f3f300\",\n    bgHeaderHasFocus: \"#eeee00\",\n    bgHeaderHovered: \"#e0e000\",\n\n    bgBubble: \"#ffff00\",\n    bgBubbleSelected: \"#ffff00\",\n\n    bgSearchResult: \"#423c24\",\n\n    borderColor: \"#ffff00\",\n    drilldownBorder: \"#ffff00\",\n\n    linkColor: \"#4F5DFF\",\n\n    headerFontStyle: \"bold 14px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nexport const ThemeSupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [theme, setTheme] = React.useState<Partial<Theme>>({});\n\n    const [numRows, setNumRows] = React.useState(1000);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        setNumRows(cv => cv + 1);\n        for (let c = 0; c < 6; c++) {\n            setCellValue([c, newRow], {\n                displayData: \"\",\n                data: \"\",\n            } as any);\n        }\n    }, [numRows, setCellValue]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Theme support\"\n            description={\n                <>\n                    <Description>\n                        DataGrid respects the theme provided by the <PropName>theme</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        <button onClick={() => setTheme({})}>Light</button> or{\" \"}\n                        <button onClick={() => setTheme(darkTheme)}>Dark</button> even{\" \"}\n                        <button onClick={() => setTheme(hotdogStand)}>Hotdog Stand</button>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                theme={theme}\n                getCellContent={getCellContent}\n                columns={cols}\n                onRowAppended={onRowAppended}\n                trailingRowOptions={{\n                    tint: true,\n                    sticky: true,\n                }}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={numRows}\n            />\n        </BeautifulWrapper>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ThemeSupport": {
    "startLoc": {
      "col": 39,
      "line": 98
    },
    "endLoc": {
      "col": 1,
      "line": 147
    },
    "startBody": {
      "col": 39,
      "line": 98
    },
    "endBody": {
      "col": 1,
      "line": 147
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport type { Theme } from \"../../common/styles\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    defaultProps,\n    useAllMockedKinds,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst darkTheme = {\n    accentColor: \"#8c96ff\",\n    accentLight: \"rgba(202, 206, 255, 0.253)\",\n\n    textDark: \"#ffffff\",\n    textMedium: \"#b8b8b8\",\n    textLight: \"#a0a0a0\",\n    textBubble: \"#ffffff\",\n\n    bgIconHeader: \"#b8b8b8\",\n    fgIconHeader: \"#000000\",\n    textHeader: \"#a1a1a1\",\n    textHeaderSelected: \"#000000\",\n\n    bgCell: \"#16161b\",\n    bgCellMedium: \"#202027\",\n    bgHeader: \"#212121\",\n    bgHeaderHasFocus: \"#474747\",\n    bgHeaderHovered: \"#404040\",\n\n    bgBubble: \"#212121\",\n    bgBubbleSelected: \"#000000\",\n\n    bgSearchResult: \"#423c24\",\n\n    borderColor: \"rgba(225,225,225,0.2)\",\n    drilldownBorder: \"rgba(225,225,225,0.4)\",\n\n    linkColor: \"#4F5DFF\",\n\n    headerFontStyle: \"bold 14px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst hotdogStand = {\n    accentColor: \"#8c96ff\",\n    accentLight: \"rgba(202, 206, 255, 0.253)\",\n\n    textDark: \"#ffffff\",\n    textMedium: \"rgba(255, 255, 255, 0.9)\",\n    textLight: \"rgba(255, 255, 255, 0.7)\",\n    textBubble: \"#000000\",\n\n    bgIconHeader: \"#880000\",\n    fgIconHeader: \"#ff5555\",\n    textHeader: \"rgba(0, 0, 0, 0.9)\",\n    textHeaderSelected: \"#000000\",\n\n    bgCell: \"#ff0000\",\n    bgCellMedium: \"#ff4d4d\",\n    bgHeader: \"#f3f300\",\n    bgHeaderHasFocus: \"#eeee00\",\n    bgHeaderHovered: \"#e0e000\",\n\n    bgBubble: \"#ffff00\",\n    bgBubbleSelected: \"#ffff00\",\n\n    bgSearchResult: \"#423c24\",\n\n    borderColor: \"#ffff00\",\n    drilldownBorder: \"#ffff00\",\n\n    linkColor: \"#4F5DFF\",\n\n    headerFontStyle: \"bold 14px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nexport const ThemeSupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [theme, setTheme] = React.useState<Partial<Theme>>({});\n\n    const [numRows, setNumRows] = React.useState(1000);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        setNumRows(cv => cv + 1);\n        for (let c = 0; c < 6; c++) {\n            setCellValue([c, newRow], {\n                displayData: \"\",\n                data: \"\",\n            } as any);\n        }\n    }, [numRows, setCellValue]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Theme support\"\n            description={\n                <>\n                    <Description>\n                        DataGrid respects the theme provided by the <PropName>theme</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        <button onClick={() => setTheme({})}>Light</button> or{\" \"}\n                        <button onClick={() => setTheme(darkTheme)}>Dark</button> even{\" \"}\n                        <button onClick={() => setTheme(hotdogStand)}>Hotdog Stand</button>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                theme={theme}\n                getCellContent={getCellContent}\n                columns={cols}\n                onRowAppended={onRowAppended}\n                trailingRowOptions={{\n                    tint: true,\n                    sticky: true,\n                }}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={numRows}\n            />\n        </BeautifulWrapper>\n    );\n};\n",
      "locationsMap": {
        "theme-support": {
          "startLoc": {
            "col": 39,
            "line": 98
          },
          "endLoc": {
            "col": 1,
            "line": 147
          },
          "startBody": {
            "col": 39,
            "line": 98
          },
          "endBody": {
            "col": 1,
            "line": 147
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const darkTheme = {
  accentColor: "#8c96ff",
  accentLight: "rgba(202, 206, 255, 0.253)",
  textDark: "#ffffff",
  textMedium: "#b8b8b8",
  textLight: "#a0a0a0",
  textBubble: "#ffffff",
  bgIconHeader: "#b8b8b8",
  fgIconHeader: "#000000",
  textHeader: "#a1a1a1",
  textHeaderSelected: "#000000",
  bgCell: "#16161b",
  bgCellMedium: "#202027",
  bgHeader: "#212121",
  bgHeaderHasFocus: "#474747",
  bgHeaderHovered: "#404040",
  bgBubble: "#212121",
  bgBubbleSelected: "#000000",
  bgSearchResult: "#423c24",
  borderColor: "rgba(225,225,225,0.2)",
  drilldownBorder: "rgba(225,225,225,0.4)",
  linkColor: "#4F5DFF",
  headerFontStyle: "bold 14px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif"
};
const hotdogStand = {
  accentColor: "#8c96ff",
  accentLight: "rgba(202, 206, 255, 0.253)",
  textDark: "#ffffff",
  textMedium: "rgba(255, 255, 255, 0.9)",
  textLight: "rgba(255, 255, 255, 0.7)",
  textBubble: "#000000",
  bgIconHeader: "#880000",
  fgIconHeader: "#ff5555",
  textHeader: "rgba(0, 0, 0, 0.9)",
  textHeaderSelected: "#000000",
  bgCell: "#ff0000",
  bgCellMedium: "#ff4d4d",
  bgHeader: "#f3f300",
  bgHeaderHasFocus: "#eeee00",
  bgHeaderHovered: "#e0e000",
  bgBubble: "#ffff00",
  bgBubbleSelected: "#ffff00",
  bgSearchResult: "#423c24",
  borderColor: "#ffff00",
  drilldownBorder: "#ffff00",
  linkColor: "#4F5DFF",
  headerFontStyle: "bold 14px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif"
};
const ThemeSupport = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useAllMockedKinds */ .fl)();
  const [theme, setTheme] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(1000);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;
    setNumRows(cv => cv + 1);

    for (let c = 0; c < 6; c++) {
      setCellValue([c, newRow], {
        displayData: "",
        data: ""
      });
    }
  }, [numRows, setCellValue]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Theme support",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "DataGrid respects the theme provided by the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "theme"), " prop."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: () => setTheme({})
    }, "Light"), " or", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: () => setTheme(darkTheme)
    }, "Dark"), " even", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: () => setTheme(hotdogStand)
    }, "Hotdog Stand")))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    theme: theme,
    getCellContent: getCellContent,
    columns: cols,
    onRowAppended: onRowAppended,
    trailingRowOptions: {
      tint: true,
      sticky: true
    },
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: numRows
  })));
};
const __namedExportsOrder = ["ThemeSupport"];

/***/ }),

/***/ "./packages/core/src/docs/examples/tooltips.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tooltips": () => (/* binding */ Tooltips),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var react_laag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/react-laag/dist/react-laag.esm.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport type { IBounds } from \"react-laag\";\nimport { useLayer } from \"react-laag\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { GridMouseEventArgs } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Tooltips\"\n                    className=\"double\"\n                    description={\n                        <Description>\n                            Using the <PropName>onItemHovered</PropName> event makes it easy to create tooltips. This\n                            story is intentionally forced to scroll vertically so layout in scrolling documents can be\n                            confirmed.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst zeroBounds = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n};\n\nexport const Tooltips: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [tooltip, setTooltip] = React.useState<{ val: string; bounds: IBounds } | undefined>();\n\n    const timeoutRef = React.useRef(0);\n\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\n        if (args.kind === \"cell\") {\n            window.clearTimeout(timeoutRef.current);\n            setTooltip(undefined);\n            timeoutRef.current = window.setTimeout(() => {\n                setTooltip({\n                    val: `Tooltip for ${args.location[0]}, ${args.location[1]}`,\n                    bounds: {\n                        // translate to react-laag types\n                        left: args.bounds.x,\n                        top: args.bounds.y,\n                        width: args.bounds.width,\n                        height: args.bounds.height,\n                        right: args.bounds.x + args.bounds.width,\n                        bottom: args.bounds.y + args.bounds.height,\n                    },\n                });\n            }, 1000);\n        } else {\n            window.clearTimeout(timeoutRef.current);\n            timeoutRef.current = 0;\n            setTooltip(undefined);\n        }\n    }, []);\n\n    React.useEffect(() => () => window.clearTimeout(timeoutRef.current), []);\n\n    const isOpen = tooltip !== undefined;\n    const { renderLayer, layerProps } = useLayer({\n        isOpen,\n        triggerOffset: 4,\n        auto: true,\n        container: \"portal\",\n        trigger: {\n            getBounds: () => tooltip?.bounds ?? zeroBounds,\n        },\n    });\n\n    return (\n        <>\n            <DataEditor\n                {...defaultProps}\n                onItemHovered={onItemHovered}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n            {isOpen &&\n                renderLayer(\n                    <div\n                        {...layerProps}\n                        style={{\n                            ...layerProps.style,\n                            padding: \"8px 12px\",\n                            color: \"white\",\n                            font: \"500 13px Inter\",\n                            backgroundColor: \"rgba(0, 0, 0, 0.85)\",\n                            borderRadius: 9,\n                        }}>\n                        {tooltip.val}\n                    </div>\n                )}\n        </>\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "Tooltips": {
    "startLoc": {
      "col": 35,
      "line": 47
    },
    "endLoc": {
      "col": 1,
      "line": 118
    },
    "startBody": {
      "col": 35,
      "line": 47
    },
    "endBody": {
      "col": 1,
      "line": 118
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport type { IBounds } from \"react-laag\";\nimport { useLayer } from \"react-laag\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport type { GridMouseEventArgs } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Tooltips\"\n                    className=\"double\"\n                    description={\n                        <Description>\n                            Using the <PropName>onItemHovered</PropName> event makes it easy to create tooltips. This\n                            story is intentionally forced to scroll vertically so layout in scrolling documents can be\n                            confirmed.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst zeroBounds = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n};\n\nexport const Tooltips: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [tooltip, setTooltip] = React.useState<{ val: string; bounds: IBounds } | undefined>();\n\n    const timeoutRef = React.useRef(0);\n\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\n        if (args.kind === \"cell\") {\n            window.clearTimeout(timeoutRef.current);\n            setTooltip(undefined);\n            timeoutRef.current = window.setTimeout(() => {\n                setTooltip({\n                    val: `Tooltip for ${args.location[0]}, ${args.location[1]}`,\n                    bounds: {\n                        // translate to react-laag types\n                        left: args.bounds.x,\n                        top: args.bounds.y,\n                        width: args.bounds.width,\n                        height: args.bounds.height,\n                        right: args.bounds.x + args.bounds.width,\n                        bottom: args.bounds.y + args.bounds.height,\n                    },\n                });\n            }, 1000);\n        } else {\n            window.clearTimeout(timeoutRef.current);\n            timeoutRef.current = 0;\n            setTooltip(undefined);\n        }\n    }, []);\n\n    React.useEffect(() => () => window.clearTimeout(timeoutRef.current), []);\n\n    const isOpen = tooltip !== undefined;\n    const { renderLayer, layerProps } = useLayer({\n        isOpen,\n        triggerOffset: 4,\n        auto: true,\n        container: \"portal\",\n        trigger: {\n            getBounds: () => tooltip?.bounds ?? zeroBounds,\n        },\n    });\n\n    return (\n        <>\n            <DataEditor\n                {...defaultProps}\n                onItemHovered={onItemHovered}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n            {isOpen &&\n                renderLayer(\n                    <div\n                        {...layerProps}\n                        style={{\n                            ...layerProps.style,\n                            padding: \"8px 12px\",\n                            color: \"white\",\n                            font: \"500 13px Inter\",\n                            backgroundColor: \"rgba(0, 0, 0, 0.85)\",\n                            borderRadius: 9,\n                        }}>\n                        {tooltip.val}\n                    </div>\n                )}\n        </>\n    );\n};\n",
      "locationsMap": {
        "tooltips": {
          "startLoc": {
            "col": 35,
            "line": 47
          },
          "endLoc": {
            "col": 1,
            "line": 118
          },
          "startBody": {
            "col": 35,
            "line": 47
          },
          "endBody": {
            "col": 1,
            "line": 118
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Tooltips",
    className: "double",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "onItemHovered"), " event makes it easy to create tooltips. This story is intentionally forced to scroll vertically so layout in scrolling documents can be confirmed.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const zeroBounds = {
  left: 0,
  top: 0,
  width: 0,
  height: 0,
  bottom: 0,
  right: 0
};
const Tooltips = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6);
  const [tooltip, setTooltip] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const onItemHovered = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (args.kind === "cell") {
      window.clearTimeout(timeoutRef.current);
      setTooltip(undefined);
      timeoutRef.current = window.setTimeout(() => {
        setTooltip({
          val: `Tooltip for ${args.location[0]}, ${args.location[1]}`,
          bounds: {
            left: args.bounds.x,
            top: args.bounds.y,
            width: args.bounds.width,
            height: args.bounds.height,
            right: args.bounds.x + args.bounds.width,
            bottom: args.bounds.y + args.bounds.height
          }
        });
      }, 1000);
    } else {
      window.clearTimeout(timeoutRef.current);
      timeoutRef.current = 0;
      setTooltip(undefined);
    }
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => window.clearTimeout(timeoutRef.current), []);
  const isOpen = tooltip !== undefined;
  const {
    renderLayer,
    layerProps
  } = (0,react_laag__WEBPACK_IMPORTED_MODULE_3__/* .useLayer */ .sJ)({
    isOpen,
    triggerOffset: 4,
    auto: true,
    container: "portal",
    trigger: {
      getBounds: () => {
        var _tooltip$bounds;

        return (_tooltip$bounds = tooltip === null || tooltip === void 0 ? void 0 : tooltip.bounds) !== null && _tooltip$bounds !== void 0 ? _tooltip$bounds : zeroBounds;
      }
    }
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    onItemHovered: onItemHovered,
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  })), isOpen && renderLayer(react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", _extends({}, layerProps, {
    style: { ...layerProps.style,
      padding: "8px 12px",
      color: "white",
      font: "500 13px Inter",
      backgroundColor: "rgba(0, 0, 0, 0.85)",
      borderRadius: 9
    }
  }), tooltip.val)));
};
const __namedExportsOrder = ["Tooltips"];

/***/ }),

/***/ "./packages/core/src/docs/examples/trailing-row-options.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrailingRowOptions": () => (/* binding */ TrailingRowOptions),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Trailing row options",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "You can customize the trailing row in each column by setting a", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "trailingRowOptions"), " in your columns.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const trailingRowOptionsColumnIndexesHint = {
  2: "Smol text",
  3: "Add",
  5: "New"
};
const trailingRowOptionsColumnIndexesIcon = {
  2: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderArray */ .PE.HeaderArray,
  3: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderEmoji */ .PE.HeaderEmoji,
  5: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderNumber */ .PE.HeaderNumber
};
const trailingRowOptionsColumnIndexesTarget = {
  2: 0,
  3: 0,
  5: 0
};
const trailingRowOptionsColumnIndexesDisabled = {
  3: true
};
const trailingRowOptionsColumnIndexesTheme = {
  2: {
    baseFontStyle: "10px"
  }
};
const TrailingRowOptions = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, newRow]);
      setCellValueRaw([c, newRow], (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .clearCell */ .MP)(cell));
    }

    setNumRows(cv => cv + 1);
  }, [getCellContent, numRows, setCellValueRaw]);
  const columnsWithRowOptions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return cols.map((c, idx) => ({ ...c,
      trailingRowOptions: {
        hint: trailingRowOptionsColumnIndexesHint[idx],
        addIcon: trailingRowOptionsColumnIndexesIcon[idx],
        targetColumn: trailingRowOptionsColumnIndexesTarget[idx],
        disabled: trailingRowOptionsColumnIndexesDisabled[idx],
        themeOverride: trailingRowOptionsColumnIndexesTheme[idx]
      }
    }));
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: columnsWithRowOptions,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      tint: true,
      sticky: true
    },
    rows: numRows,
    onRowAppended: onRowAppended
  }));
};
const __namedExportsOrder = ["TrailingRowOptions"];

/***/ }),

/***/ "./packages/core/src/docs/examples/uneven-rows.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnevenRows": () => (/* binding */ UnevenRows),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Uneven Rows\"\n                    description={\n                        <Description>\n                            Rows can be made uneven by passing a callback to the <PropName>rowHeight</PropName> prop\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const UnevenRows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowHeight={r => (r % 3 === 0 ? 30 : r % 2 ? 50 : 60)}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={1000}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "UnevenRows": {
    "startLoc": {
      "col": 37,
      "line": 32
    },
    "endLoc": {
      "col": 1,
      "line": 44
    },
    "startBody": {
      "col": 37,
      "line": 32
    },
    "endBody": {
      "col": 1,
      "line": 44
    }
  }
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Uneven Rows\"\n                    description={\n                        <Description>\n                            Rows can be made uneven by passing a callback to the <PropName>rowHeight</PropName> prop\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const UnevenRows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowHeight={r => (r % 3 === 0 ? 30 : r % 2 ? 50 : 60)}\n            getCellContent={getCellContent}\n            columns={cols}\n            rows={1000}\n        />\n    );\n};\n",
      "locationsMap": {
        "uneven-rows": {
          "startLoc": {
            "col": 37,
            "line": 32
          },
          "endLoc": {
            "col": 1,
            "line": 44
          },
          "startBody": {
            "col": 37,
            "line": 32
          },
          "endBody": {
            "col": 1,
            "line": 44
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Uneven Rows",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Rows can be made uneven by passing a callback to the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "rowHeight"), " prop")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const UnevenRows = () => {
  const {
    cols,
    getCellContent
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    rowHeight: r => r % 3 === 0 ? 30 : r % 2 ? 50 : 60,
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  }));
};
const __namedExportsOrder = ["UnevenRows"];

/***/ }),

/***/ "./packages/core/src/docs/examples/validate-data.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValidateData": () => (/* binding */ ValidateData),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Validate data\"\n                    description={\n                        <>\n                            <Description>\n                                Data can be validated using the <PropName>validateCell</PropName> callback\n                            </Description>\n                            <MoreInfo>This example only allows the word &quot;Valid&quot; inside text cells.</MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ValidateData: React.VFC = () => {\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(60, false);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onPaste={true}\n            onCellEdited={setCellValue}\n            rows={100}\n            validateCell={(_cell, newValue) => {\n                if (newValue.kind !== GridCellKind.Text) return true;\n                if (newValue.data === \"Valid\") return true;\n                if (newValue.data.toLowerCase() === \"valid\") {\n                    return {\n                        ...newValue,\n                        data: \"Valid\",\n                        selectionRange: [0, 3],\n                    };\n                }\n                return false;\n            }}\n        />\n    );\n};\n";
var __LOCATIONS_MAP__ = {
  "ValidateData": {
    "startLoc": {
      "col": 39,
      "line": 37
    },
    "endLoc": {
      "col": 1,
      "line": 63
    },
    "startBody": {
      "col": 39,
      "line": 37
    },
    "endBody": {
      "col": 1,
      "line": 63
    }
  }
};





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Validate data\"\n                    description={\n                        <>\n                            <Description>\n                                Data can be validated using the <PropName>validateCell</PropName> callback\n                            </Description>\n                            <MoreInfo>This example only allows the word &quot;Valid&quot; inside text cells.</MoreInfo>\n                        </>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const ValidateData: React.VFC = () => {\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(60, false);\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            getCellContent={getCellContent}\n            columns={cols}\n            rowMarkers={\"both\"}\n            onPaste={true}\n            onCellEdited={setCellValue}\n            rows={100}\n            validateCell={(_cell, newValue) => {\n                if (newValue.kind !== GridCellKind.Text) return true;\n                if (newValue.data === \"Valid\") return true;\n                if (newValue.data.toLowerCase() === \"valid\") {\n                    return {\n                        ...newValue,\n                        data: \"Valid\",\n                        selectionRange: [0, 3],\n                    };\n                }\n                return false;\n            }}\n        />\n    );\n};\n",
      "locationsMap": {
        "validate-data": {
          "startLoc": {
            "col": 39,
            "line": 37
          },
          "endLoc": {
            "col": 1,
            "line": 63
          },
          "startBody": {
            "col": 39,
            "line": 37
          },
          "endBody": {
            "col": 1,
            "line": 63
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .BeautifulWrapper */ .m, {
    title: "Validate data",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .Description */ .dk, null, "Data can be validated using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .PropName */ .Gi, null, "validateCell"), " callback"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .MoreInfo */ .OX, null, "This example only allows the word \"Valid\" inside text cells."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const ValidateData = () => {
  const {
    cols,
    getCellContent,
    setCellValue
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .useMockDataGenerator */ .F9)(60, false);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_3__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_2__/* .defaultProps */ .lG, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    onPaste: true,
    onCellEdited: setCellValue,
    rows: 100,
    validateCell: (_cell, newValue) => {
      if (newValue.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text) return true;
      if (newValue.data === "Valid") return true;

      if (newValue.data.toLowerCase() === "valid") {
        return { ...newValue,
          data: "Valid",
          selectionRange: [0, 3]
        };
      }

      return false;
    }
  }));
};
const __namedExportsOrder = ["ValidateData"];

/***/ }),

/***/ "./packages/core/src/docs/examples/wrapping-text.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WrappingText": () => (/* binding */ WrappingText),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash/range.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_range_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var faker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/faker/index.js");
/* harmony import */ var faker__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(faker__WEBPACK_IMPORTED_MODULE_2__);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\nimport range from \"lodash/range.js\";\nimport faker from \"faker\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Wrapping Text\"\n                    description={\n                        <Description>\n                            Text cells can have wrapping text by setting the <PropName>allowWrapping</PropName> prop to\n                            true.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const WrappingText: React.VFC<{\n    alignment: \"left\" | \"center\" | \"right\";\n    length: number;\n    hyperWrapping: boolean;\n}> = p => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(6);\n\n    const suffix = React.useMemo(() => {\n        return range(0, 100).map(() => faker.lorem.sentence(p.length));\n    }, [p.length]);\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        i => {\n            const [col, row] = i;\n\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    displayData: `${row},\\n${suffix[row % suffix.length]}`,\n                    data: `${row}, ${suffix}`,\n                    allowWrapping: true,\n                    contentAlign: p.alignment,\n                };\n            }\n            return getCellContent(i);\n        },\n        [getCellContent, p.alignment, suffix]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowHeight={80}\n            getCellContent={mangledGetCellContent}\n            columns={cols}\n            rows={1000}\n            onColumnResize={onColumnResize}\n            experimental={{\n                hyperWrapping: p.hyperWrapping,\n            }}\n        />\n    );\n};\n(WrappingText as any).args = {\n    alignment: \"left\",\n    length: 20,\n    hyperWrapping: false,\n};\n(WrappingText as any).argTypes = {\n    alignment: {\n        control: { type: \"select\", options: [\"left\", \"center\", \"right\"] },\n    },\n    length: {\n        control: {\n            type: \"range\",\n            min: 2,\n            max: 200,\n        },\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "WrappingText": {
    "startLoc": {
      "col": 5,
      "line": 40
    },
    "endLoc": {
      "col": 1,
      "line": 79
    },
    "startBody": {
      "col": 5,
      "line": 40
    },
    "endBody": {
      "col": 1,
      "line": 79
    }
  }
};







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import React from \"react\";\nimport { DataEditor } from \"../../data-editor/data-editor\";\nimport {\n    BeautifulWrapper,\n    Description,\n    PropName,\n    useMockDataGenerator,\n    defaultProps,\n} from \"../../data-editor/stories/utils\";\nimport { GridCellKind } from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\nimport range from \"lodash/range.js\";\nimport faker from \"faker\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <BeautifulWrapper\n                    title=\"Wrapping Text\"\n                    description={\n                        <Description>\n                            Text cells can have wrapping text by setting the <PropName>allowWrapping</PropName> prop to\n                            true.\n                        </Description>\n                    }>\n                    <Story />\n                </BeautifulWrapper>\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const WrappingText: React.VFC<{\n    alignment: \"left\" | \"center\" | \"right\";\n    length: number;\n    hyperWrapping: boolean;\n}> = p => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(6);\n\n    const suffix = React.useMemo(() => {\n        return range(0, 100).map(() => faker.lorem.sentence(p.length));\n    }, [p.length]);\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        i => {\n            const [col, row] = i;\n\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    displayData: `${row},\\n${suffix[row % suffix.length]}`,\n                    data: `${row}, ${suffix}`,\n                    allowWrapping: true,\n                    contentAlign: p.alignment,\n                };\n            }\n            return getCellContent(i);\n        },\n        [getCellContent, p.alignment, suffix]\n    );\n\n    return (\n        <DataEditor\n            {...defaultProps}\n            rowHeight={80}\n            getCellContent={mangledGetCellContent}\n            columns={cols}\n            rows={1000}\n            onColumnResize={onColumnResize}\n            experimental={{\n                hyperWrapping: p.hyperWrapping,\n            }}\n        />\n    );\n};\n(WrappingText as any).args = {\n    alignment: \"left\",\n    length: 20,\n    hyperWrapping: false,\n};\n(WrappingText as any).argTypes = {\n    alignment: {\n        control: { type: \"select\", options: [\"left\", \"center\", \"right\"] },\n    },\n    length: {\n        control: {\n            type: \"range\",\n            min: 2,\n            max: 200,\n        },\n    },\n};\n",
      "locationsMap": {
        "wrapping-text": {
          "startLoc": {
            "col": 5,
            "line": 40
          },
          "endLoc": {
            "col": 1,
            "line": 79
          },
          "startBody": {
            "col": 5,
            "line": 40
          },
          "endBody": {
            "col": 1,
            "line": 79
          }
        }
      }
    }
  },
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_3__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_4__/* .BeautifulWrapper */ .m, {
    title: "Wrapping Text",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_4__/* .Description */ .dk, null, "Text cells can have wrapping text by setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_4__/* .PropName */ .Gi, null, "allowWrapping"), " prop to true.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null)))]
});
const WrappingText = p => {
  const {
    cols,
    getCellContent,
    onColumnResize
  } = (0,_data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_4__/* .useMockDataGenerator */ .F9)(6);
  const suffix = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default()(0, 100).map(() => faker__WEBPACK_IMPORTED_MODULE_2___default().lorem.sentence(p.length));
  }, [p.length]);
  const mangledGetCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(i => {
    const [col, row] = i;

    if (col === 0) {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_5__/* .GridCellKind.Text */ .p6.Text,
        allowOverlay: true,
        displayData: `${row},\n${suffix[row % suffix.length]}`,
        data: `${row}, ${suffix}`,
        allowWrapping: true,
        contentAlign: p.alignment
      };
    }

    return getCellContent(i);
  }, [getCellContent, p.alignment, suffix]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, _data_editor_stories_utils__WEBPACK_IMPORTED_MODULE_4__/* .defaultProps */ .lG, {
    rowHeight: 80,
    getCellContent: mangledGetCellContent,
    columns: cols,
    rows: 1000,
    onColumnResize: onColumnResize,
    experimental: {
      hyperWrapping: p.hyperWrapping
    }
  }));
};
WrappingText.args = {
  alignment: "left",
  length: 20,
  hyperWrapping: false
};
WrappingText.argTypes = {
  alignment: {
    control: {
      type: "select",
      options: ["left", "center", "right"]
    }
  },
  length: {
    control: {
      type: "range",
      min: 2,
      max: 200
    }
  }
};
const __namedExportsOrder = ["WrappingText"];

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Simplenotest": () => (/* binding */ Simplenotest),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _scrolling_data_grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx");
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/core/src/common/styles.ts");
/* harmony import */ var _data_grid_cells__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/cells/index.ts");
var __STORY__ = "import * as React from \"react\";\n\nimport { BuilderThemeWrapper } from \"../stories/story-utils\";\nimport GridScroller from \"./scrolling-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport { CompactSelection, GridCell, GridCellKind, Rectangle, Item } from \"../data-grid/data-grid-types\";\nimport { getDefaultTheme } from \"..\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport { CellRenderers } from \"../data-grid/cells\";\n\nconst InnerContainer = styled.div`\n    width: 100%;\n    height: 100px;\n\n    > * {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\nconst getCellRenderer: GetCellRendererCallback = cell => {\n    if (cell.kind === GridCellKind.Custom) return undefined;\n    return CellRenderers[cell.kind] as any;\n};\n\nexport default {\n    title: \"Subcomponents/ScrollingDataGrid\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <div>\n                <BuilderThemeWrapper width={1500} height={1000}>\n                    <InnerContainer>\n                        <Story />\n                    </InnerContainer>\n                </BuilderThemeWrapper>\n            </div>\n        ),\n    ],\n};\n\nexport function Simplenotest() {\n    const [x, setX] = React.useState<number>(0);\n    const [y, setY] = React.useState<number>(0);\n    const [translateX, setTx] = React.useState<number | undefined>(0);\n    const [translateY, setTy] = React.useState<number | undefined>(0);\n\n    const onVisibleRegionChanged = React.useCallback((range: Rectangle, tx?: number, ty?: number) => {\n        setX(range.x);\n        setY(range.y);\n        setTx(tx);\n        setTy(ty);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        let j = 0;\n        return [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\"].map(t => ({\n            title: t,\n            width: 122 + (j += 50),\n        }));\n    }, []);\n\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => ({\n            kind: GridCellKind.Text,\n            displayData: `${col},${row} Testing things that are way too long`,\n            data: `${col},${row} Testing things that are way too long`,\n            allowOverlay: true,\n        }),\n        []\n    );\n\n    return (\n        <GridScroller\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            rows={10_000}\n            enableGroups={false}\n            clientSize={[1000, 1000]}\n            cellXOffset={x}\n            cellYOffset={y}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseUp={() => undefined}\n            canvasRef={undefined}\n            className={undefined}\n            disabledRows={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            initialSize={undefined}\n            overscrollX={undefined}\n            overscrollY={undefined}\n            preventDiagonalScrolling={undefined}\n            rightElement={undefined}\n            rightElementProps={undefined}\n            scrollRef={undefined}\n            showMinimap={undefined}\n            scrollToEnd={undefined}\n            minColumnWidth={50}\n            isFocused={true}\n            theme={getDefaultTheme()}\n            isFilling={false}\n            maxColumnWidth={500}\n            accessibilityHeight={50}\n            translateX={translateX}\n            translateY={translateY}\n            lockColumns={0}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.empty(),\n                columns: CompactSelection.empty(),\n            }}\n            firstColAccessible={true}\n            groupHeaderHeight={34}\n            headerHeight={44}\n            trailingRowType={\"none\"}\n            rowHeight={34}\n            onVisibleRegionChanged={onVisibleRegionChanged}\n            columns={columns}\n            getCellContent={getCellContent}\n            freezeColumns={0}\n            verticalBorder={() => true}\n            smoothScrollX={true}\n            smoothScrollY={true}\n        />\n    );\n}\n";
var __LOCATIONS_MAP__ = {
  "Simplenotest": {
    "startLoc": {
      "col": 7,
      "line": 43
    },
    "endLoc": {
      "col": 1,
      "line": 152
    },
    "startBody": {
      "col": 7,
      "line": 43
    },
    "endBody": {
      "col": 1,
      "line": 152
    }
  }
};







const InnerContainer = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)('div')({
  name: "InnerContainer",
  class: "i1ua65x0"
});

const getCellRenderer = cell => {
  if (cell.kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Custom */ .p6.Custom) return undefined;
  return _data_grid_cells__WEBPACK_IMPORTED_MODULE_3__/* .CellRenderers */ .L[cell.kind];
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  parameters: {
    "storySource": {
      "source": "import * as React from \"react\";\n\nimport { BuilderThemeWrapper } from \"../stories/story-utils\";\nimport GridScroller from \"./scrolling-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport { CompactSelection, GridCell, GridCellKind, Rectangle, Item } from \"../data-grid/data-grid-types\";\nimport { getDefaultTheme } from \"..\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport { CellRenderers } from \"../data-grid/cells\";\n\nconst InnerContainer = styled.div`\n    width: 100%;\n    height: 100px;\n\n    > * {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\nconst getCellRenderer: GetCellRendererCallback = cell => {\n    if (cell.kind === GridCellKind.Custom) return undefined;\n    return CellRenderers[cell.kind] as any;\n};\n\nexport default {\n    title: \"Subcomponents/ScrollingDataGrid\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <div>\n                <BuilderThemeWrapper width={1500} height={1000}>\n                    <InnerContainer>\n                        <Story />\n                    </InnerContainer>\n                </BuilderThemeWrapper>\n            </div>\n        ),\n    ],\n};\n\nexport function Simplenotest() {\n    const [x, setX] = React.useState<number>(0);\n    const [y, setY] = React.useState<number>(0);\n    const [translateX, setTx] = React.useState<number | undefined>(0);\n    const [translateY, setTy] = React.useState<number | undefined>(0);\n\n    const onVisibleRegionChanged = React.useCallback((range: Rectangle, tx?: number, ty?: number) => {\n        setX(range.x);\n        setY(range.y);\n        setTx(tx);\n        setTy(ty);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        let j = 0;\n        return [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\"].map(t => ({\n            title: t,\n            width: 122 + (j += 50),\n        }));\n    }, []);\n\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => ({\n            kind: GridCellKind.Text,\n            displayData: `${col},${row} Testing things that are way too long`,\n            data: `${col},${row} Testing things that are way too long`,\n            allowOverlay: true,\n        }),\n        []\n    );\n\n    return (\n        <GridScroller\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            rows={10_000}\n            enableGroups={false}\n            clientSize={[1000, 1000]}\n            cellXOffset={x}\n            cellYOffset={y}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseUp={() => undefined}\n            canvasRef={undefined}\n            className={undefined}\n            disabledRows={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            initialSize={undefined}\n            overscrollX={undefined}\n            overscrollY={undefined}\n            preventDiagonalScrolling={undefined}\n            rightElement={undefined}\n            rightElementProps={undefined}\n            scrollRef={undefined}\n            showMinimap={undefined}\n            scrollToEnd={undefined}\n            minColumnWidth={50}\n            isFocused={true}\n            theme={getDefaultTheme()}\n            isFilling={false}\n            maxColumnWidth={500}\n            accessibilityHeight={50}\n            translateX={translateX}\n            translateY={translateY}\n            lockColumns={0}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.empty(),\n                columns: CompactSelection.empty(),\n            }}\n            firstColAccessible={true}\n            groupHeaderHeight={34}\n            headerHeight={44}\n            trailingRowType={\"none\"}\n            rowHeight={34}\n            onVisibleRegionChanged={onVisibleRegionChanged}\n            columns={columns}\n            getCellContent={getCellContent}\n            freezeColumns={0}\n            verticalBorder={() => true}\n            smoothScrollX={true}\n            smoothScrollY={true}\n        />\n    );\n}\n",
      "locationsMap": {
        "simplenotest": {
          "startLoc": {
            "col": 7,
            "line": 43
          },
          "endLoc": {
            "col": 1,
            "line": 152
          },
          "startBody": {
            "col": 7,
            "line": 43
          },
          "endBody": {
            "col": 1,
            "line": 152
          }
        }
      }
    }
  },
  title: "Subcomponents/ScrollingDataGrid",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_4__/* .BuilderThemeWrapper */ .j, {
    width: 1500,
    height: 1000
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerContainer, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))))]
});
const Simplenotest = function Simplenotest() {
  const [x, setX] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [y, setY] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [translateX, setTx] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [translateY, setTy] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const onVisibleRegionChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((range, tx, ty) => {
    setX(range.x);
    setY(range.y);
    setTx(tx);
    setTy(ty);
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let j = 0;
    return ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten"].map(t => ({
      title: t,
      width: 122 + (j += 50)
    }));
  }, []);
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {
    let [col, row] = _ref;
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      displayData: `${col},${row} Testing things that are way too long`,
      data: `${col},${row} Testing things that are way too long`,
      allowOverlay: true
    };
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_scrolling_data_grid__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    onMouseMove: () => undefined,
    rows: 10000,
    enableGroups: false,
    clientSize: [1000, 1000],
    cellXOffset: x,
    cellYOffset: y,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseUp: () => undefined,
    canvasRef: undefined,
    className: undefined,
    disabledRows: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    initialSize: undefined,
    overscrollX: undefined,
    overscrollY: undefined,
    preventDiagonalScrolling: undefined,
    rightElement: undefined,
    rightElementProps: undefined,
    scrollRef: undefined,
    showMinimap: undefined,
    scrollToEnd: undefined,
    minColumnWidth: 50,
    isFocused: true,
    theme: (0,___WEBPACK_IMPORTED_MODULE_6__/* .getDataEditorTheme */ .Zu)(),
    isFilling: false,
    maxColumnWidth: 500,
    accessibilityHeight: 50,
    translateX: translateX,
    translateY: translateY,
    lockColumns: 0,
    selection: {
      current: undefined,
      rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
      columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
    },
    firstColAccessible: true,
    groupHeaderHeight: 34,
    headerHeight: 44,
    trailingRowType: "none",
    rowHeight: 34,
    onVisibleRegionChanged: onVisibleRegionChanged,
    columns: columns,
    getCellContent: getCellContent,
    freezeColumns: 0,
    verticalBorder: () => true,
    smoothScrollX: true,
    smoothScrollY: true
  });
};

__webpack_require__("./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx");

const __namedExportsOrder = ["Simplenotest"];

/***/ }),

/***/ "./packages/source/src/stories/use-data-source.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "MoreInfo": () => (/* binding */ MoreInfo),
  "UndoRedo": () => (/* binding */ UndoRedo),
  "UseDataSource": () => (/* binding */ UseDataSource),
  "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
  "default": () => (/* binding */ use_data_source_stories)
});

// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./node_modules/react-resize-detector/build/index.esm.js
var index_esm = __webpack_require__("./node_modules/react-resize-detector/build/index.esm.js");
// EXTERNAL MODULE: ./packages/core/dist/js/index.js
var js = __webpack_require__("./packages/core/dist/js/index.js");
// EXTERNAL MODULE: ./node_modules/faker/index.js
var faker = __webpack_require__("./node_modules/faker/index.js");
var faker_default = /*#__PURE__*/__webpack_require__.n(faker);
// EXTERNAL MODULE: ./node_modules/lodash/orderBy.js
var orderBy = __webpack_require__("./node_modules/lodash/orderBy.js");
var orderBy_default = /*#__PURE__*/__webpack_require__.n(orderBy);
;// CONCATENATED MODULE: ./packages/source/src/use-movable-columns.ts



function colToKey(c) {
  var _c$id, _c$group;

  return (_c$id = c.id) !== null && _c$id !== void 0 ? _c$id : `${(_c$group = c.group) !== null && _c$group !== void 0 ? _c$group : ""}/${c.title}`;
}

function looseCompareCol(a, b) {
  if (typeof b === "string") {
    return colToKey(a) === b;
  }

  return colToKey(a) === colToKey(b);
}

function getSortIndexByKey(needle, current, keys) {
  const index = current.indexOf(needle);
  if (index === -1) return Number.MAX_SAFE_INTEGER;
  const remapped = keys.findIndex(key => looseCompareCol(needle, key));
  if (remapped !== -1) return remapped;

  for (let n = index; n >= 0; n--) {
    const ind = keys.findIndex(key => looseCompareCol(current[n], key));
    if (ind !== -1) return ind + 0.5;
  }

  return -1;
}

function useMoveableColumns(p) {
  const {
    columns: columnsIn,
    getCellContent: getCellContentIn,
    onColumnMoved: onColumnMovedIn
  } = p;
  const [keys, setKeys] = react.useState(() => columnsIn.map(colToKey));
  const columns = react.useMemo(() => {
    return orderBy_default()(columnsIn, c => getSortIndexByKey(c, columnsIn, keys));
  }, [keys, columnsIn]);
  const onColumnMovedRef = react.useRef(onColumnMovedIn);
  onColumnMovedRef.current = onColumnMovedIn;
  const onColumnMoved = react.useCallback((startIndex, endIndex) => {
    var _onColumnMovedRef$cur;

    setKeys(old => {
      const newCols = [...old];
      const [toMove] = newCols.splice(startIndex, 1);
      newCols.splice(endIndex, 0, toMove);
      return newCols;
    });
    (_onColumnMovedRef$cur = onColumnMovedRef.current) === null || _onColumnMovedRef$cur === void 0 ? void 0 : _onColumnMovedRef$cur.call(onColumnMovedRef, startIndex, endIndex);
  }, []);
  react.useEffect(() => {
    setKeys(cv => {
      return orderBy_default()(columnsIn, x => getSortIndexByKey(x, columnsIn, cv)).map(colToKey);
    });
  }, [columnsIn]);
  const getCellContent = react.useCallback(cell => {
    const [col, row] = cell;
    const needle = columns[col];
    const index = columnsIn.indexOf(needle);
    return getCellContentIn([index, row]);
  }, [columns, columnsIn, getCellContentIn]);
  return {
    columns,
    onColumnMoved,
    getCellContent
  };
}
// EXTERNAL MODULE: ./node_modules/lodash/range.js
var range = __webpack_require__("./node_modules/lodash/range.js");
var range_default = /*#__PURE__*/__webpack_require__.n(range);
;// CONCATENATED MODULE: ./packages/source/src/use-column-sort.ts




function cellToSortData(c) {
  var _c$data$toString, _c$data, _c$data$toString2, _c$data2, _c$data3;

  switch (c.kind) {
    case js/* GridCellKind.Number */.p6.Number:
      return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";

    case js/* GridCellKind.Boolean */.p6.Boolean:
      return (_c$data$toString2 = (_c$data2 = c.data) === null || _c$data2 === void 0 ? void 0 : _c$data2.toString()) !== null && _c$data$toString2 !== void 0 ? _c$data$toString2 : "";

    case js/* GridCellKind.Markdown */.p6.Markdown:
    case js/* GridCellKind.RowID */.p6.RowID:
    case js/* GridCellKind.Text */.p6.Text:
    case js/* GridCellKind.Uri */.p6.Uri:
      return (_c$data3 = c.data) !== null && _c$data3 !== void 0 ? _c$data3 : "";

    case js/* GridCellKind.Bubble */.p6.Bubble:
    case js/* GridCellKind.Image */.p6.Image:
      return c.data.join("");

    case js/* GridCellKind.Drilldown */.p6.Drilldown:
      return c.data.map(x => x.text).join("");

    case js/* GridCellKind.Protected */.p6.Protected:
    case js/* GridCellKind.Loading */.p6.Loading:
      return "";

    case js/* GridCellKind.Custom */.p6.Custom:
      return c.copyData;
  }
}

function tryParse(val) {
  if (typeof val === "number") return val;

  if (val.length > 0) {
    const x = parseFloat(val);

    if (!isNaN(x)) {
      val = x;
    }
  }

  return val;
}

function compareSmart(a, b) {
  a = tryParse(a);
  b = tryParse(b);

  if (typeof a === "string" && typeof b === "string") {
    return a.localeCompare(b);
  } else if (typeof a === "number" && typeof b === "number") {
    if (a === b) return 0;
    return a > b ? 1 : -1;
  } else if (a == b) {
    return 0;
  }

  return a > b ? 1 : -1;
}
function compareRaw(a, b) {
  if (a > b) return 1;
  if (a === b) return 0;
  return -1;
}
function useColumnSort(p) {
  var _sort$direction;

  const {
    sort,
    rows,
    getCellContent: getCellContentIn
  } = p;
  let sortCol = sort === undefined ? undefined : p.columns.findIndex(c => sort.column === c || c.id !== undefined && sort.column.id === c.id);
  if (sortCol === -1) sortCol = undefined;
  const dir = (_sort$direction = sort === null || sort === void 0 ? void 0 : sort.direction) !== null && _sort$direction !== void 0 ? _sort$direction : "asc";
  const sortMap = react.useMemo(() => {
    if (sortCol === undefined) return undefined;
    const vals = new Array(rows);
    const index = [sortCol, 0];

    for (let i = 0; i < rows; i++) {
      index[1] = i;
      vals[i] = cellToSortData(getCellContentIn(index));
    }

    let result;

    if ((sort === null || sort === void 0 ? void 0 : sort.mode) === "raw") {
      result = range_default()(rows).sort((a, b) => compareRaw(vals[a], vals[b]));
    } else if ((sort === null || sort === void 0 ? void 0 : sort.mode) === "smart") {
      result = range_default()(rows).sort((a, b) => compareSmart(vals[a], vals[b]));
    } else {
      result = range_default()(rows).sort((a, b) => vals[a].localeCompare(vals[b]));
    }

    if (dir === "desc") {
      result.reverse();
    }

    return result;
  }, [getCellContentIn, rows, sort === null || sort === void 0 ? void 0 : sort.mode, dir, sortCol]);
  const getOriginalIndex = react.useCallback(index => {
    if (sortMap === undefined) return index;
    return sortMap[index];
  }, [sortMap]);
  const getCellContent = react.useCallback(_ref => {
    let [col, row] = _ref;
    if (sortMap === undefined) return getCellContentIn([col, row]);
    row = sortMap[row];
    return getCellContentIn([col, row]);
  }, [getCellContentIn, sortMap]);

  if (sortMap === undefined) {
    return {
      getCellContent: p.getCellContent,
      getOriginalIndex
    };
  }

  return {
    getOriginalIndex,
    getCellContent
  };
}
;// CONCATENATED MODULE: ./packages/source/src/use-collapsing-groups.ts

function useCollapsingGroups(props) {
  const [collapsed, setCollapsed] = react.useState([]);
  const [gridSelectionInner, setGridSelectionsInner] = react.useState(undefined);
  const {
    columns: columnsIn,
    onGroupHeaderClicked: onGroupHeaderClickedIn,
    onGridSelectionChange: onGridSelectionChangeIn,
    getGroupDetails: getGroupDetailsIn,
    gridSelection: gridSelectionIn,
    freezeColumns = 0,
    theme
  } = props;
  const gridSelection = gridSelectionIn !== null && gridSelectionIn !== void 0 ? gridSelectionIn : gridSelectionInner;
  const spans = react.useMemo(() => {
    const result = [];
    let current = [-1, -1];
    let lastGroup;

    for (let i = freezeColumns; i < columnsIn.length; i++) {
      var _c$group;

      const c = columnsIn[i];
      const group = (_c$group = c.group) !== null && _c$group !== void 0 ? _c$group : "";
      const isCollapsed = collapsed.includes(group);

      if (lastGroup !== group && current[0] !== -1) {
        result.push(current);
        current = [-1, -1];
      }

      if (isCollapsed && current[0] !== -1) {
        current[1] += 1;
      } else if (isCollapsed) {
        current = [i, 1];
      } else if (current[0] !== -1) {
        result.push(current);
        current = [-1, -1];
      }

      lastGroup = group;
    }

    if (current[0] !== -1) result.push(current);
    return result;
  }, [collapsed, columnsIn, freezeColumns]);
  const columns = react.useMemo(() => {
    if (spans.length === 0) return columnsIn;
    return columnsIn.map((c, index) => {
      for (const [start, length] of spans) {
        if (index >= start && index < start + length) {
          let width = 8;

          if (index === start + length - 1) {
            width = 36;
          }

          return { ...c,
            width,
            themeOverride: {
              bgCell: theme.bgCellMedium
            }
          };
        }
      }

      return c;
    });
  }, [columnsIn, spans, theme.bgCellMedium]);
  const onGroupHeaderClicked = react.useCallback((index, a) => {
    var _columns$index$group, _columns$index;

    onGroupHeaderClickedIn === null || onGroupHeaderClickedIn === void 0 ? void 0 : onGroupHeaderClickedIn(index, a);
    const group = (_columns$index$group = (_columns$index = columns[index]) === null || _columns$index === void 0 ? void 0 : _columns$index.group) !== null && _columns$index$group !== void 0 ? _columns$index$group : "";
    if (group === "") return;
    a.preventDefault();
    setCollapsed(cv => cv.includes(group) ? cv.filter(x => x !== group) : [...cv, group]);
  }, [columns, onGroupHeaderClickedIn]);
  const onGridSelectionChange = react.useCallback(s => {
    if (s.current !== undefined) {
      const col = s.current.cell[0];
      const column = columns[col];
      setCollapsed(cv => {
        var _column$group;

        if (cv.includes((_column$group = column === null || column === void 0 ? void 0 : column.group) !== null && _column$group !== void 0 ? _column$group : "")) {
          return cv.filter(g => g !== column.group);
        }

        return cv;
      });
    }

    if (onGridSelectionChangeIn !== undefined) {
      onGridSelectionChangeIn(s);
    } else {
      setGridSelectionsInner(s);
    }
  }, [columns, onGridSelectionChangeIn]);
  const getGroupDetails = react.useCallback(group => {
    const result = getGroupDetailsIn === null || getGroupDetailsIn === void 0 ? void 0 : getGroupDetailsIn(group);
    return { ...result,
      name: group,
      overrideTheme: collapsed.includes(group !== null && group !== void 0 ? group : "") ? {
        bgHeader: theme.bgHeaderHasFocus
      } : undefined
    };
  }, [collapsed, getGroupDetailsIn, theme.bgHeaderHasFocus]);
  return {
    columns,
    onGroupHeaderClicked,
    onGridSelectionChange,
    getGroupDetails,
    gridSelection
  };
}
;// CONCATENATED MODULE: ./packages/source/src/use-undo-redo.ts

const initialState = {
  undoHistory: [],
  redoHistory: [],
  canUndo: false,
  canRedo: false,
  isApplyingUndo: false,
  isApplyingRedo: false
};

function reducer(state, action) {
  const newState = { ...state
  };

  switch (action.type) {
    case "undo":
      if (state.canUndo) {
        newState.undoHistory = [...state.undoHistory];
        const operation = newState.undoHistory.pop();
        newState.operation = operation;
        newState.canUndo = newState.undoHistory.length > 0;
        newState.isApplyingUndo = true;
        return newState;
      }

      return state;

    case "redo":
      if (state.canRedo) {
        newState.redoHistory = [...state.redoHistory];
        const operation = newState.redoHistory.pop();
        newState.operation = operation;
        newState.canRedo = newState.redoHistory.length > 0;
        newState.isApplyingRedo = true;
        return newState;
      }

      return state;

    case "operationApplied":
      newState.operation = undefined;
      newState.isApplyingRedo = false;
      newState.isApplyingUndo = false;
      return newState;

    case "edit":
      if (!state.isApplyingRedo && !state.isApplyingUndo) {
        newState.undoHistory = [...state.undoHistory, action.batch];
        newState.redoHistory = [];
        newState.canUndo = true;
        newState.canRedo = false;
      }

      if (state.isApplyingUndo) {
        newState.redoHistory = [...state.redoHistory, action.batch];
        newState.canRedo = true;
      }

      if (state.isApplyingRedo) {
        newState.undoHistory = [...state.undoHistory, action.batch];
        newState.canUndo = true;
      }

      return newState;

    default:
      throw new Error("Invalid action");
  }
}

function useUndoRedo(gridRef, getCellContent, onCellEdited, onGridSelectionChange) {
  const [state, dispatch] = (0,react.useReducer)(reducer, initialState);
  const currentBatch = (0,react.useRef)(null);
  const timeout = (0,react.useRef)(null);
  const isApplyingUndoRef = (0,react.useRef)(false);
  const isApplyingRedoRef = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    isApplyingUndoRef.current = state.isApplyingUndo;
    isApplyingRedoRef.current = state.isApplyingRedo;
  }, [state.isApplyingUndo, state.isApplyingRedo]);
  const [gridSelection, setGridSelection] = (0,react.useState)(null);
  const gridSelectionRef = (0,react.useRef)(null);
  const onGridSelectionChangedEdited = (0,react.useCallback)(newVal => {
    if (onGridSelectionChange) {
      onGridSelectionChange(newVal);
    }

    setGridSelection(newVal);
    gridSelectionRef.current = newVal;
  }, [onGridSelectionChange]);
  const wrappedOnCellEdited = (0,react.useCallback)((cell, newValue) => {
    const isApplyingUpdate = isApplyingUndoRef.current || isApplyingRedoRef.current;

    if (!isApplyingUpdate && gridSelectionRef.current) {
      clearTimeout(timeout.current);
      const previousValue = getCellContent(cell);

      if (currentBatch.current === null) {
        currentBatch.current = {
          edits: [],
          selection: gridSelectionRef.current
        };
      }

      currentBatch.current.edits.push({
        cell,
        newValue: previousValue
      });
      timeout.current = setTimeout(() => {
        if (currentBatch.current) {
          dispatch({
            type: "edit",
            batch: currentBatch.current
          });
          currentBatch.current = null;
        }
      }, 0);
    }

    onCellEdited(cell, newValue);
  }, [onCellEdited, getCellContent]);
  const undo = (0,react.useCallback)(() => {
    dispatch({
      type: "undo"
    });
  }, [dispatch]);
  const redo = (0,react.useCallback)(() => {
    dispatch({
      type: "redo"
    });
  }, [dispatch]);
  (0,react.useEffect)(() => {
    if (state.operation && gridSelectionRef.current && gridRef.current) {
      const cells = [];
      const previousState = {
        edits: [],
        selection: gridSelectionRef.current
      };

      for (const edit of state.operation.edits) {
        const prevValue = getCellContent(edit.cell);
        previousState.edits.push({
          cell: edit.cell,
          newValue: prevValue
        });
        onCellEdited(edit.cell, edit.newValue);
        cells.push({
          cell: edit.cell
        });
      }

      setGridSelection(state.operation.selection);
      gridSelectionRef.current = state.operation.selection;
      gridRef.current.updateCells(cells);
      dispatch({
        type: "edit",
        batch: previousState
      });
      dispatch({
        type: "operationApplied"
      });
    }
  }, [state.operation, gridRef, onCellEdited, setGridSelection, getCellContent]);
  (0,react.useEffect)(() => {
    const onKeyDown = e => {
      if (e.key === "z" && (e.metaKey || e.ctrlKey)) {
        if (e.shiftKey) {
          redo();
        } else {
          undo();
        }
      }

      if (e.key === "y" && (e.metaKey || e.ctrlKey)) {
        redo();
      }
    };

    window.addEventListener("keydown", onKeyDown);
    return () => {
      window.removeEventListener("keydown", onKeyDown);
    };
  }, [undo, redo]);
  return (0,react.useMemo)(() => {
    return {
      undo,
      redo,
      canUndo: state.canUndo,
      canRedo: state.canRedo,
      onCellEdited: wrappedOnCellEdited,
      onGridSelectionChange: onGridSelectionChangedEdited,
      gridSelection
    };
  }, [undo, redo, wrappedOnCellEdited, state.canUndo, state.canRedo, onGridSelectionChangedEdited, gridSelection]);
}
// EXTERNAL MODULE: ./node_modules/lodash/isArray.js
var isArray = __webpack_require__("./node_modules/lodash/isArray.js");
var isArray_default = /*#__PURE__*/__webpack_require__.n(isArray);
;// CONCATENATED MODULE: ./packages/source/src/stories/utils.tsx




faker_default().seed(1337);

function isTruthy(x) {
  return x ? true : false;
}

function lossyCopyData(source, target) {
  const sourceData = source.data;

  if (typeof sourceData === typeof target.data) {
    return { ...target,
      data: sourceData
    };
  } else switch (target.kind) {
    case js/* GridCellKind.Uri */.p6.Uri:
      {
        var _sourceData$toString;

        if (isArray_default()(sourceData)) {
          return { ...target,
            data: sourceData[0]
          };
        }

        return { ...target,
          data: (_sourceData$toString = sourceData === null || sourceData === void 0 ? void 0 : sourceData.toString()) !== null && _sourceData$toString !== void 0 ? _sourceData$toString : ""
        };
      }

    case js/* GridCellKind.Boolean */.p6.Boolean:
      {
        if (isArray_default()(sourceData)) {
          return { ...target,
            data: sourceData[0] !== undefined
          };
        } else if (source.kind === js/* GridCellKind.Boolean */.p6.Boolean) {
          return { ...target,
            data: source.data
          };
        }

        return { ...target,
          data: isTruthy(sourceData) ? true : false
        };
      }

    case js/* GridCellKind.Image */.p6.Image:
      {
        var _sourceData$toString2;

        if (isArray_default()(sourceData)) {
          return { ...target,
            data: [sourceData[0]]
          };
        }

        return { ...target,
          data: [(_sourceData$toString2 = sourceData === null || sourceData === void 0 ? void 0 : sourceData.toString()) !== null && _sourceData$toString2 !== void 0 ? _sourceData$toString2 : ""]
        };
      }

    case js/* GridCellKind.Number */.p6.Number:
      {
        return { ...target,
          data: 0
        };
      }

    case js/* GridCellKind.Text */.p6.Text:
    case js/* GridCellKind.Markdown */.p6.Markdown:
      {
        var _source$data$toString, _source$data;

        if (isArray_default()(sourceData)) {
          var _sourceData$0$toStrin;

          return { ...target,
            data: (_sourceData$0$toStrin = sourceData[0].toString()) !== null && _sourceData$0$toStrin !== void 0 ? _sourceData$0$toStrin : ""
          };
        }

        return { ...target,
          data: (_source$data$toString = (_source$data = source.data) === null || _source$data === void 0 ? void 0 : _source$data.toString()) !== null && _source$data$toString !== void 0 ? _source$data$toString : ""
        };
      }

    case js/* GridCellKind.Custom */.p6.Custom:
      {
        return target;
      }
  }

  assertNever(target);
}
function getGridColumn(columnWithMock) {
  const {
    getContent,
    ...rest
  } = columnWithMock;
  return rest;
}

function getResizableColumns(amount, group) {
  const defaultColumns = [{
    title: "First name",
    id: "First name",
    group: group ? "Name" : undefined,
    icon: js/* GridColumnIcon.HeaderString */.PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const firstName = faker_default().name.firstName();
      return {
        kind: js/* GridCellKind.Text */.p6.Text,
        displayData: firstName,
        data: firstName,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Last name",
    id: "Last name",
    group: group ? "Name" : undefined,
    icon: js/* GridColumnIcon.HeaderString */.PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const lastName = faker_default().name.lastName();
      return {
        kind: js/* GridCellKind.Text */.p6.Text,
        displayData: lastName,
        data: lastName,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Avatar",
    id: "Avatar",
    group: group ? "Info" : undefined,
    icon: js/* GridColumnIcon.HeaderImage */.PE.HeaderImage,
    hasMenu: false,
    getContent: () => {
      const n = Math.round(Math.random() * 100);
      return {
        kind: js/* GridCellKind.Image */.p6.Image,
        data: [`https://picsum.photos/id/${n}/900/900`],
        displayData: [`https://picsum.photos/id/${n}/40/40`],
        allowOverlay: true,
        allowAdd: false,
        readonly: true
      };
    }
  }, {
    title: "Email",
    id: "Email",
    group: group ? "Info" : undefined,
    icon: js/* GridColumnIcon.HeaderString */.PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const email = faker_default().internet.email();
      return {
        kind: js/* GridCellKind.Text */.p6.Text,
        displayData: email,
        data: email,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Title",
    id: "Title",
    group: group ? "Info" : undefined,
    icon: js/* GridColumnIcon.HeaderString */.PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const company = faker_default().name.jobTitle();
      return {
        kind: js/* GridCellKind.Text */.p6.Text,
        displayData: company,
        data: company,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "More Info",
    id: "More Info",
    group: group ? "Info" : undefined,
    icon: js/* GridColumnIcon.HeaderUri */.PE.HeaderUri,
    hasMenu: false,
    getContent: () => {
      const url = faker_default().internet.url();
      return {
        kind: js/* GridCellKind.Uri */.p6.Uri,
        displayData: url,
        data: url,
        allowOverlay: true,
        readonly: true
      };
    }
  }];

  if (amount < defaultColumns.length) {
    return defaultColumns.slice(0, amount);
  }

  const extraColumnsAmount = amount - defaultColumns.length;
  const extraColumns = [...new Array(extraColumnsAmount)].map((_, index) => createTextColumnInfo(index + defaultColumns.length, group));
  return [...defaultColumns, ...extraColumns];
}

function createTextColumnInfo(index, group) {
  return {
    title: `Column ${index}`,
    id: `Column ${index}`,
    group: group ? `Group ${Math.round(index / 3)}` : undefined,
    icon: js/* GridColumnIcon.HeaderString */.PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const text = faker_default().lorem.word();
      return {
        kind: js/* GridCellKind.Text */.p6.Text,
        data: text,
        displayData: text,
        allowOverlay: true,
        readonly: true
      };
    }
  };
}

class ContentCache {
  constructor() {
    this.cachedContent = new Map();
  }

  get(col, row) {
    const colCache = this.cachedContent.get(col);

    if (colCache === undefined) {
      return undefined;
    }

    return colCache.get(row);
  }

  set(col, row, value) {
    if (this.cachedContent.get(col) === undefined) {
      this.cachedContent.set(col, new Map());
    }

    const rowCache = this.cachedContent.get(col);
    rowCache.set(row, value);
  }

}
function useMockDataGenerator(numCols) {
  let readonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let group = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const cache = react.useRef(new ContentCache());
  const [colsMap, setColsMap] = react.useState(() => getResizableColumns(numCols, group));
  react.useEffect(() => {
    setColsMap(getResizableColumns(numCols, group));
  }, [group, numCols]);
  const onColumnResize = react.useCallback((column, newSize) => {
    setColsMap(prevColsMap => {
      const index = prevColsMap.findIndex(ci => ci.title === column.title);
      const newArray = [...prevColsMap];
      newArray.splice(index, 1, { ...prevColsMap[index],
        width: newSize
      });
      return newArray;
    });
  }, []);
  const cols = react.useMemo(() => {
    return colsMap.map(getGridColumn);
  }, [colsMap]);
  const colsMapRef = react.useRef(colsMap);
  colsMapRef.current = colsMap;
  const getCellContent = react.useCallback(_ref => {
    let [col, row] = _ref;
    let val = cache.current.get(col, row);

    if (val === undefined) {
      val = colsMapRef.current[col].getContent();

      if (!readonly && (0,js/* isTextEditableGridCell */.f)(val)) {
        val = { ...val,
          readonly
        };
      }

      cache.current.set(col, row, val);
    }

    return val;
  }, [readonly]);
  const getCellsForSelection = react.useCallback(selection => {
    const result = [];

    for (let y = selection.y; y < selection.y + selection.height; y++) {
      const row = [];

      for (let x = selection.x; x < selection.x + selection.width; x++) {
        row.push(getCellContent([x, y]));
      }

      result.push(row);
    }

    return result;
  }, [getCellContent]);
  const setCellValueRaw = react.useCallback((_ref2, val) => {
    let [col, row] = _ref2;
    cache.current.set(col, row, val);
  }, []);
  const setCellValue = react.useCallback((_ref3, val) => {
    let [col, row] = _ref3;
    let current = cache.current.get(col, row);

    if (current === undefined) {
      current = colsMap[col].getContent();
    }

    if ((0,js/* isEditableGridCell */.T9)(val) && (0,js/* isEditableGridCell */.T9)(current)) {
      const copied = lossyCopyData(val, current);
      cache.current.set(col, row, { ...copied,
        displayData: typeof copied.data === "string" ? copied.data : copied.displayData,
        lastUpdated: performance.now()
      });
    }
  }, [colsMap]);
  return {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue,
    getCellsForSelection,
    setCellValueRaw
  };
}

function panic() {
  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "This should not happen";
  throw new Error(message);
}

function assertNever(_never) {
  return panic("Hell froze over");
}
;// CONCATENATED MODULE: ./packages/source/src/stories/use-data-source.stories.tsx
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __STORY__ = "import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"react-resize-detector\";\nimport {\n    DataEditor,\n    DataEditorProps,\n    DataEditorRef,\n    GridCellKind,\n    GridColumn,\n    Theme,\n} from \"@glideapps/glide-data-grid\";\nimport faker from \"faker\";\nimport { useCollapsingGroups, useColumnSort, useMoveableColumns } from \"..\";\nimport { useUndoRedo } from \"../use-undo-redo\";\nimport { useMockDataGenerator } from \"./utils\";\n\nfaker.seed(1337);\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {\n    title: \"Extra Packages/Source\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nconst testTheme: Theme = {\n    accentColor: \"#4F5DFF\",\n    accentFg: \"#FFFFFF\",\n    accentLight: \"rgba(62, 116, 253, 0.1)\",\n\n    textDark: \"#313139\",\n    textMedium: \"#737383\",\n    textLight: \"#B2B2C0\",\n    textBubble: \"#313139\",\n\n    bgIconHeader: \"#737383\",\n    fgIconHeader: \"#FFFFFF\",\n    textHeader: \"#313139\",\n    textGroupHeader: \"#313139BB\",\n    textHeaderSelected: \"#FFFFFF\",\n\n    bgCell: \"#FFFFFF\",\n    bgCellMedium: \"#FAFAFB\",\n    bgHeader: \"#F7F7F8\",\n    bgHeaderHasFocus: \"#E9E9EB\",\n    bgHeaderHovered: \"#EFEFF1\",\n\n    bgBubble: \"#EDEDF3\",\n    bgBubbleSelected: \"#FFFFFF\",\n\n    bgSearchResult: \"#fff9e3\",\n\n    borderColor: \"rgba(115, 116, 131, 0.16)\",\n    horizontalBorderColor: \"rgba(115, 116, 131, 0.16)\",\n    drilldownBorder: \"rgba(0, 0, 0, 0)\",\n\n    linkColor: \"#4F5DFF\",\n\n    cellHorizontalPadding: 8,\n    cellVerticalPadding: 3,\n\n    headerFontStyle: \"600 13px\",\n    baseFontStyle: \"13px\",\n    editorFontSize: \"13px\",\n    lineHeight: 1.4,\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst cols: GridColumn[] = [\n    {\n        title: \"A\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"B\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"C\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"D\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"E\",\n        width: 200,\n        group: \"Group 2\",\n    },\n];\n\nexport const UseDataSource: React.VFC = () => {\n    const cache = React.useRef<Record<string, string>>({});\n\n    const rows = 100_000;\n\n    const moveArgs = useMoveableColumns({\n        columns: cols,\n        getCellContent: React.useCallback(([col, row]) => {\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    data: `${row}`,\n                    displayData: `${row}`,\n                };\n            }\n\n            const key = `${col},${row}`;\n            if (cache.current[key] === undefined) {\n                cache.current[key] = faker.name.firstName() + \" \" + faker.name.lastName();\n            }\n            const d = cache.current[key];\n\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: d,\n                displayData: d,\n            };\n        }, []),\n    });\n\n    const [sort, setSort] = React.useState<number>();\n\n    const sortArgs = useColumnSort({\n        columns: moveArgs.columns,\n        getCellContent: moveArgs.getCellContent,\n        rows,\n        sort:\n            sort === undefined\n                ? undefined\n                : {\n                      column: moveArgs.columns[sort],\n                      direction: \"desc\",\n                      mode: \"smart\",\n                  },\n    });\n\n    const collapseArgs = useCollapsingGroups({\n        columns: moveArgs.columns,\n        theme: testTheme,\n        freezeColumns: 0,\n    });\n\n    const onHeaderClick = React.useCallback((index: number) => {\n        setSort(index);\n    }, []);\n\n    return (\n        <BeautifulWrapper title=\"Custom source extensions\" description={<Description>Fixme.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...moveArgs}\n                {...sortArgs}\n                {...collapseArgs}\n                rows={rows}\n                onColumnMoved={moveArgs.onColumnMoved}\n                onHeaderClicked={onHeaderClick}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UseDataSource as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const UndoRedo: React.VFC = () => {\n    const { cols: columns, getCellContent, setCellValue } = useMockDataGenerator(6);\n\n    const gridRef = React.useRef<DataEditorRef>(null);\n\n    const { gridSelection, onCellEdited, onGridSelectionChange, undo, canRedo, canUndo, redo } = useUndoRedo(\n        gridRef,\n        getCellContent,\n        setCellValue\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Undo / Redo Support\"\n            description={\n                <Description>\n                    A simple undo/redo implementation\n                    <MoreInfo>\n                        Use keyboard shortcuts CMD+Z and CMD+SHIFT+Z / CTRL+Z and CTRL+Y. Or click these buttons:\n                        <button onClick={undo} disabled={!canUndo} style={{ opacity: canUndo ? 1 : 0.4 }}>\n                            Undo\n                        </button>\n                        <button onClick={redo} disabled={!canRedo} style={{ opacity: canRedo ? 1 : 0.4 }}>\n                            Redo\n                        </button>\n                    </MoreInfo>\n                    <MoreInfo>\n                        It works by taking a snapshot of the content of a cell before it is edited and replaying any\n                        edits back.\n                    </MoreInfo>\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={gridRef}\n                onCellEdited={onCellEdited}\n                getCellContent={getCellContent}\n                gridSelection={gridSelection ?? undefined}\n                onGridSelectionChange={onGridSelectionChange}\n                columns={columns}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UndoRedo as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n";
var __LOCATIONS_MAP__ = {
  "UseDataSource": {
    "startLoc": {
      "col": 40,
      "line": 225
    },
    "endLoc": {
      "col": 1,
      "line": 296
    },
    "startBody": {
      "col": 40,
      "line": 225
    },
    "endBody": {
      "col": 1,
      "line": 296
    }
  },
  "UndoRedo": {
    "startLoc": {
      "col": 35,
      "line": 303
    },
    "endLoc": {
      "col": 1,
      "line": 347
    },
    "startBody": {
      "col": 35,
      "line": 303
    },
    "endBody": {
      "col": 1,
      "line": 347
    }
  }
};








faker_default().seed(1337);
const SimpleWrapper = (0,styled/* default */.Z)('div')({
  name: "SimpleWrapper",
  class: "ss4kmn3"
});

const SimpleThemeWrapper = p => {
  return react.createElement(SimpleWrapper, null, react.createElement("div", {
    className: "content"
  }, p.children));
};

/* harmony default export */ const use_data_source_stories = ({
  parameters: {
    "storySource": {
      "source": "import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"react-resize-detector\";\nimport {\n    DataEditor,\n    DataEditorProps,\n    DataEditorRef,\n    GridCellKind,\n    GridColumn,\n    Theme,\n} from \"@glideapps/glide-data-grid\";\nimport faker from \"faker\";\nimport { useCollapsingGroups, useColumnSort, useMoveableColumns } from \"..\";\nimport { useUndoRedo } from \"../use-undo-redo\";\nimport { useMockDataGenerator } from \"./utils\";\n\nfaker.seed(1337);\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {\n    title: \"Extra Packages/Source\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nconst testTheme: Theme = {\n    accentColor: \"#4F5DFF\",\n    accentFg: \"#FFFFFF\",\n    accentLight: \"rgba(62, 116, 253, 0.1)\",\n\n    textDark: \"#313139\",\n    textMedium: \"#737383\",\n    textLight: \"#B2B2C0\",\n    textBubble: \"#313139\",\n\n    bgIconHeader: \"#737383\",\n    fgIconHeader: \"#FFFFFF\",\n    textHeader: \"#313139\",\n    textGroupHeader: \"#313139BB\",\n    textHeaderSelected: \"#FFFFFF\",\n\n    bgCell: \"#FFFFFF\",\n    bgCellMedium: \"#FAFAFB\",\n    bgHeader: \"#F7F7F8\",\n    bgHeaderHasFocus: \"#E9E9EB\",\n    bgHeaderHovered: \"#EFEFF1\",\n\n    bgBubble: \"#EDEDF3\",\n    bgBubbleSelected: \"#FFFFFF\",\n\n    bgSearchResult: \"#fff9e3\",\n\n    borderColor: \"rgba(115, 116, 131, 0.16)\",\n    horizontalBorderColor: \"rgba(115, 116, 131, 0.16)\",\n    drilldownBorder: \"rgba(0, 0, 0, 0)\",\n\n    linkColor: \"#4F5DFF\",\n\n    cellHorizontalPadding: 8,\n    cellVerticalPadding: 3,\n\n    headerFontStyle: \"600 13px\",\n    baseFontStyle: \"13px\",\n    editorFontSize: \"13px\",\n    lineHeight: 1.4,\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst cols: GridColumn[] = [\n    {\n        title: \"A\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"B\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"C\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"D\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"E\",\n        width: 200,\n        group: \"Group 2\",\n    },\n];\n\nexport const UseDataSource: React.VFC = () => {\n    const cache = React.useRef<Record<string, string>>({});\n\n    const rows = 100_000;\n\n    const moveArgs = useMoveableColumns({\n        columns: cols,\n        getCellContent: React.useCallback(([col, row]) => {\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    data: `${row}`,\n                    displayData: `${row}`,\n                };\n            }\n\n            const key = `${col},${row}`;\n            if (cache.current[key] === undefined) {\n                cache.current[key] = faker.name.firstName() + \" \" + faker.name.lastName();\n            }\n            const d = cache.current[key];\n\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: d,\n                displayData: d,\n            };\n        }, []),\n    });\n\n    const [sort, setSort] = React.useState<number>();\n\n    const sortArgs = useColumnSort({\n        columns: moveArgs.columns,\n        getCellContent: moveArgs.getCellContent,\n        rows,\n        sort:\n            sort === undefined\n                ? undefined\n                : {\n                      column: moveArgs.columns[sort],\n                      direction: \"desc\",\n                      mode: \"smart\",\n                  },\n    });\n\n    const collapseArgs = useCollapsingGroups({\n        columns: moveArgs.columns,\n        theme: testTheme,\n        freezeColumns: 0,\n    });\n\n    const onHeaderClick = React.useCallback((index: number) => {\n        setSort(index);\n    }, []);\n\n    return (\n        <BeautifulWrapper title=\"Custom source extensions\" description={<Description>Fixme.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...moveArgs}\n                {...sortArgs}\n                {...collapseArgs}\n                rows={rows}\n                onColumnMoved={moveArgs.onColumnMoved}\n                onHeaderClicked={onHeaderClick}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UseDataSource as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const UndoRedo: React.VFC = () => {\n    const { cols: columns, getCellContent, setCellValue } = useMockDataGenerator(6);\n\n    const gridRef = React.useRef<DataEditorRef>(null);\n\n    const { gridSelection, onCellEdited, onGridSelectionChange, undo, canRedo, canUndo, redo } = useUndoRedo(\n        gridRef,\n        getCellContent,\n        setCellValue\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Undo / Redo Support\"\n            description={\n                <Description>\n                    A simple undo/redo implementation\n                    <MoreInfo>\n                        Use keyboard shortcuts CMD+Z and CMD+SHIFT+Z / CTRL+Z and CTRL+Y. Or click these buttons:\n                        <button onClick={undo} disabled={!canUndo} style={{ opacity: canUndo ? 1 : 0.4 }}>\n                            Undo\n                        </button>\n                        <button onClick={redo} disabled={!canRedo} style={{ opacity: canRedo ? 1 : 0.4 }}>\n                            Redo\n                        </button>\n                    </MoreInfo>\n                    <MoreInfo>\n                        It works by taking a snapshot of the content of a cell before it is edited and replaying any\n                        edits back.\n                    </MoreInfo>\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={gridRef}\n                onCellEdited={onCellEdited}\n                getCellContent={getCellContent}\n                gridSelection={gridSelection ?? undefined}\n                onGridSelectionChange={onGridSelectionChange}\n                columns={columns}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UndoRedo as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n",
      "locationsMap": {
        "use-data-source": {
          "startLoc": {
            "col": 40,
            "line": 225
          },
          "endLoc": {
            "col": 1,
            "line": 296
          },
          "startBody": {
            "col": 40,
            "line": 225
          },
          "endBody": {
            "col": 1,
            "line": 296
          }
        },
        "undo-redo": {
          "startLoc": {
            "col": 35,
            "line": 303
          },
          "endLoc": {
            "col": 1,
            "line": 347
          },
          "startBody": {
            "col": 35,
            "line": 303
          },
          "endBody": {
            "col": 1,
            "line": 347
          }
        }
      }
    }
  },
  title: "Extra Packages/Source",
  decorators: [Story => react.createElement(SimpleThemeWrapper, null, react.createElement(Story, null))]
});
const BeautifulStyle = (0,styled/* default */.Z)('div')({
  name: "BeautifulStyle",
  class: "bkh67gx"
});

const BeautifulWrapper = p => {
  const {
    title,
    children,
    description
  } = p;
  const {
    ref,
    width,
    height
  } = (0,index_esm/* useResizeDetector */.NB)();
  return react.createElement(BeautifulStyle, null, react.createElement("h1", null, title), description, react.createElement("div", {
    className: "sizer"
  }, react.createElement("div", {
    className: "sizer-clip",
    ref: ref
  }, react.createElement("div", {
    style: {
      position: "relative",
      width: width !== null && width !== void 0 ? width : 100,
      height: height !== null && height !== void 0 ? height : 100
    }
  }, children))));
};

const Description = (0,styled/* default */.Z)('p')({
  name: "Description",
  class: "d1deot3s"
});
const MoreInfo = (0,styled/* default */.Z)('p')({
  name: "MoreInfo",
  class: "m1ml0sw1"
});
const defaultProps = {
  smoothScrollX: true,
  smoothScrollY: true,
  isDraggable: false,
  rowMarkers: "none",
  width: "100%"
};
const testTheme = {
  accentColor: "#4F5DFF",
  accentFg: "#FFFFFF",
  accentLight: "rgba(62, 116, 253, 0.1)",
  textDark: "#313139",
  textMedium: "#737383",
  textLight: "#B2B2C0",
  textBubble: "#313139",
  bgIconHeader: "#737383",
  fgIconHeader: "#FFFFFF",
  textHeader: "#313139",
  textGroupHeader: "#313139BB",
  textHeaderSelected: "#FFFFFF",
  bgCell: "#FFFFFF",
  bgCellMedium: "#FAFAFB",
  bgHeader: "#F7F7F8",
  bgHeaderHasFocus: "#E9E9EB",
  bgHeaderHovered: "#EFEFF1",
  bgBubble: "#EDEDF3",
  bgBubbleSelected: "#FFFFFF",
  bgSearchResult: "#fff9e3",
  borderColor: "rgba(115, 116, 131, 0.16)",
  horizontalBorderColor: "rgba(115, 116, 131, 0.16)",
  drilldownBorder: "rgba(0, 0, 0, 0)",
  linkColor: "#4F5DFF",
  cellHorizontalPadding: 8,
  cellVerticalPadding: 3,
  headerFontStyle: "600 13px",
  baseFontStyle: "13px",
  editorFontSize: "13px",
  lineHeight: 1.4,
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif"
};
const cols = [{
  title: "A",
  width: 200,
  group: "Group 1"
}, {
  title: "B",
  width: 200,
  group: "Group 1"
}, {
  title: "C",
  width: 200,
  group: "Group 2"
}, {
  title: "D",
  width: 200,
  group: "Group 2"
}, {
  title: "E",
  width: 200,
  group: "Group 2"
}];
const UseDataSource = () => {
  const cache = react.useRef({});
  const rows = 100000;
  const moveArgs = useMoveableColumns({
    columns: cols,
    getCellContent: react.useCallback(_ref => {
      let [col, row] = _ref;

      if (col === 0) {
        return {
          kind: js/* GridCellKind.Text */.p6.Text,
          allowOverlay: true,
          data: `${row}`,
          displayData: `${row}`
        };
      }

      const key = `${col},${row}`;

      if (cache.current[key] === undefined) {
        cache.current[key] = faker_default().name.firstName() + " " + faker_default().name.lastName();
      }

      const d = cache.current[key];
      return {
        kind: js/* GridCellKind.Text */.p6.Text,
        allowOverlay: true,
        data: d,
        displayData: d
      };
    }, [])
  });
  const [sort, setSort] = react.useState();
  const sortArgs = useColumnSort({
    columns: moveArgs.columns,
    getCellContent: moveArgs.getCellContent,
    rows,
    sort: sort === undefined ? undefined : {
      column: moveArgs.columns[sort],
      direction: "desc",
      mode: "smart"
    }
  });
  const collapseArgs = useCollapsingGroups({
    columns: moveArgs.columns,
    theme: testTheme,
    freezeColumns: 0
  });
  const onHeaderClick = react.useCallback(index => {
    setSort(index);
  }, []);
  return react.createElement(BeautifulWrapper, {
    title: "Custom source extensions",
    description: react.createElement(Description, null, "Fixme.")
  }, react.createElement(js/* DataEditor */.Nd, _extends({}, defaultProps, moveArgs, sortArgs, collapseArgs, {
    rows: rows,
    onColumnMoved: moveArgs.onColumnMoved,
    onHeaderClicked: onHeaderClick
  })));
};
;
UseDataSource.parameters = {
  options: {
    showPanel: false
  }
};
const UndoRedo = () => {
  const {
    cols: columns,
    getCellContent,
    setCellValue
  } = useMockDataGenerator(6);
  const gridRef = react.useRef(null);
  const {
    gridSelection,
    onCellEdited,
    onGridSelectionChange,
    undo,
    canRedo,
    canUndo,
    redo
  } = useUndoRedo(gridRef, getCellContent, setCellValue);
  return react.createElement(BeautifulWrapper, {
    title: "Undo / Redo Support",
    description: react.createElement(Description, null, "A simple undo/redo implementation", react.createElement(MoreInfo, null, "Use keyboard shortcuts CMD+Z and CMD+SHIFT+Z / CTRL+Z and CTRL+Y. Or click these buttons:", react.createElement("button", {
      onClick: undo,
      disabled: !canUndo,
      style: {
        opacity: canUndo ? 1 : 0.4
      }
    }, "Undo"), react.createElement("button", {
      onClick: redo,
      disabled: !canRedo,
      style: {
        opacity: canRedo ? 1 : 0.4
      }
    }, "Redo")), react.createElement(MoreInfo, null, "It works by taking a snapshot of the content of a cell before it is edited and replaying any edits back."))
  }, react.createElement(js/* DataEditor */.Nd, _extends({}, defaultProps, {
    ref: gridRef,
    onCellEdited: onCellEdited,
    getCellContent: getCellContent,
    gridSelection: gridSelection !== null && gridSelection !== void 0 ? gridSelection : undefined,
    onGridSelectionChange: onGridSelectionChange,
    columns: columns,
    rows: 1000
  })));
};
UndoRedo.parameters = {
  options: {
    showPanel: false
  }
};

__webpack_require__("./packages/source/src/stories/use-data-source.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/source/src/stories/use-data-source.stories.tsx");

const __namedExportsOrder = ["MoreInfo", "UseDataSource", "UndoRedo"];

/***/ }),

/***/ "./packages/core/src/common/browser-detect.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FR": () => (/* binding */ browserIsOSX),
/* harmony export */   "Pq": () => (/* binding */ browserIsSafari),
/* harmony export */   "uC": () => (/* binding */ browserIsFirefox)
/* harmony export */ });
class Lazy {
  constructor(fn) {
    this.fn = void 0;
    this.val = void 0;
    this.fn = fn;
  }

  get value() {
    var _this$val;

    return (_this$val = this.val) !== null && _this$val !== void 0 ? _this$val : this.val = this.fn();
  }

}

function lazy(fn) {
  return new Lazy(fn);
}

const browserIsFirefox = lazy(() => window.navigator.userAgent.includes("Firefox"));
const browserIsSafari = lazy(() => window.navigator.userAgent.includes("Mac OS") && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome"));
const browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith("mac"));

/***/ }),

/***/ "./packages/core/src/common/styles.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ni": () => (/* binding */ ThemeContext),
/* harmony export */   "Zu": () => (/* binding */ getDataEditorTheme),
/* harmony export */   "be": () => (/* binding */ makeCSSStyle)
/* harmony export */ });
/* unused harmony export useTheme */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");

function makeCSSStyle(theme) {
  var _theme$textGroupHeade, _theme$horizontalBord;

  return {
    "--gdg-accent-color": theme.accentColor,
    "--gdg-accent-fg": theme.accentFg,
    "--gdg-accent-light": theme.accentLight,
    "--gdg-text-dark": theme.textDark,
    "--gdg-text-medium": theme.textMedium,
    "--gdg-text-light": theme.textLight,
    "--gdg-text-bubble": theme.textBubble,
    "--gdg-bg-icon-header": theme.bgIconHeader,
    "--gdg-fg-icon-header": theme.fgIconHeader,
    "--gdg-text-header": theme.textHeader,
    "--gdg-text-group-header": (_theme$textGroupHeade = theme.textGroupHeader) !== null && _theme$textGroupHeade !== void 0 ? _theme$textGroupHeade : theme.textHeader,
    "--gdg-text-header-selected": theme.textHeaderSelected,
    "--gdg-bg-cell": theme.bgCell,
    "--gdg-bg-cell-medium": theme.bgCellMedium,
    "--gdg-bg-header": theme.bgHeader,
    "--gdg-bg-header-has-focus": theme.bgHeaderHasFocus,
    "--gdg-bg-header-hovered": theme.bgHeaderHovered,
    "--gdg-bg-bubble": theme.bgBubble,
    "--gdg-bg-bubble-selected": theme.bgBubbleSelected,
    "--gdg-bg-search-result": theme.bgSearchResult,
    "--gdg-border-color": theme.borderColor,
    "--gdg-horizontal-border-color": (_theme$horizontalBord = theme.horizontalBorderColor) !== null && _theme$horizontalBord !== void 0 ? _theme$horizontalBord : theme.borderColor,
    "--gdg-drilldown-border": theme.drilldownBorder,
    "--gdg-link-color": theme.linkColor,
    "--gdg-cell-horizontal-padding": `${theme.cellHorizontalPadding}px`,
    "--gdg-cell-vertical-padding": `${theme.cellVerticalPadding}px`,
    "--gdg-header-font-style": theme.headerFontStyle,
    "--gdg-base-font-style": theme.baseFontStyle,
    "--gdg-font-family": theme.fontFamily,
    "--gdg-editor-font-size": theme.editorFontSize
  };
}
const dataEditorBaseTheme = {
  accentColor: "#4F5DFF",
  accentFg: "#FFFFFF",
  accentLight: "rgba(62, 116, 253, 0.1)",
  textDark: "#313139",
  textMedium: "#737383",
  textLight: "#B2B2C0",
  textBubble: "#313139",
  bgIconHeader: "#737383",
  fgIconHeader: "#FFFFFF",
  textHeader: "#313139",
  textGroupHeader: "#313139BB",
  textHeaderSelected: "#FFFFFF",
  bgCell: "#FFFFFF",
  bgCellMedium: "#FAFAFB",
  bgHeader: "#F7F7F8",
  bgHeaderHasFocus: "#E9E9EB",
  bgHeaderHovered: "#EFEFF1",
  bgBubble: "#EDEDF3",
  bgBubbleSelected: "#FFFFFF",
  bgSearchResult: "#fff9e3",
  borderColor: "rgba(115, 116, 131, 0.16)",
  drilldownBorder: "rgba(0, 0, 0, 0)",
  linkColor: "#4F5DFF",
  cellHorizontalPadding: 8,
  cellVerticalPadding: 3,
  headerIconSize: 18,
  headerFontStyle: "600 13px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif",
  editorFontSize: "13px",
  lineHeight: 1.4
};
function getDataEditorTheme() {
  return dataEditorBaseTheme;
}
const ThemeContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(dataEditorBaseTheme);
function useTheme() {
  return React.useContext(ThemeContext);
}

/***/ }),

/***/ "./packages/core/src/common/support.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NG": () => (/* binding */ proveType),
/* harmony export */   "hu": () => (/* binding */ assert),
/* harmony export */   "vE": () => (/* binding */ assertNever),
/* harmony export */   "vZ": () => (/* binding */ deepEqual),
/* harmony export */   "wY": () => (/* binding */ maybe)
/* harmony export */ });
function proveType(_val) {}

function panic() {
  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "This should not happen";
  throw new Error(message);
}

function assert(fact) {
  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";
  if (fact) return;
  return panic(message);
}
function assertNever(_never) {
  return panic("Hell froze over");
}
function maybe(fn, defaultValue) {
  try {
    return fn();
  } catch {
    return defaultValue;
  }
}
const has = Object.prototype.hasOwnProperty;
function deepEqual(foo, bar) {
  let ctor, len;
  if (foo === bar) return true;

  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();

    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && deepEqual(foo[len], bar[len]));
      }

      return len === -1;
    }

    if (!ctor || typeof foo === "object") {
      len = 0;

      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !deepEqual(foo[ctor], bar[ctor])) return false;
      }

      return Object.keys(bar).length === len;
    }
  }

  return foo !== foo && bar !== bar;
}

/***/ }),

/***/ "./packages/core/src/common/utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ht": () => (/* binding */ degreesToRadians),
/* harmony export */   "Iz": () => (/* binding */ getScrollBarWidth),
/* harmony export */   "MC": () => (/* binding */ Checkmark),
/* harmony export */   "OR": () => (/* binding */ useEventListener),
/* harmony export */   "Qy": () => (/* binding */ useDebouncedMemo),
/* harmony export */   "Wy": () => (/* binding */ EditPencil),
/* harmony export */   "ig": () => (/* binding */ useStateWithReactiveInput),
/* harmony export */   "o7": () => (/* binding */ direction),
/* harmony export */   "qJ": () => (/* binding */ whenDefined)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1__);


function useEventListener(eventName, handler, element, passive) {
  let capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  const savedHandler = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  savedHandler.current = handler;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (element === null || element.addEventListener === undefined) return;
    const el = element;

    const eventListener = event => {
      var _savedHandler$current;

      (_savedHandler$current = savedHandler.current) === null || _savedHandler$current === void 0 ? void 0 : _savedHandler$current.call(el, event);
    };

    el.addEventListener(eventName, eventListener, {
      passive,
      capture
    });
    return () => {
      el.removeEventListener(eventName, eventListener, {
        capture
      });
    };
  }, [eventName, element, passive, capture]);
}
function whenDefined(obj, result) {
  return obj === undefined ? undefined : result;
}
const PI = Math.PI;
function degreesToRadians(degrees) {
  return degrees * PI / 180;
}
const EditPencil = props => {
  var _props$fgColor;

  const fg = (_props$fgColor = props.fgColor) !== null && _props$fgColor !== void 0 ? _props$fgColor : "currentColor";
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }));
};
const Checkmark = props => {
  var _props$fgColor2;

  const fg = (_props$fgColor2 = props.fgColor) !== null && _props$fgColor2 !== void 0 ? _props$fgColor2 : "currentColor";
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M19 6L10.3802 17L5.34071 11.8758",
    vectorEffect: "non-scaling-stroke",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
function useDebouncedMemo(factory, deps, time) {
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(factory);
  const mountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => {
    mountedRef.current = false;
  }, []);
  const debouncedSetState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1___default()(x => {
    if (mountedRef.current) {
      setState(x);
    }
  }, time));
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (mountedRef.current) {
      debouncedSetState.current(() => factory());
    }
  }, deps);
  return state;
}
const rtlRange = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
const ltrRange = "A-Za-z\u00C0-\u00D6\u00D8-\u00F6" + "\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C" + "\uFE00-\uFE6F\uFEFD-\uFFFF";
const rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
const ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");
function direction(value) {
  return rtl.test(value) ? "rtl" : ltr.test(value) ? "ltr" : "neutral";
}
let scrollbarWidthCache = undefined;
function getScrollBarWidth() {
  if (scrollbarWidthCache !== undefined) return scrollbarWidthCache;
  const inner = document.createElement("p");
  inner.style.width = "100%";
  inner.style.height = "200px";
  const outer = document.createElement("div");
  outer.id = "testScrollbar";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.append(inner);
  document.body.append(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;

  if (w1 === w2) {
    w2 = outer.clientWidth;
  }

  outer.remove();
  scrollbarWidthCache = w1 - w2;
  return scrollbarWidthCache;
}
const empty = Symbol();
function useStateWithReactiveInput(inputState) {
  const inputStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([empty, inputState]);

  if (inputStateRef.current[1] !== inputState) {
    inputStateRef.current[0] = inputState;
  }

  inputStateRef.current[1] = inputState;
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(inputState);
  const [, forceRender] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const setStateOuter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(nv => {
    const s = inputStateRef.current[0];

    if (s !== empty) {
      nv = typeof nv === "function" ? nv(s) : nv;
      if (nv === s) return;
    }

    if (s !== empty) forceRender({});
    setState(pv => {
      if (typeof nv === "function") {
        return nv(s === empty ? pv : s);
      }

      return nv;
    });
    inputStateRef.current[0] = empty;
  }, []);
  const onEmpty = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    inputStateRef.current[0] = empty;
    forceRender({});
  }, []);
  return [inputStateRef.current[0] === empty ? state : inputStateRef.current[0], setStateOuter, onEmpty];
}

/***/ }),

/***/ "./packages/core/src/data-editor/data-editor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "N": () => (/* binding */ DataEditor)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./packages/core/src/common/support.ts
var support = __webpack_require__("./packages/core/src/common/support.ts");
// EXTERNAL MODULE: ./node_modules/lodash/clamp.js
var clamp = __webpack_require__("./node_modules/lodash/clamp.js");
var clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);
// EXTERNAL MODULE: ./node_modules/lodash/uniq.js
var uniq = __webpack_require__("./node_modules/lodash/uniq.js");
var uniq_default = /*#__PURE__*/__webpack_require__.n(uniq);
// EXTERNAL MODULE: ./node_modules/lodash/flatten.js
var flatten = __webpack_require__("./node_modules/lodash/flatten.js");
var flatten_default = /*#__PURE__*/__webpack_require__.n(flatten);
// EXTERNAL MODULE: ./node_modules/lodash/range.js
var range = __webpack_require__("./node_modules/lodash/range.js");
var range_default = /*#__PURE__*/__webpack_require__.n(range);
// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__("./node_modules/lodash/debounce.js");
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__("./node_modules/react-dom/index.js");
;// CONCATENATED MODULE: ./packages/core/src/click-outside-container/click-outside-container.tsx
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }


class ClickOutsideContainer extends react.PureComponent {
  constructor() {
    super(...arguments);
    this.wrapperRef = react.createRef();

    this.clickOutside = event => {
      if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target)) {
        let node = event.target;

        while (node !== null) {
          if (node.classList.contains("click-outside-ignore")) {
            return;
          }

          node = node.parentElement;
        }

        this.props.onClickOutside();
      }
    };
  }

  componentDidMount() {
    document.addEventListener("mousedown", this.clickOutside, true);
    document.addEventListener("contextmenu", this.clickOutside, true);
  }

  componentWillUnmount() {
    document.removeEventListener("mousedown", this.clickOutside);
    document.removeEventListener("contextmenu", this.clickOutside);
  }

  render() {
    const {
      onClickOutside,
      ...rest
    } = this.props;
    return react.createElement("div", _extends({}, rest, {
      ref: this.wrapperRef
    }), this.props.children);
  }

}
// EXTERNAL MODULE: ./packages/core/src/common/styles.ts
var styles = __webpack_require__("./packages/core/src/common/styles.ts");
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-types.ts
var data_grid_types = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx


const _exp = () => p => p.targetY;

const _exp2 = () => p => p.targetX - 1;

const _exp3 = () => p => p.targetY - 1;

const _exp4 = () => p => p.targetWidth + 2;

const _exp5 = () => p => p.targetHeight + 2;

const _exp6 = () => p => p.targetY + 10;

const _exp7 = () => p => Math.max(0, (p.targetHeight - 28) / 2);

const DataGridOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "DataGridOverlayEditorStyle",
  class: "dpsd959",
  vars: {
    "dpsd959-0": [_exp(), "px"],
    "dpsd959-1": [_exp2(), "px"],
    "dpsd959-2": [_exp3(), "px"],
    "dpsd959-3": [_exp4(), "px"],
    "dpsd959-4": [_exp5(), "px"],
    "dpsd959-5": [_exp6(), "px"],
    "dpsd959-6": [_exp7(), "px"]
  }
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/use-stay-on-screen.ts


function useRefState() {
  const [refState, setRefState] = react.useState();
  return [refState !== null && refState !== void 0 ? refState : undefined, setRefState];
}

function useStayOnScreen() {
  const [ref, setRef] = useRefState();
  const [xOffset, setXOffset] = react.useState(0);
  const [isIntersecting, setIsIntersecting] = react.useState(true);
  react.useLayoutEffect(() => {
    if (ref === undefined) return;
    if (!("IntersectionObserver" in window)) return;
    const observer = new IntersectionObserver(ents => {
      if (ents.length === 0) return;
      setIsIntersecting(ents[0].isIntersecting);
    }, {
      threshold: 1
    });
    observer.observe(ref);
    return () => observer.disconnect();
  }, [ref]);
  react.useEffect(() => {
    if (isIntersecting || ref === undefined) return;
    let rafHandle;

    const fn = () => {
      const {
        right: refRight
      } = ref.getBoundingClientRect();
      setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));
      rafHandle = requestAnimationFrame(fn);
    };

    rafHandle = requestAnimationFrame(fn);
    return () => {
      if (rafHandle !== undefined) {
        cancelAnimationFrame(rafHandle);
      }
    };
  }, [ref, isIntersecting]);
  const style = react.useMemo(() => {
    return {
      transform: `translateX(${xOffset}px)`
    };
  }, [xOffset]);
  return {
    ref: setRef,
    style
  };
}
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor.tsx








const DataGridOverlayEditor = p => {
  const {
    target,
    content,
    onFinishEditing: onFinishEditingIn,
    forceEditMode,
    initialValue,
    imageEditorOverride,
    markdownDivCreateNode,
    highlight,
    className,
    theme,
    id,
    cell,
    validateCell,
    getCellRenderer,
    provideEditor
  } = p;
  const [tempValue, setTempValueRaw] = react.useState(forceEditMode ? content : undefined);
  const lastValueRef = react.useRef(tempValue !== null && tempValue !== void 0 ? tempValue : content);
  lastValueRef.current = tempValue !== null && tempValue !== void 0 ? tempValue : content;
  const [isValid, setIsValid] = react.useState(() => {
    if (validateCell === undefined) return true;
    return !((0,data_grid_types/* isEditableGridCell */.T9)(content) && (validateCell === null || validateCell === void 0 ? void 0 : validateCell(cell, content, lastValueRef.current)) === false);
  });
  const onFinishEditing = react.useCallback((newCell, movement) => {
    onFinishEditingIn(isValid ? newCell : undefined, movement);
  }, [isValid, onFinishEditingIn]);
  const setTempValue = react.useCallback(newVal => {
    if (validateCell !== undefined && newVal !== undefined && (0,data_grid_types/* isEditableGridCell */.T9)(newVal)) {
      const validResult = validateCell(cell, newVal, lastValueRef.current);

      if (validResult === false) {
        setIsValid(false);
      } else if (typeof validResult === "object") {
        newVal = validResult;
        setIsValid(true);
      } else {
        setIsValid(true);
      }
    }

    setTempValueRaw(newVal);
  }, [cell, validateCell]);
  const finished = react.useRef(false);
  const customMotion = react.useRef(undefined);
  const onClickOutside = react.useCallback(() => {
    onFinishEditing(tempValue, [0, 0]);
    finished.current = true;
  }, [tempValue, onFinishEditing]);
  const onEditorFinished = react.useCallback(newValue => {
    var _customMotion$current;

    onFinishEditing(newValue, (_customMotion$current = customMotion.current) !== null && _customMotion$current !== void 0 ? _customMotion$current : [0, 0]);
    finished.current = true;
  }, [onFinishEditing]);
  const onKeyDown = react.useCallback(async event => {
    let save = false;

    if (event.key === "Escape") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 0];
    } else if (event.key === "Enter" && !event.shiftKey) {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 1];
      save = true;
    } else if (event.key === "Tab") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [event.shiftKey ? -1 : 1, 0];
      save = true;
    }

    window.setTimeout(() => {
      if (!finished.current && customMotion.current !== undefined) {
        onFinishEditing(save ? tempValue : undefined, customMotion.current);
        finished.current = true;
      }
    }, 0);
  }, [onFinishEditing, tempValue]);
  const targetValue = tempValue !== null && tempValue !== void 0 ? tempValue : content;
  const [editorProvider, useLabel] = react.useMemo(() => {
    var _getCellRenderer, _getCellRenderer$prov;

    if ((0,data_grid_types/* isInnerOnlyCell */.rs)(content)) return [];
    const external = provideEditor === null || provideEditor === void 0 ? void 0 : provideEditor(content);
    if (external !== undefined) return [external, false];
    return [(_getCellRenderer = getCellRenderer(content)) === null || _getCellRenderer === void 0 ? void 0 : (_getCellRenderer$prov = _getCellRenderer.provideEditor) === null || _getCellRenderer$prov === void 0 ? void 0 : _getCellRenderer$prov.call(_getCellRenderer, content), false];
  }, [content, getCellRenderer, provideEditor]);
  const {
    ref,
    style: stayOnScreenStyle
  } = useStayOnScreen();
  let pad = true;
  let editor;
  let style = true;
  let styleOverride;

  if (editorProvider !== undefined) {
    pad = editorProvider.disablePadding !== true;
    style = editorProvider.disableStyling !== true;
    const isObjectEditor = (0,data_grid_types/* isObjectEditorCallbackResult */.DP)(editorProvider);

    if (isObjectEditor) {
      styleOverride = editorProvider.styleOverride;
    }

    const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;
    editor = react.createElement(CustomEditor, {
      isHighlighted: highlight,
      onChange: setTempValue,
      value: targetValue,
      initialValue: initialValue,
      onFinishedEditing: onEditorFinished,
      validatedSelection: (0,data_grid_types/* isEditableGridCell */.T9)(targetValue) ? targetValue.selectionRange : undefined,
      forceEditMode: forceEditMode,
      target: target,
      imageEditorOverride: imageEditorOverride,
      markdownDivCreateNode: markdownDivCreateNode,
      isValid: isValid
    });
  }

  styleOverride = { ...styleOverride,
    ...stayOnScreenStyle
  };
  const portalElement = document.getElementById("portal");

  if (portalElement === null) {
    console.error('Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id="portal" />` as the last child of your `<body>`.');
    return null;
  }

  let classWrap = style ? "gdg-style" : "gdg-unstyle";

  if (!isValid) {
    classWrap += " invalid";
  }

  if (pad) {
    classWrap += " pad";
  }

  return (0,react_dom.createPortal)(react.createElement(styles/* ThemeContext.Provider */.Ni.Provider, {
    value: theme
  }, react.createElement(ClickOutsideContainer, {
    style: (0,styles/* makeCSSStyle */.be)(theme),
    className: className,
    onClickOutside: onClickOutside
  }, react.createElement(DataGridOverlayEditorStyle, {
    ref: ref,
    id: id,
    className: classWrap,
    style: styleOverride,
    as: useLabel === true ? "label" : undefined,
    targetX: target.x,
    targetY: target.y,
    targetWidth: target.width,
    targetHeight: target.height
  }, react.createElement("div", {
    className: "clip-region",
    onKeyDown: onKeyDown
  }, editor)))), portalElement);
};

/* harmony default export */ const data_grid_overlay_editor = (DataGridOverlayEditor);
// EXTERNAL MODULE: ./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx + 3 modules
var scrolling_data_grid = __webpack_require__("./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-search/data-grid-search-style.tsx


const data_grid_search_style_exp = () => p => p.showSearch ? 0 : 400;

const SearchWrapper = (0,styled/* default */.Z)('div')({
  name: "SearchWrapper",
  class: "s11k75lr",
  vars: {
    "s11k75lr-0": [data_grid_search_style_exp(), "px"]
  }
});

__webpack_require__("./packages/core/src/data-grid-search/data-grid-search-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-search/data-grid-search-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-search/data-grid-search.tsx





const upArrow = react.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 244l144-144 144 144M256 120v292"
}));
const downArrow = react.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 268l144 144 144-144M256 392V100"
}));
const closeX = react.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "32",
  d: "M368 368L144 144M368 144L144 368"
}));
const targetSearchTimeMS = 10;

const DataGridSearch = p => {
  const {
    canvasRef,
    cellYOffset,
    rows,
    columns,
    searchInputRef,
    getCellsForSelection,
    onSearchResultsChanged,
    showSearch = false,
    onSearchClose
  } = p;
  const [searchID] = react.useState(() => "search-box-" + Math.round(Math.random() * 1000));
  const [searchString, setSearchString] = react.useState("");
  const [searchStatus, setSearchStatus] = react.useState();
  const searchStatusRef = react.useRef(searchStatus);
  searchStatusRef.current = searchStatus;
  const abortControllerRef = react.useRef(new AbortController());
  const searchHandle = react.useRef();
  const [searchResults, setSearchResults] = react.useState([]);
  const cancelSearch = react.useCallback(() => {
    if (searchHandle.current !== undefined) {
      window.cancelAnimationFrame(searchHandle.current);
      searchHandle.current = undefined;
      abortControllerRef.current.abort();
    }
  }, []);
  const cellYOffsetRef = react.useRef(cellYOffset);
  cellYOffsetRef.current = cellYOffset;
  const beginSearch = react.useCallback(str => {
    const regex = new RegExp(str.replace(/([$()*+.?[\\\]^{|}-])/g, "\\$1"), "i");
    let startY = cellYOffsetRef.current;
    let searchStride = Math.min(10, rows);
    let rowsSearched = 0;
    setSearchStatus(undefined);
    setSearchResults([]);
    const runningResult = [];

    const tick = async () => {
      var _searchStatusRef$curr, _searchStatusRef$curr2;

      if (getCellsForSelection === undefined) return;
      const tStart = performance.now();
      const rowsLeft = rows - rowsSearched;
      let data = getCellsForSelection({
        x: 0,
        y: startY,
        width: columns.length,
        height: Math.min(searchStride, rowsLeft, rows - startY)
      }, abortControllerRef.current.signal);

      if (typeof data === "function") {
        data = await data();
      }

      let added = false;

      for (const [row, d] of data.entries()) {
        for (const [col, cell] of d.entries()) {
          let testString;

          switch (cell.kind) {
            case data_grid_types/* GridCellKind.Text */.p6.Text:
            case data_grid_types/* GridCellKind.Number */.p6.Number:
              testString = cell.displayData;
              break;

            case data_grid_types/* GridCellKind.Uri */.p6.Uri:
            case data_grid_types/* GridCellKind.Markdown */.p6.Markdown:
              testString = cell.data;
              break;

            case data_grid_types/* GridCellKind.Boolean */.p6.Boolean:
              testString = typeof cell.data === "boolean" ? cell.data.toString() : undefined;
              break;

            case data_grid_types/* GridCellKind.Image */.p6.Image:
            case data_grid_types/* GridCellKind.Bubble */.p6.Bubble:
              testString = cell.data.join("🐳");
              break;

            case data_grid_types/* GridCellKind.Custom */.p6.Custom:
              testString = cell.copyData;
              break;
          }

          if (testString !== undefined && regex.test(testString)) {
            runningResult.push([col, row + startY]);
            added = true;
          }
        }
      }

      const tEnd = performance.now();

      if (added) {
        setSearchResults([...runningResult]);
      }

      rowsSearched += data.length;
      (0,support/* assert */.hu)(rowsSearched <= rows);
      const selectedIndex = (_searchStatusRef$curr = (_searchStatusRef$curr2 = searchStatusRef.current) === null || _searchStatusRef$curr2 === void 0 ? void 0 : _searchStatusRef$curr2.selectedIndex) !== null && _searchStatusRef$curr !== void 0 ? _searchStatusRef$curr : -1;
      setSearchStatus({
        results: runningResult.length,
        rowsSearched,
        selectedIndex
      });
      onSearchResultsChanged === null || onSearchResultsChanged === void 0 ? void 0 : onSearchResultsChanged(runningResult, selectedIndex);

      if (startY + searchStride >= rows) {
        startY = 0;
      } else {
        startY += searchStride;
      }

      const tElapsed = tEnd - tStart;
      const rounded = Math.max(tElapsed, 1);
      const scalar = targetSearchTimeMS / rounded;
      searchStride = Math.ceil(searchStride * scalar);

      if (rowsSearched < rows && runningResult.length < 1000) {
        searchHandle.current = window.requestAnimationFrame(tick);
      }
    };

    cancelSearch();
    searchHandle.current = window.requestAnimationFrame(tick);
  }, [cancelSearch, columns.length, getCellsForSelection, onSearchResultsChanged, rows]);
  const onClose = react.useCallback(() => {
    var _canvasRef$current;

    onSearchClose === null || onSearchClose === void 0 ? void 0 : onSearchClose();
    setSearchStatus(undefined);
    setSearchResults([]);
    onSearchResultsChanged === null || onSearchResultsChanged === void 0 ? void 0 : onSearchResultsChanged([], -1);
    cancelSearch();
    canvasRef === null || canvasRef === void 0 ? void 0 : (_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 ? void 0 : _canvasRef$current.focus();
  }, [cancelSearch, canvasRef, onSearchClose, onSearchResultsChanged]);
  const onSearchChange = react.useCallback(event => {
    setSearchString(event.target.value);

    if (event.target.value === "") {
      setSearchStatus(undefined);
      setSearchResults([]);
      cancelSearch();
    } else {
      beginSearch(event.target.value);
    }
  }, [beginSearch, cancelSearch]);
  react.useEffect(() => {
    if (showSearch && searchInputRef.current !== null) {
      setSearchString("");
      searchInputRef.current.focus({
        preventScroll: true
      });
    }
  }, [showSearch, searchInputRef]);
  const onNext = react.useCallback(ev => {
    var _ev$stopPropagation;

    ev === null || ev === void 0 ? void 0 : (_ev$stopPropagation = ev.stopPropagation) === null || _ev$stopPropagation === void 0 ? void 0 : _ev$stopPropagation.call(ev);
    if (searchStatus === undefined) return;
    const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;
    setSearchStatus({ ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged === null || onSearchResultsChanged === void 0 ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [searchStatus, onSearchResultsChanged, searchResults]);
  const onPrev = react.useCallback(ev => {
    var _ev$stopPropagation2;

    ev === null || ev === void 0 ? void 0 : (_ev$stopPropagation2 = ev.stopPropagation) === null || _ev$stopPropagation2 === void 0 ? void 0 : _ev$stopPropagation2.call(ev);
    if (searchStatus === undefined) return;
    let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;
    if (newIndex < 0) newIndex += searchStatus.results;
    setSearchStatus({ ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged === null || onSearchResultsChanged === void 0 ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [onSearchResultsChanged, searchResults, searchStatus]);
  const onSearchKeyDown = react.useCallback(event => {
    if ((event.ctrlKey || event.metaKey) && event.nativeEvent.code === "KeyF" || event.key === "Escape") {
      onClose();
      event.stopPropagation();
      event.preventDefault();
    } else if (event.key === "Enter") {
      if (event.shiftKey) {
        onPrev();
      } else {
        onNext();
      }
    }
  }, [onClose, onNext, onPrev]);
  react.useEffect(() => {
    return () => {
      cancelSearch();
    };
  }, [cancelSearch]);
  const searchbox = react.useMemo(() => {
    var _searchStatus$rowsSea, _searchStatus$results, _searchStatus$results2;

    let resultString;

    if (searchStatus !== undefined) {
      resultString = searchStatus.results >= 1000 ? `over 1000` : `${searchStatus.results} result${searchStatus.results !== 1 ? "s" : ""}`;

      if (searchStatus.selectedIndex >= 0) {
        resultString = `${searchStatus.selectedIndex + 1} of ${resultString}`;
      }
    }

    const cancelEvent = ev => {
      ev.stopPropagation();
    };

    const rowsSearchedProgress = Math.floor(((_searchStatus$rowsSea = searchStatus === null || searchStatus === void 0 ? void 0 : searchStatus.rowsSearched) !== null && _searchStatus$rowsSea !== void 0 ? _searchStatus$rowsSea : 0) / rows * 100);
    const progressStyle = {
      width: `${rowsSearchedProgress}%`
    };
    return react.createElement(SearchWrapper, {
      showSearch: showSearch,
      onMouseDown: cancelEvent,
      onMouseMove: cancelEvent,
      onMouseUp: cancelEvent,
      onClick: cancelEvent
    }, react.createElement("div", {
      className: "search-bar-inner"
    }, react.createElement("input", {
      id: searchID,
      "aria-hidden": !showSearch,
      "data-testid": "search-input",
      ref: searchInputRef,
      onChange: onSearchChange,
      value: searchString,
      tabIndex: showSearch ? undefined : -1,
      onKeyDownCapture: onSearchKeyDown
    }), react.createElement("button", {
      "aria-label": "Previous Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? undefined : -1,
      onClick: onPrev,
      disabled: ((_searchStatus$results = searchStatus === null || searchStatus === void 0 ? void 0 : searchStatus.results) !== null && _searchStatus$results !== void 0 ? _searchStatus$results : 0) === 0
    }, upArrow), react.createElement("button", {
      "aria-label": "Next Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? undefined : -1,
      onClick: onNext,
      disabled: ((_searchStatus$results2 = searchStatus === null || searchStatus === void 0 ? void 0 : searchStatus.results) !== null && _searchStatus$results2 !== void 0 ? _searchStatus$results2 : 0) === 0
    }, downArrow), onSearchClose !== undefined && react.createElement("button", {
      "aria-label": "Close Search",
      "aria-hidden": !showSearch,
      "data-testid": "search-close-button",
      tabIndex: showSearch ? undefined : -1,
      onClick: onClose
    }, closeX)), searchStatus !== undefined ? react.createElement(react.Fragment, null, react.createElement("div", {
      className: "search-status"
    }, react.createElement("div", {
      "data-testid": "search-result-area"
    }, resultString)), react.createElement("div", {
      className: "search-progress",
      style: progressStyle
    })) : react.createElement("div", {
      className: "search-status"
    }, react.createElement("label", {
      htmlFor: searchID
    }, "Type to search")));
  }, [onClose, onNext, onPrev, onSearchChange, onSearchClose, onSearchKeyDown, rows, searchStatus, searchString, showSearch, searchID, searchInputRef]);
  return react.createElement(react.Fragment, null, react.createElement(scrolling_data_grid/* default */.Z, {
    prelightCells: searchResults,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    className: p.className,
    clientSize: p.clientSize,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    initialSize: p.initialSize,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    onVisibleRegionChanged: p.onVisibleRegionChanged,
    overscrollX: p.overscrollX,
    overscrollY: p.overscrollY,
    preventDiagonalScrolling: p.preventDiagonalScrolling,
    rightElement: p.rightElement,
    rightElementProps: p.rightElementProps,
    rowHeight: p.rowHeight,
    rows: p.rows,
    scrollRef: p.scrollRef,
    selection: p.selection,
    showMinimap: p.showMinimap,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    scrollToEnd: p.scrollToEnd
  }), searchbox);
};

/* harmony default export */ const data_grid_search = (DataGridSearch);
// EXTERNAL MODULE: ./packages/core/src/common/browser-detect.ts
var browser_detect = __webpack_require__("./packages/core/src/common/browser-detect.ts");
// EXTERNAL MODULE: ./packages/core/src/common/utils.tsx
var utils = __webpack_require__("./packages/core/src/common/utils.tsx");
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-lib.ts
var data_grid_lib = __webpack_require__("./packages/core/src/data-grid/data-grid-lib.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-editor/group-rename.tsx




const group_rename_exp = () => p => Math.max(16, p.targetHeight - 10);

const RenameInput = (0,styled/* default */.Z)('input')({
  name: "RenameInput",
  class: "r1fzhvm4",
  vars: {
    "r1fzhvm4-0": [group_rename_exp(), "px"]
  }
});
const GroupRename = p => {
  const {
    bounds,
    group,
    onClose,
    canvasBounds,
    onFinish
  } = p;
  const [value, setValue] = react.useState(group);
  return react.createElement(ClickOutsideContainer, {
    style: {
      position: "absolute",
      left: bounds.x - canvasBounds.left + 1,
      top: bounds.y - canvasBounds.top,
      width: bounds.width - 2,
      height: bounds.height
    },
    className: "c181oggi",
    onClickOutside: onClose
  }, react.createElement(RenameInput, {
    targetHeight: bounds.height,
    "data-testid": "group-rename-input",
    value: value,
    onBlur: onClose,
    onFocus: e => e.target.setSelectionRange(0, value.length),
    onChange: e => setValue(e.target.value),
    onKeyDown: e => {
      if (e.key === "Enter") {
        onFinish(value);
      } else if (e.key === "Escape") {
        onClose();
      }
    },
    autoFocus: true
  }));
};

__webpack_require__("./packages/core/src/data-editor/group-rename.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/group-rename.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-editor/use-column-sizer.ts


const defaultSize = 150;

function measureCell(ctx, cell, theme, getCellRenderer) {
  var _r$measure, _r$measure2;

  if (cell.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom) return defaultSize;
  const r = getCellRenderer(cell);
  return (_r$measure = r === null || r === void 0 ? void 0 : (_r$measure2 = r.measure) === null || _r$measure2 === void 0 ? void 0 : _r$measure2.call(r, ctx, cell, theme)) !== null && _r$measure !== void 0 ? _r$measure : defaultSize;
}

function measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, removeOutliers, getCellRenderer) {
  let sizes = [];

  if (selectedData !== undefined) {
    sizes.push(...selectedData.map(row => row[colIndex]).map(cell => measureCell(ctx, cell, theme, getCellRenderer)));
  }

  if (sizes.length > 5 && removeOutliers) {
    const average = sizes.reduce((a, b) => a + b) / sizes.length;
    sizes = sizes.filter(a => a < average * 2);
  }

  sizes.push(ctx.measureText(c.title).width + 16 + (c.icon === undefined ? 0 : 28));
  const biggest = Math.max(...sizes);
  const final = Math.max(Math.ceil(minColumnWidth), Math.min(Math.floor(maxColumnWidth), Math.ceil(biggest)));
  return { ...c,
    width: final
  };
}
function useColumnSizer(columns, rows, getCellsForSelection, clientWidth, minColumnWidth, maxColumnWidth, theme, getCellRenderer, abortController) {
  const rowsRef = react.useRef(rows);
  const getCellsForSelectionRef = react.useRef(getCellsForSelection);
  const themeRef = react.useRef(theme);
  rowsRef.current = rows;
  getCellsForSelectionRef.current = getCellsForSelection;
  themeRef.current = theme;
  const [ctx] = react.useState(() => {
    if (typeof window === "undefined") return null;
    const offscreen = document.createElement("canvas");
    offscreen.style["display"] = "none";
    offscreen.style["opacity"] = "0";
    offscreen.style["position"] = "fixed";
    document.documentElement.append(offscreen);
    return offscreen.getContext("2d", {
      alpha: false
    });
  });
  const memoMap = react.useRef({});
  const lastColumns = react.useRef();
  const [selectedData, setSelectionData] = react.useState();
  react.useLayoutEffect(() => {
    const getCells = getCellsForSelectionRef.current;
    if (getCells === undefined || columns.every(data_grid_types/* isSizedGridColumn */.Sq)) return;
    let computeRows = Math.max(1, 10 - Math.floor(columns.length / 10000));
    let tailRows = 0;

    if (computeRows < rowsRef.current && computeRows > 1) {
      computeRows--;
      tailRows = 1;
    }

    const computeArea = {
      x: 0,
      y: 0,
      width: columns.length,
      height: Math.min(rowsRef.current, computeRows)
    };
    const tailComputeArea = {
      x: 0,
      y: rowsRef.current - 1,
      width: columns.length,
      height: 1
    };

    const fn = async () => {
      const getResult = getCells(computeArea, abortController.signal);
      const tailGetResult = tailRows > 0 ? getCells(tailComputeArea, abortController.signal) : undefined;
      let toSet;

      if (typeof getResult === "object") {
        toSet = getResult;
      } else {
        toSet = await (0,data_grid_types/* resolveCellsThunk */.rL)(getResult);
      }

      if (tailGetResult !== undefined) {
        if (typeof tailGetResult === "object") {
          toSet = [...toSet, ...tailGetResult];
        } else {
          toSet = [...toSet, ...(await (0,data_grid_types/* resolveCellsThunk */.rL)(tailGetResult))];
        }
      }

      lastColumns.current = columns;
      setSelectionData(toSet);
    };

    void fn();
  }, [abortController.signal, columns]);
  return react.useMemo(() => {
    const getRaw = () => {
      if (columns.every(data_grid_types/* isSizedGridColumn */.Sq)) {
        return columns;
      }

      if (ctx === null) {
        return columns.map(c => {
          if ((0,data_grid_types/* isSizedGridColumn */.Sq)(c)) return c;
          return { ...c,
            width: defaultSize
          };
        });
      }

      ctx.font = `${themeRef.current.baseFontStyle} ${themeRef.current.fontFamily}`;
      return columns.map((c, colIndex) => {
        if ((0,data_grid_types/* isSizedGridColumn */.Sq)(c)) return c;

        if (memoMap.current[c.id] !== undefined) {
          return { ...c,
            width: memoMap.current[c.id]
          };
        }

        if (selectedData === undefined || lastColumns.current !== columns || c.id === undefined) {
          return { ...c,
            width: defaultSize
          };
        }

        const r = measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, true, getCellRenderer);
        memoMap.current[c.id] = r.width;
        return r;
      });
    };

    let result = getRaw();
    let totalWidth = 0;
    let totalGrow = 0;
    const distribute = [];

    for (const [i, c] of result.entries()) {
      totalWidth += c.width;

      if (c.grow !== undefined && c.grow > 0) {
        totalGrow += c.grow;
        distribute.push(i);
      }
    }

    if (totalWidth < clientWidth && distribute.length > 0) {
      const writeable = [...result];
      const extra = clientWidth - totalWidth;
      let remaining = extra;

      for (let di = 0; di < distribute.length; di++) {
        var _result$i$grow;

        const i = distribute[di];
        const weighted = ((_result$i$grow = result[i].grow) !== null && _result$i$grow !== void 0 ? _result$i$grow : 0) / totalGrow;
        const toAdd = di === distribute.length - 1 ? remaining : Math.min(remaining, Math.floor(extra * weighted));
        writeable[i] = { ...result[i],
          growOffset: toAdd,
          width: result[i].width + toAdd
        };
        remaining -= toAdd;
      }

      result = writeable;
    }

    return result;
  }, [clientWidth, columns, ctx, selectedData, theme, minColumnWidth, maxColumnWidth, getCellRenderer]);
}
;// CONCATENATED MODULE: ./packages/core/src/common/is-hotkey.ts


function checkKey(key, args) {
  if (key === undefined) return false;

  if (key.length > 1 && key.startsWith("_")) {
    const keycode = Number.parseInt(key.slice(1));
    if (keycode !== args.keyCode) return false;
  } else {
    if (key !== args.key) return false;
  }

  return true;
}

function isHotkey(hotkey, args) {
  if (hotkey.length === 0) return false;
  let wantCtrl = false;
  let wantShift = false;
  let wantAlt = false;
  let wantMeta = false;
  const split = hotkey.split("+");
  const key = split.pop();
  if (!checkKey(key, args)) return false;

  for (const accel of split) {
    switch (accel) {
      case "ctrl":
        wantCtrl = true;
        break;

      case "shift":
        wantShift = true;
        break;

      case "alt":
        wantAlt = true;
        break;

      case "meta":
        wantMeta = true;
        break;

      case "primary":
        if (browser_detect/* browserIsOSX.value */.FR.value) {
          wantMeta = true;
        } else {
          wantCtrl = true;
        }

        break;
    }
  }

  return args.altKey === wantAlt && args.ctrlKey === wantCtrl && args.shiftKey === wantShift && args.metaKey === wantMeta;
}
;// CONCATENATED MODULE: ./packages/core/src/data-grid/use-selection-behavior.ts


function useSelectionBehavior(gridSelection, setGridSelection, rangeBehavior, columnBehavior, rowBehavior, rangeSelect) {
  const setCurrent = react.useCallback((value, expand, append, trigger) => {
    var _gridSelection$curren, _gridSelection$curren2;

    if ((rangeSelect === "cell" || rangeSelect === "multi-cell") && value !== undefined) {
      value = { ...value,
        range: {
          x: value.cell[0],
          y: value.cell[1],
          width: 1,
          height: 1
        }
      };
    }

    const rangeMixable = rangeBehavior === "mixed" && (append || trigger === "drag");
    const allowColumnCoSelect = columnBehavior === "mixed" && rangeMixable;
    const allowRowCoSelect = rowBehavior === "mixed" && rangeMixable;
    let newVal = {
      current: value === undefined ? undefined : { ...value,
        rangeStack: trigger === "drag" ? (_gridSelection$curren = (_gridSelection$curren2 = gridSelection.current) === null || _gridSelection$curren2 === void 0 ? void 0 : _gridSelection$curren2.rangeStack) !== null && _gridSelection$curren !== void 0 ? _gridSelection$curren : [] : []
      },
      columns: allowColumnCoSelect ? gridSelection.columns : data_grid_types/* CompactSelection.empty */.EV.empty(),
      rows: allowRowCoSelect ? gridSelection.rows : data_grid_types/* CompactSelection.empty */.EV.empty()
    };
    const addLastRange = append && (rangeSelect === "multi-rect" || rangeSelect === "multi-cell");

    if (addLastRange && newVal.current !== undefined && gridSelection.current !== undefined) {
      newVal = { ...newVal,
        current: { ...newVal.current,
          rangeStack: [...gridSelection.current.rangeStack, gridSelection.current.range]
        }
      };
    }

    setGridSelection(newVal, expand);
  }, [columnBehavior, gridSelection, rangeBehavior, rangeSelect, rowBehavior, setGridSelection]);
  const setSelectedRows = react.useCallback((newRows, append, allowMixed) => {
    var _newRows;

    newRows = (_newRows = newRows) !== null && _newRows !== void 0 ? _newRows : gridSelection.rows;

    if (append !== undefined) {
      newRows = newRows.add(append);
    }

    let newVal;

    if (rowBehavior === "exclusive" && newRows.length > 0) {
      newVal = {
        current: undefined,
        columns: data_grid_types/* CompactSelection.empty */.EV.empty(),
        rows: newRows
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const columnMixed = allowMixed && columnBehavior === "mixed";
      const current = !rangeMixed ? undefined : gridSelection.current;
      newVal = {
        current,
        columns: columnMixed ? gridSelection.columns : data_grid_types/* CompactSelection.empty */.EV.empty(),
        rows: newRows
      };
    }

    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  const setSelectedColumns = react.useCallback((newCols, append, allowMixed) => {
    var _newCols;

    newCols = (_newCols = newCols) !== null && _newCols !== void 0 ? _newCols : gridSelection.columns;

    if (append !== undefined) {
      newCols = newCols.add(append);
    }

    let newVal;

    if (columnBehavior === "exclusive" && newCols.length > 0) {
      newVal = {
        current: undefined,
        rows: data_grid_types/* CompactSelection.empty */.EV.empty(),
        columns: newCols
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const rowMixed = allowMixed && rowBehavior === "mixed";
      const current = !rangeMixed ? undefined : gridSelection.current;
      newVal = {
        current,
        rows: rowMixed ? gridSelection.rows : data_grid_types/* CompactSelection.empty */.EV.empty(),
        columns: newCols
      };
    }

    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  return [setCurrent, setSelectedRows, setSelectedColumns];
}
;// CONCATENATED MODULE: ./packages/core/src/data-editor/use-cells-for-selection.ts


function useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortController, rows) {
  const getCellsForSelectionDirectWhenValid = react.useCallback(rect => {
    var _getCellsForSelection;

    if (getCellsForSelectionIn === true) {
      const result = [];

      for (let y = rect.y; y < rect.y + rect.height; y++) {
        const row = [];

        for (let x = rect.x; x < rect.x + rect.width; x++) {
          if (x < 0 || y >= rows) {
            row.push({
              kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
              allowOverlay: false
            });
          } else {
            row.push(getCellContent([x, y]));
          }
        }

        result.push(row);
      }

      return result;
    }

    return (_getCellsForSelection = getCellsForSelectionIn === null || getCellsForSelectionIn === void 0 ? void 0 : getCellsForSelectionIn(rect, abortController.signal)) !== null && _getCellsForSelection !== void 0 ? _getCellsForSelection : [];
  }, [abortController.signal, getCellContent, getCellsForSelectionIn, rows]);
  const getCellsForSelectionDirect = getCellsForSelectionIn !== undefined ? getCellsForSelectionDirectWhenValid : undefined;
  const getCellsForSelectionMangled = react.useCallback(rect => {
    if (getCellsForSelectionDirect === undefined) return [];
    const newRect = { ...rect,
      x: rect.x - rowMarkerOffset
    };

    if (newRect.x < 0) {
      newRect.x = 0;
      newRect.width--;
      const r = getCellsForSelectionDirect(newRect, abortController.signal);

      if (typeof r === "function") {
        return async () => (await r()).map(row => [{
          kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
          allowOverlay: false
        }, ...row]);
      }

      return r.map(row => [{
        kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
        allowOverlay: false
      }, ...row]);
    }

    return getCellsForSelectionDirect(newRect, abortController.signal);
  }, [abortController.signal, getCellsForSelectionDirect, rowMarkerOffset]);
  const getCellsForSelection = getCellsForSelectionIn !== undefined ? getCellsForSelectionMangled : undefined;
  return [getCellsForSelection, getCellsForSelectionDirect];
}
;// CONCATENATED MODULE: ./packages/core/src/data-editor/data-editor-fns.ts


function expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortController) {
  const origVal = newVal;
  if (spanRangeBehavior === "allowPartial" || newVal.current === undefined) return newVal;

  if (getCellsForSelection !== undefined) {
    let isFilled = false;

    do {
      var _newVal, _newVal$current;

      if (((_newVal = newVal) === null || _newVal === void 0 ? void 0 : _newVal.current) === undefined) break;
      const r = (_newVal$current = newVal.current) === null || _newVal$current === void 0 ? void 0 : _newVal$current.range;
      const cells = [];

      if (r.width > 2) {
        const leftCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);

        if (typeof leftCells === "function") {
          return origVal;
        }

        cells.push(...leftCells);
        const rightCells = getCellsForSelection({
          x: r.x + r.width - 1,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);

        if (typeof rightCells === "function") {
          return origVal;
        }

        cells.push(...rightCells);
      } else {
        const rCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: r.width,
          height: r.height
        }, abortController.signal);

        if (typeof rCells === "function") {
          return origVal;
        }

        cells.push(...rCells);
      }

      let left = r.x - rowMarkerOffset;
      let right = r.x + r.width - 1 - rowMarkerOffset;

      for (const row of cells) {
        for (const cell of row) {
          if (cell.span === undefined) continue;
          left = Math.min(cell.span[0], left);
          right = Math.max(cell.span[1], right);
        }
      }

      if (left === r.x - rowMarkerOffset && right === r.x + r.width - 1 - rowMarkerOffset) {
        isFilled = true;
      } else {
        var _newVal$current$cell;

        newVal = {
          current: {
            cell: (_newVal$current$cell = newVal.current.cell) !== null && _newVal$current$cell !== void 0 ? _newVal$current$cell : [0, 0],
            range: {
              x: left + rowMarkerOffset,
              y: r.y,
              width: right - left + 1,
              height: r.height
            },
            rangeStack: newVal.current.rangeStack
          },
          columns: newVal.columns,
          rows: newVal.rows
        };
      }
    } while (!isFilled);
  }

  return newVal;
}

function descape(s) {
  if (s.startsWith('"') && s.endsWith('"')) {
    s = s.slice(1, -1).replace(/""/g, '"');
  }

  return s;
}

function unquote(str) {
  let State;

  (function (State) {
    State[State["None"] = 0] = "None";
    State[State["inString"] = 1] = "inString";
    State[State["inStringPostQuote"] = 2] = "inStringPostQuote";
  })(State || (State = {}));

  const result = [];
  let current = [];
  let start = 0;
  let state = State.None;
  str = str.replace(/\r\n/g, "\n");
  let index = 0;

  for (const char of str) {
    switch (state) {
      case State.None:
        if (char === "\t" || char === "\n") {
          current.push(str.slice(start, index));
          start = index + 1;

          if (char === "\n") {
            result.push(current);
            current = [];
          }
        } else if (char === `"`) {
          state = State.inString;
        }

        break;

      case State.inString:
        if (char === `"`) {
          state = State.inStringPostQuote;
        }

        break;

      case State.inStringPostQuote:
        if (char === '"') {
          state = State.inString;
        } else if (char === "\t" || char === "\n") {
          current.push(descape(str.slice(start, index)));
          start = index + 1;

          if (char === "\n") {
            result.push(current);
            current = [];
          }

          state = State.None;
        } else {
          state = State.None;
        }

        break;
    }

    index++;
  }

  if (start < str.length) {
    current.push(descape(str.slice(start, str.length)));
  }

  result.push(current);
  return result;
}
function decodeHTML(tableEl) {
  const walkEl = [tableEl];
  const result = [];
  let current;

  while (walkEl.length > 0) {
    const el = walkEl.pop();
    if (el === undefined) break;

    if (el instanceof HTMLTableElement || el.nodeName === "TBODY") {
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableRowElement) {
      if (current !== undefined) {
        result.push(current);
      }

      current = [];
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableCellElement) {
      var _current, _ref, _el$innerText;

      (_current = current) === null || _current === void 0 ? void 0 : _current.push((_ref = (_el$innerText = el.innerText) !== null && _el$innerText !== void 0 ? _el$innerText : el.textContent) !== null && _ref !== void 0 ? _ref : "");
    }
  }

  if (current !== undefined) {
    result.push(current);
  }

  return result;
}

function data_editor_fns_escape(str) {
  if (/[\t\n",]/.test(str)) {
    str = `"${str.replace(/"/g, '""')}"`;
  }

  return str;
}

const formatBoolean = val => {
  switch (val) {
    case true:
      return "TRUE";

    case false:
      return "FALSE";

    case data_grid_types/* BooleanIndeterminate */.sd:
      return "INDETERMINATE";

    case data_grid_types/* BooleanEmpty */.qF:
      return "";

    default:
      (0,support/* assertNever */.vE)(val);
  }
};

function formatCell(cell, index, raw, columnIndexes) {
  var _cell$data$toString, _cell$data;

  const colIndex = columnIndexes[index];
  if (cell.span !== undefined && cell.span[0] !== colIndex) return "";

  if (cell.copyData !== undefined) {
    return data_editor_fns_escape(cell.copyData);
  }

  switch (cell.kind) {
    case data_grid_types/* GridCellKind.Text */.p6.Text:
    case data_grid_types/* GridCellKind.Number */.p6.Number:
      return data_editor_fns_escape(raw ? (_cell$data$toString = (_cell$data = cell.data) === null || _cell$data === void 0 ? void 0 : _cell$data.toString()) !== null && _cell$data$toString !== void 0 ? _cell$data$toString : "" : cell.displayData);

    case data_grid_types/* GridCellKind.Markdown */.p6.Markdown:
    case data_grid_types/* GridCellKind.RowID */.p6.RowID:
    case data_grid_types/* GridCellKind.Uri */.p6.Uri:
      return data_editor_fns_escape(cell.data);

    case data_grid_types/* GridCellKind.Image */.p6.Image:
    case data_grid_types/* GridCellKind.Bubble */.p6.Bubble:
      if (cell.data.length === 0) return "";
      return cell.data.reduce((pv, cv) => `${data_editor_fns_escape(pv)},${data_editor_fns_escape(cv)}`);

    case data_grid_types/* GridCellKind.Boolean */.p6.Boolean:
      return formatBoolean(cell.data);

    case data_grid_types/* GridCellKind.Loading */.p6.Loading:
      return raw ? "" : "#LOADING";

    case data_grid_types/* GridCellKind.Protected */.p6.Protected:
      return raw ? "" : "************";

    case data_grid_types/* GridCellKind.Drilldown */.p6.Drilldown:
      if (cell.data.length === 0) return "";
      return cell.data.map(i => i.text).reduce((pv, cv) => `${data_editor_fns_escape(pv)},${data_editor_fns_escape(cv)}`);

    case data_grid_types/* GridCellKind.Custom */.p6.Custom:
      return data_editor_fns_escape(cell.copyData);

    default:
      (0,support/* assertNever */.vE)(cell);
  }
}
function formatForCopy(cells, columnIndexes) {
  return cells.map(row => row.map((a, b) => formatCell(a, b, false, columnIndexes)).join("\t")).join("\n");
}
function copyToClipboard(cells, columnIndexes, e) {
  var _window$navigator$cli;

  const str = formatForCopy(cells, columnIndexes);

  if (((_window$navigator$cli = window.navigator.clipboard) === null || _window$navigator$cli === void 0 ? void 0 : _window$navigator$cli.write) !== undefined || e !== undefined) {
    var _window$navigator$cli2;

    const rootEl = document.createElement("tbody");

    for (const row of cells) {
      const rowEl = document.createElement("tr");

      for (const [i, cell] of row.entries()) {
        const cellEl = document.createElement("td");

        if (cell.kind === data_grid_types/* GridCellKind.Uri */.p6.Uri) {
          const link = document.createElement("a");
          link.href = cell.data;
          link.innerText = cell.data;
          cellEl.append(link);
        } else {
          cellEl.innerText = formatCell(cell, i, true, columnIndexes);
        }

        rowEl.append(cellEl);
      }

      rootEl.append(rowEl);
    }

    if (((_window$navigator$cli2 = window.navigator.clipboard) === null || _window$navigator$cli2 === void 0 ? void 0 : _window$navigator$cli2.write) !== undefined) {
      void window.navigator.clipboard.write([new ClipboardItem({
        "text/plain": new Blob([str], {
          type: "text/plain"
        }),
        "text/html": new Blob([`<table>${rootEl.outerHTML}</table>`], {
          type: "text/html"
        })
      })]);
    } else if (e !== undefined && (e === null || e === void 0 ? void 0 : e.clipboardData) !== null) {
      try {
        e.clipboardData.setData("text/plain", str);
        e.clipboardData.setData("text/html", `<table>${rootEl.outerHTML}</table>`);
      } catch {
        var _window$navigator$cli3;

        void ((_window$navigator$cli3 = window.navigator.clipboard) === null || _window$navigator$cli3 === void 0 ? void 0 : _window$navigator$cli3.writeText(str));
      }
    }
  } else {
    var _window$navigator$cli4;

    void ((_window$navigator$cli4 = window.navigator.clipboard) === null || _window$navigator$cli4 === void 0 ? void 0 : _window$navigator$cli4.writeText(str));
  }

  e === null || e === void 0 ? void 0 : e.preventDefault();
}
;// CONCATENATED MODULE: ./packages/core/src/data-editor-container/data-grid-container.tsx
function data_grid_container_extends() { data_grid_container_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return data_grid_container_extends.apply(this, arguments); }




function toCss(x) {
  if (typeof x === "string") return x;
  return `${x}px`;
}

const data_grid_container_exp = () => p => p.innerWidth;

const data_grid_container_exp2 = () => p => p.innerHeight;

const Wrapper = (0,styled/* default */.Z)('div')({
  name: "Wrapper",
  class: "wo9gtxb",
  vars: {
    "wo9gtxb-0": [data_grid_container_exp()],
    "wo9gtxb-1": [data_grid_container_exp2()]
  }
});
const DataEditorContainer = p => {
  const {
    inWidth,
    inHeight,
    children,
    ...rest
  } = p;
  return react.createElement(Wrapper, data_grid_container_extends({
    innerHeight: toCss(inHeight),
    innerWidth: toCss(inWidth)
  }, rest), children);
};

__webpack_require__("./packages/core/src/data-editor-container/data-grid-container.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor-container/data-grid-container.tsx");
// EXTERNAL MODULE: ./packages/core/src/data-grid/cells/boolean-cell.tsx
var boolean_cell = __webpack_require__("./packages/core/src/data-grid/cells/boolean-cell.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-editor/use-autoscroll.ts

const maxPxPerMs = 2;
const msToFullSpeed = 1300;
function useAutoscroll(scrollDirection, scrollRef) {
  const speedScalar = react.useRef(0);
  const [xDir, yDir] = scrollDirection !== null && scrollDirection !== void 0 ? scrollDirection : [0, 0];
  react.useEffect(() => {
    if (xDir === 0 && yDir === 0) {
      speedScalar.current = 0;
      return;
    }

    let lastTime = 0;

    const scrollFn = curTime => {
      if (lastTime === 0) {
        lastTime = curTime;
      } else {
        var _scrollRef$current;

        const step = curTime - lastTime;
        speedScalar.current = Math.min(1, speedScalar.current + step / msToFullSpeed);
        const motion = speedScalar.current ** 1.618 * step * maxPxPerMs;
        (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.scrollBy(xDir * motion, yDir * motion);
        lastTime = curTime;
      }

      t = window.requestAnimationFrame(scrollFn);
    };

    let t = window.requestAnimationFrame(scrollFn);
    return () => window.cancelAnimationFrame(t);
  }, [scrollRef, xDir, yDir]);
}
// EXTERNAL MODULE: ./packages/core/src/data-grid/cells/index.ts + 25 modules
var cells = __webpack_require__("./packages/core/src/data-grid/cells/index.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-editor/data-editor.tsx
function data_editor_extends() { data_editor_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return data_editor_extends.apply(this, arguments); }

























let idCounter = 0;

function getSpanStops(cells) {
  return uniq_default()(flatten_default()(flatten_default()(cells).filter(c => c.span !== undefined).map(c => {
    var _c$span$, _c$span, _c$span$2, _c$span2;

    return range_default()(((_c$span$ = (_c$span = c.span) === null || _c$span === void 0 ? void 0 : _c$span[0]) !== null && _c$span$ !== void 0 ? _c$span$ : 0) + 1, ((_c$span$2 = (_c$span2 = c.span) === null || _c$span2 === void 0 ? void 0 : _c$span2[1]) !== null && _c$span$2 !== void 0 ? _c$span$2 : 0) + 1);
  })));
}

function shiftSelection(input, offset) {
  if (input === undefined || offset === 0 || input.columns.length === 0 && input.current === undefined) return input;
  return {
    current: input.current === undefined ? undefined : {
      cell: [input.current.cell[0] + offset, input.current.cell[1]],
      range: { ...input.current.range,
        x: input.current.range.x + offset
      },
      rangeStack: input.current.rangeStack.map(r => ({ ...r,
        x: r.x + offset
      }))
    },
    rows: input.rows,
    columns: input.columns.offset(offset)
  };
}

const keybindingDefaults = {
  selectAll: true,
  selectRow: true,
  selectColumn: true,
  downFill: false,
  rightFill: false,
  pageUp: false,
  pageDown: false,
  clear: true,
  copy: true,
  paste: true,
  search: false,
  first: true,
  last: true
};
const loadingCell = {
  kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
  allowOverlay: false
};
const emptyGridSelection = {
  columns: data_grid_types/* CompactSelection.empty */.EV.empty(),
  rows: data_grid_types/* CompactSelection.empty */.EV.empty(),
  current: undefined
};

const DataEditorImpl = (p, forwardedRef) => {
  var _visibleRegion$height, _visibleRegion$width, _gridSelection$curren6, _gridSelectionOuter$c, _gridSelectionOuter$c2;

  const [gridSelectionInner, setGridSelectionInner] = react.useState(emptyGridSelection);
  const [overlay, setOverlay] = react.useState();
  const searchInputRef = react.useRef(null);
  const canvasRef = react.useRef(null);
  const [mouseState, setMouseState] = react.useState();
  const scrollRef = react.useRef(null);
  const lastSent = react.useRef();
  const {
    rowMarkers = "none",
    rowMarkerWidth: rowMarkerWidthRaw,
    imageEditorOverride,
    getRowThemeOverride,
    markdownDivCreateNode,
    width,
    height,
    columns: columnsIn,
    rows,
    getCellContent,
    onCellClicked,
    onCellActivated,
    onFinishedEditing,
    coercePasteValue,
    drawHeader: drawHeaderIn,
    onHeaderClicked,
    spanRangeBehavior = "default",
    onGroupHeaderClicked,
    onCellContextMenu,
    className,
    onHeaderContextMenu,
    getCellsForSelection: getCellsForSelectionIn,
    onGroupHeaderContextMenu,
    onGroupHeaderRenamed,
    onCellEdited,
    onCellsEdited,
    onKeyDown: onKeyDownIn,
    onKeyUp: onKeyUpIn,
    keybindings: keybindingsIn,
    onRowAppended,
    onColumnMoved,
    validateCell: validateCellIn,
    highlightRegions: highlightRegionsIn,
    drawCell,
    rangeSelect = "rect",
    columnSelect = "multi",
    rowSelect = "multi",
    rangeSelectionBlending = "exclusive",
    columnSelectionBlending = "exclusive",
    rowSelectionBlending = "exclusive",
    onDelete: onDeleteIn,
    onDragStart,
    onMouseMove,
    onPaste,
    copyHeaders = false,
    freezeColumns = 0,
    rowSelectionMode = "auto",
    rowMarkerStartIndex = 1,
    rowMarkerTheme,
    onHeaderMenuClick,
    getGroupDetails,
    onSearchClose: onSearchCloseIn,
    onItemHovered,
    onSelectionCleared,
    showSearch: showSearchIn,
    onVisibleRegionChanged,
    gridSelection: gridSelectionOuter,
    onGridSelectionChange,
    minColumnWidth: minColumnWidthIn = 50,
    maxColumnWidth: maxColumnWidthIn = 500,
    maxColumnAutoWidth: maxColumnAutoWidthIn,
    provideEditor,
    trailingRowOptions,
    scrollOffsetX,
    scrollOffsetY,
    verticalBorder,
    onDragOverCell,
    onDrop,
    onColumnResize: onColumnResizeIn,
    onColumnResizeEnd: onColumnResizeEndIn,
    onColumnResizeStart: onColumnResizeStartIn,
    customRenderers: additionalRenderers,
    fillHandle,
    drawFocusRing,
    experimental,
    fixedShadowX,
    fixedShadowY,
    headerIcons,
    imageWindowLoader,
    initialSize,
    isDraggable,
    onDragLeave,
    onRowMoved,
    overscrollX: overscrollXIn,
    overscrollY: overscrollYIn,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    showMinimap,
    smoothScrollX,
    smoothScrollY,
    scrollToEnd,
    scaleToRem = false,
    rowHeight: rowHeightIn = 34,
    headerHeight: headerHeightIn = 36,
    groupHeaderHeight: groupHeaderHeightIn = headerHeightIn,
    theme: themeIn
  } = p;
  const minColumnWidth = Math.max(minColumnWidthIn, 20);
  const maxColumnWidth = Math.max(maxColumnWidthIn, minColumnWidth);
  const maxColumnAutoWidth = Math.max(maxColumnAutoWidthIn !== null && maxColumnAutoWidthIn !== void 0 ? maxColumnAutoWidthIn : maxColumnWidth, minColumnWidth);
  const docStyle = react.useMemo(() => {
    if (typeof window === "undefined") return {
      fontSize: "16px"
    };
    return window.getComputedStyle(document.documentElement);
  }, []);
  const fontSizeStr = docStyle.fontSize;
  const remSize = react.useMemo(() => Number.parseFloat(fontSizeStr), [fontSizeStr]);
  const [rowHeight, headerHeight, groupHeaderHeight, theme, overscrollX, overscrollY] = react.useMemo(() => {
    var _themeIn$headerIconSi, _themeIn$cellHorizont, _themeIn$cellVertical;

    if (!scaleToRem || remSize === 16) return [rowHeightIn, headerHeightIn, groupHeaderHeightIn, themeIn, overscrollXIn, overscrollYIn];
    const scaler = remSize / 16;
    const rh = rowHeightIn;
    const bt = (0,styles/* getDataEditorTheme */.Zu)();
    return [typeof rh === "number" ? rh * scaler : n => Math.ceil(rh(n) * scaler), Math.ceil(headerHeightIn * scaler), Math.ceil(groupHeaderHeightIn * scaler), { ...themeIn,
      headerIconSize: ((_themeIn$headerIconSi = themeIn === null || themeIn === void 0 ? void 0 : themeIn.headerIconSize) !== null && _themeIn$headerIconSi !== void 0 ? _themeIn$headerIconSi : bt.headerIconSize) * scaler,
      cellHorizontalPadding: ((_themeIn$cellHorizont = themeIn === null || themeIn === void 0 ? void 0 : themeIn.cellHorizontalPadding) !== null && _themeIn$cellHorizont !== void 0 ? _themeIn$cellHorizont : bt.cellHorizontalPadding) * scaler,
      cellVerticalPadding: ((_themeIn$cellVertical = themeIn === null || themeIn === void 0 ? void 0 : themeIn.cellVerticalPadding) !== null && _themeIn$cellVertical !== void 0 ? _themeIn$cellVertical : bt.cellVerticalPadding) * scaler
    }, Math.ceil((overscrollXIn !== null && overscrollXIn !== void 0 ? overscrollXIn : 0) * scaler), Math.ceil((overscrollYIn !== null && overscrollYIn !== void 0 ? overscrollYIn : 0) * scaler)];
  }, [groupHeaderHeightIn, headerHeightIn, overscrollXIn, overscrollYIn, remSize, rowHeightIn, scaleToRem, themeIn]);
  const keybindings = react.useMemo(() => {
    return keybindingsIn === undefined ? keybindingDefaults : { ...keybindingDefaults,
      ...keybindingsIn
    };
  }, [keybindingsIn]);
  const rowMarkerWidth = rowMarkerWidthRaw !== null && rowMarkerWidthRaw !== void 0 ? rowMarkerWidthRaw : rows > 10000 ? 48 : rows > 1000 ? 44 : rows > 100 ? 36 : 32;
  const hasRowMarkers = rowMarkers !== "none";
  const rowMarkerOffset = hasRowMarkers ? 1 : 0;
  const showTrailingBlankRow = onRowAppended !== undefined;
  const lastRowSticky = (trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.sticky) === true;
  const [showSearchInner, setShowSearchInner] = react.useState(false);
  const showSearch = showSearchIn !== null && showSearchIn !== void 0 ? showSearchIn : showSearchInner;
  const onSearchClose = react.useCallback(() => {
    if (onSearchCloseIn !== undefined) {
      onSearchCloseIn();
    } else {
      setShowSearchInner(false);
    }
  }, [onSearchCloseIn]);
  const gridSelectionOuterMangled = react.useMemo(() => {
    return gridSelectionOuter === undefined ? undefined : shiftSelection(gridSelectionOuter, rowMarkerOffset);
  }, [gridSelectionOuter, rowMarkerOffset]);
  const gridSelection = gridSelectionOuterMangled !== null && gridSelectionOuterMangled !== void 0 ? gridSelectionOuterMangled : gridSelectionInner;
  const abortControllerRef = react.useRef(new AbortController());
  react.useEffect(() => {
    return () => {
      abortControllerRef === null || abortControllerRef === void 0 ? void 0 : abortControllerRef.current.abort();
    };
  }, []);
  const [getCellsForSelection, getCellsForSeletionDirect] = useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortControllerRef.current, rows);
  const validateCell = react.useCallback((cell, newValue, prevValue) => {
    if (validateCellIn === undefined) return true;
    const item = [cell[0] - rowMarkerOffset, cell[1]];
    return validateCellIn === null || validateCellIn === void 0 ? void 0 : validateCellIn(item, newValue, prevValue);
  }, [rowMarkerOffset, validateCellIn]);
  const expectedExternalGridSelection = react.useRef(gridSelectionOuter);
  const setGridSelection = react.useCallback((newVal, expand) => {
    if (expand) {
      newVal = expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortControllerRef.current);
    }

    if (onGridSelectionChange !== undefined) {
      expectedExternalGridSelection.current = shiftSelection(newVal, -rowMarkerOffset);
      onGridSelectionChange(expectedExternalGridSelection.current);
    } else {
      setGridSelectionInner(newVal);
    }
  }, [onGridSelectionChange, getCellsForSelection, rowMarkerOffset, spanRangeBehavior]);
  const onColumnResize = (0,utils/* whenDefined */.qJ)(onColumnResizeIn, react.useCallback((_, w, ind, wg) => {
    onColumnResizeIn === null || onColumnResizeIn === void 0 ? void 0 : onColumnResizeIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeEnd = (0,utils/* whenDefined */.qJ)(onColumnResizeEndIn, react.useCallback((_, w, ind, wg) => {
    onColumnResizeEndIn === null || onColumnResizeEndIn === void 0 ? void 0 : onColumnResizeEndIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeEndIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeStart = (0,utils/* whenDefined */.qJ)(onColumnResizeStartIn, react.useCallback((_, w, ind, wg) => {
    onColumnResizeStartIn === null || onColumnResizeStartIn === void 0 ? void 0 : onColumnResizeStartIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeStartIn, rowMarkerOffset, columnsIn]));
  const drawHeader = (0,utils/* whenDefined */.qJ)(drawHeaderIn, react.useCallback(args => {
    var _drawHeaderIn;

    return (_drawHeaderIn = drawHeaderIn === null || drawHeaderIn === void 0 ? void 0 : drawHeaderIn({ ...args,
      columnIndex: args.columnIndex - rowMarkerOffset
    })) !== null && _drawHeaderIn !== void 0 ? _drawHeaderIn : false;
  }, [drawHeaderIn, rowMarkerOffset]));
  const onDelete = react.useCallback(sel => {
    if (onDeleteIn !== undefined) {
      const result = onDeleteIn(shiftSelection(sel, -rowMarkerOffset));

      if (typeof result === "boolean") {
        return result;
      }

      return shiftSelection(result, rowMarkerOffset);
    }

    return true;
  }, [onDeleteIn, rowMarkerOffset]);
  const [setCurrent, setSelectedRows, setSelectedColumns] = useSelectionBehavior(gridSelection, setGridSelection, rangeSelectionBlending, columnSelectionBlending, rowSelectionBlending, rangeSelect);
  const mergedTheme = react.useMemo(() => {
    return { ...(0,styles/* getDataEditorTheme */.Zu)(),
      ...theme
    };
  }, [theme]);
  const [clientSize, setClientSize] = react.useState([10, 10, 0]);
  const getCellRenderer = react.useCallback(cell => {
    if (cell.kind !== data_grid_types/* GridCellKind.Custom */.p6.Custom) {
      return cells/* CellRenderers */.L[cell.kind];
    }

    return additionalRenderers === null || additionalRenderers === void 0 ? void 0 : additionalRenderers.find(x => x.isMatch(cell));
  }, [additionalRenderers]);
  const columns = useColumnSizer(columnsIn, rows, getCellsForSeletionDirect, clientSize[0] - (rowMarkerOffset === 0 ? 0 : rowMarkerWidth) - clientSize[2], minColumnWidth, maxColumnAutoWidth, mergedTheme, getCellRenderer, abortControllerRef.current);
  const enableGroups = react.useMemo(() => {
    return columns.some(c => c.group !== undefined);
  }, [columns]);
  const totalHeaderHeight = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;
  const numSelectedRows = gridSelection.rows.length;
  const rowMarkerHeader = rowMarkers === "none" ? "" : numSelectedRows === 0 ? data_grid_types/* headerCellUnheckedMarker */.YK : numSelectedRows === rows ? data_grid_types/* headerCellCheckedMarker */.qT : data_grid_types/* headerCellIndeterminateMarker */.iJ;
  const mangledCols = react.useMemo(() => {
    if (rowMarkers === "none") return columns;
    return [{
      title: rowMarkerHeader,
      width: rowMarkerWidth,
      icon: undefined,
      hasMenu: false,
      style: "normal",
      themeOverride: rowMarkerTheme
    }, ...columns];
  }, [columns, rowMarkerWidth, rowMarkers, rowMarkerHeader, rowMarkerTheme]);
  const [visibleRegionY, visibleRegionTy] = react.useMemo(() => {
    return [scrollOffsetY !== undefined && typeof rowHeight === "number" ? Math.floor(scrollOffsetY / rowHeight) : 0, scrollOffsetY !== undefined && typeof rowHeight === "number" ? -(scrollOffsetY % rowHeight) : 0];
  }, [scrollOffsetY, rowHeight]);
  const visibleRegionRef = react.useRef({
    height: 1,
    width: 1,
    x: 0,
    y: 0
  });
  const visibleRegionInput = react.useMemo(() => {
    var _visibleRegionRef$cur, _visibleRegionRef$cur2;

    return {
      x: visibleRegionRef.current.x,
      y: visibleRegionY,
      width: (_visibleRegionRef$cur = visibleRegionRef.current.width) !== null && _visibleRegionRef$cur !== void 0 ? _visibleRegionRef$cur : 1,
      height: (_visibleRegionRef$cur2 = visibleRegionRef.current.height) !== null && _visibleRegionRef$cur2 !== void 0 ? _visibleRegionRef$cur2 : 1,
      ty: visibleRegionTy
    };
  }, [visibleRegionTy, visibleRegionY]);
  const hasJustScrolled = react.useRef(false);
  const [visibleRegion, setVisibleRegion, empty] = (0,utils/* useStateWithReactiveInput */.ig)(visibleRegionInput);
  const vScrollReady = ((_visibleRegion$height = visibleRegion.height) !== null && _visibleRegion$height !== void 0 ? _visibleRegion$height : 1) > 1;
  react.useLayoutEffect(() => {
    if (scrollOffsetY !== undefined && scrollRef.current !== null && vScrollReady) {
      if (scrollRef.current.scrollTop === scrollOffsetY) return;
      scrollRef.current.scrollTop = scrollOffsetY;

      if (scrollRef.current.scrollTop !== scrollOffsetY) {
        empty();
      }

      hasJustScrolled.current = true;
    }
  }, [scrollOffsetY, vScrollReady, empty]);
  const hScrollReady = ((_visibleRegion$width = visibleRegion.width) !== null && _visibleRegion$width !== void 0 ? _visibleRegion$width : 1) > 1;
  react.useLayoutEffect(() => {
    if (scrollOffsetX !== undefined && scrollRef.current !== null && hScrollReady) {
      if (scrollRef.current.scrollLeft === scrollOffsetX) return;
      scrollRef.current.scrollLeft = scrollOffsetX;

      if (scrollRef.current.scrollLeft !== scrollOffsetX) {
        empty();
      }

      hasJustScrolled.current = true;
    }
  }, [scrollOffsetX, hScrollReady, empty]);
  const cellXOffset = visibleRegion.x + rowMarkerOffset;
  const cellYOffset = visibleRegion.y;
  const gridRef = react.useRef(null);
  const focus = react.useCallback(immediate => {
    if (immediate === true) {
      var _gridRef$current;

      (_gridRef$current = gridRef.current) === null || _gridRef$current === void 0 ? void 0 : _gridRef$current.focus();
    } else {
      window.requestAnimationFrame(() => {
        var _gridRef$current2;

        (_gridRef$current2 = gridRef.current) === null || _gridRef$current2 === void 0 ? void 0 : _gridRef$current2.focus();
      });
    }
  }, []);
  const mangledRows = showTrailingBlankRow ? rows + 1 : rows;
  const mangledOnCellsEdited = react.useCallback(items => {
    const mangledItems = rowMarkerOffset === 0 ? items : items.map(x => ({ ...x,
      location: [x.location[0] - rowMarkerOffset, x.location[1]]
    }));
    const r = onCellsEdited === null || onCellsEdited === void 0 ? void 0 : onCellsEdited(mangledItems);

    if (r !== true) {
      for (const i of mangledItems) onCellEdited === null || onCellEdited === void 0 ? void 0 : onCellEdited(i.location, i.value);
    }

    return r;
  }, [onCellEdited, onCellsEdited, rowMarkerOffset]);
  const highlightRegions = react.useMemo(() => {
    if (highlightRegionsIn === undefined) return undefined;
    if (rowMarkerOffset === 0) return highlightRegionsIn;
    return highlightRegionsIn.map(r => {
      const maxWidth = mangledCols.length - r.range.x - rowMarkerOffset;
      if (maxWidth <= 0) return undefined;
      return {
        color: r.color,
        range: { ...r.range,
          x: r.range.x + rowMarkerOffset,
          width: Math.min(maxWidth, r.range.width)
        },
        style: r.style
      };
    }).filter(x => x !== undefined);
  }, [highlightRegionsIn, mangledCols.length, rowMarkerOffset]);
  const mangledColsRef = react.useRef(mangledCols);
  mangledColsRef.current = mangledCols;
  const getMangledCellContent = react.useCallback(function (_ref) {
    let [col, row] = _ref;
    let forceStrict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const isTrailing = showTrailingBlankRow && row === mangledRows - 1;
    const isRowMarkerCol = col === 0 && hasRowMarkers;

    if (isRowMarkerCol) {
      if (isTrailing) {
        return loadingCell;
      }

      return {
        kind: data_grid_types/* InnerGridCellKind.Marker */.$o.Marker,
        allowOverlay: false,
        checked: (gridSelection === null || gridSelection === void 0 ? void 0 : gridSelection.rows.hasIndex(row)) === true,
        markerKind: rowMarkers === "clickable-number" ? "number" : rowMarkers,
        row: rowMarkerStartIndex + row,
        drawHandle: onRowMoved !== undefined
      };
    } else if (isTrailing) {
      var _trailingRowOptions$h, _c$trailingRowOptions;

      const isFirst = col === rowMarkerOffset;
      const maybeFirstColumnHint = isFirst ? (_trailingRowOptions$h = trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.hint) !== null && _trailingRowOptions$h !== void 0 ? _trailingRowOptions$h : "" : "";
      const c = mangledColsRef.current[col];

      if ((c === null || c === void 0 ? void 0 : (_c$trailingRowOptions = c.trailingRowOptions) === null || _c$trailingRowOptions === void 0 ? void 0 : _c$trailingRowOptions.disabled) === true) {
        return loadingCell;
      } else {
        var _c$trailingRowOptions2, _c$trailingRowOptions3, _c$trailingRowOptions4, _c$trailingRowOptions5;

        const hint = (_c$trailingRowOptions2 = c === null || c === void 0 ? void 0 : (_c$trailingRowOptions3 = c.trailingRowOptions) === null || _c$trailingRowOptions3 === void 0 ? void 0 : _c$trailingRowOptions3.hint) !== null && _c$trailingRowOptions2 !== void 0 ? _c$trailingRowOptions2 : maybeFirstColumnHint;
        const icon = (_c$trailingRowOptions4 = c === null || c === void 0 ? void 0 : (_c$trailingRowOptions5 = c.trailingRowOptions) === null || _c$trailingRowOptions5 === void 0 ? void 0 : _c$trailingRowOptions5.addIcon) !== null && _c$trailingRowOptions4 !== void 0 ? _c$trailingRowOptions4 : trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.addIcon;
        return {
          kind: data_grid_types/* InnerGridCellKind.NewRow */.$o.NewRow,
          hint,
          allowOverlay: false,
          icon
        };
      }
    } else {
      const outerCol = col - rowMarkerOffset;

      if (forceStrict || (experimental === null || experimental === void 0 ? void 0 : experimental.strict) === true) {
        var _vr$extras, _vr$extras$selected, _vr$extras2, _vr$extras3;

        const vr = visibleRegionRef.current;
        const isOutsideMainArea = vr.x > outerCol || outerCol > vr.x + vr.width || vr.y > row || row > vr.y + vr.height;
        const isSelected = outerCol === ((_vr$extras = vr.extras) === null || _vr$extras === void 0 ? void 0 : (_vr$extras$selected = _vr$extras.selected) === null || _vr$extras$selected === void 0 ? void 0 : _vr$extras$selected[0]) && row === ((_vr$extras2 = vr.extras) === null || _vr$extras2 === void 0 ? void 0 : _vr$extras2.selected[1]);
        const isOutsideFreezeArea = ((_vr$extras3 = vr.extras) === null || _vr$extras3 === void 0 ? void 0 : _vr$extras3.freezeRegion) === undefined || vr.extras.freezeRegion.x > outerCol || outerCol > vr.extras.freezeRegion.x + vr.extras.freezeRegion.width || vr.extras.freezeRegion.y > row || row > vr.extras.freezeRegion.y + vr.extras.freezeRegion.height;

        if (isOutsideMainArea && !isSelected && isOutsideFreezeArea) {
          return {
            kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
            allowOverlay: false
          };
        }
      }

      let result = getCellContent([outerCol, row]);

      if (rowMarkerOffset !== 0 && result.span !== undefined) {
        result = { ...result,
          span: [result.span[0] + rowMarkerOffset, result.span[1] + rowMarkerOffset]
        };
      }

      return result;
    }
  }, [showTrailingBlankRow, mangledRows, hasRowMarkers, gridSelection === null || gridSelection === void 0 ? void 0 : gridSelection.rows, onRowMoved, rowMarkers, rowMarkerOffset, trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.hint, trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.addIcon, experimental === null || experimental === void 0 ? void 0 : experimental.strict, getCellContent, rowMarkerStartIndex]);
  const mangledGetGroupDetails = react.useCallback(group => {
    var _getGroupDetails;

    let result = (_getGroupDetails = getGroupDetails === null || getGroupDetails === void 0 ? void 0 : getGroupDetails(group)) !== null && _getGroupDetails !== void 0 ? _getGroupDetails : {
      name: group
    };

    if (onGroupHeaderRenamed !== undefined && group !== "") {
      var _result$actions;

      result = {
        icon: result.icon,
        name: result.name,
        overrideTheme: result.overrideTheme,
        actions: [...((_result$actions = result.actions) !== null && _result$actions !== void 0 ? _result$actions : []), {
          title: "Rename",
          icon: "renameIcon",
          onClick: e => setRenameGroup({
            group: result.name,
            bounds: e.bounds
          })
        }]
      };
    }

    return result;
  }, [getGroupDetails, onGroupHeaderRenamed]);
  const setOverlaySimple = react.useCallback(val => {
    var _mangledGetGroupDetai;

    const [col, row] = val.cell;
    const column = mangledCols[col];
    const groupTheme = (column === null || column === void 0 ? void 0 : column.group) !== undefined ? (_mangledGetGroupDetai = mangledGetGroupDetails(column.group)) === null || _mangledGetGroupDetai === void 0 ? void 0 : _mangledGetGroupDetai.overrideTheme : undefined;
    const colTheme = column === null || column === void 0 ? void 0 : column.themeOverride;
    const rowTheme = getRowThemeOverride === null || getRowThemeOverride === void 0 ? void 0 : getRowThemeOverride(row);
    setOverlay({ ...val,
      theme: { ...mergedTheme,
        ...groupTheme,
        ...colTheme,
        ...rowTheme,
        ...val.content.themeOverride
      }
    });
  }, [getRowThemeOverride, mangledCols, mangledGetGroupDetails, mergedTheme]);
  const reselect = react.useCallback((bounds, fromKeyboard, initialValue) => {
    if (gridSelection.current === undefined) return;
    const [col, row] = gridSelection.current.cell;
    const c = getMangledCellContent([col, row]);

    if (c.kind !== data_grid_types/* GridCellKind.Boolean */.p6.Boolean && c.allowOverlay) {
      let content = c;

      if (initialValue !== undefined) {
        switch (content.kind) {
          case data_grid_types/* GridCellKind.Number */.p6.Number:
            {
              const d = (0,support/* maybe */.wY)(() => initialValue === "-" ? -0 : Number.parseFloat(initialValue), 0);
              content = { ...content,
                data: Number.isNaN(d) ? 0 : d
              };
              break;
            }

          case data_grid_types/* GridCellKind.Text */.p6.Text:
          case data_grid_types/* GridCellKind.Markdown */.p6.Markdown:
          case data_grid_types/* GridCellKind.Uri */.p6.Uri:
            content = { ...content,
              data: initialValue
            };
            break;
        }
      }

      setOverlaySimple({
        target: bounds,
        content,
        initialValue,
        cell: [col, row],
        highlight: initialValue === undefined,
        forceEditMode: initialValue !== undefined
      });
    } else if (c.kind === data_grid_types/* GridCellKind.Boolean */.p6.Boolean && fromKeyboard && c.readonly !== true) {
      var _gridRef$current3;

      mangledOnCellsEdited([{
        location: gridSelection.current.cell,
        value: { ...c,
          data: (0,boolean_cell/* toggleBoolean */.D)(c.data)
        }
      }]);
      (_gridRef$current3 = gridRef.current) === null || _gridRef$current3 === void 0 ? void 0 : _gridRef$current3.damage([{
        cell: gridSelection.current.cell
      }]);
    }
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited, setOverlaySimple]);
  const focusOnRowFromTrailingBlankRow = react.useCallback((col, row) => {
    var _gridRef$current4;

    const bounds = (_gridRef$current4 = gridRef.current) === null || _gridRef$current4 === void 0 ? void 0 : _gridRef$current4.getBounds(col, row);

    if (bounds === undefined || scrollRef.current === null) {
      return;
    }

    const content = getMangledCellContent([col, row]);

    if (!content.allowOverlay) {
      return;
    }

    setOverlaySimple({
      target: bounds,
      content,
      initialValue: undefined,
      highlight: true,
      cell: [col, row],
      forceEditMode: true
    });
  }, [getMangledCellContent, setOverlaySimple]);
  const scrollTo = react.useCallback(function (col, row) {
    let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "both";
    let paddingX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let paddingY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;

    if (scrollRef.current !== null) {
      const grid = gridRef.current;
      const canvas = canvasRef.current;
      const trueCol = typeof col !== "number" ? col.unit === "cell" ? col.amount : undefined : col;
      const trueRow = typeof row !== "number" ? row.unit === "cell" ? row.amount : undefined : row;
      const desiredX = typeof col !== "number" && col.unit === "px" ? col.amount : undefined;
      const desiredY = typeof row !== "number" && row.unit === "px" ? row.amount : undefined;

      if (grid !== null && canvas !== null) {
        let targetRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        let scrollX = 0;
        let scrollY = 0;

        if (trueCol !== undefined || trueRow !== undefined) {
          var _grid$getBounds;

          targetRect = (_grid$getBounds = grid.getBounds((trueCol !== null && trueCol !== void 0 ? trueCol : 0) + rowMarkerOffset, trueRow !== null && trueRow !== void 0 ? trueRow : 0)) !== null && _grid$getBounds !== void 0 ? _grid$getBounds : targetRect;
          if (targetRect.width === 0 || targetRect.height === 0) return;
        }

        const scrollBounds = canvas.getBoundingClientRect();
        const scale = scrollBounds.width / canvas.offsetWidth;

        if (desiredX !== undefined) {
          targetRect = { ...targetRect,
            x: desiredX - scrollBounds.left - scrollRef.current.scrollLeft,
            width: 1
          };
        }

        if (desiredY !== undefined) {
          targetRect = { ...targetRect,
            y: desiredY + scrollBounds.top - scrollRef.current.scrollTop,
            height: 1
          };
        }

        if (targetRect !== undefined) {
          const bounds = {
            x: targetRect.x - paddingX,
            y: targetRect.y - paddingY,
            width: targetRect.width + 2 * paddingX,
            height: targetRect.height + 2 * paddingY
          };
          let frozenWidth = 0;

          for (let i = 0; i < freezeColumns; i++) {
            frozenWidth += columns[i].width;
          }

          let trailingRowHeight = 0;

          if (lastRowSticky) {
            trailingRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows);
          }

          let sLeft = frozenWidth * scale + scrollBounds.left + rowMarkerOffset * rowMarkerWidth * scale;
          let sRight = scrollBounds.right;
          let sTop = scrollBounds.top + totalHeaderHeight * scale;
          let sBottom = scrollBounds.bottom - trailingRowHeight * scale;
          const minx = targetRect.width + paddingX * 2;

          switch (options === null || options === void 0 ? void 0 : options.hAlign) {
            case "start":
              sRight = sLeft + minx;
              break;

            case "end":
              sLeft = sRight - minx;
              break;

            case "center":
              sLeft = Math.floor((sLeft + sRight) / 2) - minx / 2;
              sRight = sLeft + minx;
              break;
          }

          const miny = targetRect.height + paddingY * 2;

          switch (options === null || options === void 0 ? void 0 : options.vAlign) {
            case "start":
              sBottom = sTop + miny;
              break;

            case "end":
              sTop = sBottom - miny;
              break;

            case "center":
              sTop = Math.floor((sTop + sBottom) / 2) - miny / 2;
              sBottom = sTop + miny;
              break;
          }

          if (sLeft > bounds.x) {
            scrollX = bounds.x - sLeft;
          } else if (sRight < bounds.x + bounds.width) {
            scrollX = bounds.x + bounds.width - sRight;
          }

          if (sTop > bounds.y) {
            scrollY = bounds.y - sTop;
          } else if (sBottom < bounds.y + bounds.height) {
            scrollY = bounds.y + bounds.height - sBottom;
          }

          if (dir === "vertical" || col < freezeColumns) {
            scrollX = 0;
          } else if (dir === "horizontal") {
            scrollY = 0;
          }

          if (scrollX !== 0 || scrollY !== 0) {
            if (scale !== 1) {
              scrollX /= scale;
              scrollY /= scale;
            }

            scrollRef.current.scrollTo(scrollX + scrollRef.current.scrollLeft, scrollY + scrollRef.current.scrollTop);
          }
        }
      }
    }
  }, [rowMarkerOffset, rowMarkerWidth, totalHeaderHeight, lastRowSticky, freezeColumns, columns, rowHeight, rows]);
  const focusCallback = react.useRef(focusOnRowFromTrailingBlankRow);
  const getCellContentRef = react.useRef(getCellContent);
  const rowsRef = react.useRef(rows);
  focusCallback.current = focusOnRowFromTrailingBlankRow;
  getCellContentRef.current = getCellContent;
  rowsRef.current = rows;
  const appendRow = react.useCallback(async function (col) {
    var _c$trailingRowOptions6;

    let openOverlay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const c = mangledCols[col];

    if ((c === null || c === void 0 ? void 0 : (_c$trailingRowOptions6 = c.trailingRowOptions) === null || _c$trailingRowOptions6 === void 0 ? void 0 : _c$trailingRowOptions6.disabled) === true) {
      return;
    }

    const appendResult = onRowAppended === null || onRowAppended === void 0 ? void 0 : onRowAppended();
    let r = undefined;
    let bottom = true;

    if (appendResult !== undefined) {
      r = await appendResult;
      if (r === "top") bottom = false;
      if (typeof r === "number") bottom = false;
    }

    let backoff = 0;

    const doFocus = () => {
      if (rowsRef.current <= rows) {
        if (backoff < 500) {
          window.setTimeout(doFocus, backoff);
        }

        backoff = 50 + backoff * 2;
        return;
      }

      const row = typeof r === "number" ? r : bottom ? rows : 0;
      scrollTo(col - rowMarkerOffset, row);
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, false, false, "edit");
      const cell = getCellContentRef.current([col - rowMarkerOffset, row]);

      if (cell.allowOverlay && (0,data_grid_types/* isReadWriteCell */.Qo)(cell) && cell.readonly !== true && openOverlay) {
        window.setTimeout(() => {
          focusCallback.current(col, row);
        }, 0);
      }
    };

    doFocus();
  }, [mangledCols, onRowAppended, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const getCustomNewRowTargetColumn = react.useCallback(col => {
    var _columns$col$trailing, _columns$col, _columns$col$trailing2;

    const customTargetColumn = (_columns$col$trailing = (_columns$col = columns[col]) === null || _columns$col === void 0 ? void 0 : (_columns$col$trailing2 = _columns$col.trailingRowOptions) === null || _columns$col$trailing2 === void 0 ? void 0 : _columns$col$trailing2.targetColumn) !== null && _columns$col$trailing !== void 0 ? _columns$col$trailing : trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.targetColumn;

    if (typeof customTargetColumn === "number") {
      const customTargetOffset = hasRowMarkers ? 1 : 0;
      return customTargetColumn + customTargetOffset;
    }

    if (typeof customTargetColumn === "object") {
      const maybeIndex = columnsIn.indexOf(customTargetColumn);

      if (maybeIndex >= 0) {
        const customTargetOffset = hasRowMarkers ? 1 : 0;
        return maybeIndex + customTargetOffset;
      }
    }

    return undefined;
  }, [columns, columnsIn, hasRowMarkers, trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.targetColumn]);
  const lastSelectedRowRef = react.useRef();
  const lastSelectedColRef = react.useRef();
  const themeForCell = react.useCallback((cell, pos) => {
    var _mangledCols$col;

    const [col, row] = pos;
    return { ...mergedTheme,
      ...((_mangledCols$col = mangledCols[col]) === null || _mangledCols$col === void 0 ? void 0 : _mangledCols$col.themeOverride),
      ...(getRowThemeOverride === null || getRowThemeOverride === void 0 ? void 0 : getRowThemeOverride(row)),
      ...cell.themeOverride
    };
  }, [getRowThemeOverride, mangledCols, mergedTheme]);
  const handleSelect = react.useCallback(args => {
    var _gridSelection$curren, _gridSelection$curren2;

    const isMultiKey = browser_detect/* browserIsOSX.value */.FR.value ? args.metaKey : args.ctrlKey;
    const isMultiRow = isMultiKey && rowSelect === "multi";
    const isMultiCol = isMultiKey && columnSelect === "multi";
    const [col, row] = args.location;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const [cellCol, cellRow] = (_gridSelection$curren = (_gridSelection$curren2 = gridSelection.current) === null || _gridSelection$curren2 === void 0 ? void 0 : _gridSelection$curren2.cell) !== null && _gridSelection$curren !== void 0 ? _gridSelection$curren : [];

    if (args.kind === "cell") {
      lastSelectedColRef.current = undefined;
      lastMouseSelectLocation.current = [col, row];

      if (col === 0 && hasRowMarkers) {
        if (showTrailingBlankRow === true && row === rows || rowMarkers === "number" || rowSelect === "none") return;
        const markerCell = getMangledCellContent(args.location);

        if (markerCell.kind !== data_grid_types/* InnerGridCellKind.Marker */.$o.Marker) {
          return;
        }

        if (onRowMoved !== undefined) {
          var _renderer$onClick;

          const renderer = getCellRenderer(markerCell);
          (0,support/* assert */.hu)((renderer === null || renderer === void 0 ? void 0 : renderer.kind) === data_grid_types/* InnerGridCellKind.Marker */.$o.Marker);
          const postClick = renderer === null || renderer === void 0 ? void 0 : (_renderer$onClick = renderer.onClick) === null || _renderer$onClick === void 0 ? void 0 : _renderer$onClick.call(renderer, { ...args,
            cell: markerCell,
            posX: args.localEventX,
            posY: args.localEventY,
            bounds: args.bounds,
            theme: themeForCell(markerCell, args.location),
            preventDefault: () => undefined
          });
          if (postClick === undefined || postClick.checked === markerCell.checked) return;
        }

        setOverlay(undefined);
        focus();
        const isSelected = selectedRows.hasIndex(row);
        const lastHighlighted = lastSelectedRowRef.current;

        if (rowSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastHighlighted !== undefined && selectedRows.hasIndex(lastHighlighted)) {
          const newSlice = [Math.min(lastHighlighted, row), Math.max(lastHighlighted, row) + 1];

          if (isMultiRow || rowSelectionMode === "multi") {
            setSelectedRows(undefined, newSlice, true);
          } else {
            setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(newSlice), undefined, isMultiRow);
          }
        } else if (isMultiRow || args.isTouch || rowSelectionMode === "multi") {
          if (isSelected) {
            setSelectedRows(selectedRows.remove(row), undefined, true);
          } else {
            setSelectedRows(undefined, row, true);
            lastSelectedRowRef.current = row;
          }
        } else if (isSelected && selectedRows.length === 1) {
          setSelectedRows(data_grid_types/* CompactSelection.empty */.EV.empty(), undefined, isMultiKey);
        } else {
          setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(row), undefined, isMultiKey);
          lastSelectedRowRef.current = row;
        }
      } else if (col >= rowMarkerOffset && showTrailingBlankRow && row === rows) {
        const customTargetColumn = getCustomNewRowTargetColumn(col);
        void appendRow(customTargetColumn !== null && customTargetColumn !== void 0 ? customTargetColumn : col);
      } else {
        if (cellCol !== col || cellRow !== row) {
          var _gridSelection$curren3;

          const cell = getMangledCellContent(args.location);
          const renderer = getCellRenderer(cell);

          if ((renderer === null || renderer === void 0 ? void 0 : renderer.onSelect) !== undefined) {
            let prevented = false;
            renderer.onSelect({ ...args,
              cell,
              posX: args.localEventX,
              posY: args.localEventY,
              bounds: args.bounds,
              preventDefault: () => prevented = true,
              theme: themeForCell(cell, args.location)
            });

            if (prevented) {
              return;
            }
          }

          const isLastStickyRow = lastRowSticky && row === rows;
          const startedFromLastSticky = lastRowSticky && gridSelection !== undefined && ((_gridSelection$curren3 = gridSelection.current) === null || _gridSelection$curren3 === void 0 ? void 0 : _gridSelection$curren3.cell[1]) === rows;

          if ((args.shiftKey || args.isLongTouch === true) && cellCol !== undefined && cellRow !== undefined && gridSelection.current !== undefined && !startedFromLastSticky) {
            if (isLastStickyRow) {
              return;
            }

            const left = Math.min(col, cellCol);
            const right = Math.max(col, cellCol);
            const top = Math.min(row, cellRow);
            const bottom = Math.max(row, cellRow);
            setCurrent({ ...gridSelection.current,
              range: {
                x: left,
                y: top,
                width: right - left + 1,
                height: bottom - top + 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = undefined;
            focus();
          } else {
            setCurrent({
              cell: [col, row],
              range: {
                x: col,
                y: row,
                width: 1,
                height: 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = undefined;
            setOverlay(undefined);
            focus();
          }
        }
      }
    } else if (args.kind === "header") {
      lastMouseSelectLocation.current = [col, row];
      setOverlay(undefined);

      if (hasRowMarkers && col === 0) {
        lastSelectedRowRef.current = undefined;
        lastSelectedColRef.current = undefined;

        if (rowSelect === "multi") {
          if (selectedRows.length !== rows) {
            setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection([0, rows]), undefined, isMultiKey);
          } else {
            setSelectedRows(data_grid_types/* CompactSelection.empty */.EV.empty(), undefined, isMultiKey);
          }

          focus();
        }
      } else {
        const lastCol = lastSelectedColRef.current;

        if (columnSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastCol !== undefined && selectedColumns.hasIndex(lastCol)) {
          const newSlice = [Math.min(lastCol, col), Math.max(lastCol, col) + 1];

          if (isMultiCol) {
            setSelectedColumns(undefined, newSlice, isMultiKey);
          } else {
            setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(newSlice), undefined, isMultiKey);
          }
        } else if (isMultiCol) {
          if (selectedColumns.hasIndex(col)) {
            setSelectedColumns(selectedColumns.remove(col), undefined, isMultiKey);
          } else {
            setSelectedColumns(undefined, col, isMultiKey);
          }

          lastSelectedColRef.current = col;
        } else if (columnSelect !== "none") {
          setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(col), undefined, isMultiKey);
          lastSelectedColRef.current = col;
        }

        lastSelectedRowRef.current = undefined;
        focus();
      }
    } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      lastMouseSelectLocation.current = [col, row];
    } else if (args.kind === data_grid_types/* outOfBoundsKind */.Xv) {
      setGridSelection(emptyGridSelection, false);
      setOverlay(undefined);
      focus();
      onSelectionCleared === null || onSelectionCleared === void 0 ? void 0 : onSelectionCleared();
      lastSelectedRowRef.current = undefined;
      lastSelectedColRef.current = undefined;
    }
  }, [appendRow, columnSelect, focus, getCellRenderer, getCustomNewRowTargetColumn, getMangledCellContent, gridSelection, hasRowMarkers, lastRowSticky, onSelectionCleared, onRowMoved, rowMarkerOffset, rowMarkers, rowSelect, rowSelectionMode, rows, setCurrent, setGridSelection, setSelectedColumns, setSelectedRows, showTrailingBlankRow, themeForCell]);
  const lastMouseSelectLocation = react.useRef();
  const touchDownArgs = react.useRef(visibleRegion);
  const mouseDownData = react.useRef();
  const onMouseDown = react.useCallback(args => {
    var _mouseDownData$curren, _mouseDownData$curren2;

    isPrevented.current = false;
    touchDownArgs.current = visibleRegionRef.current;

    if (args.button !== 0) {
      mouseDownData.current = undefined;
      return;
    }

    const time = performance.now();
    const wasDoubleClick = time - ((_mouseDownData$curren = (_mouseDownData$curren2 = mouseDownData.current) === null || _mouseDownData$curren2 === void 0 ? void 0 : _mouseDownData$curren2.time) !== null && _mouseDownData$curren !== void 0 ? _mouseDownData$curren : -1000) < 250;
    mouseDownData.current = {
      wasDoubleClick,
      time,
      location: args.location
    };
    const fh = args.kind === "cell" && args.isFillHandle;
    if (!fh && args.kind !== "cell" && args.isEdge) return;
    setMouseState({
      previousSelection: gridSelection,
      fillHandle: fh
    });
    lastMouseSelectLocation.current = undefined;

    if (!args.isTouch) {
      handleSelect(args);
    }
  }, [gridSelection, handleSelect]);
  const [renameGroup, setRenameGroup] = react.useState();
  const handleGroupHeaderSelection = react.useCallback(args => {
    if (args.kind !== data_grid_types/* groupHeaderKind */.mr || columnSelect !== "multi") {
      return;
    }

    const isMultiKey = browser_detect/* browserIsOSX.value */.FR.value ? args.metaKey : args.ctrlKey;
    const [col] = args.location;
    const selectedColumns = gridSelection.columns;
    if (col < rowMarkerOffset) return;
    const needle = mangledCols[col];
    let start = col;
    let end = col;

    for (let i = col - 1; i >= rowMarkerOffset; i--) {
      if (!(0,data_grid_lib/* isGroupEqual */.PU)(needle.group, mangledCols[i].group)) break;
      start--;
    }

    for (let i = col + 1; i < mangledCols.length; i++) {
      if (!(0,data_grid_lib/* isGroupEqual */.PU)(needle.group, mangledCols[i].group)) break;
      end++;
    }

    focus();

    if (isMultiKey) {
      if (selectedColumns.hasAll([start, end + 1])) {
        let newVal = selectedColumns;

        for (let index = start; index <= end; index++) {
          newVal = newVal.remove(index);
        }

        setSelectedColumns(newVal, undefined, isMultiKey);
      } else {
        setSelectedColumns(undefined, [start, end + 1], isMultiKey);
      }
    } else {
      setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection([start, end + 1]), undefined, isMultiKey);
    }
  }, [columnSelect, focus, gridSelection.columns, mangledCols, rowMarkerOffset, setSelectedColumns]);
  const fillDown = react.useCallback(reverse => {
    var _gridRef$current5;

    if (gridSelection.current === undefined) return;
    const v = [];
    const r = gridSelection.current.range;

    for (let x = 0; x < r.width; x++) {
      const fillCol = x + r.x;
      const fillVal = getMangledCellContent([fillCol, reverse ? r.y + r.height - 1 : r.y]);
      if ((0,data_grid_types/* isInnerOnlyCell */.rs)(fillVal) || !(0,data_grid_types/* isReadWriteCell */.Qo)(fillVal)) continue;

      for (let y = 1; y < r.height; y++) {
        const fillRow = reverse ? r.y + r.height - (y + 1) : y + r.y;
        const target = [fillCol, fillRow];
        v.push({
          location: target,
          value: { ...fillVal
          }
        });
      }
    }

    mangledOnCellsEdited(v);
    (_gridRef$current5 = gridRef.current) === null || _gridRef$current5 === void 0 ? void 0 : _gridRef$current5.damage(v.map(c => ({
      cell: c.location
    })));
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited]);
  const isPrevented = react.useRef(false);
  const normalSizeColumn = react.useCallback(async function (col) {
    var _mouseDownData$curren3;

    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if ((((_mouseDownData$curren3 = mouseDownData.current) === null || _mouseDownData$curren3 === void 0 ? void 0 : _mouseDownData$curren3.wasDoubleClick) === true || force) && getCellsForSelection !== undefined && onColumnResize !== undefined) {
      const start = visibleRegionRef.current.y;
      const end = visibleRegionRef.current.height;
      let cells = getCellsForSelection({
        x: col,
        y: start,
        width: 1,
        height: Math.min(end, rows - start)
      }, abortControllerRef.current.signal);

      if (typeof cells !== "object") {
        cells = await cells();
      }

      const inputCol = columns[col - rowMarkerOffset];
      const offscreen = document.createElement("canvas");
      const ctx = offscreen.getContext("2d", {
        alpha: false
      });

      if (ctx !== null) {
        ctx.font = `${mergedTheme.baseFontStyle} ${mergedTheme.fontFamily}`;
        const newCol = measureColumn(ctx, mergedTheme, inputCol, 0, cells, minColumnWidth, maxColumnWidth, false, getCellRenderer);
        onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(inputCol, newCol.width, col, newCol.width);
      }
    }
  }, [columns, getCellsForSelection, maxColumnWidth, mergedTheme, minColumnWidth, onColumnResize, rowMarkerOffset, rows, getCellRenderer]);
  const [scrollDir, setScrollDir] = react.useState();
  const onMouseUp = react.useCallback((args, isOutside) => {
    var _lastMouseSelectLocat;

    const mouse = mouseState;
    setMouseState(undefined);
    setScrollDir(undefined);
    if (isOutside) return;

    if ((mouse === null || mouse === void 0 ? void 0 : mouse.fillHandle) === true && gridSelection.current !== undefined) {
      fillDown(gridSelection.current.cell[1] !== gridSelection.current.range.y);
      return;
    }

    const [col, row] = args.location;
    const [lastMouseDownCol, lastMouseDownRow] = (_lastMouseSelectLocat = lastMouseSelectLocation.current) !== null && _lastMouseSelectLocat !== void 0 ? _lastMouseSelectLocat : [];

    const preventDefault = () => {
      isPrevented.current = true;
    };

    const handleMaybeClick = a => {
      if (a.isTouch || lastMouseDownCol === col && lastMouseDownRow === row) {
        onCellClicked === null || onCellClicked === void 0 ? void 0 : onCellClicked([col - rowMarkerOffset, row], { ...a,
          preventDefault
        });
      }

      if (!isPrevented.current) {
        var _mouse$previousSelect, _mouse$previousSelect2;

        const c = getMangledCellContent(args.location);
        const r = getCellRenderer(c);

        if (r !== undefined && r.onClick !== undefined) {
          const newVal = r.onClick({ ...a,
            cell: c,
            posX: a.localEventX,
            posY: a.localEventY,
            bounds: a.bounds,
            theme: themeForCell(c, args.location),
            preventDefault
          });

          if (newVal !== undefined && !(0,data_grid_types/* isInnerOnlyCell */.rs)(newVal) && (0,data_grid_types/* isEditableGridCell */.T9)(newVal)) {
            var _gridRef$current6;

            mangledOnCellsEdited([{
              location: a.location,
              value: newVal
            }]);
            (_gridRef$current6 = gridRef.current) === null || _gridRef$current6 === void 0 ? void 0 : _gridRef$current6.damage([{
              cell: a.location
            }]);
          }
        }

        if (!isPrevented.current && (mouse === null || mouse === void 0 ? void 0 : (_mouse$previousSelect = mouse.previousSelection) === null || _mouse$previousSelect === void 0 ? void 0 : (_mouse$previousSelect2 = _mouse$previousSelect.current) === null || _mouse$previousSelect2 === void 0 ? void 0 : _mouse$previousSelect2.cell) !== undefined && gridSelection.current !== undefined) {
          const [selectedCol, selectedRow] = gridSelection.current.cell;
          const [prevCol, prevRow] = mouse.previousSelection.current.cell;

          if (col === selectedCol && col === prevCol && row === selectedRow && row === prevRow) {
            onCellActivated === null || onCellActivated === void 0 ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
            reselect(a.bounds, false);
            return true;
          }
        }
      }

      return false;
    };

    const clickLocation = args.location[0] - rowMarkerOffset;

    if (args.isTouch) {
      const vr = visibleRegionRef.current;
      const touchVr = touchDownArgs.current;

      if (vr.x !== touchVr.x || vr.y !== touchVr.y) {
        return;
      }

      if (args.isLongTouch === true) {
        var _gridSelection$curren4, _gridSelection$curren5;

        if (args.kind === "cell" && (gridSelection === null || gridSelection === void 0 ? void 0 : (_gridSelection$curren4 = gridSelection.current) === null || _gridSelection$curren4 === void 0 ? void 0 : _gridSelection$curren4.cell[0]) === col && (gridSelection === null || gridSelection === void 0 ? void 0 : (_gridSelection$curren5 = gridSelection.current) === null || _gridSelection$curren5 === void 0 ? void 0 : _gridSelection$curren5.cell[1]) === row) {
          onCellContextMenu === null || onCellContextMenu === void 0 ? void 0 : onCellContextMenu([clickLocation, args.location[1]], { ...args,
            preventDefault
          });
          return;
        } else if (args.kind === "header" && gridSelection.columns.hasIndex(col)) {
          onHeaderContextMenu === null || onHeaderContextMenu === void 0 ? void 0 : onHeaderContextMenu(clickLocation, { ...args,
            preventDefault
          });
          return;
        } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
          if (clickLocation < 0) {
            return;
          }

          onGroupHeaderContextMenu === null || onGroupHeaderContextMenu === void 0 ? void 0 : onGroupHeaderContextMenu(clickLocation, { ...args,
            preventDefault
          });
          return;
        }
      }

      if (args.kind === "cell") {
        if (!handleMaybeClick(args)) {
          handleSelect(args);
        }
      } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
        onGroupHeaderClicked === null || onGroupHeaderClicked === void 0 ? void 0 : onGroupHeaderClicked(clickLocation, { ...args,
          preventDefault
        });
      } else {
        if (args.kind === data_grid_types/* headerKind */.aZ) {
          onHeaderClicked === null || onHeaderClicked === void 0 ? void 0 : onHeaderClicked(clickLocation, { ...args,
            preventDefault
          });
        }

        handleSelect(args);
      }

      return;
    }

    if (args.kind === "header") {
      if (clickLocation < 0) {
        return;
      }

      if (args.isEdge) {
        void normalSizeColumn(col);
      } else if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onHeaderClicked === null || onHeaderClicked === void 0 ? void 0 : onHeaderClicked(clickLocation, { ...args,
          preventDefault
        });
      }
    }

    if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      if (clickLocation < 0) {
        return;
      }

      if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onGroupHeaderClicked === null || onGroupHeaderClicked === void 0 ? void 0 : onGroupHeaderClicked(clickLocation, { ...args,
          preventDefault
        });

        if (!isPrevented.current) {
          handleGroupHeaderSelection(args);
        }
      }
    }

    if (args.kind === "cell" && args.button === 0) {
      handleMaybeClick(args);
    }

    lastMouseSelectLocation.current = undefined;
  }, [mouseState, rowMarkerOffset, gridSelection, onCellClicked, fillDown, getMangledCellContent, getCellRenderer, themeForCell, mangledOnCellsEdited, onCellActivated, reselect, onCellContextMenu, onHeaderContextMenu, onGroupHeaderContextMenu, handleSelect, onGroupHeaderClicked, normalSizeColumn, onHeaderClicked, handleGroupHeaderSelection]);
  const onMouseMoveImpl = react.useCallback(args => {
    const a = { ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    };
    onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(a);
    setScrollDir(cv => {
      var _mouseDownData$curren4, _mouseDownData$curren5;

      if (args.scrollEdge[0] === (cv === null || cv === void 0 ? void 0 : cv[0]) && args.scrollEdge[1] === cv[1]) return cv;
      return mouseState === undefined || ((_mouseDownData$curren4 = (_mouseDownData$curren5 = mouseDownData.current) === null || _mouseDownData$curren5 === void 0 ? void 0 : _mouseDownData$curren5.location[0]) !== null && _mouseDownData$curren4 !== void 0 ? _mouseDownData$curren4 : 0) < rowMarkerOffset ? undefined : args.scrollEdge;
    });
  }, [mouseState, onMouseMove, rowMarkerOffset]);
  useAutoscroll(scrollDir, scrollRef);
  const onHeaderMenuClickInner = react.useCallback((col, screenPosition) => {
    onHeaderMenuClick === null || onHeaderMenuClick === void 0 ? void 0 : onHeaderMenuClick(col - rowMarkerOffset, screenPosition);
  }, [onHeaderMenuClick, rowMarkerOffset]);
  const currentCell = gridSelection === null || gridSelection === void 0 ? void 0 : (_gridSelection$curren6 = gridSelection.current) === null || _gridSelection$curren6 === void 0 ? void 0 : _gridSelection$curren6.cell;
  const onVisibleRegionChangedImpl = react.useCallback((region, clientWidth, clientHeight, rightElWidth, tx, ty) => {
    hasJustScrolled.current = false;
    let selected = currentCell;

    if (selected !== undefined) {
      selected = [selected[0] - rowMarkerOffset, selected[1]];
    }

    const newRegion = {
      x: region.x - rowMarkerOffset,
      y: region.y,
      width: region.width,
      height: showTrailingBlankRow && region.y + region.height >= rows ? region.height - 1 : region.height,
      tx,
      ty,
      extras: {
        selected,
        freezeRegion: freezeColumns === 0 ? undefined : {
          x: 0,
          y: region.y,
          width: freezeColumns,
          height: region.height
        }
      }
    };
    visibleRegionRef.current = newRegion;
    setVisibleRegion(newRegion);
    setClientSize([clientWidth, clientHeight, rightElWidth]);
    onVisibleRegionChanged === null || onVisibleRegionChanged === void 0 ? void 0 : onVisibleRegionChanged(newRegion, newRegion.tx, newRegion.ty, newRegion.extras);
  }, [currentCell, rowMarkerOffset, showTrailingBlankRow, rows, freezeColumns, setVisibleRegion, onVisibleRegionChanged]);
  const onColumnMovedImpl = (0,utils/* whenDefined */.qJ)(onColumnMoved, react.useCallback((startIndex, endIndex) => {
    onColumnMoved === null || onColumnMoved === void 0 ? void 0 : onColumnMoved(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);

    if (columnSelect !== "none") {
      setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(endIndex), undefined, true);
    }
  }, [columnSelect, onColumnMoved, rowMarkerOffset, setSelectedColumns]));
  const isActivelyDragging = react.useRef(false);
  const onDragStartImpl = react.useCallback(args => {
    if (args.location[0] === 0 && rowMarkerOffset > 0) {
      args.preventDefault();
      return;
    }

    onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({ ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });

    if (!args.defaultPrevented()) {
      isActivelyDragging.current = true;
    }

    setMouseState(undefined);
  }, [onDragStart, rowMarkerOffset]);
  const onDragEnd = react.useCallback(() => {
    isActivelyDragging.current = false;
  }, []);
  const onItemHoveredImpl = react.useCallback(args => {
    var _mouseDownData$curren6;

    if (mouseState !== undefined && ((_mouseDownData$curren6 = mouseDownData.current) === null || _mouseDownData$curren6 === void 0 ? void 0 : _mouseDownData$curren6.location[0]) === 0 && args.location[0] === 0 && rowMarkerOffset === 1 && rowSelect === "multi" && mouseState.previousSelection && !mouseState.previousSelection.rows.hasIndex(mouseDownData.current.location[1]) && gridSelection.rows.hasIndex(mouseDownData.current.location[1])) {
      const start = Math.min(mouseDownData.current.location[1], args.location[1]);
      const end = Math.max(mouseDownData.current.location[1], args.location[1]) + 1;
      setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection([start, end]), undefined, false);
    }

    if (mouseState !== undefined && gridSelection.current !== undefined && !isActivelyDragging.current && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
      const [selectedCol, selectedRow] = gridSelection.current.cell;
      let [col, row] = args.location;

      if (row < 0) {
        row = visibleRegionRef.current.y;
      }

      const startedFromLastStickyRow = lastRowSticky && selectedRow === rows;
      if (startedFromLastStickyRow) return;
      const landedOnLastStickyRow = lastRowSticky && row === rows;

      if (landedOnLastStickyRow) {
        if (args.kind === data_grid_types/* outOfBoundsKind */.Xv) row--;else return;
      }

      col = Math.max(col, rowMarkerOffset);
      const deltaX = col - selectedCol;
      const deltaY = row - selectedRow;
      const newRange = {
        x: deltaX >= 0 ? selectedCol : col,
        y: deltaY >= 0 ? selectedRow : row,
        width: Math.abs(deltaX) + 1,
        height: Math.abs(deltaY) + 1
      };
      setCurrent({ ...gridSelection.current,
        range: newRange
      }, true, false, "drag");
    }

    onItemHovered === null || onItemHovered === void 0 ? void 0 : onItemHovered({ ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });
  }, [mouseState, rowMarkerOffset, rowSelect, gridSelection, rangeSelect, onItemHovered, setSelectedRows, lastRowSticky, rows, setCurrent]);
  const adjustSelection = react.useCallback(direction => {
    if (gridSelection.current === undefined) return;
    const [x, y] = direction;
    const [col, row] = gridSelection.current.cell;
    const old = gridSelection.current.range;
    let left = old.x;
    let right = old.x + old.width;
    let top = old.y;
    let bottom = old.y + old.height;

    if (y !== 0) {
      switch (y) {
        case 2:
          {
            bottom = rows;
            top = row;
            scrollTo(0, bottom, "vertical");
            break;
          }

        case -2:
          {
            top = 0;
            bottom = row + 1;
            scrollTo(0, top, "vertical");
            break;
          }

        case 1:
          {
            if (top < row) {
              top++;
              scrollTo(0, top, "vertical");
            } else {
              bottom = Math.min(rows, bottom + 1);
              scrollTo(0, bottom, "vertical");
            }

            break;
          }

        case -1:
          {
            if (bottom > row + 1) {
              bottom--;
              scrollTo(0, bottom, "vertical");
            } else {
              top = Math.max(0, top - 1);
              scrollTo(0, top, "vertical");
            }

            break;
          }

        default:
          {
            (0,support/* assertNever */.vE)(y);
          }
      }
    }

    if (x !== 0) {
      if (x === 2) {
        right = mangledCols.length;
        left = col;
        scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
      } else if (x === -2) {
        left = rowMarkerOffset;
        right = col + 1;
        scrollTo(left - rowMarkerOffset, 0, "horizontal");
      } else {
        let disallowed = [];

        if (getCellsForSelection !== undefined) {
          const cells = getCellsForSelection({
            x: left,
            y: top,
            width: right - left - rowMarkerOffset,
            height: bottom - top
          }, abortControllerRef.current.signal);

          if (typeof cells === "object") {
            disallowed = getSpanStops(cells);
          }
        }

        if (x === 1) {
          let done = false;

          if (left < col) {
            if (disallowed.length > 0) {
              const target = range_default()(left + 1, col + 1).find(n => !disallowed.includes(n - rowMarkerOffset));

              if (target !== undefined) {
                left = target;
                done = true;
              }
            } else {
              left++;
              done = true;
            }

            if (done) scrollTo(left, 0, "horizontal");
          }

          if (!done) {
            right = Math.min(mangledCols.length, right + 1);
            scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
          }
        } else if (x === -1) {
          let done = false;

          if (right > col + 1) {
            if (disallowed.length > 0) {
              const target = range_default()(right - 1, col, -1).find(n => !disallowed.includes(n - rowMarkerOffset));

              if (target !== undefined) {
                right = target;
                done = true;
              }
            } else {
              right--;
              done = true;
            }

            if (done) scrollTo(right - rowMarkerOffset, 0, "horizontal");
          }

          if (!done) {
            left = Math.max(rowMarkerOffset, left - 1);
            scrollTo(left - rowMarkerOffset, 0, "horizontal");
          }
        } else {
          (0,support/* assertNever */.vE)(x);
        }
      }
    }

    setCurrent({
      cell: gridSelection.current.cell,
      range: {
        x: left,
        y: top,
        width: right - left,
        height: bottom - top
      }
    }, true, false, "keyboard-select");
  }, [getCellsForSelection, gridSelection, mangledCols.length, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const updateSelectedCell = react.useCallback((col, row, fromEditingTrailingRow, freeMove) => {
    const rowMax = mangledRows - (fromEditingTrailingRow ? 0 : 1);
    col = clamp_default()(col, rowMarkerOffset, columns.length - 1 + rowMarkerOffset);
    row = clamp_default()(row, 0, rowMax);
    if (col === (currentCell === null || currentCell === void 0 ? void 0 : currentCell[0]) && row === (currentCell === null || currentCell === void 0 ? void 0 : currentCell[1])) return false;

    if (freeMove && gridSelection.current !== undefined) {
      const newStack = [...gridSelection.current.rangeStack];

      if (gridSelection.current.range.width > 1 || gridSelection.current.range.height > 1) {
        newStack.push(gridSelection.current.range);
      }

      setGridSelection({ ...gridSelection,
        current: {
          cell: [col, row],
          range: {
            x: col,
            y: row,
            width: 1,
            height: 1
          },
          rangeStack: newStack
        }
      }, true);
    } else {
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-nav");
    }

    if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {
      lastSent.current = undefined;
    }

    scrollTo(col - rowMarkerOffset, row);
    return true;
  }, [mangledRows, rowMarkerOffset, columns.length, currentCell, gridSelection, scrollTo, setGridSelection, setCurrent]);
  const onFinishEditing = react.useCallback((newValue, movement) => {
    if ((overlay === null || overlay === void 0 ? void 0 : overlay.cell) !== undefined && newValue !== undefined && (0,data_grid_types/* isEditableGridCell */.T9)(newValue)) {
      mangledOnCellsEdited([{
        location: overlay.cell,
        value: newValue
      }]);
      window.requestAnimationFrame(() => {
        var _gridRef$current7;

        (_gridRef$current7 = gridRef.current) === null || _gridRef$current7 === void 0 ? void 0 : _gridRef$current7.damage([{
          cell: overlay.cell
        }]);
      });
    }

    focus(true);
    setOverlay(undefined);
    const [movX, movY] = movement;

    if (gridSelection.current !== undefined && (movX !== 0 || movY !== 0)) {
      const isEditingTrailingRow = gridSelection.current.cell[1] === mangledRows - 1 && newValue !== undefined;
      updateSelectedCell(clamp_default()(gridSelection.current.cell[0] + movX, 0, mangledCols.length - 1), clamp_default()(gridSelection.current.cell[1] + movY, 0, mangledRows - 1), isEditingTrailingRow, false);
    }

    onFinishedEditing === null || onFinishedEditing === void 0 ? void 0 : onFinishedEditing(newValue, movement);
  }, [overlay === null || overlay === void 0 ? void 0 : overlay.cell, focus, gridSelection, onFinishedEditing, mangledOnCellsEdited, mangledRows, updateSelectedCell, mangledCols.length]);
  const overlayID = react.useMemo(() => {
    return `gdg-overlay-${idCounter++}`;
  }, []);
  const onKeyDown = react.useCallback(event => {
    const fn = async () => {
      let cancelled = false;

      if (onKeyDownIn !== undefined) {
        onKeyDownIn({ ...event,
          cancel: () => {
            cancelled = true;
          }
        });
      }

      if (cancelled) return;

      const cancel = () => {
        event.stopPropagation();
        event.preventDefault();
      };

      const overlayOpen = overlay !== undefined;
      const {
        altKey,
        shiftKey,
        metaKey,
        ctrlKey,
        key,
        bounds
      } = event;
      const isOSX = browser_detect/* browserIsOSX.value */.FR.value;
      const isPrimaryKey = isOSX ? metaKey : ctrlKey;
      const isDeleteKey = key === "Delete" || isOSX && key === "Backspace";
      const vr = visibleRegionRef.current;
      const selectedColumns = gridSelection.columns;
      const selectedRows = gridSelection.rows;

      if (key === "Escape") {
        if (overlayOpen) {
          setOverlay(undefined);
        } else if (keybindings.clear) {
          setGridSelection(emptyGridSelection, false);
          onSelectionCleared === null || onSelectionCleared === void 0 ? void 0 : onSelectionCleared();
        }

        return;
      } else if (isHotkey("primary+a", event) && keybindings.selectAll) {
        if (!overlayOpen) {
          var _gridSelection$curren7, _gridSelection$curren8;

          setGridSelection({
            columns: data_grid_types/* CompactSelection.empty */.EV.empty(),
            rows: data_grid_types/* CompactSelection.empty */.EV.empty(),
            current: {
              cell: (_gridSelection$curren7 = (_gridSelection$curren8 = gridSelection.current) === null || _gridSelection$curren8 === void 0 ? void 0 : _gridSelection$curren8.cell) !== null && _gridSelection$curren7 !== void 0 ? _gridSelection$curren7 : [rowMarkerOffset, 0],
              range: {
                x: rowMarkerOffset,
                y: 0,
                width: columnsIn.length,
                height: rows
              },
              rangeStack: []
            }
          }, false);
        } else {
          const el = document.getElementById(overlayID);

          if (el !== null) {
            const s = window.getSelection();
            const r = document.createRange();
            r.selectNodeContents(el);
            s === null || s === void 0 ? void 0 : s.removeAllRanges();
            s === null || s === void 0 ? void 0 : s.addRange(r);
          }
        }

        cancel();
        return;
      } else if (isHotkey("primary+f", event) && keybindings.search) {
        var _searchInputRef$curre;

        cancel();
        searchInputRef === null || searchInputRef === void 0 ? void 0 : (_searchInputRef$curre = searchInputRef.current) === null || _searchInputRef$curre === void 0 ? void 0 : _searchInputRef$curre.focus({
          preventScroll: true
        });
        setShowSearchInner(true);
      }

      function deleteRange(r) {
        var _gridRef$current8;

        focus();
        const editList = [];

        for (let x = r.x; x < r.x + r.width; x++) {
          for (let y = r.y; y < r.y + r.height; y++) {
            const cellValue = getCellContent([x - rowMarkerOffset, y]);
            if (!cellValue.allowOverlay && cellValue.kind !== data_grid_types/* GridCellKind.Boolean */.p6.Boolean) continue;
            let newVal = undefined;

            if (cellValue.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom) {
              var _toDelete$provideEdit;

              const toDelete = getCellRenderer(cellValue);
              const editor = toDelete === null || toDelete === void 0 ? void 0 : (_toDelete$provideEdit = toDelete.provideEditor) === null || _toDelete$provideEdit === void 0 ? void 0 : _toDelete$provideEdit.call(toDelete, cellValue);

              if ((toDelete === null || toDelete === void 0 ? void 0 : toDelete.onDelete) !== undefined) {
                newVal = toDelete.onDelete(cellValue);
              } else if ((0,data_grid_types/* isObjectEditorCallbackResult */.DP)(editor)) {
                var _editor$deletedValue;

                newVal = editor === null || editor === void 0 ? void 0 : (_editor$deletedValue = editor.deletedValue) === null || _editor$deletedValue === void 0 ? void 0 : _editor$deletedValue.call(editor, cellValue);
              }
            } else if ((0,data_grid_types/* isEditableGridCell */.T9)(cellValue) && cellValue.allowOverlay || cellValue.kind === data_grid_types/* GridCellKind.Boolean */.p6.Boolean) {
              var _toDelete$onDelete;

              const toDelete = getCellRenderer(cellValue);
              newVal = toDelete === null || toDelete === void 0 ? void 0 : (_toDelete$onDelete = toDelete.onDelete) === null || _toDelete$onDelete === void 0 ? void 0 : _toDelete$onDelete.call(toDelete, cellValue);
            }

            if (newVal !== undefined && !(0,data_grid_types/* isInnerOnlyCell */.rs)(newVal) && (0,data_grid_types/* isEditableGridCell */.T9)(newVal)) {
              editList.push({
                location: [x, y],
                value: newVal
              });
            }
          }
        }

        mangledOnCellsEdited(editList);
        (_gridRef$current8 = gridRef.current) === null || _gridRef$current8 === void 0 ? void 0 : _gridRef$current8.damage(editList.map(x => ({
          cell: x.location
        })));
      }

      if (isDeleteKey) {
        var _onDelete;

        const callbackResult = (_onDelete = onDelete === null || onDelete === void 0 ? void 0 : onDelete(gridSelection)) !== null && _onDelete !== void 0 ? _onDelete : true;
        cancel();

        if (callbackResult !== false) {
          const toDelete = callbackResult === true ? gridSelection : callbackResult;

          if (toDelete.current !== undefined) {
            deleteRange(toDelete.current.range);

            for (const r of toDelete.current.rangeStack) {
              deleteRange(r);
            }
          }

          for (const r of toDelete.rows) {
            deleteRange({
              x: rowMarkerOffset,
              y: r,
              width: mangledCols.length - rowMarkerOffset,
              height: 1
            });
          }

          for (const col of toDelete.columns) {
            deleteRange({
              x: col,
              y: 0,
              width: 1,
              height: rows
            });
          }
        }

        return;
      }

      if (gridSelection.current === undefined) return;
      let [col, row] = gridSelection.current.cell;
      let freeMove = false;

      if (keybindings.selectColumn && isHotkey("ctrl+ ", event) && columnSelect !== "none") {
        if (selectedColumns.hasIndex(col)) {
          setSelectedColumns(selectedColumns.remove(col), undefined, true);
        } else {
          if (columnSelect === "single") {
            setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(col), undefined, true);
          } else {
            setSelectedColumns(undefined, col, true);
          }
        }
      } else if (keybindings.selectRow && isHotkey("shift+ ", event) && rowSelect !== "none") {
        if (selectedRows.hasIndex(row)) {
          setSelectedRows(selectedRows.remove(row), undefined, true);
        } else {
          if (rowSelect === "single") {
            setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(row), undefined, true);
          } else {
            setSelectedRows(undefined, row, true);
          }
        }
      } else if ((isHotkey("Enter", event) || isHotkey(" ", event) || isHotkey("shift+Enter", event)) && bounds !== undefined) {
        if (overlayOpen) {
          setOverlay(undefined);

          if (isHotkey("Enter", event)) {
            row++;
          } else if (isHotkey("shift+Enter", event)) {
            row--;
          }
        } else if (row === rows && showTrailingBlankRow) {
          window.setTimeout(() => {
            const customTargetColumn = getCustomNewRowTargetColumn(col);
            void appendRow(customTargetColumn !== null && customTargetColumn !== void 0 ? customTargetColumn : col);
          }, 0);
        } else {
          onCellActivated === null || onCellActivated === void 0 ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
          reselect(bounds, true);
          cancel();
        }
      } else if (keybindings.downFill && isHotkey("primary+_68", event) && gridSelection.current.range.height > 1) {
        fillDown(false);
        cancel();
      } else if (keybindings.rightFill && isHotkey("primary+_82", event) && gridSelection.current.range.width > 1) {
        var _gridRef$current9;

        const editList = [];
        const r = gridSelection.current.range;

        for (let y = 0; y < r.height; y++) {
          const fillRow = y + r.y;
          const fillVal = getMangledCellContent([r.x, fillRow]);
          if ((0,data_grid_types/* isInnerOnlyCell */.rs)(fillVal) || !(0,data_grid_types/* isReadWriteCell */.Qo)(fillVal)) continue;

          for (let x = 1; x < r.width; x++) {
            const fillCol = x + r.x;
            const target = [fillCol, fillRow];
            editList.push({
              location: target,
              value: { ...fillVal
              }
            });
          }
        }

        mangledOnCellsEdited(editList);
        (_gridRef$current9 = gridRef.current) === null || _gridRef$current9 === void 0 ? void 0 : _gridRef$current9.damage(editList.map(c => ({
          cell: c.location
        })));
        cancel();
      } else if (keybindings.pageDown && isHotkey("PageDown", event)) {
        row += Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.pageUp && isHotkey("PageUp", event)) {
        row -= Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.first && isHotkey("primary+Home", event)) {
        setOverlay(undefined);
        row = 0;
        col = 0;
      } else if (keybindings.last && isHotkey("primary+End", event)) {
        setOverlay(undefined);
        row = Number.MAX_SAFE_INTEGER;
        col = Number.MAX_SAFE_INTEGER;
      } else if (keybindings.first && isHotkey("primary+shift+Home", event)) {
        setOverlay(undefined);
        adjustSelection([-2, -2]);
      } else if (keybindings.last && isHotkey("primary+shift+End", event)) {
        setOverlay(undefined);
        adjustSelection([2, 2]);
      } else if (key === "ArrowDown") {
        if (ctrlKey && altKey) {
          return;
        }

        setOverlay(undefined);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, isPrimaryKey && !altKey ? 2 : 1]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }

          if (isPrimaryKey && !altKey) {
            row = rows - 1;
          } else {
            row += 1;
          }
        }
      } else if (key === "ArrowUp" || key === "Home") {
        const asPrimary = key === "Home" || isPrimaryKey;
        setOverlay(undefined);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, asPrimary && !altKey ? -2 : -1]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }

          row += asPrimary && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "ArrowRight" || key === "End") {
        const asPrimary = key === "End" || isPrimaryKey;
        setOverlay(undefined);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([asPrimary && !altKey ? 2 : 1, 0]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }

          col += asPrimary && !altKey ? Number.MAX_SAFE_INTEGER : 1;
        }
      } else if (key === "ArrowLeft") {
        setOverlay(undefined);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([isPrimaryKey && !altKey ? -2 : -1, 0]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }

          col += isPrimaryKey && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "Tab") {
        setOverlay(undefined);

        if (shiftKey) {
          col--;
        } else {
          col++;
        }
      } else if (!metaKey && !ctrlKey && gridSelection.current !== undefined && key.length === 1 && /[ -~]/g.test(key) && bounds !== undefined && (0,data_grid_types/* isReadWriteCell */.Qo)(getCellContent([col - rowMarkerOffset, Math.max(0, row - 1)]))) {
        if ((!lastRowSticky || row !== rows) && (vr.y > row || row > vr.y + vr.height || vr.x > col || col > vr.x + vr.width)) {
          return;
        }

        reselect(bounds, true, key);
        cancel();
      }

      const moved = updateSelectedCell(col, row, false, freeMove);

      if (moved) {
        cancel();
      }
    };

    void fn();
  }, [onKeyDownIn, overlay, gridSelection, keybindings.selectAll, keybindings.search, keybindings.selectColumn, keybindings.selectRow, keybindings.downFill, keybindings.rightFill, keybindings.pageDown, keybindings.pageUp, keybindings.first, keybindings.last, keybindings.clear, columnSelect, rowSelect, getCellContent, rowMarkerOffset, updateSelectedCell, setGridSelection, onSelectionCleared, columnsIn.length, rows, overlayID, focus, mangledOnCellsEdited, getCellRenderer, onDelete, mangledCols.length, setSelectedColumns, setSelectedRows, showTrailingBlankRow, getCustomNewRowTargetColumn, appendRow, onCellActivated, reselect, fillDown, getMangledCellContent, adjustSelection, rangeSelect, lastRowSticky]);
  const onContextMenu = react.useCallback((args, preventDefault) => {
    const adjustedCol = args.location[0] - rowMarkerOffset;

    if (args.kind === "header") {
      onHeaderContextMenu === null || onHeaderContextMenu === void 0 ? void 0 : onHeaderContextMenu(adjustedCol, { ...args,
        preventDefault
      });
    }

    if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      if (adjustedCol < 0) {
        return;
      }

      onGroupHeaderContextMenu === null || onGroupHeaderContextMenu === void 0 ? void 0 : onGroupHeaderContextMenu(adjustedCol, { ...args,
        preventDefault
      });
    }

    if (args.kind === "cell") {
      const [col, row] = args.location;
      onCellContextMenu === null || onCellContextMenu === void 0 ? void 0 : onCellContextMenu([adjustedCol, row], { ...args,
        preventDefault
      });

      if (!(0,data_grid_types/* gridSelectionHasItem */.pZ)(gridSelection, args.location)) {
        updateSelectedCell(col, row, false, false);
      }
    }
  }, [gridSelection, onCellContextMenu, onGroupHeaderContextMenu, onHeaderContextMenu, rowMarkerOffset, updateSelectedCell]);
  const onPasteInternal = react.useCallback(async e => {
    var _scrollRef$current, _canvasRef$current, _gridSelection$curren9;

    if (!keybindings.paste) return;

    function pasteToCell(inner, target, toPaste) {
      if (!(0,data_grid_types/* isInnerOnlyCell */.rs)(inner) && (0,data_grid_types/* isReadWriteCell */.Qo)(inner) && inner.readonly !== true) {
        const coerced = coercePasteValue === null || coercePasteValue === void 0 ? void 0 : coercePasteValue(toPaste, inner);

        if (coerced !== undefined && (0,data_grid_types/* isEditableGridCell */.T9)(coerced)) {
          if (false) {}

          return {
            location: target,
            value: coerced
          };
        }

        const r = getCellRenderer(inner);
        if (r === undefined) return undefined;

        if (r.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom) {
          var _r$onPaste;

          (0,support/* assert */.hu)(inner.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom);
          const newVal = (_r$onPaste = r.onPaste) === null || _r$onPaste === void 0 ? void 0 : _r$onPaste.call(r, toPaste, inner);
          if (newVal === undefined) return undefined;
          return {
            location: target,
            value: { ...inner,
              data: newVal
            }
          };
        } else {
          var _r$onPaste2;

          const newVal = (_r$onPaste2 = r.onPaste) === null || _r$onPaste2 === void 0 ? void 0 : _r$onPaste2.call(r, toPaste, inner);
          if (newVal === undefined) return undefined;
          (0,support/* assert */.hu)(newVal.kind === inner.kind);
          return {
            location: target,
            value: newVal
          };
        }
      }

      return undefined;
    }

    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const focused = ((_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.contains(document.activeElement)) === true || ((_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 ? void 0 : _canvasRef$current.contains(document.activeElement)) === true;
    let target = (_gridSelection$curren9 = gridSelection.current) === null || _gridSelection$curren9 === void 0 ? void 0 : _gridSelection$curren9.cell;

    if (target === undefined && selectedColumns.length === 1) {
      var _selectedColumns$firs;

      target = [(_selectedColumns$firs = selectedColumns.first()) !== null && _selectedColumns$firs !== void 0 ? _selectedColumns$firs : 0, 0];
    }

    if (target === undefined && selectedRows.length === 1) {
      var _selectedRows$first;

      target = [rowMarkerOffset, (_selectedRows$first = selectedRows.first()) !== null && _selectedRows$first !== void 0 ? _selectedRows$first : 0];
    }

    if (focused && target !== undefined) {
      var _gridRef$current10;

      let data;
      let text;
      const textPlain = "text/plain";
      const textHtml = "text/html";

      if (navigator.clipboard.read !== undefined) {
        const clipboardContent = await navigator.clipboard.read();

        for (const item of clipboardContent) {
          if (item.types.includes(textHtml)) {
            const htmlBlob = await item.getType(textHtml);
            const html = await htmlBlob.text();
            const fragment = document.createElement("html");
            fragment.innerHTML = html;
            const el = fragment.querySelector("table");

            if (el !== null) {
              data = decodeHTML(el);
              break;
            }
          }

          if (item.types.includes(textPlain)) {
            text = await (await item.getType(textPlain)).text();
          }
        }
      } else if (navigator.clipboard.readText !== undefined) {
        text = await navigator.clipboard.readText();
      } else if (e !== undefined && (e === null || e === void 0 ? void 0 : e.clipboardData) !== null) {
        if (e.clipboardData.types.includes(textHtml)) {
          const html = e.clipboardData.getData(textHtml);
          const fragment = document.createElement("html");
          fragment.innerHTML = html;
          const el = fragment.querySelector("table");

          if (el !== null) {
            data = decodeHTML(el);
          }
        }

        if (data === undefined && e.clipboardData.types.includes(textPlain)) {
          text = e.clipboardData.getData(textPlain);
        }
      } else {
        return;
      }

      const [gridCol, gridRow] = target;
      const editList = [];

      do {
        if (onPaste === undefined) {
          var _ref2, _text, _data;

          const cellData = getMangledCellContent(target);
          const newVal = pasteToCell(cellData, target, (_ref2 = (_text = text) !== null && _text !== void 0 ? _text : (_data = data) === null || _data === void 0 ? void 0 : _data.map(r => r.join("\t")).join("\t")) !== null && _ref2 !== void 0 ? _ref2 : "");

          if (newVal !== undefined) {
            editList.push(newVal);
          }

          break;
        }

        if (data === undefined) {
          if (text === undefined) return;
          data = unquote(text);
        }

        if (onPaste === false || typeof onPaste === "function" && (onPaste === null || onPaste === void 0 ? void 0 : onPaste([target[0] - rowMarkerOffset, target[1]], data)) !== true) {
          return;
        }

        for (const [row, dataRow] of data.entries()) {
          if (row + gridRow >= rows) break;

          for (const [col, dataItem] of dataRow.entries()) {
            const index = [col + gridCol, row + gridRow];
            const cellData = getMangledCellContent(index);
            const newVal = pasteToCell(cellData, index, dataItem);

            if (newVal !== undefined) {
              editList.push(newVal);
            }
          }
        }
      } while (false);

      mangledOnCellsEdited(editList);
      (_gridRef$current10 = gridRef.current) === null || _gridRef$current10 === void 0 ? void 0 : _gridRef$current10.damage(editList.map(c => ({
        cell: c.location
      })));
    }
  }, [coercePasteValue, getCellRenderer, getMangledCellContent, gridSelection, keybindings.paste, mangledOnCellsEdited, onPaste, rowMarkerOffset, rows]);
  (0,utils/* useEventListener */.OR)("paste", onPasteInternal, window, false, true);
  const onCopy = react.useCallback(async (e, ignoreFocus) => {
    var _scrollRef$current2, _canvasRef$current2;

    if (!keybindings.copy) return;
    const focused = ignoreFocus === true || ((_scrollRef$current2 = scrollRef.current) === null || _scrollRef$current2 === void 0 ? void 0 : _scrollRef$current2.contains(document.activeElement)) === true || ((_canvasRef$current2 = canvasRef.current) === null || _canvasRef$current2 === void 0 ? void 0 : _canvasRef$current2.contains(document.activeElement)) === true;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;

    const copyToClipboardWithHeaders = (cells, columnIndexes) => {
      if (!copyHeaders) {
        copyToClipboard(cells, columnIndexes, e);
      } else {
        const headers = columnIndexes.map(index => ({
          kind: data_grid_types/* GridCellKind.Text */.p6.Text,
          data: columnsIn[index].title,
          displayData: columnsIn[index].title,
          allowOverlay: false
        }));
        copyToClipboard([headers, ...cells], columnIndexes, e);
      }
    };

    if (focused && getCellsForSelection !== undefined) {
      if (gridSelection.current !== undefined) {
        let thunk = getCellsForSelection(gridSelection.current.range, abortControllerRef.current.signal);

        if (typeof thunk !== "object") {
          thunk = await thunk();
        }

        copyToClipboardWithHeaders(thunk, range_default()(gridSelection.current.range.x - rowMarkerOffset, gridSelection.current.range.x + gridSelection.current.range.width - rowMarkerOffset));
      } else if (selectedRows !== undefined && selectedRows.length > 0) {
        const toCopy = [...selectedRows];
        const cells = toCopy.map(rowIndex => {
          const thunk = getCellsForSelection({
            x: rowMarkerOffset,
            y: rowIndex,
            width: columnsIn.length - rowMarkerOffset,
            height: 1
          }, abortControllerRef.current.signal);

          if (typeof thunk === "object") {
            return thunk[0];
          }

          return thunk().then(v => v[0]);
        });

        if (cells.some(x => x instanceof Promise)) {
          const settled = await Promise.all(cells);
          copyToClipboardWithHeaders(settled, range_default()(columnsIn.length));
        } else {
          copyToClipboardWithHeaders(cells, range_default()(columnsIn.length));
        }
      } else if (selectedColumns.length > 0) {
        const results = [];
        const cols = [];

        for (const col of selectedColumns) {
          let thunk = getCellsForSelection({
            x: col,
            y: 0,
            width: 1,
            height: rows
          }, abortControllerRef.current.signal);

          if (typeof thunk !== "object") {
            thunk = await thunk();
          }

          results.push(thunk);
          cols.push(col - rowMarkerOffset);
        }

        if (results.length === 1) {
          copyToClipboardWithHeaders(results[0], cols);
        } else {
          const toCopy = results.reduce((pv, cv) => pv.map((row, index) => [...row, ...cv[index]]));
          copyToClipboardWithHeaders(toCopy, cols);
        }
      }
    }
  }, [columnsIn, getCellsForSelection, gridSelection, keybindings.copy, rowMarkerOffset, rows, copyHeaders]);
  (0,utils/* useEventListener */.OR)("copy", onCopy, window, false, false);
  const onSearchResultsChanged = react.useCallback((results, navIndex) => {
    if (results.length === 0 || navIndex === -1) return;
    const [col, row] = results[navIndex];

    if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {
      return;
    }

    lastSent.current = [col, row];
    updateSelectedCell(col, row, false, false);
  }, [updateSelectedCell]);
  const [outCol, outRow] = (_gridSelectionOuter$c = gridSelectionOuter === null || gridSelectionOuter === void 0 ? void 0 : (_gridSelectionOuter$c2 = gridSelectionOuter.current) === null || _gridSelectionOuter$c2 === void 0 ? void 0 : _gridSelectionOuter$c2.cell) !== null && _gridSelectionOuter$c !== void 0 ? _gridSelectionOuter$c : [];
  const scrollToRef = react.useRef(scrollTo);
  scrollToRef.current = scrollTo;
  react.useLayoutEffect(() => {
    var _expectedExternalGrid, _expectedExternalGrid2, _expectedExternalGrid3, _expectedExternalGrid4;

    if (!hasJustScrolled.current && outCol !== undefined && outRow !== undefined && (outCol !== ((_expectedExternalGrid = expectedExternalGridSelection.current) === null || _expectedExternalGrid === void 0 ? void 0 : (_expectedExternalGrid2 = _expectedExternalGrid.current) === null || _expectedExternalGrid2 === void 0 ? void 0 : _expectedExternalGrid2.cell[0]) || outRow !== ((_expectedExternalGrid3 = expectedExternalGridSelection.current) === null || _expectedExternalGrid3 === void 0 ? void 0 : (_expectedExternalGrid4 = _expectedExternalGrid3.current) === null || _expectedExternalGrid4 === void 0 ? void 0 : _expectedExternalGrid4.cell[1]))) {
      scrollToRef.current(outCol, outRow);
    }

    hasJustScrolled.current = false;
  }, [outCol, outRow]);
  const selectionOutOfBounds = gridSelection.current !== undefined && (gridSelection.current.cell[0] >= columnsIn.length || gridSelection.current.cell[1] >= mangledRows);
  react.useLayoutEffect(() => {
    if (selectionOutOfBounds) {
      setGridSelection(emptyGridSelection, false);
    }
  }, [selectionOutOfBounds, setGridSelection]);
  const disabledRows = react.useMemo(() => {
    if (showTrailingBlankRow === true && (trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.tint) === true) {
      return data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(mangledRows - 1);
    }

    return data_grid_types/* CompactSelection.empty */.EV.empty();
  }, [mangledRows, showTrailingBlankRow, trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.tint]);
  const mangledVerticalBorder = react.useCallback(col => {
    var _verticalBorder;

    return typeof verticalBorder === "boolean" ? verticalBorder : (_verticalBorder = verticalBorder === null || verticalBorder === void 0 ? void 0 : verticalBorder(col - rowMarkerOffset)) !== null && _verticalBorder !== void 0 ? _verticalBorder : true;
  }, [rowMarkerOffset, verticalBorder]);
  const renameGroupNode = react.useMemo(() => {
    if (renameGroup === undefined || canvasRef.current === null) return null;
    const {
      bounds,
      group
    } = renameGroup;
    const canvasBounds = canvasRef.current.getBoundingClientRect();
    return react.createElement(GroupRename, {
      bounds: bounds,
      group: group,
      canvasBounds: canvasBounds,
      onClose: () => setRenameGroup(undefined),
      onFinish: newVal => {
        setRenameGroup(undefined);
        onGroupHeaderRenamed === null || onGroupHeaderRenamed === void 0 ? void 0 : onGroupHeaderRenamed(group, newVal);
      }
    });
  }, [onGroupHeaderRenamed, renameGroup]);
  const mangledFreezeColumns = Math.min(mangledCols.length, freezeColumns + (hasRowMarkers ? 1 : 0));
  react.useImperativeHandle(forwardedRef, () => ({
    appendRow: col => appendRow(col + rowMarkerOffset),
    updateCells: damageList => {
      var _gridRef$current11;

      if (rowMarkerOffset !== 0) {
        damageList = damageList.map(x => ({
          cell: [x.cell[0] + rowMarkerOffset, x.cell[1]]
        }));
      }

      return (_gridRef$current11 = gridRef.current) === null || _gridRef$current11 === void 0 ? void 0 : _gridRef$current11.damage(damageList);
    },
    getBounds: (col, row) => {
      var _gridRef$current12;

      return (_gridRef$current12 = gridRef.current) === null || _gridRef$current12 === void 0 ? void 0 : _gridRef$current12.getBounds(col + rowMarkerOffset, row);
    },
    focus: () => {
      var _gridRef$current13;

      return (_gridRef$current13 = gridRef.current) === null || _gridRef$current13 === void 0 ? void 0 : _gridRef$current13.focus();
    },
    emit: async e => {
      switch (e) {
        case "delete":
          onKeyDown({
            bounds: undefined,
            cancel: () => undefined,
            stopPropagation: () => undefined,
            preventDefault: () => undefined,
            ctrlKey: false,
            key: "Delete",
            keyCode: 46,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: undefined
          });
          break;

        case "fill-right":
          onKeyDown({
            bounds: undefined,
            cancel: () => undefined,
            stopPropagation: () => undefined,
            preventDefault: () => undefined,
            ctrlKey: true,
            key: "r",
            keyCode: 82,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: undefined
          });
          break;

        case "fill-down":
          onKeyDown({
            bounds: undefined,
            cancel: () => undefined,
            stopPropagation: () => undefined,
            preventDefault: () => undefined,
            ctrlKey: true,
            key: "d",
            keyCode: 68,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: undefined
          });
          break;

        case "copy":
          await onCopy(undefined, true);
          break;

        case "paste":
          await onPasteInternal();
          break;
      }
    },
    scrollTo,
    remeasureColumns: cols => {
      for (const col of cols) {
        void normalSizeColumn(col + rowMarkerOffset, true);
      }
    }
  }), [appendRow, normalSizeColumn, onCopy, onKeyDown, onPasteInternal, rowMarkerOffset, scrollTo]);
  const [selCol, selRow] = currentCell !== null && currentCell !== void 0 ? currentCell : [];
  const onCellFocused = react.useCallback(cell => {
    const [col, row] = cell;

    if (row === -1) {
      if (columnSelect !== "none") {
        setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(col), undefined, false);
        focus();
      }

      return;
    }

    if (selCol === col && selRow === row) return;
    setCurrent({
      cell,
      range: {
        x: col,
        y: row,
        width: 1,
        height: 1
      }
    }, true, false, "keyboard-nav");
    scrollTo(col, row);
  }, [columnSelect, focus, scrollTo, selCol, selRow, setCurrent, setSelectedColumns]);
  const [isFocused, setIsFocused] = react.useState(false);
  const setIsFocusedDebounced = react.useRef(debounce_default()(val => {
    setIsFocused(val);
  }, 5));
  const onCanvasFocused = react.useCallback(() => {
    setIsFocusedDebounced.current(true);

    if (gridSelection.current === undefined && gridSelection.columns.length === 0 && gridSelection.rows.length === 0 && mouseState === undefined) {
      setCurrent({
        cell: [rowMarkerOffset, cellYOffset],
        range: {
          x: rowMarkerOffset,
          y: cellYOffset,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-select");
    }
  }, [cellYOffset, gridSelection, mouseState, rowMarkerOffset, setCurrent]);
  const onFocusOut = react.useCallback(() => {
    setIsFocusedDebounced.current(false);
  }, []);
  const [idealWidth, idealHeight] = react.useMemo(() => {
    var _experimental$scrollb;

    let h;
    const scrollbarWidth = (_experimental$scrollb = experimental === null || experimental === void 0 ? void 0 : experimental.scrollbarWidthOverride) !== null && _experimental$scrollb !== void 0 ? _experimental$scrollb : (0,utils/* getScrollBarWidth */.Iz)();
    const rowsCountWithTrailingRow = rows + (showTrailingBlankRow ? 1 : 0);

    if (typeof rowHeight === "number") {
      h = totalHeaderHeight + rowsCountWithTrailingRow * rowHeight;
    } else {
      let avg = 0;
      const toAverage = Math.min(rowsCountWithTrailingRow, 10);

      for (let i = 0; i < toAverage; i++) {
        avg += rowHeight(i);
      }

      avg = Math.floor(avg / toAverage);
      h = totalHeaderHeight + rowsCountWithTrailingRow * avg;
    }

    h += scrollbarWidth;
    const w = mangledCols.reduce((acc, x) => x.width + acc, 0) + scrollbarWidth;
    return [`${Math.min(100000, w)}px`, `${Math.min(100000, h)}px`];
  }, [mangledCols, experimental === null || experimental === void 0 ? void 0 : experimental.scrollbarWidthOverride, rowHeight, rows, showTrailingBlankRow, totalHeaderHeight]);
  return react.createElement(styles/* ThemeContext.Provider */.Ni.Provider, {
    value: mergedTheme
  }, react.createElement(DataEditorContainer, {
    style: (0,styles/* makeCSSStyle */.be)(mergedTheme),
    className: className,
    inWidth: width !== null && width !== void 0 ? width : idealWidth,
    inHeight: height !== null && height !== void 0 ? height : idealHeight
  }, react.createElement(data_grid_search, {
    fillHandle: fillHandle,
    drawFocusRing: drawFocusRing,
    experimental: experimental,
    fixedShadowX: fixedShadowX,
    fixedShadowY: fixedShadowY,
    getRowThemeOverride: getRowThemeOverride,
    headerIcons: headerIcons,
    imageWindowLoader: imageWindowLoader,
    initialSize: initialSize,
    isDraggable: isDraggable,
    onDragLeave: onDragLeave,
    onRowMoved: onRowMoved,
    overscrollX: overscrollX,
    overscrollY: overscrollY,
    preventDiagonalScrolling: preventDiagonalScrolling,
    rightElement: rightElement,
    rightElementProps: rightElementProps,
    showMinimap: showMinimap,
    smoothScrollX: smoothScrollX,
    smoothScrollY: smoothScrollY,
    className: className,
    enableGroups: enableGroups,
    onCanvasFocused: onCanvasFocused,
    onCanvasBlur: onFocusOut,
    canvasRef: canvasRef,
    onContextMenu: onContextMenu,
    theme: mergedTheme,
    cellXOffset: cellXOffset,
    cellYOffset: cellYOffset,
    accessibilityHeight: visibleRegion.height,
    onDragEnd: onDragEnd,
    columns: mangledCols,
    drawCustomCell: drawCell,
    drawHeader: drawHeader,
    disabledRows: disabledRows,
    freezeColumns: mangledFreezeColumns,
    lockColumns: rowMarkerOffset,
    firstColAccessible: rowMarkerOffset === 0,
    getCellContent: getMangledCellContent,
    minColumnWidth: minColumnWidth,
    maxColumnWidth: maxColumnWidth,
    searchInputRef: searchInputRef,
    showSearch: showSearch,
    onSearchClose: onSearchClose,
    highlightRegions: highlightRegions,
    getCellsForSelection: getCellsForSelection,
    getGroupDetails: mangledGetGroupDetails,
    headerHeight: headerHeight,
    isFocused: isFocused,
    groupHeaderHeight: enableGroups ? groupHeaderHeight : 0,
    trailingRowType: !showTrailingBlankRow ? "none" : (trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.sticky) === true ? "sticky" : "appended",
    onColumnResize: onColumnResize,
    onColumnResizeEnd: onColumnResizeEnd,
    onColumnResizeStart: onColumnResizeStart,
    onCellFocused: onCellFocused,
    onColumnMoved: onColumnMovedImpl,
    onDragStart: onDragStartImpl,
    onHeaderMenuClick: onHeaderMenuClickInner,
    onItemHovered: onItemHoveredImpl,
    isFilling: (mouseState === null || mouseState === void 0 ? void 0 : mouseState.fillHandle) === true,
    onMouseMove: onMouseMoveImpl,
    onKeyDown: onKeyDown,
    onKeyUp: onKeyUpIn,
    onMouseDown: onMouseDown,
    onMouseUp: onMouseUp,
    onDragOverCell: onDragOverCell,
    onDrop: onDrop,
    onSearchResultsChanged: onSearchResultsChanged,
    onVisibleRegionChanged: onVisibleRegionChangedImpl,
    clientSize: [clientSize[0], clientSize[1]],
    rowHeight: rowHeight,
    rows: mangledRows,
    scrollRef: scrollRef,
    selection: gridSelection,
    translateX: visibleRegion.tx,
    translateY: visibleRegion.ty,
    verticalBorder: mangledVerticalBorder,
    gridRef: gridRef,
    getCellRenderer: getCellRenderer,
    scrollToEnd: scrollToEnd
  }), renameGroupNode, overlay !== undefined && react.createElement(data_grid_overlay_editor, data_editor_extends({}, overlay, {
    validateCell: validateCell,
    id: overlayID,
    getCellRenderer: getCellRenderer,
    className: (experimental === null || experimental === void 0 ? void 0 : experimental.isSubGrid) === true ? "click-outside-ignore" : undefined,
    provideEditor: provideEditor,
    imageEditorOverride: imageEditorOverride,
    onFinishEditing: onFinishEditing,
    markdownDivCreateNode: markdownDivCreateNode
  }))));
};

const DataEditor = react.forwardRef(DataEditorImpl);

/***/ }),

/***/ "./packages/core/src/data-editor/stories/utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F9": () => (/* binding */ useMockDataGenerator),
/* harmony export */   "Gi": () => (/* binding */ PropName),
/* harmony export */   "MP": () => (/* binding */ clearCell),
/* harmony export */   "OX": () => (/* binding */ MoreInfo),
/* harmony export */   "YE": () => (/* binding */ ColumnAddButton),
/* harmony export */   "dk": () => (/* binding */ Description),
/* harmony export */   "et": () => (/* binding */ KeyName),
/* harmony export */   "fl": () => (/* binding */ useAllMockedKinds),
/* harmony export */   "lG": () => (/* binding */ defaultProps),
/* harmony export */   "m": () => (/* binding */ BeautifulWrapper),
/* harmony export */   "xl": () => (/* binding */ BeautifulStyle)
/* harmony export */ });
/* unused harmony exports lossyCopyData, getGridColumn, ContentCache */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var faker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/faker/index.js");
/* harmony import */ var faker__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(faker__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/lodash/isArray.js");
/* harmony import */ var lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_support__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/common/support.ts");
/* harmony import */ var _common_browser_detect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/core/src/common/browser-detect.ts");
/* harmony import */ var react_resize_detector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/react-resize-detector/build/index.esm.js");
/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/lodash/noop.js");
/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__);









faker__WEBPACK_IMPORTED_MODULE_1___default().seed(1337);

function isTruthy(x) {
  return x ? true : false;
}

function lossyCopyData(source, target) {
  const sourceData = source.data;

  if (typeof sourceData === typeof target.data) {
    return { ...target,
      data: sourceData
    };
  } else switch (target.kind) {
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Uri */ .p6.Uri:
      {
        var _sourceData$toString;

        if (lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default()(sourceData)) {
          return { ...target,
            data: sourceData[0]
          };
        }

        return { ...target,
          data: (_sourceData$toString = sourceData === null || sourceData === void 0 ? void 0 : sourceData.toString()) !== null && _sourceData$toString !== void 0 ? _sourceData$toString : ""
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Boolean */ .p6.Boolean:
      {
        if (lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default()(sourceData)) {
          return { ...target,
            data: sourceData[0] !== undefined
          };
        } else if (source.kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Boolean */ .p6.Boolean) {
          return { ...target,
            data: source.data
          };
        }

        return { ...target,
          data: isTruthy(sourceData) ? true : false
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Image */ .p6.Image:
      {
        var _sourceData$toString2;

        if (lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default()(sourceData)) {
          return { ...target,
            data: [sourceData[0]]
          };
        }

        return { ...target,
          data: [(_sourceData$toString2 = sourceData === null || sourceData === void 0 ? void 0 : sourceData.toString()) !== null && _sourceData$toString2 !== void 0 ? _sourceData$toString2 : ""]
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Number */ .p6.Number:
      {
        return { ...target,
          data: 0
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text:
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Markdown */ .p6.Markdown:
      {
        var _source$data$toString, _source$data;

        if (lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default()(sourceData)) {
          var _sourceData$0$toStrin;

          return { ...target,
            data: (_sourceData$0$toStrin = sourceData[0].toString()) !== null && _sourceData$0$toStrin !== void 0 ? _sourceData$0$toStrin : ""
          };
        }

        return { ...target,
          data: (_source$data$toString = (_source$data = source.data) === null || _source$data === void 0 ? void 0 : _source$data.toString()) !== null && _source$data$toString !== void 0 ? _source$data$toString : ""
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Custom */ .p6.Custom:
      {
        return target;
      }
  }

  (0,_common_support__WEBPACK_IMPORTED_MODULE_5__/* .assertNever */ .vE)(target);
}
function getGridColumn(columnWithMock) {
  const {
    getContent,
    ...rest
  } = columnWithMock;
  return rest;
}
const ColumnAddButton = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)('div')({
  name: "ColumnAddButton",
  class: "c4uqbye"
});
const BeautifulStyle = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)('div')({
  name: "BeautifulStyle",
  class: "b1bsqg7n"
});
const PropName = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)('span')({
  name: "PropName",
  class: "piiq54i"
});
const Description = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)('p')({
  name: "Description",
  class: "d1k3yj19"
});
const MoreInfo = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)('p')({
  name: "MoreInfo",
  class: "m1j0dy02"
});
const BeautifulWrapper = p => {
  const {
    title,
    children,
    description,
    className,
    scale
  } = p;
  const {
    ref,
    width,
    height
  } = (0,react_resize_detector__WEBPACK_IMPORTED_MODULE_7__/* .useResizeDetector */ .NB)();
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(BeautifulStyle, {
    className: className + (_common_browser_detect__WEBPACK_IMPORTED_MODULE_8__/* .browserIsFirefox.value */ .uC.value ? " firefox" : "")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", null, title), description, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      scale
    },
    className: "sizer"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "sizer-clip",
    ref: ref
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      position: "relative",
      width: width !== null && width !== void 0 ? width : 100,
      height: height !== null && height !== void 0 ? height : 100
    }
  }, children))));
};

function createTextColumnInfo(index, group) {
  return {
    title: `Column ${index}`,
    id: `Column ${index}`,
    group: group ? `Group ${Math.round(index / 3)}` : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const text = faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.word();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
        data: text,
        displayData: text,
        allowOverlay: true,
        readonly: true
      };
    }
  };
}

function getResizableColumns(amount, group) {
  const defaultColumns = [{
    title: "First name",
    id: "First name",
    group: group ? "Name" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const firstName = faker__WEBPACK_IMPORTED_MODULE_1___default().name.firstName();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
        displayData: firstName,
        data: firstName,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Last name",
    id: "Last name",
    group: group ? "Name" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const lastName = faker__WEBPACK_IMPORTED_MODULE_1___default().name.lastName();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
        displayData: lastName,
        data: lastName,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Avatar",
    id: "Avatar",
    group: group ? "Info" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderImage */ .PE.HeaderImage,
    hasMenu: false,
    getContent: () => {
      const n = Math.round(Math.random() * 100);
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Image */ .p6.Image,
        data: [`https://picsum.photos/id/${n}/900/900`],
        displayData: [`https://picsum.photos/id/${n}/40/40`],
        allowOverlay: true,
        allowAdd: false,
        readonly: true
      };
    }
  }, {
    title: "Email",
    id: "Email",
    group: group ? "Info" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const email = faker__WEBPACK_IMPORTED_MODULE_1___default().internet.email();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
        displayData: email,
        data: email,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Title",
    id: "Title",
    group: group ? "Info" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const company = faker__WEBPACK_IMPORTED_MODULE_1___default().name.jobTitle();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
        displayData: company,
        data: company,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "More Info",
    id: "More Info",
    group: group ? "Info" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderUri */ .PE.HeaderUri,
    hasMenu: false,
    getContent: () => {
      const url = faker__WEBPACK_IMPORTED_MODULE_1___default().internet.url();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Uri */ .p6.Uri,
        displayData: url,
        data: url,
        allowOverlay: true,
        readonly: true
      };
    }
  }];

  if (amount < defaultColumns.length) {
    return defaultColumns.slice(0, amount);
  }

  const extraColumnsAmount = amount - defaultColumns.length;
  const extraColumns = [...new Array(extraColumnsAmount)].map((_, index) => createTextColumnInfo(index + defaultColumns.length, group));
  return [...defaultColumns, ...extraColumns];
}

class ContentCache {
  constructor() {
    this.cachedContent = new Map();
  }

  get(col, row) {
    const colCache = this.cachedContent.get(col);

    if (colCache === undefined) {
      return undefined;
    }

    return colCache.get(row);
  }

  set(col, row, value) {
    if (this.cachedContent.get(col) === undefined) {
      this.cachedContent.set(col, new Map());
    }

    const rowCache = this.cachedContent.get(col);
    rowCache.set(row, value);
  }

}
function useMockDataGenerator(numCols) {
  let readonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let group = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const cache = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new ContentCache());
  const [colsMap, setColsMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => getResizableColumns(numCols, group));
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    setColsMap(getResizableColumns(numCols, group));
  }, [group, numCols]);
  const onColumnResize = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((column, newSize) => {
    setColsMap(prevColsMap => {
      const index = prevColsMap.findIndex(ci => ci.title === column.title);
      const newArray = [...prevColsMap];
      newArray.splice(index, 1, { ...prevColsMap[index],
        width: newSize
      });
      return newArray;
    });
  }, []);
  const cols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return colsMap.map(getGridColumn);
  }, [colsMap]);
  const colsMapRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(colsMap);
  colsMapRef.current = colsMap;
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {
    let [col, row] = _ref;
    let val = cache.current.get(col, row);

    if (val === undefined) {
      val = colsMapRef.current[col].getContent();

      if (!readonly && (0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .isTextEditableGridCell */ .f)(val)) {
        val = { ...val,
          readonly
        };
      }

      cache.current.set(col, row, val);
    }

    return val;
  }, [readonly]);
  const setCellValueRaw = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_ref2, val) => {
    let [col, row] = _ref2;
    cache.current.set(col, row, val);
  }, []);
  const setCellValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_ref3, val) => {
    let [col, row] = _ref3;
    let current = cache.current.get(col, row);

    if (current === undefined) {
      current = colsMap[col].getContent();
    }

    if ((0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .isEditableGridCell */ .T9)(val) && (0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .isEditableGridCell */ .T9)(current)) {
      const copied = lossyCopyData(val, current);
      cache.current.set(col, row, { ...copied,
        displayData: typeof copied.data === "string" ? copied.data : copied.displayData,
        lastUpdated: performance.now()
      });
    }
  }, [colsMap]);
  return {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue,
    setCellValueRaw
  };
}
const KeyName = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)('kbd')({
  name: "KeyName",
  class: "kcvwzr4"
});
const defaultProps = {
  smoothScrollX: true,
  smoothScrollY: true,
  getCellsForSelection: true,
  width: "100%"
};
function clearCell(cell) {
  switch (cell.kind) {
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Boolean */ .p6.Boolean:
      {
        return { ...cell,
          data: false
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Image */ .p6.Image:
      {
        return { ...cell,
          data: [],
          displayData: []
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Drilldown */ .p6.Drilldown:
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Bubble */ .p6.Bubble:
      {
        return { ...cell,
          data: []
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Uri */ .p6.Uri:
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Markdown */ .p6.Markdown:
      {
        return { ...cell,
          data: ""
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text:
      {
        return { ...cell,
          data: "",
          displayData: ""
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Number */ .p6.Number:
      {
        return { ...cell,
          data: 0,
          displayData: ""
        };
      }
  }

  return cell;
}

function getColumnsForCellTypes() {
  return [{
    title: "Row ID",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderRowID */ .PE.HeaderRowID,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.RowID */ .p6.RowID,
        data: faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.uuid(),
        allowOverlay: true
      };
    }
  }, {
    title: "Protected",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderCode */ .PE.HeaderCode,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Protected */ .p6.Protected,
        data: faker__WEBPACK_IMPORTED_MODULE_1___default().finance.bitcoinAddress(),
        allowOverlay: false
      };
    }
  }, {
    title: "Loading",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Loading */ .p6.Loading,
        allowOverlay: false
      };
    }
  }, {
    title: "Text",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderCode */ .PE.HeaderCode,
    hasMenu: false,
    getContent: () => {
      const name = faker__WEBPACK_IMPORTED_MODULE_1___default().name.firstName();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
        data: name,
        displayData: name,
        allowOverlay: true
      };
    }
  }, {
    title: "Number",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderNumber */ .PE.HeaderNumber,
    hasMenu: false,
    getContent: () => {
      const age = faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.number(100);
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Number */ .p6.Number,
        data: age,
        displayData: `${age}`,
        allowOverlay: true
      };
    }
  }, {
    title: "Boolean",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderBoolean */ .PE.HeaderBoolean,
    hasMenu: false,
    getContent: () => {
      const roll = Math.random();
      const checked = roll < 0.1 ? undefined : roll < 0.2 ? null : roll < 0.6;
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Boolean */ .p6.Boolean,
        data: checked,
        allowOverlay: false,
        readonly: false
      };
    }
  }, {
    title: "Image",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderImage */ .PE.HeaderImage,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Image */ .p6.Image,
        data: [`${faker__WEBPACK_IMPORTED_MODULE_1___default().image.animals(40, 40)}?random=${faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.number(100000)}`],
        allowOverlay: true,
        allowAdd: false,
        readonly: true
      };
    }
  }, {
    title: "Uri",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderUri */ .PE.HeaderUri,
    hasMenu: false,
    getContent: () => {
      const url = faker__WEBPACK_IMPORTED_MODULE_1___default().internet.url();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Uri */ .p6.Uri,
        data: url,
        allowOverlay: true
      };
    }
  }, {
    title: "Markdown",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderMarkdown */ .PE.HeaderMarkdown,
    hasMenu: false,
    getContent: () => {
      const markdown = `# Title
Hello my name is *${faker__WEBPACK_IMPORTED_MODULE_1___default().name.firstName()}*

## TODO:
Try out [Glide](https://www.glideapps.com/)
`;
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Markdown */ .p6.Markdown,
        data: markdown,
        allowOverlay: true
      };
    }
  }, {
    title: "Bubble",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderArray */ .PE.HeaderArray,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Bubble */ .p6.Bubble,
        data: [faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.word(), faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.word(), faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.word()],
        allowOverlay: true
      };
    }
  }, {
    title: "Drilldown",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridColumnIcon.HeaderArray */ .PE.HeaderArray,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Drilldown */ .p6.Drilldown,
        data: [{
          text: faker__WEBPACK_IMPORTED_MODULE_1___default().address.cityName(),
          img: `${faker__WEBPACK_IMPORTED_MODULE_1___default().image.nature(40, 40)}?random=${faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.number(100000)}`
        }, {
          text: faker__WEBPACK_IMPORTED_MODULE_1___default().address.cityName(),
          img: `${faker__WEBPACK_IMPORTED_MODULE_1___default().image.nature(40, 40)}?random=${faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.number(100000)}`
        }],
        allowOverlay: true
      };
    }
  }];
}

function useAllMockedKinds() {
  const cache = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new ContentCache());
  const [colsMap, setColsMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(getColumnsForCellTypes);
  const onColumnResize = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((column, newSize) => {
    setColsMap(prevColsMap => {
      const index = prevColsMap.findIndex(ci => ci.title === column.title);
      const newArray = [...prevColsMap];
      newArray.splice(index, 1, { ...prevColsMap[index],
        width: newSize
      });
      return newArray;
    });
  }, []);
  const cols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return colsMap.map(getGridColumn);
  }, [colsMap]);
  const [updateVersion, setUpdateVersion] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref4 => {
    let [col, row] = _ref4;
    lodash_noop_js__WEBPACK_IMPORTED_MODULE_3___default()(updateVersion);
    let val = cache.current.get(col, row);

    if (val === undefined) {
      val = colsMap[col].getContent();
      cache.current.set(col, row, val);
    }

    return val;
  }, [colsMap, updateVersion]);
  const setCellValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_ref5, val, noDisplay, forceUpdate) => {
    let [col, row] = _ref5;
    let current = cache.current.get(col, row);

    if (current === undefined) {
      current = colsMap[col].getContent();
    }

    if ((0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .isEditableGridCell */ .T9)(val) && (0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .isEditableGridCell */ .T9)(current)) {
      var _copied$data$toString, _copied$data;

      const copied = lossyCopyData(val, current);
      cache.current.set(col, row, { ...copied,
        displayData: noDisplay === true ? undefined : (_copied$data$toString = (_copied$data = copied.data) === null || _copied$data === void 0 ? void 0 : _copied$data.toString()) !== null && _copied$data$toString !== void 0 ? _copied$data$toString : ""
      });

      if (forceUpdate === true) {
        setUpdateVersion(v => v + 1);
      }
    }
  }, [colsMap]);
  return {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  };
}

__webpack_require__("./packages/core/src/data-editor/stories/utils.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/utils.tsx");

/***/ }),

/***/ "./packages/core/src/data-grid/cells/boolean-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": () => (/* binding */ toggleBoolean),
/* harmony export */   "j": () => (/* binding */ booleanCellRenderer)
/* harmony export */ });
/* harmony import */ var _data_grid_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/data-grid/data-grid-lib.ts");
/* harmony import */ var _data_grid_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");


function toggleBoolean(data) {
  return data !== true;
}
const defaultCellMaxSize = 20;
const booleanCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "false";
  },
  kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .GridCellKind.Boolean */ .p6.Boolean,
  needsHover: true,
  useLabel: false,
  needsHoverPosition: true,
  measure: () => 50,
  draw: a => {
    var _a$cell$maxSize;

    return (0,_data_grid_lib__WEBPACK_IMPORTED_MODULE_1__/* .drawBoolean */ .Df)(a, a.cell.data, (0,_data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .booleanCellIsEditable */ .kf)(a.cell), (_a$cell$maxSize = a.cell.maxSize) !== null && _a$cell$maxSize !== void 0 ? _a$cell$maxSize : defaultCellMaxSize);
  },
  onDelete: c => ({ ...c,
    data: false
  }),
  onClick: e => {
    var _cell$maxSize;

    const {
      cell,
      posX: x,
      posY: y,
      bounds
    } = e;
    const maxWidth = (_cell$maxSize = cell.maxSize) !== null && _cell$maxSize !== void 0 ? _cell$maxSize : defaultCellMaxSize;

    if ((0,_data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .booleanCellIsEditable */ .kf)(cell) && Math.abs(x - bounds.width / 2) <= Math.min(maxWidth / 2, bounds.height / 3.4) && Math.abs(y - bounds.height / 2) <= Math.min(maxWidth / 2, bounds.height / 3.4)) {
      return { ...cell,
        data: toggleBoolean(cell.data)
      };
    }

    return undefined;
  },
  onPaste: (toPaste, cell) => {
    let newVal = _data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .BooleanEmpty */ .qF;

    if (toPaste.toLowerCase() === "true") {
      newVal = true;
    } else if (toPaste.toLowerCase() === "false") {
      newVal = false;
    } else if (toPaste.toLowerCase() === "indeterminate") {
      newVal = _data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .BooleanIndeterminate */ .sd;
    }

    return newVal === cell.data ? undefined : { ...cell,
      data: newVal
    };
  }
};

/***/ }),

/***/ "./packages/core/src/data-grid/cells/index.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "L": () => (/* binding */ CellRenderers)
});

// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-types.ts
var data_grid_types = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
// EXTERNAL MODULE: ./packages/core/src/data-grid/cells/boolean-cell.tsx
var boolean_cell = __webpack_require__("./packages/core/src/data-grid/cells/boolean-cell.tsx");
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx

const BubblesOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "BubblesOverlayEditorStyle",
  class: "bvh4xn4"
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor.tsx



const BubblesOverlayEditor = p => {
  const {
    bubbles
  } = p;
  return react.createElement(BubblesOverlayEditorStyle, null, bubbles.map((b, i) => react.createElement("div", {
    key: i,
    className: "boe-bubble"
  }, b)), react.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};

/* harmony default export */ const bubbles_overlay_editor = (BubblesOverlayEditor);
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-lib.ts
var data_grid_lib = __webpack_require__("./packages/core/src/data-grid/data-grid-lib.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/bubble-cell.tsx




const bubbleCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Bubble */.p6.Bubble,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data).width + acc + 20, 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => (0,data_grid_lib/* drawBubbles */.hp)(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return react.createElement(bubbles_overlay_editor, {
      bubbles: value.data
    });
  },
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx


const DrilldownOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "DrilldownOverlayEditorStyle",
  class: "d11gcyta"
});

const DrilldownOverlayEditor = p => {
  const {
    drilldowns
  } = p;
  return react.createElement(DrilldownOverlayEditorStyle, null, drilldowns.map((d, i) => react.createElement("div", {
    key: i,
    className: "doe-bubble"
  }, d.img !== undefined && react.createElement("img", {
    src: d.img
  }), react.createElement("div", null, d.text))));
};

/* harmony default export */ const drilldown_overlay_editor = (DrilldownOverlayEditor);

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/drilldown-cell.tsx




const drilldownCellRenderer = {
  getAccessibilityString: c => c.data.map(d => d.text).join(", "),
  kind: data_grid_types/* GridCellKind.Drilldown */.p6.Drilldown,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data.text).width + acc + 20 + (data.img !== undefined ? 18 : 0), 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => (0,data_grid_lib/* drawDrilldownCell */.SP)(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return react.createElement(drilldown_overlay_editor, {
      drilldowns: value.data
    });
  },
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx

const ImageOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "ImageOverlayEditorStyle",
  class: "i1v3763o"
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx");
// EXTERNAL MODULE: ./node_modules/react-responsive-carousel/lib/js/index.js
var js = __webpack_require__("./node_modules/react-responsive-carousel/lib/js/index.js");
// EXTERNAL MODULE: ./packages/core/src/common/utils.tsx
var utils = __webpack_require__("./packages/core/src/common/utils.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor.tsx




const ImageOverlayEditor = p => {
  const {
    urls,
    canWrite,
    onEditClick,
    renderImage
  } = p;
  const filtered = urls.filter(u => u !== "");

  if (filtered.length === 0) {
    return null;
  }

  const allowMove = filtered.length > 1;
  return react.createElement(ImageOverlayEditorStyle, {
    "data-testid": "GDG-default-image-overlay-editor"
  }, react.createElement(js/* Carousel */.lr, {
    showArrows: allowMove,
    showThumbs: false,
    swipeable: allowMove,
    emulateTouch: allowMove,
    infiniteLoop: allowMove
  }, filtered.map(url => {
    var _renderImage;

    const innerContent = (_renderImage = renderImage === null || renderImage === void 0 ? void 0 : renderImage(url)) !== null && _renderImage !== void 0 ? _renderImage : react.createElement("img", {
      draggable: false,
      src: url
    });
    return react.createElement("div", {
      className: "centering-container",
      key: url
    }, innerContent);
  })), canWrite && onEditClick && react.createElement("button", {
    className: "edit-icon",
    onClick: onEditClick
  }, react.createElement(utils/* EditPencil */.Wy, null)));
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/image-cell.tsx




const imageCellRenderer = {
  getAccessibilityString: c => c.data.join(", "),
  kind: data_grid_types/* GridCellKind.Image */.p6.Image,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  draw: a => {
    var _a$cell$displayData;

    return (0,data_grid_lib/* drawImage */.AE)(a, (_a$cell$displayData = a.cell.displayData) !== null && _a$cell$displayData !== void 0 ? _a$cell$displayData : a.cell.data, a.cell.rounding, a.cell.contentAlign);
  },
  measure: (_ctx, cell) => cell.data.length * 50,
  onDelete: c => ({ ...c,
    data: []
  }),
  provideEditor: () => p => {
    const {
      value,
      onFinishedEditing,
      imageEditorOverride
    } = p;
    const ImageEditor = imageEditorOverride !== null && imageEditorOverride !== void 0 ? imageEditorOverride : ImageOverlayEditor;
    return react.createElement(ImageEditor, {
      urls: value.data,
      canWrite: value.allowAdd,
      onCancel: onFinishedEditing,
      onChange: newImage => {
        onFinishedEditing({ ...value,
          data: [newImage]
        });
      }
    });
  },
  onPaste: (toPaste, cell) => {
    toPaste = toPaste.trim();
    const fragments = toPaste.split(",");
    const uris = fragments.map(f => {
      try {
        new URL(f);
        return f;
      } catch {
        return undefined;
      }
    }).filter(x => x !== undefined);
    if (uris.length === cell.data.length && uris.every((u, i) => u === cell.data[i])) return undefined;
    return { ...cell,
      data: uris
    };
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/loading-cell.tsx

const loadingCellRenderer = {
  getAccessibilityString: () => "",
  kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: () => 120,
  draw: () => undefined,
  onPaste: () => undefined
};
// EXTERNAL MODULE: ./node_modules/marked/lib/marked.esm.js
var marked_esm = __webpack_require__("./node_modules/marked/lib/marked.esm.js");
;// CONCATENATED MODULE: ./packages/core/src/markdown-div/private/markdown-container.tsx

const MarkdownContainer = (0,styled/* default */.Z)('div')({
  name: "MarkdownContainer",
  class: "m1fme8sm"
});

__webpack_require__("./packages/core/src/markdown-div/private/markdown-container.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/markdown-div/private/markdown-container.tsx");
;// CONCATENATED MODULE: ./packages/core/src/markdown-div/markdown-div.tsx



class MarkdownDiv extends react.PureComponent {
  constructor() {
    super(...arguments);
    this.targetElement = null;

    this.containerRefHook = element => {
      this.targetElement = element;
      this.renderMarkdownIntoDiv();
    };
  }

  renderMarkdownIntoDiv() {
    const {
      targetElement,
      props
    } = this;
    if (targetElement === null) return;
    const {
      contents,
      createNode
    } = props;
    const innerHTML = (0,marked_esm/* marked */.TU)(contents);
    const childRange = document.createRange();
    childRange.selectNodeContents(targetElement);
    childRange.deleteContents();
    let newChild = createNode === null || createNode === void 0 ? void 0 : createNode(innerHTML);

    if (newChild === undefined) {
      const childDoc = document.createElement("template");
      childDoc.innerHTML = innerHTML;
      newChild = childDoc.content;
    }

    targetElement.append(newChild);
    const tags = targetElement.getElementsByTagName("a");

    for (const tag of tags) {
      tag.target = "_blank";
      tag.rel = "noreferrer noopener";
    }
  }

  render() {
    this.renderMarkdownIntoDiv();
    return react.createElement(MarkdownContainer, {
      ref: this.containerRefHook
    });
  }

}
;// CONCATENATED MODULE: ./packages/core/src/growing-entry/growing-entry-style.tsx

const InputBox = (0,styled/* default */.Z)('textarea')({
  name: "InputBox",
  class: "ifmjl02"
});
const ShadowBox = (0,styled/* default */.Z)('div')({
  name: "ShadowBox",
  class: "s71wzxx"
});
const GrowingEntryStyle = (0,styled/* default */.Z)('div')({
  name: "GrowingEntryStyle",
  class: "gecuh31"
});

__webpack_require__("./packages/core/src/growing-entry/growing-entry-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/growing-entry/growing-entry-style.tsx");
// EXTERNAL MODULE: ./packages/core/src/common/support.ts
var support = __webpack_require__("./packages/core/src/common/support.ts");
;// CONCATENATED MODULE: ./packages/core/src/growing-entry/growing-entry.tsx
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }




const GrowingEntry = props => {
  const {
    placeholder,
    value,
    onKeyDown,
    highlight,
    altNewline,
    validatedSelection,
    ...rest
  } = props;
  const {
    onChange,
    className
  } = rest;
  const inputRef = react.useRef(null);
  const useText = value !== null && value !== void 0 ? value : "";
  (0,support/* assert */.hu)(onChange !== undefined, "GrowingEntry must be a controlled input area");
  react.useEffect(() => {
    const ta = inputRef.current;
    if (ta === null) return;
    if (ta.disabled) return;
    const length = useText.toString().length;
    ta.focus();
    ta.setSelectionRange(highlight ? 0 : length, length);
  }, []);
  react.useLayoutEffect(() => {
    if (validatedSelection !== undefined) {
      var _inputRef$current;

      const range = typeof validatedSelection === "number" ? [validatedSelection, null] : validatedSelection;
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.setSelectionRange(range[0], range[1]);
    }
  }, [validatedSelection]);
  const onKeyDownInner = react.useCallback(e => {
    if (e.key === "Enter" && e.shiftKey && altNewline === true) {
      return;
    }

    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
  }, [altNewline, onKeyDown]);
  return react.createElement(GrowingEntryStyle, {
    className: "gdg-growing-entry"
  }, react.createElement(ShadowBox, {
    className: className
  }, useText + "\n"), react.createElement(InputBox, _extends({}, rest, {
    className: (className !== null && className !== void 0 ? className : "") + " gdg-input",
    ref: inputRef,
    onKeyDown: onKeyDownInner,
    value: useText,
    placeholder: placeholder,
    dir: "auto"
  })));
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx


const _exp = () => p => p.targetWidth;

const MarkdownOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "MarkdownOverlayEditorStyle",
  class: "m1bd3197",
  vars: {
    "m1bd3197-0": [_exp(), "px"]
  }
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor.tsx





const MarkdownOverlayEditor = p => {
  const {
    value,
    onChange,
    forceEditMode,
    createNode,
    targetRect,
    onFinish,
    validatedSelection
  } = p;
  const markdown = value.data;
  const readonly = value.readonly === true;
  const [editMode, setEditMode] = react.useState(markdown === "" || forceEditMode);
  const onEditClick = react.useCallback(() => {
    setEditMode(e => !e);
  }, []);
  const addLeftPad = markdown ? "ml-6" : "";

  if (editMode) {
    return react.createElement(MarkdownOverlayEditorStyle, {
      targetWidth: targetRect.width - 20
    }, react.createElement(GrowingEntry, {
      autoFocus: true,
      highlight: false,
      validatedSelection: validatedSelection,
      value: markdown,
      onKeyDown: e => {
        if (e.key === "Enter") e.stopPropagation();
      },
      onChange: onChange
    }), react.createElement("div", {
      className: `edit-icon checkmark-hover ${addLeftPad}`,
      onClick: () => onFinish(value)
    }, react.createElement(utils/* Checkmark */.MC, null)));
  }

  return react.createElement(MarkdownOverlayEditorStyle, {
    targetWidth: targetRect.width
  }, react.createElement(MarkdownDiv, {
    contents: markdown,
    createNode: createNode
  }), !readonly && react.createElement(react.Fragment, null, react.createElement("div", {
    className: "spacer"
  }), react.createElement("div", {
    className: `edit-icon edit-hover ${addLeftPad}`,
    onClick: onEditClick
  }, react.createElement(utils/* EditPencil */.Wy, null))), react.createElement("textarea", {
    className: "md-edit-textarea gdg-input",
    autoFocus: true
  }));
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/markdown-cell.tsx




const markdownCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Markdown */.p6.Markdown,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: data_grid_lib/* prepTextCell */.k0,
  measure: (ctx, cell, t) => {
    const firstLine = cell.data.split("\n")[0];
    return ctx.measureText(firstLine).width + 2 * t.cellHorizontalPadding;
  },
  draw: a => (0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.data, a.cell.contentAlign),
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      onChange,
      value,
      target,
      onFinishedEditing,
      markdownDivCreateNode,
      forceEditMode,
      validatedSelection
    } = p;
    return react.createElement(MarkdownOverlayEditor, {
      onFinish: onFinishedEditing,
      targetRect: target,
      value: value,
      validatedSelection: validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      }),
      forceEditMode: forceEditMode,
      createNode: markdownDivCreateNode
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? undefined : { ...cell,
    data: toPaste
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/marker-cell.tsx


const markerCellRenderer = {
  getAccessibilityString: c => c.row.toString(),
  kind: data_grid_types/* InnerGridCellKind.Marker */.$o.Marker,
  needsHover: true,
  needsHoverPosition: false,
  drawPrep: data_grid_lib/* prepMarkerRowCell */.Z1,
  measure: () => 44,
  draw: a => (0,data_grid_lib/* drawMarkerRowCell */.ld)(a, a.cell.row, a.cell.checked, a.cell.markerKind, a.cell.drawHandle),
  onClick: e => {
    const {
      bounds,
      cell,
      posX: x,
      posY: y
    } = e;
    const {
      width,
      height
    } = bounds;
    const centerX = cell.drawHandle ? 7 + (width - 7) / 2 : width / 2;
    const centerY = height / 2;

    if (Math.abs(x - centerX) <= 10 && Math.abs(y - centerY) <= 10) {
      return { ...cell,
        checked: !cell.checked
      };
    }

    return undefined;
  },
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/new-row-cell.tsx


const newRowCellRenderer = {
  getAccessibilityString: () => "",
  kind: data_grid_types/* InnerGridCellKind.NewRow */.$o.NewRow,
  needsHover: true,
  needsHoverPosition: false,
  measure: () => 200,
  draw: a => (0,data_grid_lib/* drawNewRowCell */.RM)(a, a.cell.hint, a.cell.icon),
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/number-cell.tsx



const NumberOverlayEditor = react.lazy(async () => await Promise.all(/* import() */[__webpack_require__.e(333), __webpack_require__.e(987)]).then(__webpack_require__.bind(__webpack_require__, "./packages/core/src/data-grid-overlay-editor/private/number-overlay-editor.tsx")));
const numberCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Number */.p6.Number,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: data_grid_lib/* prepTextCell */.k0,
  draw: a => (0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.displayData, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.displayData).width + 16,
  onDelete: c => ({ ...c,
    data: undefined
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react.createElement(react.Suspense, {
      fallback: null
    }, react.createElement(NumberOverlayEditor, {
      highlight: isHighlighted,
      disabled: value.readonly === true,
      value: value.data,
      fixedDecimals: value.fixedDecimals,
      allowNegative: value.allowNegative,
      validatedSelection: validatedSelection,
      onChange: x => {
        var _x$floatValue;

        return onChange({ ...value,
          data: Number.isNaN((_x$floatValue = x.floatValue) !== null && _x$floatValue !== void 0 ? _x$floatValue : 0) ? 0 : x.floatValue
        });
      }
    }));
  },
  onPaste: (toPaste, cell) => {
    const newNumber = Number.parseFloat(toPaste);
    if (Number.isNaN(newNumber) || cell.data === newNumber) return undefined;
    return { ...cell,
      data: newNumber
    };
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/protected-cell.tsx


const protectedCellRenderer = {
  getAccessibilityString: () => "",
  measure: () => 108,
  kind: data_grid_types/* GridCellKind.Protected */.p6.Protected,
  needsHover: false,
  needsHoverPosition: false,
  draw: data_grid_lib/* drawProtectedCell */.sr,
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/row-id-cell.tsx




const rowIDCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.RowID */.p6.RowID,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: (a, b) => (0,data_grid_lib/* prepTextCell */.k0)(a, b, a.theme.textLight),
  draw: a => (0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly !== false,
      value: value.data,
      validatedSelection: validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/text-cell.tsx




const textCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Text */.p6.Text,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: data_grid_lib/* prepTextCell */.k0,
  useLabel: true,
  draw: a => ((0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.displayData, a.cell.contentAlign, a.cell.allowWrapping, a.hyperWrapping), true),
  measure: (ctx, cell, t) => {
    const lines = cell.displayData.split("\n").slice(0, cell.allowWrapping === true ? undefined : 1);
    return Math.max(...lines.map(l => ctx.measureText(l).width + 2 * t.cellHorizontalPadding));
  },
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly === true,
      altNewline: true,
      value: value.data,
      validatedSelection: validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? undefined : { ...cell,
    data: toPaste
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx

const UriOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "UriOverlayEditorStyle",
  class: "uvnt6gu"
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor.tsx





const UriOverlayEditor = p => {
  const {
    uri,
    onChange,
    forceEditMode,
    readonly,
    validatedSelection,
    preview
  } = p;
  const [editMode, setEditMode] = react.useState(uri === "" || forceEditMode);
  const onEditClick = react.useCallback(() => {
    setEditMode(true);
  }, []);

  if (editMode) {
    return react.createElement(GrowingEntry, {
      validatedSelection: validatedSelection,
      highlight: true,
      autoFocus: true,
      value: uri,
      onChange: onChange
    });
  }

  return react.createElement(UriOverlayEditorStyle, null, react.createElement("a", {
    className: "link-area",
    href: uri,
    target: "_blank",
    rel: "noopener noreferrer"
  }, preview), !readonly && react.createElement("div", {
    className: "edit-icon",
    onClick: onEditClick
  }, react.createElement(utils/* EditPencil */.Wy, null)), react.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};

/* harmony default export */ const uri_overlay_editor = (UriOverlayEditor);
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/uri-cell.tsx




const uriCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Uri */.p6.Uri,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: data_grid_lib/* prepTextCell */.k0,
  draw: a => (0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell, theme) => ctx.measureText(cell.data).width + theme.cellHorizontalPadding * 2,
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    var _value$displayData;

    const {
      onChange,
      value,
      forceEditMode,
      validatedSelection
    } = p;
    return react.createElement(uri_overlay_editor, {
      forceEditMode: forceEditMode,
      uri: value.data,
      preview: (_value$displayData = value.displayData) !== null && _value$displayData !== void 0 ? _value$displayData : value.data,
      validatedSelection: validatedSelection,
      readonly: value.readonly === true,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? undefined : { ...cell,
    data: toPaste
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/index.ts














const CellRenderers = {
  [data_grid_types/* InnerGridCellKind.Marker */.$o.Marker]: markerCellRenderer,
  [data_grid_types/* InnerGridCellKind.NewRow */.$o.NewRow]: newRowCellRenderer,
  [data_grid_types/* GridCellKind.Boolean */.p6.Boolean]: boolean_cell/* booleanCellRenderer */.j,
  [data_grid_types/* GridCellKind.Bubble */.p6.Bubble]: bubbleCellRenderer,
  [data_grid_types/* GridCellKind.Drilldown */.p6.Drilldown]: drilldownCellRenderer,
  [data_grid_types/* GridCellKind.Image */.p6.Image]: imageCellRenderer,
  [data_grid_types/* GridCellKind.Loading */.p6.Loading]: loadingCellRenderer,
  [data_grid_types/* GridCellKind.Markdown */.p6.Markdown]: markdownCellRenderer,
  [data_grid_types/* GridCellKind.Number */.p6.Number]: numberCellRenderer,
  [data_grid_types/* GridCellKind.Protected */.p6.Protected]: protectedCellRenderer,
  [data_grid_types/* GridCellKind.RowID */.p6.RowID]: rowIDCellRenderer,
  [data_grid_types/* GridCellKind.Text */.p6.Text]: textCellRenderer,
  [data_grid_types/* GridCellKind.Uri */.p6.Uri]: uriCellRenderer
};

/***/ }),

/***/ "./packages/core/src/data-grid/data-grid-lib.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AE": () => (/* binding */ drawImage),
/* harmony export */   "Df": () => (/* binding */ drawBoolean),
/* harmony export */   "G6": () => (/* binding */ getStickyWidth),
/* harmony export */   "H1": () => (/* binding */ cellIsInRange),
/* harmony export */   "NZ": () => (/* binding */ useMappedColumns),
/* harmony export */   "PU": () => (/* binding */ isGroupEqual),
/* harmony export */   "RM": () => (/* binding */ drawNewRowCell),
/* harmony export */   "SP": () => (/* binding */ drawDrilldownCell),
/* harmony export */   "Sb": () => (/* binding */ cellIsSelected),
/* harmony export */   "Ve": () => (/* binding */ computeBounds),
/* harmony export */   "Z1": () => (/* binding */ prepMarkerRowCell),
/* harmony export */   "_n": () => (/* binding */ drawWithLastUpdate),
/* harmony export */   "_u": () => (/* binding */ drawCheckbox),
/* harmony export */   "aX": () => (/* binding */ getMiddleCenterBias),
/* harmony export */   "hp": () => (/* binding */ drawBubbles),
/* harmony export */   "ih": () => (/* binding */ getEffectiveColumns),
/* harmony export */   "k0": () => (/* binding */ prepTextCell),
/* harmony export */   "ld": () => (/* binding */ drawMarkerRowCell),
/* harmony export */   "oK": () => (/* binding */ getColumnIndexForX),
/* harmony export */   "pV": () => (/* binding */ getRowIndexForY),
/* harmony export */   "sr": () => (/* binding */ drawProtectedCell),
/* harmony export */   "uN": () => (/* binding */ drawTextCell),
/* harmony export */   "zu": () => (/* binding */ roundedPoly)
/* harmony export */ });
/* unused harmony exports measureTextCached, drawTextCellExternal, deprepMarkerRowCell */
/* harmony import */ var _data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/common/utils.tsx");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _common_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/common/support.ts");
/* harmony import */ var canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/canvas-hypertxt/dist/js/index.js");





function useMappedColumns(columns, freezeColumns) {
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => columns.map((c, i) => ({ ...c,
    sourceIndex: i,
    sticky: i < freezeColumns
  })), [columns, freezeColumns]);
}
function isGroupEqual(left, right) {
  return (left !== null && left !== void 0 ? left : "") === (right !== null && right !== void 0 ? right : "");
}
function cellIsSelected(location, cell, selection) {
  if ((selection === null || selection === void 0 ? void 0 : selection.current) === undefined) return false;
  const [col, row] = selection.current.cell;
  const [cellCol, cellRow] = location;
  if (cellRow !== row) return false;

  if (cell.span === undefined) {
    return col === cellCol;
  }

  return col >= cell.span[0] && col <= cell.span[1];
}

function cellIsInRect(location, cell, rect) {
  const startX = rect.x;
  const endX = rect.x + rect.width - 1;
  const startY = rect.y;
  const endY = rect.y + rect.height - 1;
  const [cellCol, cellRow] = location;
  if (cellRow < startY || cellRow > endY) return false;

  if (cell.span === undefined) {
    return cellCol >= startX && cellCol <= endX;
  }

  const [spanStart, spanEnd] = cell.span;
  return spanStart >= startX && spanStart <= endX || spanEnd >= startX && spanStart <= endX || spanStart < startX && spanEnd > endX;
}

function cellIsInRange(location, cell, selection) {
  let result = 0;
  if (selection.current === undefined) return result;
  if (cellIsInRect(location, cell, selection.current.range)) result++;

  for (const r of selection.current.rangeStack) {
    if (cellIsInRect(location, cell, r)) {
      result++;
    }
  }

  return result;
}

function remapForDnDState(columns, dndState) {
  let mappedCols = columns;

  if (dndState !== undefined) {
    let writable = [...columns];
    const temp = mappedCols[dndState.src];

    if (dndState.src > dndState.dest) {
      writable.splice(dndState.src, 1);
      writable.splice(dndState.dest, 0, temp);
    } else {
      writable.splice(dndState.dest + 1, 0, temp);
      writable.splice(dndState.src, 1);
    }

    writable = writable.map((c, i) => ({ ...c,
      sticky: columns[i].sticky
    }));
    mappedCols = writable;
  }

  return mappedCols;
}

function getStickyWidth(columns, dndState) {
  let result = 0;
  const remapped = remapForDnDState(columns, dndState);

  for (let i = 0; i < remapped.length; i++) {
    const c = remapped[i];
    if (c.sticky) result += c.width;else break;
  }

  return result;
}
function getEffectiveColumns(columns, cellXOffset, width, dndState, tx) {
  const mappedCols = remapForDnDState(columns, dndState);
  const sticky = [];

  for (const c of mappedCols) {
    if (c.sticky) {
      sticky.push(c);
    } else {
      break;
    }
  }

  if (sticky.length > 0) {
    for (const c of sticky) {
      width -= c.width;
    }
  }

  let endIndex = cellXOffset;
  let curX = tx !== null && tx !== void 0 ? tx : 0;

  while (curX <= width && endIndex < mappedCols.length) {
    curX += mappedCols[endIndex].width;
    endIndex++;
  }

  for (let i = cellXOffset; i < endIndex; i++) {
    const c = mappedCols[i];

    if (!c.sticky) {
      sticky.push(c);
    }
  }

  return sticky;
}
function getColumnIndexForX(targetX, effectiveColumns, translateX) {
  let x = 0;

  for (const c of effectiveColumns) {
    const cx = c.sticky ? x : x + (translateX !== null && translateX !== void 0 ? translateX : 0);

    if (targetX <= cx + c.width) {
      return c.sourceIndex;
    }

    x += c.width;
  }

  return -1;
}
function getRowIndexForY(targetY, height, hasGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, lastRowSticky) {
  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (hasGroups && targetY <= groupHeaderHeight) return -2;
  if (targetY <= totalHeaderHeight) return -1;
  const lastRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows - 1);

  if (lastRowSticky && targetY > height - lastRowHeight) {
    return rows - 1;
  }

  const effectiveRows = rows - (lastRowSticky ? 1 : 0);
  const ty = targetY - (translateY !== null && translateY !== void 0 ? translateY : 0);

  if (typeof rowHeight === "number") {
    const target = Math.floor((ty - totalHeaderHeight) / rowHeight) + cellYOffset;
    if (target >= effectiveRows) return undefined;
    return target;
  } else {
    let curY = totalHeaderHeight;

    for (let i = cellYOffset; i < effectiveRows; i++) {
      const rh = rowHeight(i);
      if (ty <= curY + rh) return i;
      curY += rh;
    }

    return undefined;
  }
}
let metricsSize = 0;
let metricsCache = {};
const isSSR = typeof window === "undefined";

async function clearCacheOnLoad() {
  var _document, _document$fonts;

  if (isSSR || ((_document = document) === null || _document === void 0 ? void 0 : (_document$fonts = _document.fonts) === null || _document$fonts === void 0 ? void 0 : _document$fonts.ready) === undefined) return;
  await document.fonts.ready;
  metricsSize = 0;
  metricsCache = {};
  (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__/* .clearCache */ .L)();
}

void clearCacheOnLoad();

function makeCacheKey(s, ctx, baseline, font) {
  return `${s}_${font !== null && font !== void 0 ? font : ctx.font}_${baseline}`;
}

function measureTextCached(s, ctx, font) {
  const key = makeCacheKey(s, ctx, "middle", font);
  let metrics = metricsCache[key];

  if (metrics === undefined) {
    metrics = ctx.measureText(s);
    metricsCache[key] = metrics;
    metricsSize++;
  }

  if (metricsSize > 10000) {
    metricsCache = {};
    metricsSize = 0;
  }

  return metrics;
}
function getMiddleCenterBias(ctx, font) {
  if (typeof font !== "string") {
    font = `${font.baseFontStyle} ${font.fontFamily}`;
  }

  return getMiddleCenterBiasInner(ctx, font);
}

function loadMetric(ctx, baseline) {
  const sample = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  ctx.save();
  ctx.textBaseline = baseline;
  const result = ctx.measureText(sample);
  ctx.restore();
  return result;
}

const biasCache = [];

function getMiddleCenterBiasInner(ctx, font) {
  for (const x of biasCache) {
    if (x.key === font) return x.val;
  }

  const alphabeticMetrics = loadMetric(ctx, "alphabetic");
  const middleMetrics = loadMetric(ctx, "middle");
  const bias = -(middleMetrics.actualBoundingBoxDescent - alphabeticMetrics.actualBoundingBoxDescent) + alphabeticMetrics.actualBoundingBoxAscent / 2;
  biasCache.push({
    key: font,
    val: bias
  });
  return bias;
}

function drawWithLastUpdate(args, lastUpdate, frameTime, lastPrep, draw) {
  const {
    ctx,
    rect,
    theme
  } = args;
  let progress = Number.MAX_SAFE_INTEGER;
  const animTime = 500;

  if (lastUpdate !== undefined) {
    progress = frameTime - lastUpdate;

    if (progress < animTime) {
      const fade = 1 - progress / animTime;
      ctx.globalAlpha = fade;
      ctx.fillStyle = theme.bgSearchResult;
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
      ctx.globalAlpha = 1;

      if (lastPrep !== undefined) {
        lastPrep.fillStyle = theme.bgSearchResult;
      }
    }
  }

  draw();
  return progress < animTime;
}
function prepTextCell(args, lastPrep, overrideColor) {
  const {
    ctx,
    theme
  } = args;
  const result = lastPrep !== null && lastPrep !== void 0 ? lastPrep : {};
  const newFill = overrideColor !== null && overrideColor !== void 0 ? overrideColor : theme.textDark;

  if (newFill !== result.fillStyle) {
    ctx.fillStyle = newFill;
    result.fillStyle = newFill;
  }

  return result;
}
function drawTextCellExternal(args, data, contentAlign) {
  const {
    rect,
    ctx,
    theme
  } = args;
  ctx.fillStyle = theme.textDark;
  drawTextCell({
    ctx: ctx,
    rect,
    theme: theme
  }, data, contentAlign);
}

function drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign) {
  if (contentAlign === "right") {
    ctx.fillText(data, x + w - (theme.cellHorizontalPadding + 0.5), y + h / 2 + bias);
  } else if (contentAlign === "center") {
    ctx.fillText(data, x + w / 2, y + h / 2 + bias);
  } else {
    ctx.fillText(data, x + theme.cellHorizontalPadding + 0.5, y + h / 2 + bias);
  }
}

function getEmHeight(ctx, fontStyle) {
  const textMetrics = measureTextCached("ABCi09jgqpy", ctx, fontStyle);
  return textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
}

function drawTextCell(args, data, contentAlign, allowWrapping, hyperWrapping) {
  var _allowWrapping;

  const {
    ctx,
    rect,
    theme
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  allowWrapping = (_allowWrapping = allowWrapping) !== null && _allowWrapping !== void 0 ? _allowWrapping : false;

  if (!allowWrapping) {
    if (data.includes("\n")) {
      data = data.split(/\r?\n/)[0];
    }

    const max = w / 4;

    if (data.length > max) {
      data = data.slice(0, max);
    }
  }

  const bias = getMiddleCenterBias(ctx, theme);
  const isRtl = (0,_common_utils__WEBPACK_IMPORTED_MODULE_2__/* .direction */ .o7)(data) === "rtl";

  if (contentAlign === undefined && isRtl) {
    contentAlign = "right";
  }

  if (isRtl) {
    ctx.direction = "rtl";
  }

  if (data.length > 0) {
    let changed = false;

    if (contentAlign === "right") {
      ctx.textAlign = "right";
      changed = true;
    } else if (contentAlign !== undefined && contentAlign !== "left") {
      ctx.textAlign = contentAlign;
      changed = true;
    }

    if (!allowWrapping) {
      drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign);
    } else {
      const fontStyle = `${theme.fontFamily} ${theme.baseFontStyle}`;
      const split = (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__/* .split */ .V)(ctx, data, fontStyle, w - theme.cellHorizontalPadding * 2, hyperWrapping !== null && hyperWrapping !== void 0 ? hyperWrapping : false);
      const emHeight = getEmHeight(ctx, fontStyle);
      const lineHeight = theme.lineHeight * emHeight;
      const actualHeight = emHeight + lineHeight * (split.length - 1);
      const mustClip = actualHeight + theme.cellVerticalPadding > h;

      if (mustClip) {
        ctx.save();
        ctx.rect(x, y, w, h);
        ctx.clip();
      }

      const optimalY = y + h / 2 - actualHeight / 2;
      let drawY = Math.max(y + theme.cellVerticalPadding, optimalY);

      for (const line of split) {
        drawSingleTextLine(ctx, line, x, drawY, w, emHeight, bias, theme, contentAlign);
        drawY += lineHeight;
        if (drawY > y + h) break;
      }

      if (mustClip) {
        ctx.restore();
      }
    }

    if (changed) {
      ctx.textAlign = "start";
    }

    if (isRtl) {
      ctx.direction = "inherit";
    }
  }
}
function drawNewRowCell(args, data, icon) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme,
    spriteManager
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  ctx.beginPath();
  ctx.globalAlpha = hoverAmount;
  ctx.rect(x, y, w, h);
  ctx.fillStyle = theme.bgHeaderHovered;
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.beginPath();
  const alwaysShowIcon = data !== "";
  let textX = 0;

  if (icon !== undefined) {
    const padding = 8;
    const size = h - padding;
    const px = x + padding / 2;
    const py = y + padding / 2;
    spriteManager.drawSprite(icon, "normal", ctx, px, py, size, theme, alwaysShowIcon ? 1 : hoverAmount);
    textX = size;
  } else {
    textX = 24;
    const finalLineSize = 12;
    const lineSize = alwaysShowIcon ? finalLineSize : hoverAmount * finalLineSize;
    const xTranslate = alwaysShowIcon ? 0 : (1 - hoverAmount) * finalLineSize * 0.5;
    const padPlus = theme.cellHorizontalPadding + 4;

    if (lineSize > 0) {
      ctx.moveTo(x + padPlus + xTranslate, y + h / 2);
      ctx.lineTo(x + padPlus + xTranslate + lineSize, y + h / 2);
      ctx.moveTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 - lineSize * 0.5);
      ctx.lineTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 + lineSize * 0.5);
      ctx.lineWidth = 2;
      ctx.strokeStyle = theme.bgIconHeader;
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }

  ctx.fillStyle = theme.textMedium;
  ctx.fillText(data, textX + x + theme.cellHorizontalPadding + 0.5, y + h / 2 + getMiddleCenterBias(ctx, theme));
  ctx.beginPath();
}
function drawCheckbox(ctx, theme, checked, x, y, width, height, highlighted) {
  let hoverX = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : -20;
  let hoverY = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : -20;
  let maxSize = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 32;
  const centerX = Math.floor(x + width / 2);
  const centerY = Math.floor(y + height / 2);
  const checkBoxWidth = Math.min(maxSize, height - theme.cellVerticalPadding * 2);
  const hoverHelper = checkBoxWidth / 2;
  const hovered = Math.abs(hoverX - width / 2) < hoverHelper && Math.abs(hoverY - height / 2) < hoverHelper;
  const rectBordRadius = 4;
  const posHelperChecked = checkBoxWidth / 2;

  switch (checked) {
    case true:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);
        ctx.fillStyle = highlighted ? theme.accentColor : theme.textMedium;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - posHelperChecked + checkBoxWidth / 4.23, centerY - posHelperChecked + checkBoxWidth / 1.97);
        ctx.lineTo(centerX - posHelperChecked + checkBoxWidth / 2.42, centerY - posHelperChecked + checkBoxWidth / 1.44);
        ctx.lineTo(centerX - posHelperChecked + checkBoxWidth / 1.29, centerY - posHelperChecked + checkBoxWidth / 3.25);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }

    case _data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .BooleanEmpty */ .qF:
    case false:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2 + 0.5, centerY - checkBoxWidth / 2 + 0.5, checkBoxWidth - 1, checkBoxWidth - 1, rectBordRadius);
        ctx.lineWidth = 1;
        ctx.strokeStyle = hovered ? theme.textDark : theme.textMedium;
        ctx.stroke();
        break;
      }

    case _data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .BooleanIndeterminate */ .sd:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);
        ctx.fillStyle = hovered ? theme.textMedium : theme.textLight;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - checkBoxWidth / 3, centerY);
        ctx.lineTo(centerX + checkBoxWidth / 3, centerY);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }

    default:
      (0,_common_support__WEBPACK_IMPORTED_MODULE_4__/* .assertNever */ .vE)(checked);
  }
}
function prepMarkerRowCell(args, lastPrep) {
  const {
    ctx,
    theme
  } = args;
  const newFont = `9px ${theme.fontFamily}`;
  const result = lastPrep !== null && lastPrep !== void 0 ? lastPrep : {};

  if ((result === null || result === void 0 ? void 0 : result.font) !== newFont) {
    ctx.font = newFont;
    result.font = newFont;
  }

  result.deprep = deprepMarkerRowCell;
  ctx.textAlign = "center";
  return result;
}
function deprepMarkerRowCell(args) {
  const {
    ctx
  } = args;
  ctx.textAlign = "start";
}
function drawMarkerRowCell(args, index, checked, markerKind, drawHandle) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme
  } = args;
  const {
    x,
    y,
    width,
    height
  } = rect;
  const checkedboxAlpha = checked ? 1 : markerKind === "checkbox-visible" ? 0.6 + 0.4 * hoverAmount : hoverAmount;

  if (markerKind !== "number" && checkedboxAlpha > 0) {
    ctx.globalAlpha = checkedboxAlpha;
    const offsetAmount = 7 * (checked ? hoverAmount : 1);
    drawCheckbox(ctx, theme, checked, drawHandle ? x + offsetAmount : x, y, drawHandle ? width - offsetAmount : width, height, true, undefined, undefined, 18);

    if (drawHandle) {
      ctx.globalAlpha = hoverAmount;
      ctx.beginPath();

      for (const xOffset of [3, 6]) {
        for (const yOffset of [-5, -1, 3]) {
          ctx.rect(x + xOffset, y + height / 2 + yOffset, 2, 2);
        }
      }

      ctx.fillStyle = theme.textLight;
      ctx.fill();
      ctx.beginPath();
    }

    ctx.globalAlpha = 1;
  }

  if (markerKind === "number" || markerKind === "both" && !checked) {
    const text = index.toString();
    const start = x + width / 2;

    if (markerKind === "both" && hoverAmount !== 0) {
      ctx.globalAlpha = 1 - hoverAmount;
    }

    ctx.fillStyle = theme.textLight;
    ctx.fillText(text, start, y + height / 2 + getMiddleCenterBias(ctx, `9px ${theme.fontFamily}`));

    if (hoverAmount !== 0) {
      ctx.globalAlpha = 1;
    }
  }
}
function drawProtectedCell(args) {
  const {
    ctx,
    theme,
    rect
  } = args;
  const {
    x,
    y,
    height: h
  } = rect;
  ctx.beginPath();
  const radius = 2.5;
  let xStart = x + theme.cellHorizontalPadding + radius;
  const center = y + h / 2;
  const p = Math.cos((0,_common_utils__WEBPACK_IMPORTED_MODULE_2__/* .degreesToRadians */ .Ht)(30)) * radius;
  const q = Math.sin((0,_common_utils__WEBPACK_IMPORTED_MODULE_2__/* .degreesToRadians */ .Ht)(30)) * radius;

  for (let i = 0; i < 12; i++) {
    ctx.moveTo(xStart, center - radius);
    ctx.lineTo(xStart, center + radius);
    ctx.moveTo(xStart + p, center - q);
    ctx.lineTo(xStart - p, center + q);
    ctx.moveTo(xStart - p, center - q);
    ctx.lineTo(xStart + p, center + q);
    xStart += 8;
  }

  ctx.lineWidth = 1.1;
  ctx.lineCap = "square";
  ctx.strokeStyle = theme.textLight;
  ctx.stroke();
}

function roundedRect(ctx, x, y, width, height, radius) {
  if (typeof radius === "number") {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius
    };
  }

  radius = {
    tl: Math.min(radius.tl, height / 2, width / 2),
    tr: Math.min(radius.tr, height / 2, width / 2),
    bl: Math.min(radius.bl, height / 2, width / 2),
    br: Math.min(radius.br, height / 2, width / 2)
  };
  ctx.moveTo(x + radius.tl, y);
  ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);
  ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);
  ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);
  ctx.arcTo(x, y, x + radius.tl, y, radius.tl);
}

function drawBoolean(args, data, canEdit, maxSize) {
  if (!canEdit && data === _data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .BooleanEmpty */ .qF) {
    return;
  }

  const {
    ctx,
    hoverAmount,
    theme,
    rect,
    highlighted,
    hoverX,
    hoverY
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const hoverEffect = 0.35;
  let alpha = canEdit ? 1 - hoverEffect + hoverEffect * hoverAmount : 0.4;

  if (data === _data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .BooleanEmpty */ .qF) {
    alpha *= hoverAmount;
  }

  if (alpha === 0) {
    return;
  }

  ctx.globalAlpha = alpha;
  drawCheckbox(ctx, theme, data, x, y, w, h, highlighted, hoverX, hoverY, maxSize);
  ctx.globalAlpha = 1;
}
const itemMargin = 4;
function drawBubbles(args, data) {
  const {
    rect,
    theme,
    ctx,
    highlighted
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const bubbleHeight = 20;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const renderBoxes = [];

  for (const s of data) {
    if (renderX > x + w) break;
    const textWidth = measureTextCached(s, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;
    renderBoxes.push({
      x: renderX,
      width: textWidth
    });
    renderX += textWidth + bubblePad * 2 + bubbleMargin;
  }

  ctx.beginPath();

  for (const rectInfo of renderBoxes) {
    roundedRect(ctx, rectInfo.x, y + (h - bubbleHeight) / 2, rectInfo.width + bubblePad * 2, bubbleHeight, bubbleHeight / 2);
  }

  ctx.fillStyle = highlighted ? theme.bgBubbleSelected : theme.bgBubble;
  ctx.fill();

  for (const [i, rectInfo] of renderBoxes.entries()) {
    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(data[i], rectInfo.x + bubblePad, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}
const drilldownCache = {};

function getAndCacheDrilldownBorder(bgCell, border, height) {
  const dpr = Math.ceil(window.devicePixelRatio);
  const shadowBlur = 5;
  const targetHeight = height - shadowBlur * 2;
  const middleWidth = 4;
  const rounding = 6;
  const innerHeight = height * dpr;
  const sideWidth = rounding + shadowBlur;
  const targetWidth = rounding * 3;
  const innerWidth = (targetWidth + shadowBlur * 2) * dpr;
  const key = `${bgCell},${border},${dpr},${height}`;

  if (drilldownCache[key] !== undefined) {
    return {
      el: drilldownCache[key],
      height: innerHeight,
      width: innerWidth,
      middleWidth: middleWidth * dpr,
      sideWidth: sideWidth * dpr,
      padding: shadowBlur * dpr,
      dpr
    };
  }

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (ctx === null) return null;
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  ctx.scale(dpr, dpr);
  drilldownCache[key] = canvas;
  const trueRounding = Math.min(rounding, targetWidth / 2, targetHeight / 2);
  ctx.beginPath();
  roundedRect(ctx, shadowBlur, shadowBlur, targetWidth, targetHeight, trueRounding);
  ctx.shadowColor = "rgba(24, 25, 34, 0.4)";
  ctx.shadowBlur = 1;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowColor = "rgba(24, 25, 34, 0.3)";
  ctx.shadowOffsetY = 1;
  ctx.shadowBlur = 5;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
  ctx.shadowBlur = 0;
  ctx.beginPath();
  roundedRect(ctx, shadowBlur + 0.5, shadowBlur + 0.5, targetWidth, targetHeight, trueRounding);
  ctx.strokeStyle = border;
  ctx.lineWidth = 1;
  ctx.stroke();
  return {
    el: canvas,
    height: innerHeight,
    width: innerWidth,
    sideWidth: sideWidth * dpr,
    middleWidth: rounding * dpr,
    padding: shadowBlur * dpr,
    dpr
  };
}

function drawDrilldownCell(args, data) {
  const {
    rect,
    theme,
    ctx,
    imageLoader,
    col,
    row
  } = args;
  const {
    x,
    width: w
  } = rect;
  const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
  const emHeight = getEmHeight(ctx, font);
  const h = Math.min(rect.height, Math.max(16, Math.ceil(emHeight * theme.lineHeight) * 2));
  const y = Math.floor(rect.y + (rect.height - h) / 2);
  const bubbleHeight = h - 10;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const tileMap = getAndCacheDrilldownBorder(theme.bgCell, theme.drilldownBorder, h);
  const renderBoxes = [];

  for (const el of data) {
    if (renderX > x + w) break;
    const textMetrics = measureTextCached(el.text, ctx, font);
    const textWidth = textMetrics.width;
    let imgWidth = 0;

    if (el.img !== undefined) {
      const img = imageLoader.loadOrGetImage(el.img, col, row);

      if (img !== undefined) {
        imgWidth = bubbleHeight - 8 + 4;
      }
    }

    const renderWidth = textWidth + imgWidth + bubblePad * 2;
    renderBoxes.push({
      x: renderX,
      width: renderWidth
    });
    renderX += renderWidth + bubbleMargin;
  }

  if (tileMap !== null) {
    const {
      el,
      height,
      middleWidth,
      sideWidth,
      width,
      dpr,
      padding
    } = tileMap;
    const outerSideWidth = sideWidth / dpr;
    const outerPadding = padding / dpr;

    for (const rectInfo of renderBoxes) {
      const rx = Math.floor(rectInfo.x);
      const rw = Math.floor(rectInfo.width);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(el, 0, 0, sideWidth, height, rx - outerPadding, y, outerSideWidth, h);
      if (rectInfo.width > sideWidth * 2) ctx.drawImage(el, sideWidth, 0, middleWidth, height, rx + (outerSideWidth - outerPadding), y, rw - (outerSideWidth - outerPadding) * 2, h);
      ctx.drawImage(el, width - sideWidth, 0, sideWidth, height, rx + rw - (outerSideWidth - outerPadding), y, outerSideWidth, h);
      ctx.imageSmoothingEnabled = true;
    }
  }

  ctx.beginPath();

  for (const [i, rectInfo] of renderBoxes.entries()) {
    const d = data[i];
    let drawX = rectInfo.x + bubblePad;

    if (d.img !== undefined) {
      const img = imageLoader.loadOrGetImage(d.img, col, row);

      if (img !== undefined) {
        const imgSize = bubbleHeight - 8;
        let srcX = 0;
        let srcY = 0;
        let srcWidth = img.width;
        let srcHeight = img.height;

        if (srcWidth > srcHeight) {
          srcX += (srcWidth - srcHeight) / 2;
          srcWidth = srcHeight;
        } else if (srcHeight > srcWidth) {
          srcY += (srcHeight - srcWidth) / 2;
          srcHeight = srcWidth;
        }

        ctx.beginPath();
        roundedRect(ctx, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize, 3);
        ctx.save();
        ctx.clip();
        ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize);
        ctx.restore();
        drawX += imgSize + 4;
      }
    }

    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(d.text, drawX, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}
function drawImage(args, data) {
  let rounding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
  let contentAlign = arguments.length > 3 ? arguments[3] : undefined;
  const {
    rect,
    col,
    row,
    theme,
    ctx,
    imageLoader
  } = args;
  const {
    x,
    y,
    height: h,
    width: w
  } = rect;
  const imgHeight = h - theme.cellVerticalPadding * 2;
  const images = [];
  let totalWidth = 0;

  for (let index = 0; index < data.length; index++) {
    const i = data[index];
    if (i.length === 0) continue;
    const img = imageLoader.loadOrGetImage(i, col, row);

    if (img !== undefined) {
      images[index] = img;
      const imgWidth = img.width * (imgHeight / img.height);
      totalWidth += imgWidth + itemMargin;
    }
  }

  if (totalWidth === 0) return;
  totalWidth -= itemMargin;
  let drawX = x + theme.cellHorizontalPadding;
  if (contentAlign === "right") drawX = Math.floor(x + w - theme.cellHorizontalPadding - totalWidth);else if (contentAlign === "center") drawX = Math.floor(x + w / 2 - totalWidth / 2);

  for (const img of images) {
    if (img === undefined) continue;
    const imgWidth = img.width * (imgHeight / img.height);

    if (rounding > 0) {
      roundedRect(ctx, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight, rounding);
      ctx.save();
      ctx.clip();
    }

    ctx.drawImage(img, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight);

    if (rounding > 0) {
      ctx.restore();
    }

    drawX += imgWidth + itemMargin;
  }
}
function roundedPoly(ctx, points, radiusAll) {
  const asVec = function (p, pp) {
    const vx = pp.x - p.x;
    const vy = pp.y - p.y;
    const vlen = Math.sqrt(vx * vx + vy * vy);
    const vnx = vx / vlen;
    const vny = vy / vlen;
    return {
      x: vx,
      y: pp.y - p.y,
      len: vlen,
      nx: vnx,
      ny: vny,
      ang: Math.atan2(vny, vnx)
    };
  };

  let radius;
  const len = points.length;
  let p1 = points[len - 1];

  for (let i = 0; i < len; i++) {
    let p2 = points[i % len];
    const p3 = points[(i + 1) % len];
    const v1 = asVec(p2, p1);
    const v2 = asVec(p2, p3);
    const sinA = v1.nx * v2.ny - v1.ny * v2.nx;
    const sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
    let angle = Math.asin(sinA < -1 ? -1 : sinA > 1 ? 1 : sinA);
    let radDirection = 1;
    let drawDirection = false;

    if (sinA90 < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else {
      if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
    }

    radius = p2.radius !== undefined ? p2.radius : radiusAll;
    const halfAngle = angle / 2;
    let lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    let cRadius;

    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }

    let x = p2.x + v2.nx * lenOut;
    let y = p2.y + v2.ny * lenOut;
    x += -v2.ny * cRadius * radDirection;
    y += v2.nx * cRadius * radDirection;
    ctx.arc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
    p1 = p2;
    p2 = p3;
  }

  ctx.closePath();
}
function computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight) {
  const result = {
    x: 0,
    y: totalHeaderHeight + translateY,
    width: 0,
    height: 0
  };
  const headerHeight = totalHeaderHeight - groupHeaderHeight;

  if (col >= freezeColumns) {
    const dir = cellXOffset > col ? -1 : 1;
    const freezeWidth = getStickyWidth(mappedColumns);
    result.x += freezeWidth + translateX;

    for (let i = cellXOffset; i !== col; i += dir) {
      result.x += mappedColumns[dir === 1 ? i : i - 1].width * dir;
    }
  } else {
    for (let i = 0; i < col; i++) {
      result.x += mappedColumns[i].width;
    }
  }

  result.width = mappedColumns[col].width + 1;

  if (row === -1) {
    result.y = groupHeaderHeight;
    result.height = headerHeight;
  } else if (row === -2) {
    result.y = 0;
    result.height = groupHeaderHeight;
    let start = col;
    const group = mappedColumns[col].group;
    const sticky = mappedColumns[col].sticky;

    while (start > 0 && isGroupEqual(mappedColumns[start - 1].group, group) && mappedColumns[start - 1].sticky === sticky) {
      const c = mappedColumns[start - 1];
      result.x -= c.width;
      result.width += c.width;
      start--;
    }

    let end = col;

    while (end + 1 < mappedColumns.length && isGroupEqual(mappedColumns[end + 1].group, group) && mappedColumns[end + 1].sticky === sticky) {
      const c = mappedColumns[end + 1];
      result.width += c.width;
      end++;
    }

    if (!sticky) {
      const freezeWidth = getStickyWidth(mappedColumns);
      const clip = result.x - freezeWidth;

      if (clip < 0) {
        result.x -= clip;
        result.width += clip;
      }

      if (result.x + result.width > width) {
        result.width = width - result.x;
      }
    }
  } else if (lastRowSticky && row === rows - 1) {
    const stickyHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(row);
    result.y = height - stickyHeight;
    result.height = stickyHeight;
  } else {
    const dir = cellYOffset > row ? -1 : 1;

    if (typeof rowHeight === "number") {
      const delta = row - cellYOffset;
      result.y += delta * rowHeight;
    } else {
      for (let r = cellYOffset; r !== row; r += dir) {
        result.y += rowHeight(r) * dir;
      }
    }

    result.height = (typeof rowHeight === "number" ? rowHeight : rowHeight(row)) + 1;
  }

  return result;
}

/***/ }),

/***/ "./packages/core/src/data-grid/data-grid-types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$o": () => (/* binding */ InnerGridCellKind),
/* harmony export */   "DP": () => (/* binding */ isObjectEditorCallbackResult),
/* harmony export */   "EV": () => (/* binding */ CompactSelection),
/* harmony export */   "Gf": () => (/* binding */ headerCellCheckboxPrefix),
/* harmony export */   "PE": () => (/* binding */ GridColumnIcon),
/* harmony export */   "Qo": () => (/* binding */ isReadWriteCell),
/* harmony export */   "Sq": () => (/* binding */ isSizedGridColumn),
/* harmony export */   "T9": () => (/* binding */ isEditableGridCell),
/* harmony export */   "Xv": () => (/* binding */ outOfBoundsKind),
/* harmony export */   "YK": () => (/* binding */ headerCellUnheckedMarker),
/* harmony export */   "aZ": () => (/* binding */ headerKind),
/* harmony export */   "f": () => (/* binding */ isTextEditableGridCell),
/* harmony export */   "iJ": () => (/* binding */ headerCellIndeterminateMarker),
/* harmony export */   "kf": () => (/* binding */ booleanCellIsEditable),
/* harmony export */   "mr": () => (/* binding */ groupHeaderKind),
/* harmony export */   "p6": () => (/* binding */ GridCellKind),
/* harmony export */   "pZ": () => (/* binding */ gridSelectionHasItem),
/* harmony export */   "qF": () => (/* binding */ BooleanEmpty),
/* harmony export */   "qT": () => (/* binding */ headerCellCheckedMarker),
/* harmony export */   "rL": () => (/* binding */ resolveCellsThunk),
/* harmony export */   "rs": () => (/* binding */ isInnerOnlyCell),
/* harmony export */   "sd": () => (/* binding */ BooleanIndeterminate)
/* harmony export */ });
/* harmony import */ var _common_support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/common/support.ts");
/* harmony import */ var lodash_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/has.js");
/* harmony import */ var lodash_has_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_has_js__WEBPACK_IMPORTED_MODULE_0__);
let _Symbol$iterator;



function gridSelectionHasItem(sel, item) {
  const [col, row] = item;
  if (sel.columns.hasIndex(col) || sel.rows.hasIndex(row)) return true;

  if (sel.current !== undefined) {
    if (sel.current.cell[0] === col && sel.current.cell[1] === row) return true;
    const toCheck = [sel.current.range, ...sel.current.rangeStack];

    for (const r of toCheck) {
      if (col >= r.x && col < r.x + r.width && row >= r.y && row < r.y + r.height) return true;
    }
  }

  return false;
}
const BooleanEmpty = null;
const BooleanIndeterminate = undefined;
const headerKind = "header";
const groupHeaderKind = "group-header";
const outOfBoundsKind = "out-of-bounds";
let GridCellKind;

(function (GridCellKind) {
  GridCellKind["Uri"] = "uri";
  GridCellKind["Text"] = "text";
  GridCellKind["Image"] = "image";
  GridCellKind["RowID"] = "row-id";
  GridCellKind["Number"] = "number";
  GridCellKind["Bubble"] = "bubble";
  GridCellKind["Boolean"] = "boolean";
  GridCellKind["Loading"] = "loading";
  GridCellKind["Markdown"] = "markdown";
  GridCellKind["Drilldown"] = "drilldown";
  GridCellKind["Protected"] = "protected";
  GridCellKind["Custom"] = "custom";
})(GridCellKind || (GridCellKind = {}));

let GridColumnIcon;

(function (GridColumnIcon) {
  GridColumnIcon["HeaderRowID"] = "headerRowID";
  GridColumnIcon["HeaderCode"] = "headerCode";
  GridColumnIcon["HeaderNumber"] = "headerNumber";
  GridColumnIcon["HeaderString"] = "headerString";
  GridColumnIcon["HeaderBoolean"] = "headerBoolean";
  GridColumnIcon["HeaderAudioUri"] = "headerAudioUri";
  GridColumnIcon["HeaderVideoUri"] = "headerVideoUri";
  GridColumnIcon["HeaderEmoji"] = "headerEmoji";
  GridColumnIcon["HeaderImage"] = "headerImage";
  GridColumnIcon["HeaderUri"] = "headerUri";
  GridColumnIcon["HeaderPhone"] = "headerPhone";
  GridColumnIcon["HeaderMarkdown"] = "headerMarkdown";
  GridColumnIcon["HeaderDate"] = "headerDate";
  GridColumnIcon["HeaderTime"] = "headerTime";
  GridColumnIcon["HeaderEmail"] = "headerEmail";
  GridColumnIcon["HeaderReference"] = "headerReference";
  GridColumnIcon["HeaderIfThenElse"] = "headerIfThenElse";
  GridColumnIcon["HeaderSingleValue"] = "headerSingleValue";
  GridColumnIcon["HeaderLookup"] = "headerLookup";
  GridColumnIcon["HeaderTextTemplate"] = "headerTextTemplate";
  GridColumnIcon["HeaderMath"] = "headerMath";
  GridColumnIcon["HeaderRollup"] = "headerRollup";
  GridColumnIcon["HeaderJoinStrings"] = "headerJoinStrings";
  GridColumnIcon["HeaderSplitString"] = "headerSplitString";
  GridColumnIcon["HeaderGeoDistance"] = "headerGeoDistance";
  GridColumnIcon["HeaderArray"] = "headerArray";
  GridColumnIcon["RowOwnerOverlay"] = "rowOwnerOverlay";
  GridColumnIcon["ProtectedColumnOverlay"] = "protectedColumnOverlay";
})(GridColumnIcon || (GridColumnIcon = {}));

const headerCellCheckboxPrefix = "___gdg_header_cell_";
const headerCellCheckedMarker = headerCellCheckboxPrefix + "checked";
const headerCellUnheckedMarker = headerCellCheckboxPrefix + "unchecked";
const headerCellIndeterminateMarker = headerCellCheckboxPrefix + "indeterminate";
function isSizedGridColumn(c) {
  return "width" in c && typeof c.width === "number";
}
async function resolveCellsThunk(thunk) {
  if (typeof thunk === "object") return thunk;
  return await thunk();
}
function isEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown) {
    return false;
  }

  (0,_common_support__WEBPACK_IMPORTED_MODULE_1__/* .proveType */ .NG)(cell);
  return true;
}
function isTextEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown || cell.kind === GridCellKind.Boolean || cell.kind === GridCellKind.Image || cell.kind === GridCellKind.Custom) {
    return false;
  }

  (0,_common_support__WEBPACK_IMPORTED_MODULE_1__/* .proveType */ .NG)(cell);
  return true;
}
function isInnerOnlyCell(cell) {
  return cell.kind === InnerGridCellKind.Marker || cell.kind === InnerGridCellKind.NewRow;
}
function isReadWriteCell(cell) {
  if (!isEditableGridCell(cell) || cell.kind === GridCellKind.Image) return false;

  if (cell.kind === GridCellKind.Text || cell.kind === GridCellKind.Number || cell.kind === GridCellKind.Markdown || cell.kind === GridCellKind.Uri || cell.kind === GridCellKind.Custom || cell.kind === GridCellKind.Boolean) {
    return cell.readonly !== true;
  }

  (0,_common_support__WEBPACK_IMPORTED_MODULE_1__/* .assertNever */ .vE)(cell);
}
function isObjectEditorCallbackResult(obj) {
  return lodash_has_js__WEBPACK_IMPORTED_MODULE_0___default()(obj, "editor");
}
function booleanCellIsEditable(cell) {
  var _cell$readonly;

  return !((_cell$readonly = cell.readonly) !== null && _cell$readonly !== void 0 ? _cell$readonly : false);
}
let InnerGridCellKind;

(function (InnerGridCellKind) {
  InnerGridCellKind["NewRow"] = "new-row";
  InnerGridCellKind["Marker"] = "marker";
})(InnerGridCellKind || (InnerGridCellKind = {}));

function mergeRanges(input) {
  if (input.length === 0) {
    return [];
  }

  const ranges = [...input];
  const stack = [];
  ranges.sort(function (a, b) {
    return a[0] - b[0];
  });
  stack.push([...ranges[0]]);

  for (const range of ranges.slice(1)) {
    const top = stack[stack.length - 1];

    if (top[1] < range[0]) {
      stack.push([...range]);
    } else if (top[1] < range[1]) {
      top[1] = range[1];
    }
  }

  return stack;
}

let emptyCompactSelection;
_Symbol$iterator = Symbol.iterator;
class CompactSelection {
  constructor(items) {
    this.items = items;

    this.offset = amount => {
      if (amount === 0) return this;
      const newItems = this.items.map(x => [x[0] + amount, x[1] + amount]);
      return new CompactSelection(newItems);
    };

    this.add = selection => {
      const slice = typeof selection === "number" ? [selection, selection + 1] : selection;
      const newItems = mergeRanges([...this.items, slice]);
      return new CompactSelection(newItems);
    };

    this.remove = selection => {
      const items = [...this.items];
      const selMin = typeof selection === "number" ? selection : selection[0];
      const selMax = typeof selection === "number" ? selection + 1 : selection[1];

      for (const [i, slice] of items.entries()) {
        const [start, end] = slice;

        if (start <= selMax && selMin <= end) {
          const toAdd = [];

          if (start < selMin) {
            toAdd.push([start, selMin]);
          }

          if (selMax < end) {
            toAdd.push([selMax, end]);
          }

          items.splice(i, 1, ...toAdd);
        }
      }

      return new CompactSelection(items);
    };

    this.first = () => {
      if (this.items.length === 0) return undefined;
      return this.items[0][0];
    };

    this.last = () => {
      if (this.items.length === 0) return undefined;
      return this.items.slice(-1)[0][1] - 1;
    };

    this.hasIndex = index => {
      for (let i = 0; i < this.items.length; i++) {
        const [start, end] = this.items[i];
        if (index >= start && index < end) return true;
      }

      return false;
    };

    this.hasAll = index => {
      for (let x = index[0]; x < index[1]; x++) {
        if (!this.hasIndex(x)) return false;
      }

      return true;
    };

    this.some = predicate => {
      for (const i of this) {
        if (predicate(i)) return true;
      }

      return false;
    };

    this.equals = other => {
      if (other === this) return true;
      if (other.items.length !== this.items.length) return false;

      for (let i = 0; i < this.items.length; i++) {
        const left = other.items[i];
        const right = this.items[i];
        if (left[0] !== right[0] || left[1] !== right[1]) return false;
      }

      return true;
    };

    this.toArray = () => {
      const result = [];

      for (const [start, end] of this.items) {
        for (let x = start; x < end; x++) {
          result.push(x);
        }
      }

      return result;
    };
  }

  get length() {
    let len = 0;

    for (const [start, end] of this.items) {
      len += end - start;
    }

    return len;
  }

  *[_Symbol$iterator]() {
    for (const [start, end] of this.items) {
      for (let x = start; x < end; x++) {
        yield x;
      }
    }
  }

}

CompactSelection.empty = () => {
  var _emptyCompactSelectio;

  return (_emptyCompactSelectio = emptyCompactSelection) !== null && _emptyCompactSelectio !== void 0 ? _emptyCompactSelectio : emptyCompactSelection = new CompactSelection([]);
};

CompactSelection.fromSingleSelection = selection => {
  return CompactSelection.empty().add(selection);
};

/***/ }),

/***/ "./packages/core/src/data-grid/data-grid.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ data_grid)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./node_modules/lodash/throttle.js
var throttle = __webpack_require__("./node_modules/lodash/throttle.js");
var throttle_default = /*#__PURE__*/__webpack_require__.n(throttle);
;// CONCATENATED MODULE: ./packages/core/src/common/image-window-loader.ts

const rowShift = 1 << 16;
const imgPool = [];

function packColRowToNumber(col, row) {
  return row * rowShift + col;
}

function unpackCol(packed) {
  return packed % rowShift;
}

function unpackRow(packed, col) {
  return (packed - col) / rowShift;
}

function unpackNumberToColRow(packed) {
  const col = unpackCol(packed);
  const row = unpackRow(packed, col);
  return [col, row];
}

class ImageWindowLoaderImpl {
  constructor() {
    this.imageLoaded = () => undefined;

    this.loadedLocations = [];
    this.visibleWindow = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    this.freezeCols = 0;

    this.isInWindow = packed => {
      const col = unpackCol(packed);
      const row = unpackRow(packed, col);
      const w = this.visibleWindow;
      if (col < this.freezeCols && row >= w.y && row <= w.y + w.height) return true;
      return col >= w.x && col <= w.x + w.width && row >= w.y && row <= w.y + w.height;
    };

    this.cache = {};
    this.sendLoaded = throttle_default()(() => {
      this.imageLoaded(this.loadedLocations);
      this.loadedLocations = [];
    }, 20);

    this.clearOutOfWindow = () => {
      const keys = Object.keys(this.cache);

      for (const key of keys) {
        const obj = this.cache[key];
        let keep = false;

        for (let j = 0; j < obj.cells.length; j++) {
          const packed = obj.cells[j];

          if (this.isInWindow(packed)) {
            keep = true;
            break;
          }
        }

        if (keep) {
          obj.cells = obj.cells.filter(this.isInWindow);
        } else {
          obj.cancel();
          delete this.cache[key];
        }
      }
    };
  }

  setCallback(imageLoaded) {
    this.imageLoaded = imageLoaded;
  }

  setWindow(newWindow, freezeCols) {
    if (this.visibleWindow.x === newWindow.x && this.visibleWindow.y === newWindow.y && this.visibleWindow.width === newWindow.width && this.visibleWindow.height === newWindow.height && this.freezeCols === freezeCols) return;
    this.visibleWindow = newWindow;
    this.freezeCols = freezeCols;
    this.clearOutOfWindow();
  }

  loadImage(url, col, row, key) {
    var _imgPool$pop;

    let loaded = false;
    const img = (_imgPool$pop = imgPool.pop()) !== null && _imgPool$pop !== void 0 ? _imgPool$pop : new Image();
    let canceled = false;
    const result = {
      img: undefined,
      cells: [packColRowToNumber(col, row)],
      url,
      cancel: () => {
        if (canceled) return;
        canceled = true;

        if (imgPool.length < 12) {
          imgPool.unshift(img);
        } else if (!loaded) {
          img.src = "";
        }
      }
    };
    const loadPromise = new Promise(r => img.addEventListener("load", () => r(null)));
    requestAnimationFrame(async () => {
      try {
        img.src = url;
        await loadPromise;
        await img.decode();
        const toWrite = this.cache[key];

        if (toWrite !== undefined && !canceled) {
          toWrite.img = img;

          for (const packed of toWrite.cells) {
            this.loadedLocations.push(unpackNumberToColRow(packed));
          }

          loaded = true;
          this.sendLoaded();
        }
      } catch {
        result.cancel();
      }
    });
    this.cache[key] = result;
  }

  loadOrGetImage(url, col, row) {
    const key = url;
    const current = this.cache[key];

    if (current !== undefined) {
      const packed = packColRowToNumber(col, row);

      if (!current.cells.includes(packed)) {
        current.cells.push(packed);
      }

      return current.img;
    } else {
      this.loadImage(url, col, row, key);
    }

    return undefined;
  }

}

/* harmony default export */ const image_window_loader = (ImageWindowLoaderImpl);
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-lib.ts
var data_grid_lib = __webpack_require__("./packages/core/src/data-grid/data-grid-lib.ts");
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-types.ts
var data_grid_types = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/sprites.ts
const iconHead = `<svg width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">`;

const headerRowID = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/><path d="M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z" fill="${fg}"/></svg>`;
};

const headerCode = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="4" fill="${bg}"/><path d="m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z" fill="${fg}"/></svg>`;
};

const headerNumber = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z" fill="${fg}"/>
  </svg>`;
};

const headerString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z" fill="${fg}"/>
</svg>`;
};

const headerBoolean = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path
        d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
        fill="${bg}"
    />
    <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z"
        fill="${fg}"
    />
</svg>`;
};

const headerUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
<path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z" fill="${fg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z" fill="${fg}"/>
</svg>
  `;
};

const renameIcon = props => {
  const bg = props.bgColor;
  return `${iconHead}
    <path stroke="${bg}" stroke-width="2" d="M12 3v14"/>
    <path stroke="${bg}" stroke-width="2" stroke-linecap="round" d="M10 4h4m-4 12h4"/>
    <path d="M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z" fill="${bg}"/>
  </svg>
`;
};

const headerAudioUri = headerUri;

const headerVideoUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z" fill="${fg}"/>
</svg>`;
};

const headerEmoji = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z" fill="${fg}"/>
    <path d="M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z" fill="${fg}"/>
    <path d="M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
  </svg>`;
};

const headerImage = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path opacity=".5" fill-rule="evenodd" clip-rule="evenodd" d="M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z" fill="${fg}"/>
</svg>`;
};

const headerPhone = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path fill="${fg}" d="M3 3h14v14H3z"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z" fill="${bg}"/>
  </svg>`;
};

const headerMarkdown = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z" fill="${fg}"/>
  </svg>`;
};

const headerDate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z" fill="${fg}"/>
</svg>`;
};

const headerTime = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z" fill="${fg}"/>
    <path d="M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z" fill="${fg}"/>
  </svg>`;
};

const headerEmail = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z" fill="${fg}"/>
</svg>`;
};

const headerReference = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="8" width="10" height="8" rx="2" fill="${bg}"/>
    <rect x="8" y="4" width="10" height="8" rx="2" fill="${bg}"/>
    <path d="M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z" fill="${fg}"/>
  </svg>`;
};

const headerIfThenElse = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path fill="${fg}" d="M4 3h12v14H4z"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z" fill="${bg}"/>
</svg>`;
};

const headerSingleValue = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z" fill="${fg}"/>
  </svg>`;
};

const headerLookup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z" fill="${fg}"/>
  </svg>`;
};

const headerTextTemplate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z" fill="${fg}"/>
</svg>`;
};

const headerMath = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z" fill="${fg}"/>
  <path d="M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z" fill="${fg}"/>
</svg>`;
};

const headerRollup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z" fill="${fg}"/>
  </svg>`;
};

const headerJoinStrings = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z" fill="${fg}"/>
</svg>`;
};

const headerSplitString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z" fill="${fg}"/>
  </svg>`;
};

const headerGeoDistance = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z" fill="${fg}"/>
</svg>`;
};

const headerArray = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z" fill="${fg}"/>
</svg>`;
};

const rowOwnerOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>`;
};

const protectedColumnOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>
`;
};

const sprites = {
  headerRowID,
  headerNumber,
  headerCode,
  headerString,
  headerBoolean,
  headerAudioUri,
  headerVideoUri,
  headerEmoji,
  headerImage,
  headerUri,
  headerPhone,
  headerMarkdown,
  headerDate,
  headerTime,
  headerEmail,
  headerReference,
  headerIfThenElse,
  headerSingleValue,
  headerLookup,
  headerTextTemplate,
  headerMath,
  headerRollup,
  headerJoinStrings,
  headerSplitString,
  headerGeoDistance,
  headerArray,
  rowOwnerOverlay,
  protectedColumnOverlay,
  renameIcon
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/data-grid-sprites.ts


function getColors(variant, theme) {
  if (variant === "normal") {
    return [theme.bgIconHeader, theme.fgIconHeader];
  } else if (variant === "selected") {
    return ["white", theme.accentColor];
  } else {
    return [theme.accentColor, theme.bgHeader];
  }
}

class SpriteManager {
  constructor(headerIcons, onSettled) {
    this.onSettled = onSettled;
    this.spriteMap = new Map();
    this.headerIcons = void 0;
    this.inFlight = 0;
    this.headerIcons = { ...sprites,
      ...headerIcons
    };
  }

  drawSprite(sprite, variant, ctx, x, y, size, theme) {
    let alpha = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
    const [bgColor, fgColor] = getColors(variant, theme);
    const rSize = size * Math.ceil(window.devicePixelRatio);
    const key = `${bgColor}_${fgColor}_${rSize}_${sprite}`;
    let spriteCanvas = this.spriteMap.get(key);

    if (spriteCanvas === undefined) {
      const spriteCb = this.headerIcons[sprite];
      if (spriteCb === undefined) return;
      spriteCanvas = document.createElement("canvas");
      const spriteCtx = spriteCanvas.getContext("2d");
      if (spriteCtx === null) return;
      const imgSource = new Image();
      imgSource.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(spriteCb({
        fgColor,
        bgColor
      }))}`;
      this.spriteMap.set(key, spriteCanvas);
      const promise = imgSource.decode();
      if (promise === undefined) return;
      this.inFlight++;
      promise.then(() => {
        spriteCtx.drawImage(imgSource, 0, 0, rSize, rSize);
      }).finally(() => {
        this.inFlight--;

        if (this.inFlight === 0) {
          this.onSettled();
        }
      });
    } else {
      if (alpha < 1) {
        ctx.globalAlpha = alpha;
      }

      ctx.drawImage(spriteCanvas, 0, 0, rSize, rSize, x, y, size, size);

      if (alpha < 1) {
        ctx.globalAlpha = 1;
      }
    }
  }

}
// EXTERNAL MODULE: ./packages/core/src/common/utils.tsx
var utils = __webpack_require__("./packages/core/src/common/utils.tsx");
// EXTERNAL MODULE: ./node_modules/lodash/clamp.js
var clamp = __webpack_require__("./node_modules/lodash/clamp.js");
var clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);
// EXTERNAL MODULE: ./node_modules/lodash/range.js
var lodash_range = __webpack_require__("./node_modules/lodash/range.js");
var range_default = /*#__PURE__*/__webpack_require__.n(lodash_range);
// EXTERNAL MODULE: ./node_modules/lodash/groupBy.js
var groupBy = __webpack_require__("./node_modules/lodash/groupBy.js");
var groupBy_default = /*#__PURE__*/__webpack_require__.n(groupBy);
;// CONCATENATED MODULE: ./packages/core/src/data-grid/color-parser.ts
const cache = {};
let div = null;

function createDiv() {
  const d = document.createElement("div");
  d.style.opacity = "0";
  d.style.pointerEvents = "none";
  d.style.position = "fixed";
  document.body.append(d);
  return d;
}

function parseToRgba(color) {
  const normalizedColor = color.toLowerCase().trim();
  if (cache[normalizedColor] !== undefined) return cache[normalizedColor];
  div = div || createDiv();
  div.style.color = "#000";
  div.style.color = normalizedColor;
  const control = getComputedStyle(div).color;
  div.style.color = "#fff";
  div.style.color = normalizedColor;
  const computedColor = getComputedStyle(div).color;
  if (computedColor !== control) return [0, 0, 0, 1];
  let result = computedColor.replace(/[^\d.,]/g, "").split(",").map(Number.parseFloat);

  if (result.length < 4) {
    result.push(1);
  }

  result = result.map(x => {
    const isNaN = Number.isNaN(x);

    if (false) {}

    return isNaN ? 0 : x;
  });
  cache[normalizedColor] = result;
  return result;
}
function withAlpha(color, alpha) {
  const [r, g, b] = parseToRgba(color);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
function blend(color, background) {
  if (background === undefined) return color;
  const [r, g, b, a] = parseToRgba(color);
  if (a === 1) return color;
  const [br, bg, bb, ba] = parseToRgba(background);
  const ao = a + ba * (1 - a);
  const ro = (a * r + ba * br * (1 - a)) / ao;
  const go = (a * g + ba * bg * (1 - a)) / ao;
  const bo = (a * b + ba * bb * (1 - a)) / ao;
  return `rgba(${ro}, ${go}, ${bo}, ${ao})`;
}
function interpolateColors(leftColor, rightColor, val) {
  if (val <= 0) return leftColor;
  if (val >= 1) return rightColor;
  const left = [...parseToRgba(leftColor)];
  left[0] = left[0] * left[3];
  left[1] = left[1] * left[3];
  left[2] = left[2] * left[3];
  const right = [...parseToRgba(rightColor)];
  right[0] = right[0] * right[3];
  right[1] = right[1] * right[3];
  right[2] = right[2] * right[3];
  const hScaler = val;
  const nScaler = 1 - val;
  const a = left[3] * nScaler + right[3] * hScaler;
  const r = Math.floor((left[0] * nScaler + right[0] * hScaler) / a);
  const g = Math.floor((left[1] * nScaler + right[1] * hScaler) / a);
  const b = Math.floor((left[2] * nScaler + right[2] * hScaler) / a);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
// EXTERNAL MODULE: ./packages/core/src/common/support.ts
var support = __webpack_require__("./packages/core/src/common/support.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/data-grid-render.tsx





const loadingCell = {
  kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
  allowOverlay: false
};
function drawCell(ctx, row, cell, col, x, y, w, h, highlighted, theme, drawCustomCell, imageLoader, spriteManager, hoverAmount, hoverInfo, hyperWrapping, frameTime, lastPrep, enqueue, getCellRenderer) {
  let hoverX;
  let hoverY;

  if (hoverInfo !== undefined && hoverInfo[0][0] === col && hoverInfo[0][1] === row) {
    hoverX = hoverInfo[1][0];
    hoverY = hoverInfo[1][1];
  }

  let result = undefined;
  const args = {
    ctx,
    theme,
    col,
    row,
    cell,
    rect: {
      x,
      y,
      width: w,
      height: h
    },
    highlighted,
    hoverAmount,
    hoverX,
    hoverY,
    imageLoader,
    spriteManager,
    hyperWrapping,
    requestAnimationFrame: () => {
      forceAnim = true;
    }
  };
  let forceAnim = false;
  const needsAnim = (0,data_grid_lib/* drawWithLastUpdate */._n)(args, cell.lastUpdated, frameTime, lastPrep, () => {
    const drawn = (0,data_grid_types/* isInnerOnlyCell */.rs)(cell) ? false : (drawCustomCell === null || drawCustomCell === void 0 ? void 0 : drawCustomCell(args)) === true;

    if (!drawn) {
      const r = getCellRenderer(cell);

      if (r !== undefined) {
        var _lastPrep, _r$drawPrep;

        if (((_lastPrep = lastPrep) === null || _lastPrep === void 0 ? void 0 : _lastPrep.renderer) !== r) {
          var _lastPrep2, _lastPrep2$deprep;

          (_lastPrep2 = lastPrep) === null || _lastPrep2 === void 0 ? void 0 : (_lastPrep2$deprep = _lastPrep2.deprep) === null || _lastPrep2$deprep === void 0 ? void 0 : _lastPrep2$deprep.call(_lastPrep2, args);
          lastPrep = undefined;
        }

        const partialPrepResult = (_r$drawPrep = r.drawPrep) === null || _r$drawPrep === void 0 ? void 0 : _r$drawPrep.call(r, args, lastPrep);
        r.draw(args, cell);
        result = {
          deprep: partialPrepResult === null || partialPrepResult === void 0 ? void 0 : partialPrepResult.deprep,
          fillStyle: partialPrepResult === null || partialPrepResult === void 0 ? void 0 : partialPrepResult.fillStyle,
          font: partialPrepResult === null || partialPrepResult === void 0 ? void 0 : partialPrepResult.font,
          renderer: r
        };
      }
    }
  });
  if (needsAnim || forceAnim) enqueue === null || enqueue === void 0 ? void 0 : enqueue([col, row]);
  return result;
}

function blitLastFrame(ctx, canvas, last, cellXOffset, cellYOffset, translateX, translateY, lastRowSticky, width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, getRowHeight, doubleBuffer) {
  const drawRegions = [];
  let blittedYOnly = false;
  ctx.imageSmoothingEnabled = false;
  const minY = Math.min(last.cellYOffset, cellYOffset);
  const maxY = Math.max(last.cellYOffset, cellYOffset);
  let deltaY = 0;

  if (typeof getRowHeight === "number") {
    deltaY += (maxY - minY) * getRowHeight;
  } else {
    for (let i = minY; i < maxY; i++) {
      deltaY += getRowHeight(i);
    }
  }

  if (cellYOffset > last.cellYOffset) {
    deltaY = -deltaY;
  }

  deltaY += translateY - last.translateY;
  const minX = Math.min(last.cellXOffset, cellXOffset);
  const maxX = Math.max(last.cellXOffset, cellXOffset);
  let deltaX = 0;

  for (let i = minX; i < maxX; i++) {
    deltaX += mappedColumns[i].width;
  }

  if (cellXOffset > last.cellXOffset) {
    deltaX = -deltaX;
  }

  deltaX += translateX - last.translateX;
  let stickyWidth = (0,data_grid_lib/* getStickyWidth */.G6)(effectiveCols);
  if (stickyWidth > 0) stickyWidth++;

  if (deltaX !== 0 && deltaY !== 0) {
    return {
      regions: [],
      yOnly: false
    };
  }

  const stickyRowHeight = lastRowSticky ? typeof getRowHeight === "number" ? getRowHeight : getRowHeight(rows - 1) : 0;
  const blitWidth = width - stickyWidth - Math.abs(deltaX);
  const blitHeight = height - totalHeaderHeight - stickyRowHeight - Math.abs(deltaY) - 1;

  if (blitWidth > 150 && blitHeight > 150) {
    blittedYOnly = deltaX === 0;
    const args = {
      sx: 0,
      sy: 0,
      sw: width * dpr,
      sh: height * dpr,
      dx: 0,
      dy: 0,
      dw: width * dpr,
      dh: height * dpr
    };

    if (deltaY > 0) {
      args.sy = (totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (deltaY + totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: totalHeaderHeight,
        width: width,
        height: deltaY + 1
      });
    } else if (deltaY < 0) {
      args.sy = (-deltaY + totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: height + deltaY - stickyRowHeight,
        width: width,
        height: -deltaY + stickyRowHeight
      });
    }

    if (deltaX > 0) {
      args.sx = stickyWidth * dpr;
      args.sw = blitWidth * dpr;
      args.dx = (deltaX + stickyWidth) * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: stickyWidth - 1,
        y: 0,
        width: deltaX + 2,
        height: height
      });
    } else if (deltaX < 0) {
      args.sx = (stickyWidth - deltaX) * dpr;
      args.sw = blitWidth * dpr;
      args.dx = stickyWidth * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: width + deltaX,
        y: 0,
        width: -deltaX,
        height: height
      });
    }

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    if (stickyWidth > 0 && deltaX !== 0 && deltaY === 0 && doubleBuffer) {
      ctx.drawImage(canvas, 0, 0, stickyWidth * dpr, height * dpr, 0, 0, stickyWidth * dpr, height * dpr);
    }

    ctx.drawImage(canvas, args.sx, args.sy, args.sw, args.sh, args.dx, args.dy, args.dw, args.dh);
    ctx.scale(dpr, dpr);
  }

  ctx.imageSmoothingEnabled = true;
  return {
    regions: drawRegions,
    yOnly: blittedYOnly
  };
}

function blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedIndex) {
  const drawRegions = [];

  if (cellXOffset !== last.cellXOffset || cellYOffset !== last.cellYOffset || translateX !== last.translateX || translateY !== last.translateY) {
    return drawRegions;
  }

  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _drawY, clipX) => {
    if (c.sourceIndex === resizedIndex) {
      const x = Math.max(drawX, clipX) + 1;
      drawRegions.push({
        x,
        y: 0,
        width: width - x,
        height
      });
      return true;
    }
  });
  return drawRegions;
}

function drawGridLines(ctx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme) {
  var _theme$horizontalBord;

  let verticalOnly = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : false;

  if (spans !== undefined) {
    ctx.beginPath();
    ctx.save();
    ctx.rect(0, 0, width, height);

    for (const span of spans) {
      ctx.rect(span.x + 1, span.y + 1, span.width - 1, span.height - 1);
    }

    ctx.clip("evenodd");
  }

  const hColor = (_theme$horizontalBord = theme.horizontalBorderColor) !== null && _theme$horizontalBord !== void 0 ? _theme$horizontalBord : theme.borderColor;
  const vColor = theme.borderColor;
  let minX = 0;
  let maxX = width;
  let minY = 0;
  let maxY = height;

  if (drawRegions !== undefined && drawRegions.length > 0) {
    minX = Number.MAX_SAFE_INTEGER;
    minY = Number.MAX_SAFE_INTEGER;
    maxX = Number.MIN_SAFE_INTEGER;
    maxY = Number.MIN_SAFE_INTEGER;

    for (const r of drawRegions) {
      minX = Math.min(minX, r.x - 1);
      maxX = Math.max(maxX, r.x + r.width + 1);
      minY = Math.min(minY, r.y - 1);
      maxY = Math.max(maxY, r.y + r.height + 1);
    }
  }

  const toDraw = [];
  ctx.beginPath();
  let x = 0.5;

  for (let index = 0; index < effectiveCols.length; index++) {
    const c = effectiveCols[index];
    if (c.width === 0) continue;
    x += c.width;
    const tx = c.sticky ? x : x + translateX;

    if (tx >= minX && tx <= maxX && verticalBorder(index + 1)) {
      toDraw.push({
        x1: tx,
        y1: Math.max(groupHeaderHeight, minY),
        x2: tx,
        y2: Math.min(height, maxY),
        color: vColor
      });
    }
  }

  const stickyHeight = getRowHeight(rows - 1);
  const stickyRowY = height - stickyHeight + 0.5;
  const lastRowSticky = trailingRowType === "sticky";

  if (lastRowSticky) {
    toDraw.push({
      x1: minX,
      y1: stickyRowY,
      x2: maxX,
      y2: stickyRowY,
      color: hColor
    });
  }

  if (verticalOnly !== true) {
    let y = totalHeaderHeight + 0.5;
    let row = cellYOffset;
    const target = lastRowSticky ? height - stickyHeight : height;

    while (y + translateY <= target) {
      const ty = y + translateY;

      if (ty >= minY && ty <= maxY - 1 && (!lastRowSticky || row !== rows - 1 || Math.abs(ty - stickyRowY) > 1)) {
        var _ref, _rowTheme$horizontalB;

        const rowTheme = getRowThemeOverride === null || getRowThemeOverride === void 0 ? void 0 : getRowThemeOverride(row);
        toDraw.push({
          x1: minX,
          y1: ty,
          x2: maxX,
          y2: ty,
          color: (_ref = (_rowTheme$horizontalB = rowTheme === null || rowTheme === void 0 ? void 0 : rowTheme.horizontalBorderColor) !== null && _rowTheme$horizontalB !== void 0 ? _rowTheme$horizontalB : rowTheme === null || rowTheme === void 0 ? void 0 : rowTheme.borderColor) !== null && _ref !== void 0 ? _ref : hColor
        });
      }

      y += getRowHeight(row);
      row++;
    }
  }

  const groups = groupBy_default()(toDraw, line => line.color);

  for (const g of Object.keys(groups)) {
    ctx.strokeStyle = g;

    for (const line of groups[g]) {
      ctx.moveTo(line.x1, line.y1);
      ctx.lineTo(line.x2, line.y2);
    }

    ctx.stroke();
    ctx.beginPath();
  }

  if (spans !== undefined) {
    ctx.restore();
  }
}

function getActionBoundsForGroup(box, actions) {
  const result = [];
  let x = box.x + box.width - 26 * actions.length;
  const y = box.y + box.height / 2 - 13;
  const height = 26;
  const width = 26;

  for (let i = 0; i < actions.length; i++) {
    result.push({
      x,
      y,
      width,
      height
    });
    x += 26;
  }

  return result;
}
function pointInRect(rect, x, y) {
  return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
}

function drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, theme, spriteManager, _hoverValues, verticalBorder, getGroupDetails, damage) {
  var _hovered$;

  const xPad = 8;
  const [hCol, hRow] = (_hovered$ = hovered === null || hovered === void 0 ? void 0 : hovered[0]) !== null && _hovered$ !== void 0 ? _hovered$ : [];
  let finalX = 0;
  walkGroups(effectiveCols, width, translateX, groupHeaderHeight, (span, groupName, x, y, w, h) => {
    var _groupTheme$textGroup;

    if (damage !== undefined && !damage.some(d => d[1] === -2 && d[0] >= span[0] && d[0] <= span[1])) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip();
    const group = getGroupDetails(groupName);
    const groupTheme = (group === null || group === void 0 ? void 0 : group.overrideTheme) === undefined ? theme : { ...theme,
      ...group.overrideTheme
    };
    const isHovered = hRow === -2 && hCol !== undefined && hCol >= span[0] && hCol <= span[1];
    const fillColor = isHovered ? groupTheme.bgHeaderHovered : groupTheme.bgHeader;

    if (fillColor !== theme.bgHeader) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }

    ctx.fillStyle = (_groupTheme$textGroup = groupTheme.textGroupHeader) !== null && _groupTheme$textGroup !== void 0 ? _groupTheme$textGroup : groupTheme.textHeader;

    if (group !== undefined) {
      let drawX = x;

      if (group.icon !== undefined) {
        spriteManager.drawSprite(group.icon, "normal", ctx, drawX + xPad, (groupHeaderHeight - 20) / 2, 20, groupTheme);
        drawX += 26;
      }

      ctx.fillText(group.name, drawX + xPad, groupHeaderHeight / 2 + (0,data_grid_lib/* getMiddleCenterBias */.aX)(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));

      if (group.actions !== undefined && isHovered) {
        var _hovered$2;

        const actionBoxes = getActionBoundsForGroup({
          x,
          y,
          width: w,
          height: h
        }, group.actions);
        ctx.beginPath();
        const fadeStartX = actionBoxes[0].x - 10;
        const fadeWidth = x + w - fadeStartX;
        ctx.rect(fadeStartX, 0, fadeWidth, groupHeaderHeight);
        const grad = ctx.createLinearGradient(fadeStartX, 0, fadeStartX + fadeWidth, 0);
        const trans = withAlpha(fillColor, 0);
        grad.addColorStop(0, trans);
        grad.addColorStop(10 / fadeWidth, fillColor);
        grad.addColorStop(1, fillColor);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 0.6;
        const [mouseX, mouseY] = (_hovered$2 = hovered === null || hovered === void 0 ? void 0 : hovered[1]) !== null && _hovered$2 !== void 0 ? _hovered$2 : [-1, -1];

        for (let i = 0; i < group.actions.length; i++) {
          const action = group.actions[i];
          const box = actionBoxes[i];
          const actionHovered = pointInRect(box, mouseX + x, mouseY);

          if (actionHovered) {
            ctx.globalAlpha = 1;
          }

          spriteManager.drawSprite(action.icon, "normal", ctx, box.x + box.width / 2 - 10, box.y + box.height / 2 - 10, 20, groupTheme);

          if (actionHovered) {
            ctx.globalAlpha = 0.6;
          }
        }

        ctx.globalAlpha = 1;
      }
    }

    if (x !== 0 && verticalBorder(span[0])) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, groupHeaderHeight);
      ctx.strokeStyle = theme.borderColor;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.restore();
    finalX = x + w;
  });
  ctx.beginPath();
  ctx.moveTo(finalX + 0.5, 0);
  ctx.lineTo(finalX + 0.5, groupHeaderHeight);
  ctx.moveTo(0, groupHeaderHeight + 0.5);
  ctx.lineTo(width, groupHeaderHeight + 0.5);
  ctx.strokeStyle = theme.borderColor;
  ctx.lineWidth = 1;
  ctx.stroke();
}

const menuButtonSize = 30;
function getHeaderMenuBounds(x, y, width, height) {
  return {
    x: x + width - menuButtonSize,
    y: Math.max(y, y + height / 2 - menuButtonSize / 2),
    width: menuButtonSize,
    height: Math.min(menuButtonSize, height)
  };
}
function drawHeader(ctx, x, y, width, height, c, selected, theme, isHovered, hasSelectedCell, hoverAmount, spriteManager, drawHeaderCallback, touchMode) {
  const isCheckboxHeader = c.title.startsWith(data_grid_types/* headerCellCheckboxPrefix */.Gf);
  const menuBounds = getHeaderMenuBounds(x, y, width, height);

  if (drawHeaderCallback !== undefined) {
    let passCol = c;

    if (isCheckboxHeader) {
      passCol = { ...c,
        title: ""
      };
    }

    if (drawHeaderCallback({
      ctx,
      theme,
      rect: {
        x,
        y,
        width,
        height
      },
      column: passCol,
      columnIndex: passCol.sourceIndex,
      isSelected: selected,
      hoverAmount,
      isHovered,
      hasSelectedCell,
      spriteManager,
      menuBounds
    })) {
      return;
    }
  }

  if (isCheckboxHeader) {
    let checked = undefined;
    if (c.title === data_grid_types/* headerCellCheckedMarker */.qT) checked = true;
    if (c.title === data_grid_types/* headerCellUnheckedMarker */.YK) checked = false;

    if (checked !== true) {
      ctx.globalAlpha = hoverAmount;
    }

    (0,data_grid_lib/* drawCheckbox */._u)(ctx, theme, checked, x, y, width, height, false, undefined, undefined, 18);

    if (checked !== true) {
      ctx.globalAlpha = 1;
    }

    return;
  }

  const xPad = theme.cellHorizontalPadding;
  const fillStyle = selected ? theme.textHeaderSelected : theme.textHeader;
  const shouldDrawMenu = c.hasMenu === true && (isHovered || touchMode && selected);
  let drawX = x + xPad;

  if (c.icon !== undefined) {
    let variant = selected ? "selected" : "normal";

    if (c.style === "highlight") {
      variant = selected ? "selected" : "special";
    }

    const headerSize = theme.headerIconSize;
    spriteManager.drawSprite(c.icon, variant, ctx, drawX, y + (height - headerSize) / 2, headerSize, theme);

    if (c.overlayIcon !== undefined) {
      spriteManager.drawSprite(c.overlayIcon, selected ? "selected" : "special", ctx, drawX + 9, y + ((height - 18) / 2 + 6), 18, theme);
    }

    drawX += Math.ceil(headerSize * 1.3);
  }

  if (shouldDrawMenu && c.hasMenu === true && width > 35) {
    const fadeWidth = 35;
    const fadeStart = width - fadeWidth;
    const fadeEnd = width - fadeWidth * 0.7;
    const fadeStartPercent = fadeStart / width;
    const fadeEndPercent = fadeEnd / width;
    const grad = ctx.createLinearGradient(x, 0, x + width, 0);
    const trans = withAlpha(fillStyle, 0);
    grad.addColorStop(0, fillStyle);
    grad.addColorStop(fadeStartPercent, fillStyle);
    grad.addColorStop(fadeEndPercent, trans);
    grad.addColorStop(1, trans);
    ctx.fillStyle = grad;
  } else {
    ctx.fillStyle = fillStyle;
  }

  ctx.fillText(c.title, drawX, y + height / 2 + (0,data_grid_lib/* getMiddleCenterBias */.aX)(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));

  if (shouldDrawMenu && c.hasMenu === true) {
    ctx.beginPath();
    const triangleX = menuBounds.x + menuBounds.width / 2 - 5.5;
    const triangleY = menuBounds.y + menuBounds.height / 2 - 3;
    (0,data_grid_lib/* roundedPoly */.zu)(ctx, [{
      x: triangleX,
      y: triangleY
    }, {
      x: triangleX + 11,
      y: triangleY
    }, {
      x: triangleX + 5.5,
      y: triangleY + 6
    }], 1);
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }
}

function drawGridHeaders(ctx, effectiveCols, enableGroups, hovered, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode) {
  var _hovered$3;

  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (totalHeaderHeight <= 0) return;
  ctx.fillStyle = outerTheme.bgHeader;
  ctx.fillRect(0, 0, width, totalHeaderHeight);
  const [hCol, hRow] = (_hovered$3 = hovered === null || hovered === void 0 ? void 0 : hovered[0]) !== null && _hovered$3 !== void 0 ? _hovered$3 : [];
  const font = `${outerTheme.headerFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  walkColumns(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x, _y, clipX) => {
    var _c$group, _hoverValues$find$hov, _hoverValues$find;

    if (damage !== undefined && !damage.some(d => d[1] === -1 && d[0] === c.sourceIndex)) return;
    const diff = Math.max(0, clipX - x);
    ctx.save();
    ctx.beginPath();
    ctx.rect(x + diff, groupHeaderHeight, c.width - diff, headerHeight);
    ctx.clip();
    const groupTheme = getGroupDetails((_c$group = c.group) !== null && _c$group !== void 0 ? _c$group : "").overrideTheme;
    const theme = c.themeOverride === undefined && groupTheme === undefined ? outerTheme : { ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };

    if (theme.bgHeader !== outerTheme.bgHeader) {
      ctx.fillStyle = theme.bgHeader;
      ctx.fill();
    }

    const f = `${theme.headerFontStyle} ${theme.fontFamily}`;

    if (font !== f) {
      ctx.font = f;
    }

    const selected = selection.columns.hasIndex(c.sourceIndex);
    const noHover = dragAndDropState !== undefined || isResizing;
    const hoveredBoolean = !noHover && hRow === -1 && hCol === c.sourceIndex;
    const hover = noHover ? 0 : (_hoverValues$find$hov = (_hoverValues$find = hoverValues.find(s => s.item[0] === c.sourceIndex && s.item[1] === -1)) === null || _hoverValues$find === void 0 ? void 0 : _hoverValues$find.hoverAmount) !== null && _hoverValues$find$hov !== void 0 ? _hoverValues$find$hov : 0;
    const hasSelectedCell = (selection === null || selection === void 0 ? void 0 : selection.current) !== undefined && selection.current.cell[0] === c.sourceIndex;
    const bgFillStyle = selected ? theme.accentColor : hasSelectedCell ? theme.bgHeaderHasFocus : theme.bgHeader;
    const y = enableGroups ? groupHeaderHeight : 0;
    const xOffset = c.sourceIndex === 0 ? 0 : 1;

    if (selected) {
      ctx.fillStyle = bgFillStyle;
      ctx.fillRect(x + xOffset, y, c.width - xOffset, headerHeight);
    } else if (hasSelectedCell || hover > 0) {
      ctx.beginPath();
      ctx.rect(x + xOffset, y, c.width - xOffset, headerHeight);

      if (hasSelectedCell) {
        ctx.fillStyle = theme.bgHeaderHasFocus;
        ctx.fill();
      }

      if (hover > 0) {
        ctx.globalAlpha = hover;
        ctx.fillStyle = theme.bgHeaderHovered;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    drawHeader(ctx, x, y, c.width, headerHeight, c, selected, theme, hoveredBoolean, hasSelectedCell, hover, spriteManager, drawHeaderCallback, touchMode);
    ctx.restore();
  });

  if (enableGroups) {
    drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage);
  }
}

function intersectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
  return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;
}

function clipDamage(ctx, effectiveColumns, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, includeCells) {
  if (damage === undefined || damage.length === 0) return;
  const stickyRowHeight = trailingRowType === "sticky" ? getRowHeight(rows - 1) : 0;
  ctx.beginPath();
  walkGroups(effectiveColumns, width, translateX, groupHeaderHeight, (span, _group, x, y, w, h) => {
    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];

      if (d[1] === -2 && d[0] >= span[0] && d[0] <= span[1]) {
        ctx.rect(x, y, w, h);
        break;
      }
    }
  });
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    const diff = Math.max(0, clipX - drawX);
    const finalX = drawX + diff + 1;
    const finalWidth = c.width - diff - 1;

    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];

      if (d[0] === c.sourceIndex && (d[1] === -1 || d[1] === undefined)) {
        ctx.rect(finalX, groupHeaderHeight, finalWidth, totalHeaderHeight - groupHeaderHeight);
        break;
      }
    }

    if (!includeCells) return;
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      let isDamaged = false;

      for (let i = 0; i < damage.length; i++) {
        const d = damage[i];

        if (d[0] === c.sourceIndex && d[1] === row) {
          isDamaged = true;
          break;
        }
      }

      if (isDamaged) {
        const top = drawY + 1;
        const bottom = isSticky ? top + rh - 1 : Math.min(top + rh - 1, height - stickyRowHeight);
        const h = bottom - top;

        if (h > 0) {
          ctx.rect(finalX, top, finalWidth, h);
        }
      }
    });
  });
  ctx.clip();
}

function getSpanBounds(span, cellX, cellY, cellW, cellH, column, allColumns) {
  var _allColumns$find$sour, _allColumns$find;

  const [startCol, endCol] = span;
  let frozenRect;
  let contentRect;
  const firstNonSticky = (_allColumns$find$sour = (_allColumns$find = allColumns.find(x => !x.sticky)) === null || _allColumns$find === void 0 ? void 0 : _allColumns$find.sourceIndex) !== null && _allColumns$find$sour !== void 0 ? _allColumns$find$sour : 0;

  if (endCol > firstNonSticky) {
    const renderFromCol = Math.max(startCol, firstNonSticky);
    let tempX = cellX;
    let tempW = cellW;

    for (let x = column.sourceIndex - 1; x >= renderFromCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }

    for (let x = column.sourceIndex + 1; x <= endCol; x++) {
      tempW += allColumns[x].width;
    }

    contentRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }

  if (firstNonSticky > startCol) {
    const renderToCol = Math.min(endCol, firstNonSticky - 1);
    let tempX = cellX;
    let tempW = cellW;

    for (let x = column.sourceIndex - 1; x >= startCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }

    for (let x = column.sourceIndex + 1; x <= renderToCol; x++) {
      tempW += allColumns[x].width;
    }

    frozenRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }

  return [frozenRect, contentRect];
}

function drawCells(ctx, effectiveColumns, allColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, outerTheme, enqueue, getCellRenderer) {
  var _damage$length;

  let toDraw = (_damage$length = damage === null || damage === void 0 ? void 0 : damage.length) !== null && _damage$length !== void 0 ? _damage$length : Number.MAX_SAFE_INTEGER;
  const frameTime = performance.now();
  let font = `${outerTheme.baseFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  let result;
  const handledSpans = new Set();
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawStartY, clipX, startRow) => {
    var _c$group2;

    const diff = Math.max(0, clipX - drawX);
    const colDrawX = drawX + diff;
    const colDrawY = totalHeaderHeight + 1;
    const colWidth = c.width - diff;
    const colHeight = height - totalHeaderHeight - 1;

    if (drawRegions.length > 0) {
      let found = false;

      for (let i = 0; i < drawRegions.length; i++) {
        const dr = drawRegions[i];

        if (intersectRect(colDrawX, colDrawY, colWidth, colHeight, dr.x, dr.y, dr.width, dr.height)) {
          found = true;
          break;
        }
      }

      if (!found) return;
    }

    const reclip = () => {
      ctx.save();
      ctx.beginPath();
      ctx.rect(colDrawX, colDrawY, colWidth, colHeight);
      ctx.clip();
    };

    const colSelected = selection.columns.hasIndex(c.sourceIndex);
    const groupTheme = getGroupDetails((_c$group2 = c.group) !== null && _c$group2 !== void 0 ? _c$group2 : "").overrideTheme;
    const colTheme = c.themeOverride === undefined && groupTheme === undefined ? outerTheme : { ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };
    const colFont = `${colTheme.baseFontStyle} ${colTheme.fontFamily}`;

    if (colFont !== font) {
      font = colFont;
      ctx.font = colFont;
    }

    reclip();
    let prepResult = undefined;
    walkRowsInCol(startRow, colDrawStartY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky, isTrailingRow) => {
      var _c$trailingRowOptions, _c$trailingRowOptions2;

      if (row < 0) return;

      if (damage !== undefined) {
        let found = false;

        for (let i = 0; i < damage.length; i++) {
          const d = damage[i];

          if (d[0] === c.sourceIndex && d[1] === row) {
            found = true;
            break;
          }
        }

        if (!found) return;
      }

      if (drawRegions.length > 0) {
        let found = false;

        for (let i = 0; i < drawRegions.length; i++) {
          const dr = drawRegions[i];

          if (intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height)) {
            found = true;
            break;
          }
        }

        if (!found) return;
      }

      const rowSelected = selection.rows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      const cell = row < rows ? getCellContent([c.sourceIndex, row]) : loadingCell;
      let cellX = drawX;
      let cellWidth = c.width;
      let drawingSpan = false;
      let skipContents = false;

      if (cell.span !== undefined) {
        const [startCol, endCol] = cell.span;
        const spanKey = `${row},${startCol},${endCol},${c.sticky}`;

        if (!handledSpans.has(spanKey)) {
          const areas = getSpanBounds(cell.span, drawX, drawY, c.width, rh, c, allColumns);
          const area = c.sticky ? areas[0] : areas[1];

          if (!c.sticky && areas[0] !== undefined) {
            skipContents = true;
          }

          if (area !== undefined) {
            cellX = area.x;
            cellWidth = area.width;
            handledSpans.add(spanKey);
            ctx.restore();
            prepResult = undefined;
            ctx.save();
            ctx.beginPath();
            const d = Math.max(0, clipX - area.x);
            ctx.rect(area.x + d, drawY, area.width - d, rh);

            if (result === undefined) {
              result = [];
            }

            result.push({
              x: area.x + d,
              y: drawY,
              width: area.width - d,
              height: rh
            });
            ctx.clip();
            drawingSpan = true;
          }
        } else {
          toDraw--;
          return;
        }
      }

      const rowTheme = getRowThemeOverride === null || getRowThemeOverride === void 0 ? void 0 : getRowThemeOverride(row);
      const trailingTheme = isTrailingRow && ((_c$trailingRowOptions = c.trailingRowOptions) === null || _c$trailingRowOptions === void 0 ? void 0 : _c$trailingRowOptions.themeOverride) !== undefined ? (_c$trailingRowOptions2 = c.trailingRowOptions) === null || _c$trailingRowOptions2 === void 0 ? void 0 : _c$trailingRowOptions2.themeOverride : undefined;
      const theme = cell.themeOverride === undefined && rowTheme === undefined && trailingTheme === undefined ? colTheme : { ...colTheme,
        ...rowTheme,
        ...trailingTheme,
        ...cell.themeOverride
      };
      ctx.beginPath();
      const cellIndex = [c.sourceIndex, row];
      const isSelected = (0,data_grid_lib/* cellIsSelected */.Sb)(cellIndex, cell, selection);
      let accentCount = (0,data_grid_lib/* cellIsInRange */.H1)(cellIndex, cell, selection);
      const spanIsHighlighted = cell.span !== undefined && selection.columns.some(index => cell.span !== undefined && index >= cell.span[0] && index <= cell.span[1]);

      if (isSelected && !isFocused && drawFocus) {
        accentCount = 0;
      } else if (isSelected) {
        accentCount = Math.max(accentCount, 1);
      }

      if (spanIsHighlighted) {
        accentCount++;
      }

      if (!isSelected) {
        if (rowSelected) accentCount++;
        if (colSelected && !isSticky) accentCount++;
      }

      const bgCell = cell.kind === data_grid_types/* GridCellKind.Protected */.p6.Protected ? theme.bgCellMedium : theme.bgCell;
      let fill;

      if (isSticky || bgCell !== outerTheme.bgCell) {
        fill = blend(bgCell, fill);
      }

      if (accentCount > 0 || rowDisabled) {
        if (rowDisabled) {
          fill = blend(theme.bgHeader, fill);
        }

        for (let i = 0; i < accentCount; i++) {
          fill = blend(theme.accentLight, fill);
        }
      } else {
        if ((prelightCells === null || prelightCells === void 0 ? void 0 : prelightCells.some(pre => pre[0] === c.sourceIndex && pre[1] === row)) === true) {
          fill = blend(theme.bgSearchResult, fill);
        }
      }

      if (highlightRegions !== undefined) {
        for (const region of highlightRegions) {
          const r = region.range;

          if (r.x <= c.sourceIndex && c.sourceIndex < r.x + r.width && r.y <= row && row < r.y + r.height) {
            fill = blend(region.color, fill);
          }
        }
      }

      if (fill !== undefined) {
        ctx.fillStyle = fill;

        if (prepResult !== undefined) {
          prepResult.fillStyle = fill;
        }

        ctx.fillRect(cellX, drawY, cellWidth, rh);
      }

      if (cell.style === "faded") {
        ctx.globalAlpha = 0.6;
      }

      const hoverValue = hoverValues.find(hv => hv.item[0] === c.sourceIndex && hv.item[1] === row);

      if (cellWidth > 10 && !skipContents) {
        var _hoverValue$hoverAmou;

        const cellFont = `${theme.baseFontStyle} ${theme.fontFamily}`;

        if (cellFont !== font) {
          ctx.font = cellFont;
          font = cellFont;
        }

        prepResult = drawCell(ctx, row, cell, c.sourceIndex, cellX, drawY, cellWidth, rh, accentCount > 0, theme, drawCustomCell, imageLoader, spriteManager, (_hoverValue$hoverAmou = hoverValue === null || hoverValue === void 0 ? void 0 : hoverValue.hoverAmount) !== null && _hoverValue$hoverAmou !== void 0 ? _hoverValue$hoverAmou : 0, hoverInfo, hyperWrapping, frameTime, prepResult, enqueue, getCellRenderer);
      }

      if (cell.style === "faded") {
        ctx.globalAlpha = 1;
      }

      toDraw--;

      if (drawingSpan) {
        var _prepResult, _prepResult$deprep;

        ctx.restore();
        (_prepResult = prepResult) === null || _prepResult === void 0 ? void 0 : (_prepResult$deprep = _prepResult.deprep) === null || _prepResult$deprep === void 0 ? void 0 : _prepResult$deprep.call(_prepResult, {
          ctx
        });
        prepResult = undefined;
        reclip();
        font = colFont;
        ctx.font = colFont;
      }

      return toDraw <= 0;
    });
    ctx.restore();
    return toDraw <= 0;
  });
  return result;
}

function drawBlanks(ctx, effectiveColumns, allColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowTheme, selectedRows, disabledRows, trailingRowType, drawRegions, damage, theme) {
  if (damage !== undefined || effectiveColumns[effectiveColumns.length - 1] !== allColumns[effectiveColumns.length - 1]) return;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    if (c !== effectiveColumns[effectiveColumns.length - 1]) return;
    drawX += c.width;
    const x = Math.max(drawX, clipX);
    if (x > width) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, totalHeaderHeight + 1, 10000, height - totalHeaderHeight - 1);
    ctx.clip();
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      if (!isSticky && drawRegions.length > 0 && !drawRegions.some(dr => intersectRect(drawX, drawY, 10000, rh, dr.x, dr.y, dr.width, dr.height))) {
        return;
      }

      const rowSelected = selectedRows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      ctx.beginPath();
      const rowTheme = getRowTheme === null || getRowTheme === void 0 ? void 0 : getRowTheme(row);
      const blankTheme = rowTheme === undefined ? theme : { ...theme,
        ...rowTheme
      };

      if (blankTheme.bgCell !== theme.bgCell) {
        ctx.fillStyle = blankTheme.bgCell;
        ctx.fillRect(drawX, drawY, 10000, rh);
      }

      if (rowDisabled) {
        ctx.fillStyle = blankTheme.bgHeader;
        ctx.fillRect(drawX, drawY, 10000, rh);
      }

      if (rowSelected) {
        ctx.fillStyle = blankTheme.accentLight;
        ctx.fillRect(drawX, drawY, 10000, rh);
      }
    });
    ctx.restore();
  });
}

function overdrawStickyBoundaries(ctx, effectiveCols, width, height, lastRowSticky, rows, verticalBorder, getRowHeight, theme) {
  var _theme$horizontalBord2;

  let drawFreezeBorder = false;

  for (const c of effectiveCols) {
    if (c.sticky) continue;
    drawFreezeBorder = verticalBorder(c.sourceIndex);
    break;
  }

  const hColor = (_theme$horizontalBord2 = theme.horizontalBorderColor) !== null && _theme$horizontalBord2 !== void 0 ? _theme$horizontalBord2 : theme.borderColor;
  const vColor = theme.borderColor;
  const drawX = drawFreezeBorder ? (0,data_grid_lib/* getStickyWidth */.G6)(effectiveCols) : 0;

  if (drawX !== 0) {
    ctx.beginPath();
    ctx.moveTo(drawX + 0.5, 0);
    ctx.lineTo(drawX + 0.5, height);
    ctx.strokeStyle = blend(vColor, theme.bgCell);
    ctx.stroke();
  }

  if (lastRowSticky) {
    const h = getRowHeight(rows - 1);
    ctx.beginPath();
    ctx.moveTo(0, height - h + 0.5);
    ctx.lineTo(width, height - h + 0.5);
    ctx.strokeStyle = blend(hColor, theme.bgCell);
    ctx.stroke();
  }
}

function drawHighlightRings(ctx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, lastRowSticky, rows, allHighlightRegions) {
  const highlightRegions = allHighlightRegions === null || allHighlightRegions === void 0 ? void 0 : allHighlightRegions.filter(x => x.style !== "no-outline");
  if (highlightRegions === undefined || highlightRegions.length === 0) return undefined;
  const drawRects = highlightRegions.map(h => {
    const r = h.range;
    const topLeftBounds = (0,data_grid_lib/* computeBounds */.Ve)(r.x, r.y, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);

    if (r.width === 1 && r.height === 1) {
      var _h$style2;

      if (r.x < freezeColumns) {
        var _h$style;

        return [{
          color: h.color,
          style: (_h$style = h.style) !== null && _h$style !== void 0 ? _h$style : "dashed",
          rect: topLeftBounds
        }, undefined];
      }

      return [undefined, {
        color: h.color,
        style: (_h$style2 = h.style) !== null && _h$style2 !== void 0 ? _h$style2 : "dashed",
        rect: topLeftBounds
      }];
    }

    const bottomRightBounds = (0,data_grid_lib/* computeBounds */.Ve)(r.x + r.width - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);

    if (r.x < freezeColumns && r.x + r.width >= freezeColumns) {
      var _h$style3, _h$style4;

      const freezeSectionRightBounds = (0,data_grid_lib/* computeBounds */.Ve)(freezeColumns - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      const unfreezeSectionleftBounds = (0,data_grid_lib/* computeBounds */.Ve)(freezeColumns, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      return [{
        color: h.color,
        style: (_h$style3 = h.style) !== null && _h$style3 !== void 0 ? _h$style3 : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: freezeSectionRightBounds.x + freezeSectionRightBounds.width - topLeftBounds.x,
          height: freezeSectionRightBounds.y + freezeSectionRightBounds.height - topLeftBounds.y
        }
      }, {
        color: h.color,
        style: (_h$style4 = h.style) !== null && _h$style4 !== void 0 ? _h$style4 : "dashed",
        rect: {
          x: unfreezeSectionleftBounds.x,
          y: unfreezeSectionleftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - unfreezeSectionleftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - unfreezeSectionleftBounds.y
        }
      }];
    } else {
      var _h$style5;

      return [undefined, {
        color: h.color,
        style: (_h$style5 = h.style) !== null && _h$style5 !== void 0 ? _h$style5 : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - topLeftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - topLeftBounds.y
        }
      }];
    }
  });
  const stickyWidth = (0,data_grid_lib/* getStickyWidth */.G6)(mappedColumns);

  const drawCb = () => {
    ctx.beginPath();
    ctx.save();
    let dashed = false;

    const setDashed = dash => {
      if (dashed === dash) return;
      ctx.setLineDash(dash ? [5, 3] : []);
      dashed = dash;
    };

    ctx.lineWidth = 1;

    for (const dr of drawRects) {
      const [s] = dr;

      if (s !== undefined && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");
        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }

    let clipped = false;

    for (const dr of drawRects) {
      const [, s] = dr;

      if (s !== undefined && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");

        if (!clipped && s.rect.x < stickyWidth) {
          ctx.rect(stickyWidth, 0, width, height);
          ctx.clip();
          clipped = true;
        }

        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }

    ctx.restore();
  };

  drawCb();
  return drawCb;
}

function drawFocusRing(ctx, width, height, cellYOffset, translateX, translateY, effectiveCols, allColumns, theme, totalHeaderHeight, selectedCell, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) {
  var _cell$span;

  if (selectedCell.current === undefined || !effectiveCols.some(c => {
    var _selectedCell$current;

    return c.sourceIndex === ((_selectedCell$current = selectedCell.current) === null || _selectedCell$current === void 0 ? void 0 : _selectedCell$current.cell[0]);
  })) return undefined;
  const [targetCol, targetRow] = selectedCell.current.cell;
  const cell = getCellContent(selectedCell.current.cell);
  const targetColSpan = (_cell$span = cell.span) !== null && _cell$span !== void 0 ? _cell$span : [targetCol, targetCol];
  const isStickyRow = trailingRowType === "sticky" && targetRow === rows - 1;
  const stickRowHeight = trailingRowType === "sticky" && !isStickyRow ? getRowHeight(rows - 1) - 1 : 0;
  let drawCb = undefined;
  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (col, drawX, colDrawY, clipX, startRow) => {
    if (col.sticky && targetCol > col.sourceIndex) return;

    if (col.sourceIndex < targetColSpan[0] || col.sourceIndex > targetColSpan[1]) {
      return;
    }

    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh) => {
      if (row !== targetRow) return;
      let cellX = drawX;
      let cellWidth = col.width;

      if (cell.span !== undefined) {
        const areas = getSpanBounds(cell.span, drawX, drawY, col.width, rh, col, allColumns);
        const area = col.sticky ? areas[0] : areas[1];

        if (area !== undefined) {
          cellX = area.x;
          cellWidth = area.width;
        }
      }

      drawCb = () => {
        var _col$themeOverride$ac, _col$themeOverride;

        if (clipX > cellX && !col.sticky) {
          ctx.beginPath();
          ctx.rect(clipX, 0, width - clipX, height);
          ctx.clip();
        }

        ctx.beginPath();
        ctx.rect(cellX + 0.5, drawY + 0.5, cellWidth, rh);
        ctx.strokeStyle = (_col$themeOverride$ac = (_col$themeOverride = col.themeOverride) === null || _col$themeOverride === void 0 ? void 0 : _col$themeOverride.accentColor) !== null && _col$themeOverride$ac !== void 0 ? _col$themeOverride$ac : theme.accentColor;
        ctx.lineWidth = 1;
        ctx.stroke();

        if (fillHandle) {
          var _col$themeOverride$ac2, _col$themeOverride2;

          ctx.beginPath();
          ctx.rect(cellX + cellWidth - 4, drawY + rh - 4, 4, 4);
          ctx.fillStyle = (_col$themeOverride$ac2 = (_col$themeOverride2 = col.themeOverride) === null || _col$themeOverride2 === void 0 ? void 0 : _col$themeOverride2.accentColor) !== null && _col$themeOverride$ac2 !== void 0 ? _col$themeOverride$ac2 : theme.accentColor;
          ctx.fill();
        }
      };

      return true;
    });
    return true;
  });
  if (drawCb === undefined) return undefined;

  const result = () => {
    var _drawCb;

    ctx.save();
    ctx.beginPath();
    ctx.rect(0, totalHeaderHeight, width, height - totalHeaderHeight - stickRowHeight);
    ctx.clip();
    (_drawCb = drawCb) === null || _drawCb === void 0 ? void 0 : _drawCb();
    ctx.restore();
  };

  result();
  return result;
}

function getLastRow(effectiveColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType) {
  let result = 0;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (_c, __drawX, colDrawY, _clipX, startRow) => {
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (_drawY, row, _rh, isSticky) => {
      if (!isSticky) {
        result = Math.max(row, result);
      }
    });
    return true;
  });
  return result;
}

function computeCanBlit(current, last) {
  if (last === undefined) return false;

  if (current.width !== last.width || current.height !== last.height || current.theme !== last.theme || current.headerHeight !== last.headerHeight || current.rowHeight !== last.rowHeight || current.rows !== last.rows || current.getRowThemeOverride !== last.getRowThemeOverride || current.isFocused !== last.isFocused || current.isResizing !== last.isResizing || current.verticalBorder !== last.verticalBorder || current.getCellContent !== last.getCellContent || current.highlightRegions !== last.highlightRegions || current.selection !== last.selection || current.dragAndDropState !== last.dragAndDropState || current.prelightCells !== last.prelightCells || current.touchMode !== last.touchMode || current.scrolling !== last.scrolling) {
    return false;
  }

  if (current.mappedColumns !== last.mappedColumns) {
    if (current.mappedColumns.length > 100 || current.mappedColumns.length !== last.mappedColumns.length) {
      return false;
    }

    let resized;

    for (let i = 0; i < current.mappedColumns.length; i++) {
      const curCol = current.mappedColumns[i];
      const lastCol = last.mappedColumns[i];
      if ((0,support/* deepEqual */.vZ)(curCol, lastCol)) continue;
      if (resized !== undefined) return false;
      if (curCol.width === lastCol.width) return false;
      const {
        width,
        ...curRest
      } = curCol;
      const {
        width: lastWidth,
        ...lastRest
      } = lastCol;
      if (!(0,support/* deepEqual */.vZ)(curRest, lastRest)) return false;
      resized = i;
    }

    if (resized === undefined) {
      return true;
    }

    return resized;
  }

  return true;
}

function drawGrid(arg, lastArg) {
  var _window$devicePixelRa, _selection$current;

  const {
    canvas,
    headerCanvas,
    width,
    height,
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mappedColumns,
    enableGroups,
    freezeColumns,
    dragAndDropState,
    theme,
    drawFocus,
    headerHeight,
    groupHeaderHeight,
    disabledRows,
    rowHeight,
    verticalBorder,
    isResizing,
    selection,
    fillHandle,
    lastRowSticky: trailingRowType,
    rows,
    getCellContent,
    getGroupDetails,
    getRowThemeOverride,
    isFocused,
    drawCustomCell,
    drawHeaderCallback,
    prelightCells,
    highlightRegions,
    imageLoader,
    lastBlitData,
    hoverValues,
    hyperWrapping,
    hoverInfo,
    spriteManager,
    scrolling,
    touchMode,
    enqueue,
    getCellRenderer,
    renderStrategy,
    bufferA,
    bufferB
  } = arg;
  let {
    damage
  } = arg;
  if (width === 0 || height === 0) return;
  const doubleBuffer = renderStrategy === "double-buffer";
  const dpr = scrolling ? 1 : Math.ceil((_window$devicePixelRa = window.devicePixelRatio) !== null && _window$devicePixelRa !== void 0 ? _window$devicePixelRa : 1);
  const canBlit = renderStrategy !== "direct" && computeCanBlit(arg, lastArg);

  if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
  }

  const overlayCanvas = headerCanvas;
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const overlayHeight = totalHeaderHeight + 1;

  if (overlayCanvas.width !== width * dpr || overlayCanvas.height !== overlayHeight * dpr) {
    overlayCanvas.width = width * dpr;
    overlayCanvas.height = overlayHeight * dpr;
    overlayCanvas.style.width = width + "px";
    overlayCanvas.style.height = overlayHeight + "px";
  }

  if (doubleBuffer && (bufferA.width !== width * dpr || bufferA.height !== height * dpr)) {
    bufferA.width = width * dpr;
    bufferA.height = height * dpr;
  }

  if (doubleBuffer && (bufferB.width !== width * dpr || bufferB.height !== height * dpr)) {
    bufferB.width = width * dpr;
    bufferB.height = height * dpr;
  }

  const last = lastBlitData.current;
  if (canBlit === true && cellXOffset === (last === null || last === void 0 ? void 0 : last.cellXOffset) && cellYOffset === (last === null || last === void 0 ? void 0 : last.cellYOffset) && translateX === (last === null || last === void 0 ? void 0 : last.translateX) && translateY === (last === null || last === void 0 ? void 0 : last.translateY)) return;
  let mainCtx = null;

  if (doubleBuffer) {
    mainCtx = canvas.getContext("2d", {
      alpha: false
    });
  }

  const overlayCtx = overlayCanvas.getContext("2d", {
    alpha: false
  });
  let targetBuffer;

  if (!doubleBuffer) {
    targetBuffer = canvas;
  } else if (damage !== undefined) {
    targetBuffer = (last === null || last === void 0 ? void 0 : last.lastBuffer) === "b" ? bufferB : bufferA;
  } else {
    targetBuffer = (last === null || last === void 0 ? void 0 : last.lastBuffer) === "b" ? bufferA : bufferB;
  }

  const targetCtx = targetBuffer.getContext("2d", {
    alpha: false
  });
  const blitSource = doubleBuffer ? targetBuffer === bufferA ? bufferB : bufferA : canvas;
  if (overlayCtx === null || targetCtx === null) return;
  const getRowHeight = typeof rowHeight === "number" ? () => rowHeight : rowHeight;
  overlayCtx.save();
  overlayCtx.beginPath();
  targetCtx.save();
  targetCtx.beginPath();
  overlayCtx.textBaseline = "middle";
  targetCtx.textBaseline = "middle";

  if (dpr !== 1) {
    overlayCtx.scale(dpr, dpr);
    targetCtx.scale(dpr, dpr);
  }

  const effectiveCols = (0,data_grid_lib/* getEffectiveColumns */.ih)(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
  let drawRegions = [];
  const mustDrawFocusOnHeader = drawFocus && ((_selection$current = selection.current) === null || _selection$current === void 0 ? void 0 : _selection$current.cell[1]) === cellYOffset && translateY === 0;

  const drawHeaderTexture = () => {
    var _ref2, _theme$headerBottomBo;

    drawGridHeaders(overlayCtx, effectiveCols, enableGroups, hoverInfo, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, theme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode);
    drawGridLines(overlayCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, undefined, undefined, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme, true);
    overlayCtx.beginPath();
    overlayCtx.moveTo(0, overlayHeight - 0.5);
    overlayCtx.lineTo(width, overlayHeight - 0.5);
    overlayCtx.strokeStyle = blend((_ref2 = (_theme$headerBottomBo = theme.headerBottomBorderColor) !== null && _theme$headerBottomBo !== void 0 ? _theme$headerBottomBo : theme.horizontalBorderColor) !== null && _ref2 !== void 0 ? _ref2 : theme.borderColor, theme.bgHeader);
    overlayCtx.stroke();

    if (mustDrawFocusOnHeader) {
      drawFocusRing(overlayCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
    }
  };

  if (damage !== undefined) {
    let doHeaders = false;
    damage = damage.filter(x => {
      doHeaders = doHeaders || x[1] < 0;
      return x[1] < 0 || intersectRect(cellXOffset, cellYOffset, effectiveCols.length, 300, x[0], x[1], 1, 1) || intersectRect(0, cellYOffset, freezeColumns, 300, x[0], x[1], 1, 1) || trailingRowType && intersectRect(cellXOffset, rows - 1, effectiveCols.length, 1, x[0], x[1], 1, 1);
    });

    if (damage.length > 0) {
      clipDamage(targetCtx, effectiveCols, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, true);
      targetCtx.fillStyle = theme.bgCell;
      targetCtx.fillRect(0, totalHeaderHeight + 1, width, height - totalHeaderHeight - 1);
      drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);

      if (fillHandle && drawFocus && selection.current !== undefined && damage.some(x => {
        var _selection$current2, _selection$current3;

        return x[0] === ((_selection$current2 = selection.current) === null || _selection$current2 === void 0 ? void 0 : _selection$current2.cell[0]) && x[1] === ((_selection$current3 = selection.current) === null || _selection$current3 === void 0 ? void 0 : _selection$current3.cell[1]);
      })) {
        drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
      }
    }

    if (doHeaders) {
      clipDamage(overlayCtx, effectiveCols, width, totalHeaderHeight, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, false);
      drawHeaderTexture();
    }

    targetCtx.restore();
    overlayCtx.restore();

    if (mainCtx !== null) {
      mainCtx.fillStyle = theme.bgCell;
      mainCtx.fillRect(0, 0, width, height);
      mainCtx.drawImage(targetCtx.canvas, 0, 0);
    }

    return;
  }

  if (canBlit !== true || cellXOffset !== (last === null || last === void 0 ? void 0 : last.cellXOffset) || translateX !== (last === null || last === void 0 ? void 0 : last.translateX) || mustDrawFocusOnHeader !== (last === null || last === void 0 ? void 0 : last.mustDrawFocusOnHeader)) {
    drawHeaderTexture();
  }

  if (canBlit === true) {
    (0,support/* assert */.hu)(blitSource !== undefined && last !== undefined);
    const {
      regions
    } = blitLastFrame(targetCtx, blitSource, last, cellXOffset, cellYOffset, translateX, translateY, trailingRowType === "sticky", width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, rowHeight, doubleBuffer);
    drawRegions = regions;
  } else if (canBlit !== false) {
    (0,support/* assert */.hu)(last !== undefined);
    const resizedCol = canBlit;
    drawRegions = blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedCol);
  }

  overdrawStickyBoundaries(targetCtx, effectiveCols, width, height, trailingRowType === "sticky", rows, verticalBorder, getRowHeight, theme);
  const focusRedraw = drawFocus ? drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) : undefined;
  const highlightRedraw = drawHighlightRings(targetCtx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, trailingRowType === "sticky", rows, highlightRegions);
  targetCtx.fillStyle = theme.bgCell;

  if (drawRegions.length > 0) {
    targetCtx.beginPath();

    for (const r of drawRegions) {
      targetCtx.rect(r.x, r.y, r.width, r.height);
    }

    targetCtx.clip();
    targetCtx.fill();
    targetCtx.beginPath();
  } else {
    targetCtx.fillRect(0, 0, width, height);
  }

  const spans = drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);
  drawBlanks(targetCtx, effectiveCols, mappedColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowThemeOverride, selection.rows, disabledRows, trailingRowType, drawRegions, damage, theme);
  drawGridLines(targetCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme);
  focusRedraw === null || focusRedraw === void 0 ? void 0 : focusRedraw();
  highlightRedraw === null || highlightRedraw === void 0 ? void 0 : highlightRedraw();

  if (mainCtx !== null) {
    mainCtx.fillStyle = theme.bgCell;
    mainCtx.fillRect(0, 0, width, height);
    mainCtx.drawImage(targetCtx.canvas, 0, 0);
  }

  const lastRowDrawn = getLastRow(effectiveCols, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType);
  imageLoader === null || imageLoader === void 0 ? void 0 : imageLoader.setWindow({
    x: cellXOffset,
    y: cellYOffset,
    width: effectiveCols.length,
    height: lastRowDrawn - cellYOffset
  }, freezeColumns);
  lastBlitData.current = {
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mustDrawFocusOnHeader,
    lastBuffer: doubleBuffer ? targetBuffer === bufferA ? "a" : "b" : undefined
  };
  targetCtx.restore();
  overlayCtx.restore();
}

function walkRowsInCol(startRow, drawY, height, rows, getRowHeight, trailingRowType, cb) {
  let y = drawY;
  let row = startRow;
  let doSticky = trailingRowType === "sticky";

  while (y < height || doSticky) {
    const doingSticky = doSticky && y >= height;

    if (doingSticky) {
      doSticky = false;
      row = rows - 1;
    }

    const rh = getRowHeight(row);

    if (doingSticky) {
      y = height - rh;
    }

    const isMovedStickyRow = doSticky && row === rows - 1;

    if (!isMovedStickyRow && cb(y, row, rh, doingSticky, trailingRowType !== "none" && row === rows - 1) === true) {
      break;
    }

    if (doingSticky) {
      break;
    }

    y += rh;
    row++;
  }
}

function walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, cb) {
  let x = 0;
  let clipX = 0;
  const drawY = totalHeaderHeight + translateY;

  for (const c of effectiveCols) {
    const drawX = c.sticky ? clipX : x + translateX;

    if (cb(c, drawX, drawY, clipX, cellYOffset) === true) {
      break;
    }

    x += c.width;
    clipX += c.sticky ? c.width : 0;
  }
}

function walkGroups(effectiveCols, width, translateX, groupHeaderHeight, cb) {
  let x = 0;
  let clipX = 0;

  for (let index = 0; index < effectiveCols.length; index++) {
    var _startCol$group;

    const startCol = effectiveCols[index];
    let end = index + 1;
    let boxWidth = startCol.width;

    if (startCol.sticky) {
      clipX += boxWidth;
    }

    while (end < effectiveCols.length && (0,data_grid_lib/* isGroupEqual */.PU)(effectiveCols[end].group, startCol.group) && effectiveCols[end].sticky === effectiveCols[index].sticky) {
      const endCol = effectiveCols[end];
      boxWidth += endCol.width;
      end++;
      index++;

      if (endCol.sticky) {
        clipX += endCol.width;
      }
    }

    const t = startCol.sticky ? 0 : translateX;
    const localX = x + t;
    const delta = startCol.sticky ? 0 : Math.max(0, clipX - localX);
    const w = Math.min(boxWidth - delta, width - (localX + delta));
    cb([startCol.sourceIndex, effectiveCols[end - 1].sourceIndex], (_startCol$group = startCol.group) !== null && _startCol$group !== void 0 ? _startCol$group : "", localX + delta, 0, w, groupHeaderHeight);
    x += boxWidth;
  }
}
;// CONCATENATED MODULE: ./packages/core/src/data-grid/animation-manager.ts

const hoverTime = 80;

function easeOutCubic(x) {
  const x1 = x - 1;
  return x1 * x1 * x1 + 1;
}

class AnimationManager {
  constructor(callback) {
    this.callback = callback;
    this.currentHoveredItem = undefined;
    this.leavingItems = [];
    this.lastAnimationTime = void 0;

    this.areSameItems = (left, right) => {
      return (left === null || left === void 0 ? void 0 : left[0]) === (right === null || right === void 0 ? void 0 : right[0]) && (left === null || left === void 0 ? void 0 : left[1]) === (right === null || right === void 0 ? void 0 : right[1]);
    };

    this.addToLeavingItems = item => {
      const isAlreadyLeaving = this.leavingItems.some(i => this.areSameItems(i.item, item.item));

      if (isAlreadyLeaving) {
        return;
      }

      this.leavingItems.push(item);
    };

    this.removeFromLeavingItems = item => {
      var _leavingItem$hoverAmo;

      const leavingItem = this.leavingItems.find(e => this.areSameItems(e.item, item));
      this.leavingItems = this.leavingItems.filter(i => i !== leavingItem);
      return (_leavingItem$hoverAmo = leavingItem === null || leavingItem === void 0 ? void 0 : leavingItem.hoverAmount) !== null && _leavingItem$hoverAmo !== void 0 ? _leavingItem$hoverAmo : 0;
    };

    this.cleanUpLeavingElements = () => {
      this.leavingItems = this.leavingItems.filter(i => i.hoverAmount > 0);
    };

    this.shouldStep = () => {
      const hasLeavingItems = this.leavingItems.length > 0;
      const currentHoveredIsAnimating = this.currentHoveredItem !== undefined && this.currentHoveredItem.hoverAmount < 1;
      return hasLeavingItems || currentHoveredIsAnimating;
    };

    this.getAnimatingItems = () => {
      if (this.currentHoveredItem !== undefined) {
        return [...this.leavingItems, this.currentHoveredItem];
      }

      return this.leavingItems.map(x => ({ ...x,
        hoverAmount: easeOutCubic(x.hoverAmount)
      }));
    };

    this.step = timestamp => {
      if (this.lastAnimationTime === undefined) {
        this.lastAnimationTime = timestamp;
      } else {
        const step = timestamp - this.lastAnimationTime;
        const delta = step / hoverTime;

        for (const item of this.leavingItems) {
          item.hoverAmount = clamp_default()(item.hoverAmount - delta, 0, 1);
        }

        if (this.currentHoveredItem !== undefined) {
          this.currentHoveredItem.hoverAmount = clamp_default()(this.currentHoveredItem.hoverAmount + delta, 0, 1);
        }

        const animating = this.getAnimatingItems();
        this.callback(animating);
        this.cleanUpLeavingElements();
      }

      if (this.shouldStep()) {
        this.lastAnimationTime = timestamp;
        window.requestAnimationFrame(this.step);
      } else {
        this.lastAnimationTime = undefined;
      }
    };

    this.setHovered = item => {
      var _this$currentHoveredI;

      if (this.areSameItems((_this$currentHoveredI = this.currentHoveredItem) === null || _this$currentHoveredI === void 0 ? void 0 : _this$currentHoveredI.item, item)) {
        return;
      }

      if (this.currentHoveredItem !== undefined) {
        this.addToLeavingItems(this.currentHoveredItem);
      }

      if (item !== undefined) {
        const hoverAmount = this.removeFromLeavingItems(item);
        this.currentHoveredItem = {
          item,
          hoverAmount
        };
      } else {
        this.currentHoveredItem = undefined;
      }

      if (this.lastAnimationTime === undefined) {
        window.requestAnimationFrame(this.step);
      }
    };
  }

}
// EXTERNAL MODULE: ./packages/core/src/common/browser-detect.ts
var browser_detect = __webpack_require__("./packages/core/src/common/browser-detect.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/use-animation-queue.ts


function hasItem(arr, item) {
  for (const element of arr) {
    if (element[0] === item[0] && element[1] === item[1]) return true;
  }

  return false;
}

function useAnimationQueue(draw) {
  const queue = react.useRef([]);
  const seq = react.useRef(0);
  const drawRef = react.useRef(draw);
  drawRef.current = draw;
  const loop = react.useCallback(() => {
    const requeue = () => window.requestAnimationFrame(fn);

    const fn = () => {
      const toDraw = queue.current;
      queue.current = [];
      drawRef.current(toDraw);

      if (queue.current.length > 0) {
        seq.current++;
      } else {
        seq.current = 0;
      }
    };

    window.requestAnimationFrame(seq.current > 600 ? requeue : fn);
  }, []);
  return react.useCallback(item => {
    if (hasItem(queue.current, item)) return;

    if (queue.current.length === 0) {
      loop();
    }

    queue.current.push(item);
  }, [loop]);
}
;// CONCATENATED MODULE: ./packages/core/src/data-grid/data-grid.tsx














const getRowData = (cell, getCellRenderer) => {
  var _r$getAccessibilitySt;

  if (cell.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom) return cell.copyData;
  const r = getCellRenderer === null || getCellRenderer === void 0 ? void 0 : getCellRenderer(cell);
  return (_r$getAccessibilitySt = r === null || r === void 0 ? void 0 : r.getAccessibilityString(cell)) !== null && _r$getAccessibilitySt !== void 0 ? _r$getAccessibilitySt : "";
};

const DataGrid = (p, forwardedRef) => {
  var _p$translateX, _p$translateY, _eventTargetRef$curre, _eventTargetRef$curre2, _eventTargetRef$curre3, _eventTargetRef$curre4, _eventTargetRef$curre5, _eventTargetRef$curre6;

  const {
    width,
    height,
    accessibilityHeight,
    columns,
    cellXOffset: cellXOffsetReal,
    cellYOffset,
    headerHeight,
    fillHandle = false,
    groupHeaderHeight,
    rowHeight,
    rows,
    getCellContent,
    getRowThemeOverride,
    onHeaderMenuClick,
    enableGroups,
    isFilling,
    onCanvasFocused,
    onCanvasBlur,
    isFocused,
    selection,
    freezeColumns,
    onContextMenu,
    trailingRowType: trailingRowType,
    fixedShadowX = true,
    fixedShadowY = true,
    drawFocusRing = true,
    onMouseDown,
    onMouseUp,
    onMouseMoveRaw,
    onMouseMove,
    onItemHovered,
    dragAndDropState,
    firstColAccessible,
    onKeyDown,
    onKeyUp,
    highlightRegions,
    canvasRef,
    onDragStart,
    onDragEnd,
    eventTargetRef,
    isResizing,
    isDragging,
    isDraggable = false,
    allowResize,
    disabledRows,
    getGroupDetails,
    theme,
    prelightCells,
    headerIcons,
    verticalBorder,
    drawHeader: drawHeaderCallback,
    drawCustomCell,
    onCellFocused,
    onDragOverCell,
    onDrop,
    onDragLeave,
    imageWindowLoader,
    smoothScrollX = false,
    smoothScrollY = false,
    experimental,
    getCellRenderer
  } = p;
  const translateX = (_p$translateX = p.translateX) !== null && _p$translateX !== void 0 ? _p$translateX : 0;
  const translateY = (_p$translateY = p.translateY) !== null && _p$translateY !== void 0 ? _p$translateY : 0;
  const cellXOffset = Math.max(freezeColumns, Math.min(columns.length - 1, cellXOffsetReal));
  const ref = react.useRef(null);
  const imageWindowLoaderInternal = react.useMemo(() => new image_window_loader(), []);
  const imageLoader = imageWindowLoader !== null && imageWindowLoader !== void 0 ? imageWindowLoader : imageWindowLoaderInternal;
  const damageRegion = react.useRef();
  const [scrolling, setScrolling] = react.useState(false);
  const hoverValues = react.useRef([]);
  const lastBlitData = react.useRef();
  const [hoveredItemInfo, setHoveredItemInfo] = react.useState();
  const [hoveredOnEdge, setHoveredOnEdge] = react.useState();
  const overlayRef = react.useRef(null);
  const [lastWasTouch, setLastWasTouch] = react.useState(false);
  const lastWasTouchRef = react.useRef(lastWasTouch);
  lastWasTouchRef.current = lastWasTouch;
  const spriteManager = react.useMemo(() => new SpriteManager(headerIcons, () => {
    lastArgsRef.current = undefined;
    lastDrawRef.current();
  }), [headerIcons]);
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const scrollingStopRef = react.useRef(-1);
  const disableFirefoxRescaling = (experimental === null || experimental === void 0 ? void 0 : experimental.enableFirefoxRescaling) !== true;
  react.useLayoutEffect(() => {
    if (!browser_detect/* browserIsFirefox.value */.uC.value || window.devicePixelRatio === 1 || disableFirefoxRescaling) return;

    if (scrollingStopRef.current !== -1) {
      setScrolling(true);
    }

    window.clearTimeout(scrollingStopRef.current);
    scrollingStopRef.current = window.setTimeout(() => {
      setScrolling(false);
      scrollingStopRef.current = -1;
    }, 200);
  }, [cellYOffset, cellXOffset, translateX, translateY, disableFirefoxRescaling]);
  const mappedColumns = (0,data_grid_lib/* useMappedColumns */.NZ)(columns, freezeColumns);
  const getBoundsForItem = react.useCallback((canvas, col, row) => {
    const rect = canvas.getBoundingClientRect();

    if (col >= mappedColumns.length || row >= rows) {
      return undefined;
    }

    const scale = rect.width / width;
    const result = (0,data_grid_lib/* computeBounds */.Ve)(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType === "sticky", mappedColumns, rowHeight);

    if (scale !== 1) {
      result.x *= scale;
      result.y *= scale;
      result.width *= scale;
      result.height *= scale;
    }

    result.x += rect.x;
    result.y += rect.y;
    return result;
  }, [width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType, mappedColumns, rowHeight]);
  const getMouseArgsForPosition = react.useCallback((canvas, posX, posY, ev) => {
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / width;
    const x = (posX - rect.left) / scale;
    const y = (posY - rect.top) / scale;
    const edgeDetectionBuffer = 5;
    const effectiveCols = (0,data_grid_lib/* getEffectiveColumns */.ih)(mappedColumns, cellXOffset, width, undefined, translateX);
    let button = 0;

    if (ev instanceof MouseEvent) {
      button = ev.button;
    }

    const col = (0,data_grid_lib/* getColumnIndexForX */.oK)(x, effectiveCols, translateX);
    const row = (0,data_grid_lib/* getRowIndexForY */.pV)(y, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType === "sticky");
    const shiftKey = (ev === null || ev === void 0 ? void 0 : ev.shiftKey) === true;
    const ctrlKey = (ev === null || ev === void 0 ? void 0 : ev.ctrlKey) === true;
    const metaKey = (ev === null || ev === void 0 ? void 0 : ev.metaKey) === true;
    const isTouch = ev !== undefined && !(ev instanceof MouseEvent) || (ev === null || ev === void 0 ? void 0 : ev.pointerType) === "touch";
    const edgeSize = 20;
    const scrollEdge = [Math.abs(x) < edgeSize ? -1 : Math.abs(rect.width - x) < edgeSize ? 1 : 0, Math.abs(y) < edgeSize ? -1 : Math.abs(rect.height - y) < edgeSize ? 1 : 0];
    let result;

    if (col === -1 || y < 0 || x < 0 || row === undefined || x > width || y > height) {
      const horizontal = x > width ? -1 : x < 0 ? 1 : 0;
      const vertical = y > height ? 1 : y < 0 ? -1 : 0;
      let isEdge = false;

      if (col === -1 && row === -1) {
        const b = getBoundsForItem(canvas, mappedColumns.length - 1, -1);
        (0,support/* assert */.hu)(b !== undefined);
        isEdge = posX < b.x + b.width + edgeDetectionBuffer;
      }

      result = {
        kind: data_grid_types/* outOfBoundsKind */.Xv,
        location: [col !== -1 ? col : x < 0 ? 0 : mappedColumns.length - 1, row !== null && row !== void 0 ? row : rows - 1],
        direction: [horizontal, vertical],
        shiftKey,
        ctrlKey,
        metaKey,
        isEdge,
        isTouch,
        button,
        scrollEdge
      };
    } else if (row <= -1) {
      let bounds = getBoundsForItem(canvas, col, row);
      (0,support/* assert */.hu)(bounds !== undefined);
      let isEdge = bounds !== undefined && bounds.x + bounds.width - posX <= edgeDetectionBuffer;
      const previousCol = col - 1;

      if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= 0) {
        var _mappedColumns$previo;

        isEdge = true;
        bounds = getBoundsForItem(canvas, previousCol, row);
        (0,support/* assert */.hu)(bounds !== undefined);
        result = {
          kind: enableGroups && row === -2 ? data_grid_types/* groupHeaderKind */.mr : data_grid_types/* headerKind */.aZ,
          location: [previousCol, row],
          bounds: bounds,
          group: (_mappedColumns$previo = mappedColumns[previousCol].group) !== null && _mappedColumns$previo !== void 0 ? _mappedColumns$previo : "",
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      } else {
        var _mappedColumns$col$gr;

        result = {
          kind: enableGroups && row === -2 ? data_grid_types/* groupHeaderKind */.mr : data_grid_types/* headerKind */.aZ,
          group: (_mappedColumns$col$gr = mappedColumns[col].group) !== null && _mappedColumns$col$gr !== void 0 ? _mappedColumns$col$gr : "",
          location: [col, row],
          bounds: bounds,
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      }
    } else {
      const bounds = getBoundsForItem(canvas, col, row);
      (0,support/* assert */.hu)(bounds !== undefined);
      const isEdge = bounds !== undefined && bounds.x + bounds.width - posX < edgeDetectionBuffer;
      const isFillHandle = fillHandle && bounds !== undefined && bounds.x + bounds.width - posX < 6 && bounds.y + bounds.height - posY < 6;
      result = {
        kind: "cell",
        location: [col, row],
        bounds: bounds,
        isEdge,
        shiftKey,
        ctrlKey,
        isFillHandle,
        metaKey,
        isTouch,
        localEventX: posX - bounds.x,
        localEventY: posY - bounds.y,
        button,
        scrollEdge
      };
    }

    return result;
  }, [mappedColumns, cellXOffset, width, translateX, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType, getBoundsForItem, fillHandle]);

  function isSameItem(item, other) {
    if (item === other) return true;
    return (item === null || item === void 0 ? void 0 : item.kind) === (other === null || other === void 0 ? void 0 : other.kind) && (item === null || item === void 0 ? void 0 : item.location[0]) === (other === null || other === void 0 ? void 0 : other.location[0]) && (item === null || item === void 0 ? void 0 : item.location[1]) === (other === null || other === void 0 ? void 0 : other.location[1]);
  }

  const [hoveredItem] = hoveredItemInfo !== null && hoveredItemInfo !== void 0 ? hoveredItemInfo : [];
  const enqueueRef = react.useRef(_item => {});
  const hoverInfoRef = react.useRef(hoveredItemInfo);
  hoverInfoRef.current = hoveredItemInfo;
  const [bufferA, bufferB] = react.useMemo(() => {
    const a = document.createElement("canvas");
    const b = document.createElement("canvas");
    a.style["display"] = "none";
    a.style["opacity"] = "0";
    a.style["position"] = "fixed";
    b.style["display"] = "none";
    b.style["opacity"] = "0";
    b.style["position"] = "fixed";
    return [a, b];
  }, []);
  react.useLayoutEffect(() => {
    document.documentElement.append(bufferA);
    document.documentElement.append(bufferB);
    return () => {
      bufferA.remove();
      bufferB.remove();
    };
  }, [bufferA, bufferB]);
  const lastArgsRef = react.useRef();
  const draw = react.useCallback(() => {
    var _experimental$hyperWr, _experimental$renderS;

    const canvas = ref.current;
    const overlay = overlayRef.current;
    if (canvas === null || overlay === null) return;
    const last = lastArgsRef.current;
    const current = {
      canvas,
      bufferA,
      bufferB,
      headerCanvas: overlay,
      width,
      height,
      cellXOffset,
      cellYOffset,
      translateX: Math.round(translateX),
      translateY: Math.round(translateY),
      mappedColumns,
      enableGroups,
      freezeColumns,
      dragAndDropState,
      theme,
      headerHeight,
      groupHeaderHeight,
      disabledRows: disabledRows !== null && disabledRows !== void 0 ? disabledRows : data_grid_types/* CompactSelection.empty */.EV.empty(),
      rowHeight,
      verticalBorder,
      isResizing,
      isFocused,
      selection,
      fillHandle,
      lastRowSticky: trailingRowType,
      rows,
      drawFocus: drawFocusRing,
      getCellContent,
      getGroupDetails: getGroupDetails !== null && getGroupDetails !== void 0 ? getGroupDetails : name => ({
        name
      }),
      getRowThemeOverride,
      drawCustomCell,
      drawHeaderCallback,
      prelightCells,
      highlightRegions,
      imageLoader,
      lastBlitData,
      damage: damageRegion.current,
      hoverValues: hoverValues.current,
      hoverInfo: hoverInfoRef.current,
      spriteManager,
      scrolling,
      hyperWrapping: (_experimental$hyperWr = experimental === null || experimental === void 0 ? void 0 : experimental.hyperWrapping) !== null && _experimental$hyperWr !== void 0 ? _experimental$hyperWr : false,
      touchMode: lastWasTouch,
      enqueue: enqueueRef.current,
      renderStrategy: (_experimental$renderS = experimental === null || experimental === void 0 ? void 0 : experimental.renderStrategy) !== null && _experimental$renderS !== void 0 ? _experimental$renderS : browser_detect/* browserIsSafari.value */.Pq.value ? "double-buffer" : "single-buffer",
      getCellRenderer
    };

    if (current.damage === undefined) {
      lastArgsRef.current = current;
      drawGrid(current, last);
    } else {
      drawGrid(current, undefined);
    }
  }, [bufferA, bufferB, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, enableGroups, freezeColumns, dragAndDropState, theme, headerHeight, groupHeaderHeight, disabledRows, rowHeight, verticalBorder, isResizing, isFocused, selection, fillHandle, trailingRowType, rows, drawFocusRing, getCellContent, getGroupDetails, getRowThemeOverride, drawCustomCell, drawHeaderCallback, prelightCells, highlightRegions, imageLoader, spriteManager, scrolling, experimental === null || experimental === void 0 ? void 0 : experimental.hyperWrapping, experimental === null || experimental === void 0 ? void 0 : experimental.renderStrategy, lastWasTouch, getCellRenderer]);
  const lastDrawRef = react.useRef(draw);
  react.useLayoutEffect(() => {
    draw();
    lastDrawRef.current = draw;
  }, [draw]);
  react.useLayoutEffect(() => {
    const fn = async () => {
      var _document, _document$fonts;

      if (((_document = document) === null || _document === void 0 ? void 0 : (_document$fonts = _document.fonts) === null || _document$fonts === void 0 ? void 0 : _document$fonts.ready) === undefined) return;
      await document.fonts.ready;
      lastArgsRef.current = undefined;
      lastDrawRef.current();
    };

    void fn();
  }, []);
  const damageInternal = react.useCallback(locations => {
    damageRegion.current = locations;
    lastDrawRef.current();
    damageRegion.current = undefined;
  }, []);
  const enqueue = useAnimationQueue(damageInternal);
  enqueueRef.current = enqueue;
  const damage = react.useCallback(cells => {
    damageInternal(cells.map(x => x.cell));
  }, [damageInternal]);
  imageLoader.setCallback(damageInternal);
  const [overFill, setOverFill] = react.useState(false);
  const [hCol, hRow] = hoveredItem !== null && hoveredItem !== void 0 ? hoveredItem : [];
  const headerHovered = hCol !== undefined && hRow === -1;
  const groupHeaderHovered = hCol !== undefined && hRow === -2;
  let clickableInnerCellHovered = false;
  let editableBoolHovered = false;
  let cursorOverride;

  if (hCol !== undefined && hRow !== undefined && hRow > -1) {
    const cell = getCellContent([hCol, hRow], true);
    clickableInnerCellHovered = cell.kind === data_grid_types/* InnerGridCellKind.NewRow */.$o.NewRow || cell.kind === data_grid_types/* InnerGridCellKind.Marker */.$o.Marker && cell.markerKind !== "number";
    editableBoolHovered = cell.kind === data_grid_types/* GridCellKind.Boolean */.p6.Boolean && (0,data_grid_types/* booleanCellIsEditable */.kf)(cell);
    cursorOverride = cell.cursor;
  }

  const canDrag = hoveredOnEdge !== null && hoveredOnEdge !== void 0 ? hoveredOnEdge : false;
  const cursor = isDragging ? "grabbing" : canDrag || isResizing ? "col-resize" : overFill || isFilling ? "crosshair" : cursorOverride !== undefined ? cursorOverride : headerHovered || clickableInnerCellHovered || editableBoolHovered || groupHeaderHovered ? "pointer" : "default";
  const style = react.useMemo(() => ({
    contain: "strict",
    display: "block",
    cursor
  }), [cursor]);
  const lastSetCursor = react.useRef("default");
  const target = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current;

  if (target !== null && target !== undefined && lastSetCursor.current !== style.cursor) {
    target.style.cursor = lastSetCursor.current = style.cursor;
  }

  const groupHeaderActionForEvent = react.useCallback((group, bounds, localEventX, localEventY) => {
    if (getGroupDetails === undefined) return undefined;
    const groupDesc = getGroupDetails(group);

    if (groupDesc.actions !== undefined) {
      const boxes = getActionBoundsForGroup(bounds, groupDesc.actions);

      for (const [i, box] of boxes.entries()) {
        if (pointInRect(box, localEventX + bounds.x, localEventY + box.y)) {
          return groupDesc.actions[i];
        }
      }
    }

    return undefined;
  }, [getGroupDetails]);
  const isOverHeaderMenu = react.useCallback((canvas, col, clientX, clientY) => {
    const header = columns[col];

    if (!isDragging && !isResizing && header.hasMenu === true && !(hoveredOnEdge !== null && hoveredOnEdge !== void 0 ? hoveredOnEdge : false)) {
      const headerBounds = getBoundsForItem(canvas, col, -1);
      (0,support/* assert */.hu)(headerBounds !== undefined);
      const menuBounds = getHeaderMenuBounds(headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height);

      if (clientX > menuBounds.x && clientX < menuBounds.x + menuBounds.width && clientY > menuBounds.y && clientY < menuBounds.y + menuBounds.height) {
        return headerBounds;
      }
    }

    return undefined;
  }, [columns, getBoundsForItem, hoveredOnEdge, isDragging, isResizing]);
  const downTime = react.useRef(0);
  const downPosition = react.useRef();
  const onMouseDownImpl = react.useCallback(ev => {
    const canvas = ref.current;
    const eventTarget = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current;
    if (canvas === null || ev.target !== canvas && ev.target !== eventTarget) return;
    let clientX;
    let clientY;

    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;
    } else {
      clientX = ev.touches[0].clientX;
      clientY = ev.touches[0].clientY;
    }

    if (ev.target === eventTarget && eventTarget !== null) {
      const bounds = eventTarget.getBoundingClientRect();
      if (clientX > bounds.left + eventTarget.clientWidth) return;
      if (clientY > bounds.top + eventTarget.clientHeight) return;
    }

    const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);
    downPosition.current = args.location;

    if (args.isTouch) {
      downTime.current = Date.now();
    }

    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }

    if (args.kind === data_grid_types/* headerKind */.aZ && isOverHeaderMenu(canvas, args.location[0], clientX, clientY) !== undefined) {
      return;
    } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);

      if (action !== undefined) {
        return;
      }
    }

    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(args);

    if (!args.isTouch && isDraggable !== true && isDraggable !== args.kind) {
      ev.preventDefault();
    }
  }, [eventTargetRef, isDraggable, getMouseArgsForPosition, groupHeaderActionForEvent, isOverHeaderMenu, onMouseDown]);
  (0,utils/* useEventListener */.OR)("touchstart", onMouseDownImpl, window, false);
  (0,utils/* useEventListener */.OR)("mousedown", onMouseDownImpl, window, false);
  const onMouseUpImpl = react.useCallback(ev => {
    const canvas = ref.current;
    if (onMouseUp === undefined || canvas === null) return;
    const eventTarget = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current;
    const isOutside = ev.target !== canvas && ev.target !== eventTarget;
    let clientX;
    let clientY;

    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;

      if (ev.pointerType === "touch") {
        return;
      }
    } else {
      clientX = ev.changedTouches[0].clientX;
      clientY = ev.changedTouches[0].clientY;
    }

    let args = getMouseArgsForPosition(canvas, clientX, clientY, ev);

    if (args.isTouch && downTime.current !== 0 && Date.now() - downTime.current > 500) {
      args = { ...args,
        isLongTouch: true
      };
    }

    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }

    if (!isOutside && ev.cancelable) {
      ev.preventDefault();
    }

    if (args.kind === data_grid_types/* headerKind */.aZ && isOverHeaderMenu(canvas, args.location[0], clientX, clientY)) {
      const [col] = args.location;
      const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);

      if (headerBounds !== undefined) {
        var _downPosition$current, _downPosition$current2;

        if (args.button === 0 && ((_downPosition$current = downPosition.current) === null || _downPosition$current === void 0 ? void 0 : _downPosition$current[0]) === col && ((_downPosition$current2 = downPosition.current) === null || _downPosition$current2 === void 0 ? void 0 : _downPosition$current2[1]) === -1) {
          onHeaderMenuClick === null || onHeaderMenuClick === void 0 ? void 0 : onHeaderMenuClick(col, headerBounds);
        } else {
          onMouseUp(args, true);
        }

        return;
      }
    } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);

      if (action !== undefined) {
        if (args.button === 0) {
          action.onClick(args);
        }

        return;
      }
    }

    onMouseUp(args, isOutside);
  }, [onMouseUp, eventTargetRef, getMouseArgsForPosition, isOverHeaderMenu, onHeaderMenuClick, groupHeaderActionForEvent]);
  (0,utils/* useEventListener */.OR)("click", onMouseUpImpl, window, false);
  (0,utils/* useEventListener */.OR)("touchend", onMouseUpImpl, window, false);
  const onContextMenuImpl = react.useCallback(ev => {
    const canvas = ref.current;
    if (canvas === null || onContextMenu === undefined) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);
    onContextMenu(args, () => {
      if (ev.cancelable) ev.preventDefault();
    });
  }, [getMouseArgsForPosition, onContextMenu]);
  (0,utils/* useEventListener */.OR)("contextmenu", onContextMenuImpl, (_eventTargetRef$curre = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre !== void 0 ? _eventTargetRef$curre : null, false);
  const onAnimationFrame = react.useCallback(values => {
    damageRegion.current = values.map(x => x.item);
    hoverValues.current = values;
    lastDrawRef.current();
    damageRegion.current = undefined;
  }, []);
  const animManagerValue = react.useMemo(() => new AnimationManager(onAnimationFrame), [onAnimationFrame]);
  const animationManager = react.useRef(animManagerValue);
  animationManager.current = animManagerValue;
  react.useLayoutEffect(() => {
    const am = animationManager.current;

    if (hoveredItem === undefined || hoveredItem[1] < 0) {
      am.setHovered(hoveredItem);
      return;
    }

    const cell = getCellContent(hoveredItem);
    const r = getCellRenderer(cell);
    am.setHovered(r === undefined && cell.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom || (r === null || r === void 0 ? void 0 : r.needsHover) === true ? hoveredItem : undefined);
  }, [getCellContent, getCellRenderer, hoveredItem]);
  const hoveredRef = react.useRef();
  const onMouseMoveImpl = react.useCallback(ev => {
    const canvas = ref.current;
    if (canvas === null) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);

    if (!isSameItem(args, hoveredRef.current)) {
      onItemHovered === null || onItemHovered === void 0 ? void 0 : onItemHovered(args);
      setHoveredItemInfo(args.kind === data_grid_types/* outOfBoundsKind */.Xv ? undefined : [args.location, [args.localEventX, args.localEventY]]);
      hoveredRef.current = args;
    } else if (args.kind === "cell" || args.kind === data_grid_types/* headerKind */.aZ || args.kind === data_grid_types/* groupHeaderKind */.mr) {
      const newInfo = [args.location, [args.localEventX, args.localEventY]];
      setHoveredItemInfo(newInfo);
      hoverInfoRef.current = newInfo;

      if (args.kind === "cell") {
        var _getCellRenderer;

        const toCheck = getCellContent(args.location);

        if (toCheck.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom || ((_getCellRenderer = getCellRenderer(toCheck)) === null || _getCellRenderer === void 0 ? void 0 : _getCellRenderer.needsHoverPosition) === true) {
          damageInternal([args.location]);
        }
      } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
        damageInternal([args.location]);
      }
    }

    const notRowMarkerCol = args.location[0] >= (firstColAccessible ? 0 : 1);
    setHoveredOnEdge(args.kind === data_grid_types/* headerKind */.aZ && args.isEdge && notRowMarkerCol && allowResize === true);

    if (fillHandle && selection.current !== undefined) {
      const [col, row] = selection.current.cell;
      const sb = getBoundsForItem(canvas, col, row);
      const x = ev.clientX;
      const y = ev.clientY;
      (0,support/* assert */.hu)(sb !== undefined);
      setOverFill(x >= sb.x + sb.width - 6 && x <= sb.x + sb.width && y >= sb.y + sb.height - 6 && y <= sb.y + sb.height);
    } else {
      setOverFill(false);
    }

    onMouseMoveRaw === null || onMouseMoveRaw === void 0 ? void 0 : onMouseMoveRaw(ev);
    onMouseMove(args);
  }, [getMouseArgsForPosition, allowResize, fillHandle, selection, onMouseMoveRaw, onMouseMove, onItemHovered, getCellContent, getCellRenderer, damageInternal, getBoundsForItem, firstColAccessible]);
  (0,utils/* useEventListener */.OR)("mousemove", onMouseMoveImpl, window, true);
  const onKeyDownImpl = react.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;

    if (selection.current !== undefined) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }

    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => undefined,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyDown, selection, getBoundsForItem]);
  const onKeyUpImpl = react.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;

    if (selection.current !== undefined) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }

    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => undefined,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyUp, selection, getBoundsForItem]);
  const refImpl = react.useCallback(instance => {
    ref.current = instance;

    if (canvasRef !== undefined) {
      canvasRef.current = instance;
    }
  }, [canvasRef]);
  const onDragStartImpl = react.useCallback(event => {
    const canvas = ref.current;

    if (canvas === null || isDraggable === false || isResizing) {
      event.preventDefault();
      return;
    }

    let dragMime;
    let dragData;
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);

    if (isDraggable !== true && args.kind !== isDraggable) {
      event.preventDefault();
      return;
    }

    const setData = (mime, payload) => {
      dragMime = mime;
      dragData = payload;
    };

    let dragImage;
    let dragImageX;
    let dragImageY;

    const setDragImage = (image, x, y) => {
      dragImage = image;
      dragImageX = x;
      dragImageY = y;
    };

    let prevented = false;
    onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({ ...args,
      setData,
      setDragImage,
      preventDefault: () => prevented = true,
      defaultPrevented: () => prevented
    });

    if (!prevented && dragMime !== undefined && dragData !== undefined && event.dataTransfer !== null) {
      event.dataTransfer.setData(dragMime, dragData);
      event.dataTransfer.effectAllowed = "copyLink";

      if (dragImage !== undefined && dragImageX !== undefined && dragImageY !== undefined) {
        event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);
      } else {
        const [col, row] = args.location;

        if (row !== undefined) {
          const offscreen = document.createElement("canvas");
          const boundsForDragTarget = getBoundsForItem(canvas, col, row);
          (0,support/* assert */.hu)(boundsForDragTarget !== undefined);
          offscreen.width = boundsForDragTarget.width;
          offscreen.height = boundsForDragTarget.height;
          const ctx = offscreen.getContext("2d");

          if (ctx !== null) {
            ctx.textBaseline = "middle";

            if (row === -1) {
              ctx.font = `${theme.headerFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgHeader;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawHeader(ctx, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, mappedColumns[col], false, theme, false, false, 0, spriteManager, drawHeaderCallback, false);
            } else {
              ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgCell;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawCell(ctx, row, getCellContent([col, row]), 0, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, false, theme, drawCustomCell, imageLoader, spriteManager, 1, undefined, false, 0, undefined, undefined, getCellRenderer);
            }
          }

          offscreen.style.left = "-100%";
          offscreen.style.position = "absolute";
          document.body.append(offscreen);
          event.dataTransfer.setDragImage(offscreen, boundsForDragTarget.width / 2, boundsForDragTarget.height / 2);
          window.setTimeout(() => {
            offscreen.remove();
          }, 0);
        }
      }
    } else {
      event.preventDefault();
    }
  }, [isDraggable, isResizing, getMouseArgsForPosition, onDragStart, getBoundsForItem, theme, mappedColumns, spriteManager, drawHeaderCallback, getCellContent, drawCustomCell, imageLoader, getCellRenderer]);
  (0,utils/* useEventListener */.OR)("dragstart", onDragStartImpl, (_eventTargetRef$curre2 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre2 !== void 0 ? _eventTargetRef$curre2 : null, false, false);
  const activeDropTarget = react.useRef();
  const onDragOverImpl = react.useCallback(event => {
    var _activeDropTarget$cur;

    const canvas = ref.current;

    if (onDrop !== undefined) {
      event.preventDefault();
    }

    if (canvas === null || onDragOverCell === undefined) {
      return;
    }

    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    const [activeCol, activeRow] = (_activeDropTarget$cur = activeDropTarget.current) !== null && _activeDropTarget$cur !== void 0 ? _activeDropTarget$cur : [];

    if (activeCol !== col || activeRow !== row) {
      activeDropTarget.current = [col, row];
      onDragOverCell([col, row], event.dataTransfer);
    }
  }, [firstColAccessible, getMouseArgsForPosition, onDragOverCell, onDrop]);
  (0,utils/* useEventListener */.OR)("dragover", onDragOverImpl, (_eventTargetRef$curre3 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre3 !== void 0 ? _eventTargetRef$curre3 : null, false, false);
  const onDragEndImpl = react.useCallback(() => {
    activeDropTarget.current = undefined;
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd();
  }, [onDragEnd]);
  (0,utils/* useEventListener */.OR)("dragend", onDragEndImpl, (_eventTargetRef$curre4 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre4 !== void 0 ? _eventTargetRef$curre4 : null, false, false);
  const onDropImpl = react.useCallback(event => {
    const canvas = ref.current;

    if (canvas === null || onDrop === undefined) {
      return;
    }

    event.preventDefault();
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    onDrop([col, row], event.dataTransfer);
  }, [firstColAccessible, getMouseArgsForPosition, onDrop]);
  (0,utils/* useEventListener */.OR)("drop", onDropImpl, (_eventTargetRef$curre5 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre5 !== void 0 ? _eventTargetRef$curre5 : null, false, false);
  const onDragLeaveImpl = react.useCallback(() => {
    onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave();
  }, [onDragLeave]);
  (0,utils/* useEventListener */.OR)("dragleave", onDragLeaveImpl, (_eventTargetRef$curre6 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre6 !== void 0 ? _eventTargetRef$curre6 : null, false, false);
  const selectionRef = react.useRef(selection);
  selectionRef.current = selection;
  const focusRef = react.useRef(null);
  const focusElement = react.useCallback(el => {
    if (ref.current === null || !ref.current.contains(document.activeElement)) return;

    if (el === null && selectionRef.current.current !== undefined) {
      var _canvasRef$current;

      canvasRef === null || canvasRef === void 0 ? void 0 : (_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 ? void 0 : _canvasRef$current.focus({
        preventScroll: true
      });
    } else if (el !== null) {
      el.focus({
        preventScroll: true
      });
    }

    focusRef.current = el;
  }, [canvasRef]);
  react.useImperativeHandle(forwardedRef, () => ({
    focus: () => {
      const el = focusRef.current;

      if (el === null || !document.contains(el)) {
        var _canvasRef$current2;

        canvasRef === null || canvasRef === void 0 ? void 0 : (_canvasRef$current2 = canvasRef.current) === null || _canvasRef$current2 === void 0 ? void 0 : _canvasRef$current2.focus({
          preventScroll: true
        });
      } else {
        el.focus({
          preventScroll: true
        });
      }
    },
    getBounds: (col, row) => {
      if (canvasRef === undefined || canvasRef.current === null) {
        return undefined;
      }

      return getBoundsForItem(canvasRef.current, col, row !== null && row !== void 0 ? row : -1);
    },
    damage
  }), [canvasRef, damage, getBoundsForItem]);
  const lastFocusedSubdomNode = react.useRef();
  const accessibilityTree = (0,utils/* useDebouncedMemo */.Qy)(() => {
    var _effectiveCols$, _selection$current$ce, _selection$current, _selection$current2;

    if (width < 50) return null;
    let effectiveCols = (0,data_grid_lib/* getEffectiveColumns */.ih)(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
    const colOffset = firstColAccessible ? 0 : -1;

    if (!firstColAccessible && ((_effectiveCols$ = effectiveCols[0]) === null || _effectiveCols$ === void 0 ? void 0 : _effectiveCols$.sourceIndex) === 0) {
      effectiveCols = effectiveCols.slice(1);
    }

    const [fCol, fRow] = (_selection$current$ce = (_selection$current = selection.current) === null || _selection$current === void 0 ? void 0 : _selection$current.cell) !== null && _selection$current$ce !== void 0 ? _selection$current$ce : [];
    const range = (_selection$current2 = selection.current) === null || _selection$current2 === void 0 ? void 0 : _selection$current2.range;
    const visibleCols = effectiveCols.map(c => c.sourceIndex);
    const visibleRows = range_default()(cellYOffset, Math.min(rows, cellYOffset + accessibilityHeight));

    if (fCol !== undefined && fRow !== undefined && !(visibleCols.includes(fCol) && visibleRows.includes(fRow))) {
      focusElement(null);
    }

    return react.createElement("table", {
      key: "access-tree",
      role: "grid",
      "aria-rowcount": rows + 1,
      "aria-multiselectable": "true",
      "aria-colcount": mappedColumns.length + colOffset
    }, react.createElement("thead", {
      role: "rowgroup"
    }, react.createElement("tr", {
      role: "row",
      "aria-rowindex": 1
    }, effectiveCols.map(c => react.createElement("th", {
      role: "columnheader",
      "aria-selected": selection.columns.hasIndex(c.sourceIndex),
      "aria-colindex": c.sourceIndex + 1 + colOffset,
      tabIndex: -1,
      onFocus: e => {
        if (e.target === focusRef.current) return;
        return onCellFocused === null || onCellFocused === void 0 ? void 0 : onCellFocused([c.sourceIndex, -1]);
      },
      key: c.sourceIndex
    }, c.title)))), react.createElement("tbody", {
      role: "rowgroup"
    }, visibleRows.map(row => react.createElement("tr", {
      role: "row",
      "aria-selected": selection.rows.hasIndex(row),
      key: row,
      "aria-rowindex": row + 2
    }, effectiveCols.map(c => {
      const col = c.sourceIndex;
      const key = `${col},${row}`;
      const focused = fCol === col && fRow === row;
      const selected = range !== undefined && col >= range.x && col < range.x + range.width && row >= range.y && row < range.y + range.height;
      const id = `glide-cell-${col}-${row}`;
      const cellContent = getCellContent([col, row], true);
      return react.createElement("td", {
        key: key,
        role: "gridcell",
        "aria-colindex": col + 1 + colOffset,
        "aria-selected": selected,
        "aria-readonly": (0,data_grid_types/* isInnerOnlyCell */.rs)(cellContent) || !(0,data_grid_types/* isReadWriteCell */.Qo)(cellContent),
        id: id,
        "data-testid": id,
        onClick: () => {
          const canvas = canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current;
          if (canvas === null || canvas === undefined) return;
          return onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown({
            bounds: getBoundsForItem(canvas, col, row),
            cancel: () => undefined,
            preventDefault: () => undefined,
            stopPropagation: () => undefined,
            ctrlKey: false,
            key: "Enter",
            keyCode: 13,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: undefined
          });
        },
        onFocusCapture: e => {
          var _lastFocusedSubdomNod, _lastFocusedSubdomNod2;

          if (e.target === focusRef.current || ((_lastFocusedSubdomNod = lastFocusedSubdomNode.current) === null || _lastFocusedSubdomNod === void 0 ? void 0 : _lastFocusedSubdomNod[0]) === col && ((_lastFocusedSubdomNod2 = lastFocusedSubdomNode.current) === null || _lastFocusedSubdomNod2 === void 0 ? void 0 : _lastFocusedSubdomNod2[1]) === row) return;
          lastFocusedSubdomNode.current = [col, row];
          return onCellFocused === null || onCellFocused === void 0 ? void 0 : onCellFocused([col, row]);
        },
        ref: focused ? focusElement : undefined,
        tabIndex: -1
      }, getRowData(cellContent, getCellRenderer));
    })))));
  }, [width, mappedColumns, cellXOffset, dragAndDropState, translateX, rows, cellYOffset, accessibilityHeight, selection, focusElement, getCellContent, canvasRef, onKeyDown, getBoundsForItem, onCellFocused], 200);
  const stickyX = fixedShadowX ? (0,data_grid_lib/* getStickyWidth */.G6)(mappedColumns, dragAndDropState) : 0;
  const opacityX = freezeColumns === 0 || !fixedShadowX ? 0 : cellXOffset > freezeColumns ? 1 : clamp_default()(-translateX / 100, 0, 1);
  const absoluteOffsetY = -cellYOffset * 32 + translateY;
  const opacityY = !fixedShadowY ? 0 : clamp_default()(-absoluteOffsetY / 100, 0, 1);
  const stickyShadow = react.useMemo(() => {
    if (!opacityX && !opacityY) {
      return null;
    }

    const styleX = {
      position: "absolute",
      top: 0,
      left: stickyX,
      width: width - stickyX,
      height: height,
      opacity: opacityX,
      pointerEvents: "none",
      transition: !smoothScrollX ? "opacity 0.2s" : undefined,
      boxShadow: "inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)"
    };
    const styleY = {
      position: "absolute",
      top: totalHeaderHeight,
      left: 0,
      width: width,
      height: height,
      opacity: opacityY,
      pointerEvents: "none",
      transition: !smoothScrollY ? "opacity 0.2s" : undefined,
      boxShadow: "inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)"
    };
    return react.createElement(react.Fragment, null, opacityX > 0 && react.createElement("div", {
      id: "shadow-x",
      style: styleX
    }), opacityY > 0 && react.createElement("div", {
      id: "shadow-y",
      style: styleY
    }));
  }, [opacityX, opacityY, stickyX, width, smoothScrollX, totalHeaderHeight, height, smoothScrollY]);
  const overlayStyle = react.useMemo(() => ({
    position: "absolute",
    top: 0,
    left: 0
  }), []);
  return react.createElement(react.Fragment, null, react.createElement("canvas", {
    "data-testid": "data-grid-canvas",
    tabIndex: 0,
    onKeyDown: onKeyDownImpl,
    onKeyUp: onKeyUpImpl,
    onFocus: onCanvasFocused,
    onBlur: onCanvasBlur,
    ref: refImpl,
    style: style
  }, accessibilityTree), react.createElement("canvas", {
    ref: overlayRef,
    style: overlayStyle
  }), stickyShadow);
};

/* harmony default export */ const data_grid = (react.memo(react.forwardRef(DataGrid)));

/***/ }),

/***/ "./packages/core/src/docs/05-copy-paste.stories.tsx.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CopyPaste": () => (/* binding */ CopyPaste),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const CopyPaste = () => {
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([{
    name: "Deidre Morris",
    company: "GONKLE",
    email: "deidremorris@gonkle.com",
    phone: "+1 (867) 507-3332"
  }, {
    name: "Sheryl Craig",
    company: "EVENTAGE",
    email: "sherylcraig@eventage.com",
    phone: "+1 (869) 520-2227"
  }, {
    name: "Lidia Bowers",
    company: "ANOCHA",
    email: "lidiabowers@anocha.com",
    phone: "+1 (808) 414-3826"
  }, {
    name: "Jones Norton",
    company: "REPETWIRE",
    email: "jonesnorton@repetwire.com",
    phone: "+1 (875) 582-3320"
  }, {
    name: "Lula Bruce",
    company: "COMDOM",
    email: "lulabruce@comdom.com",
    phone: "+1 (873) 452-2472"
  }, {
    name: "Larsen Montgomery",
    company: "SQUISH",
    email: "larsenmontgomery@squish.com",
    phone: "+1 (893) 482-3651"
  }, {
    name: "Becky Bright",
    company: "COMCUR",
    email: "beckybright@comcur.com",
    phone: "+1 (879) 494-2331"
  }, {
    name: "Charlotte Rowland",
    company: "FROLIX",
    email: "charlotterowland@frolix.com",
    phone: "+1 (861) 439-2134"
  }, {
    name: "Sonya Hensley",
    company: "GEEKETRON",
    email: "sonyahensley@geeketron.com",
    phone: "+1 (802) 553-2194"
  }, {
    name: "Stephenson Guthrie",
    company: "EXOSWITCH",
    email: "stephensonguthrie@exoswitch.com",
    phone: "+1 (903) 449-3271"
  }, {
    name: "Mcmillan Cline",
    company: "TURNLING",
    email: "mcmillancline@turnling.com",
    phone: "+1 (982) 496-2454"
  }, {
    name: "Kemp Davis",
    company: "TETRATREX",
    email: "kempdavis@tetratrex.com",
    phone: "+1 (859) 594-2982"
  }, {
    name: "Matilda Levy",
    company: "SLOFAST",
    email: "matildalevy@slofast.com",
    phone: "+1 (841) 521-2444"
  }, {
    name: "Hattie Simpson",
    company: "COMTRAK",
    email: "hattiesimpson@comtrak.com",
    phone: "+1 (962) 587-3805"
  }, {
    name: "Kinney Munoz",
    company: "IDETICA",
    email: "kinneymunoz@idetica.com",
    phone: "+1 (921) 513-2012"
  }, {
    name: "Lambert Raymond",
    company: "TURNABOUT",
    email: "lambertraymond@turnabout.com",
    phone: "+1 (919) 519-2442"
  }, {
    name: "Bryant Dunlap",
    company: "BYTREX",
    email: "bryantdunlap@bytrex.com",
    phone: "+1 (872) 583-2883"
  }]);
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = dataRef.current[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  const onCellEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newValue) => {
    if (newValue.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text) {
      return;
    }

    const indexes = ["name", "company", "email", "phone"];
    const [col, row] = cell;
    const key = indexes[col];
    dataRef.current[row][key] = newValue.data;
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Copy Paste

Copy and Paste support is built in to Glide Data Grid. It is not enabled by default to ensure developers are expecting its behavior.

## Copy

By default copy is not enabled, to enabled copy implement the \`getCellsForSelection\` callback. The callback returns results as row-major ordering.

> \`getCellsForSelection\` is used instead of \`getCellContent\` to allow optimization when fetching large amounts of data outside of the visible region.

This example uses the built in generic function which simply calls \`getContent\`, which is inefficient but fine for a local data source.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor {...rest} getCellsForSelection={true} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    getCellsForSelection: true,
    columns: columns,
    rows: dataRef.current.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    style: {
      padding: 12,
      width: "100%",
      height: "200px",
      borderRadius: 9
    },
    placeholder: "Highlight some stuff up there and paste it here"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
Implementations may wish to use far more efficient mechanisms for fetching data.

## Paste

The easiest way to enable paste is to set \`onPaste\` to true when \`onCellEdited\` is already working. The Glide Data Grid will automatically parse the paste buffer and send cell update events.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor {...rest} onCellEdited={onCellEdited} onPaste={true} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    onCellEdited: onCellEdited,
    getCellsForSelection: true,
    onPaste: true,
    columns: columns,
    rows: dataRef.current.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `Try copying this.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    style: {
      padding: 12,
      width: "100%",
      height: "80px",
      borderRadius: 9
    },
    value: "Sheryl Craig\tEVENTAGE\tsherylcraig@eventage.com\nLidia Bowers\tANOCHA\tlidiabowers@anocha.com\nJones Norton\tREPETWIRE\tjonesnorton@repetwire.com"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
If desired paste events can be handled manually. Passing a callback to \`onPaste\` will instead receive a parsed verison of the pasted data. Returning \`true\` from the callback will cause the paste event to be handled the same as before, emitting \`onCellEdited\`. Returning \`false\` will prevent the edit callback from being emitted.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor
    {...rest}
    onCellEdited={onCellEdited}
    onPaste={(target, value) => {
        window.alert(JSON.stringify({ target, value }));
        return false;
    }}
/>
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    onCellEdited: onCellEdited,
    getCellsForSelection: true,
    columns: columns,
    onPaste: (target, value) => {
      window.alert(JSON.stringify({
        target,
        value
      }));
      return false;
    },
    rows: dataRef.current.length
  })));
};
CopyPaste.storyName = "05. Copy/Paste Support";
const __namedExportsOrder = ["CopyPaste"];

/***/ }),

/***/ "./packages/core/src/docs/doc-wrapper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M2": () => (/* binding */ Marked),
/* harmony export */   "im": () => (/* binding */ Wrapper),
/* harmony export */   "kT": () => (/* binding */ DocWrapper),
/* harmony export */   "y$": () => (/* binding */ Highlight)
/* harmony export */ });
/* unused harmony exports PropName, Description, MoreInfo */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/marked/lib/marked.esm.js");
/* harmony import */ var react_syntax_highlighter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/react-syntax-highlighter/dist/esm/default-highlight.js");
/* harmony import */ var react_syntax_highlighter_dist_esm_styles_hljs_github__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/react-syntax-highlighter/dist/esm/styles/hljs/github.js");






const _exp = () => p => p.height;

const Wrapper = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('div')({
  name: "Wrapper",
  class: "w1gh5fuv",
  vars: {
    "w1gh5fuv-0": [_exp(), "px"]
  }
});
const Highlight = p => {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_syntax_highlighter__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, {
    style: react_syntax_highlighter_dist_esm_styles_hljs_github__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z,
    showLineNumbers: true,
    lineNumberStyle: {
      opacity: 0.5
    },
    language: "typescript"
  }, p.children.trim());
};
const Marked = p => {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "marked",
    dangerouslySetInnerHTML: {
      __html: (0,marked__WEBPACK_IMPORTED_MODULE_1__/* .marked */ .TU)(p.children)
    }
  });
};
const BeautifulStyle = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('div')({
  name: "BeautifulStyle",
  class: "b1bk6rj1"
});
const PropName = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('span')({
  name: "PropName",
  class: "p65g85a"
});
const Description = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('p')({
  name: "Description",
  class: "d2b9oy3"
});
const MoreInfo = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('p')({
  name: "MoreInfo",
  class: "mnvl60p"
});
const DocWrapper = p => {
  const {
    children
  } = p;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(BeautifulStyle, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "inner"
  }, children));
};

__webpack_require__("./packages/core/src/docs/doc-wrapper.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/doc-wrapper.tsx");

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ scrolling_data_grid)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
// EXTERNAL MODULE: ./node_modules/lodash/clamp.js
var clamp = __webpack_require__("./node_modules/lodash/clamp.js");
var clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid.tsx + 7 modules
var data_grid = __webpack_require__("./packages/core/src/data-grid/data-grid.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-dnd/data-grid-dnd.tsx




function offsetColumnSize(column, width, min, max) {
  var _column$growOffset;

  return clamp_default()(Math.round(width - ((_column$growOffset = column.growOffset) !== null && _column$growOffset !== void 0 ? _column$growOffset : 0)), Math.ceil(min), Math.floor(max));
}

const DataGridDnd = p => {
  var _ref;

  const [resizeColStartX, setResizeColStartX] = react.useState();
  const [resizeCol, setResizeCol] = react.useState();
  const [dragCol, setDragCol] = react.useState();
  const [dropCol, setDropCol] = react.useState();
  const [dragColActive, setDragColActive] = react.useState(false);
  const [dragStartX, setDragStartX] = react.useState();
  const [dragRow, setDragRow] = react.useState();
  const [dropRow, setDropRow] = react.useState();
  const [dragRowActive, setDragRowActive] = react.useState(false);
  const [dragStartY, setDragStartY] = react.useState();
  const {
    onHeaderMenuClick,
    getCellContent,
    onColumnMoved,
    onColumnResize,
    onColumnResizeStart,
    onColumnResizeEnd,
    gridRef,
    maxColumnWidth,
    minColumnWidth,
    onRowMoved,
    lockColumns,
    onMouseDown,
    onMouseUp,
    onItemHovered,
    onDragStart,
    canvasRef
  } = p;
  const canResize = ((_ref = onColumnResize !== null && onColumnResize !== void 0 ? onColumnResize : onColumnResizeEnd) !== null && _ref !== void 0 ? _ref : onColumnResizeStart) !== undefined;
  const {
    columns,
    selection
  } = p;
  const selectedColumns = selection.columns;
  const onItemHoveredImpl = react.useCallback(args => {
    const [col, row] = args.location;

    if (dragCol !== undefined && dropCol !== col && col >= lockColumns) {
      setDragColActive(true);
      setDropCol(col);
    } else if (dragRow !== undefined && row !== undefined) {
      setDragRowActive(true);
      setDropRow(Math.max(0, row));
    } else {
      onItemHovered === null || onItemHovered === void 0 ? void 0 : onItemHovered(args);
    }
  }, [dragCol, dragRow, dropCol, onItemHovered, lockColumns]);
  const canDragCol = onColumnMoved !== undefined;
  const onMouseDownImpl = react.useCallback(args => {
    if (args.button === 0) {
      const [col, row] = args.location;

      if (args.kind === "out-of-bounds" && args.isEdge && canResize) {
        var _gridRef$current;

        const bounds = gridRef === null || gridRef === void 0 ? void 0 : (_gridRef$current = gridRef.current) === null || _gridRef$current === void 0 ? void 0 : _gridRef$current.getBounds(columns.length - 1, -1);

        if (bounds !== undefined) {
          setResizeColStartX(bounds.x);
          setResizeCol(columns.length - 1);
        }
      } else if (args.kind === "header" && col >= lockColumns) {
        const canvas = canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current;

        if (args.isEdge && canResize && canvas) {
          var _columns$col$growOffs;

          setResizeColStartX(args.bounds.x);
          setResizeCol(col);
          const rect = canvas.getBoundingClientRect();
          const scale = rect.width / canvas.offsetWidth;
          const width = args.bounds.width / scale;
          onColumnResizeStart === null || onColumnResizeStart === void 0 ? void 0 : onColumnResizeStart(columns[col], width, col, width + ((_columns$col$growOffs = columns[col].growOffset) !== null && _columns$col$growOffs !== void 0 ? _columns$col$growOffs : 0));
        } else if (args.kind === "header" && canDragCol) {
          setDragStartX(args.bounds.x);
          setDragCol(col);
        }
      } else if (args.kind === "cell" && lockColumns > 0 && col === 0 && row !== undefined && onRowMoved !== undefined) {
        setDragStartY(args.bounds.y);
        setDragRow(row);
      }
    }

    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(args);
  }, [onMouseDown, canResize, lockColumns, onRowMoved, gridRef, columns, canDragCol, onColumnResizeStart, canvasRef]);
  const onHeaderMenuClickMangled = react.useCallback((col, screenPosition) => {
    if (dragColActive || dragRowActive) return;
    onHeaderMenuClick === null || onHeaderMenuClick === void 0 ? void 0 : onHeaderMenuClick(col, screenPosition);
  }, [dragColActive, dragRowActive, onHeaderMenuClick]);
  const lastResizeWidthRef = react.useRef(-1);
  const clearAll = react.useCallback(() => {
    lastResizeWidthRef.current = -1;
    setDragRow(undefined);
    setDropRow(undefined);
    setDragStartY(undefined);
    setDragRowActive(false);
    setDragCol(undefined);
    setDropCol(undefined);
    setDragStartX(undefined);
    setDragColActive(false);
    setResizeCol(undefined);
    setResizeColStartX(undefined);
  }, []);
  const onMouseUpImpl = react.useCallback((args, isOutside) => {
    if (args.button === 0) {
      if (resizeCol !== undefined) {
        var _columns$resizeCol$gr;

        if ((selectedColumns === null || selectedColumns === void 0 ? void 0 : selectedColumns.hasIndex(resizeCol)) === true) {
          for (const c of selectedColumns) {
            var _col$growOffset;

            if (c === resizeCol) continue;
            const col = columns[c];
            const newSize = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
            onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(col, newSize, c, newSize + ((_col$growOffset = col.growOffset) !== null && _col$growOffset !== void 0 ? _col$growOffset : 0));
          }
        }

        const ns = offsetColumnSize(columns[resizeCol], lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
        onColumnResizeEnd === null || onColumnResizeEnd === void 0 ? void 0 : onColumnResizeEnd(columns[resizeCol], ns, resizeCol, ns + ((_columns$resizeCol$gr = columns[resizeCol].growOffset) !== null && _columns$resizeCol$gr !== void 0 ? _columns$resizeCol$gr : 0));

        if (selectedColumns.hasIndex(resizeCol)) {
          for (const c of selectedColumns) {
            var _col$growOffset2;

            if (c === resizeCol) continue;
            const col = columns[c];
            const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
            onColumnResizeEnd === null || onColumnResizeEnd === void 0 ? void 0 : onColumnResizeEnd(col, s, c, s + ((_col$growOffset2 = col.growOffset) !== null && _col$growOffset2 !== void 0 ? _col$growOffset2 : 0));
          }
        }
      }

      clearAll();

      if (dragCol !== undefined && dropCol !== undefined) {
        onColumnMoved === null || onColumnMoved === void 0 ? void 0 : onColumnMoved(dragCol, dropCol);
      }

      if (dragRow !== undefined && dropRow !== undefined) {
        onRowMoved === null || onRowMoved === void 0 ? void 0 : onRowMoved(dragRow, dropRow);
      }
    }

    onMouseUp === null || onMouseUp === void 0 ? void 0 : onMouseUp(args, isOutside);
  }, [onMouseUp, resizeCol, dragCol, dropCol, dragRow, dropRow, selectedColumns, onColumnResizeEnd, columns, minColumnWidth, maxColumnWidth, onColumnResize, onColumnMoved, onRowMoved, clearAll]);
  const dragOffset = react.useMemo(() => {
    if (dragCol === undefined || dropCol === undefined) return undefined;
    if (dragCol === dropCol) return undefined;
    return {
      src: dragCol,
      dest: dropCol
    };
  }, [dragCol, dropCol]);
  const onMouseMove = react.useCallback(event => {
    const canvas = canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current;

    if (dragCol !== undefined && dragStartX !== undefined) {
      const diff = Math.abs(event.clientX - dragStartX);

      if (diff > 20) {
        setDragColActive(true);
      }
    } else if (dragRow !== undefined && dragStartY !== undefined) {
      const diff = Math.abs(event.clientY - dragStartY);

      if (diff > 20) {
        setDragRowActive(true);
      }
    } else if (resizeCol !== undefined && resizeColStartX !== undefined && canvas) {
      var _column$growOffset2;

      const rect = canvas.getBoundingClientRect();
      const scale = rect.width / canvas.offsetWidth;
      const newWidth = (event.clientX - resizeColStartX) / scale;
      const column = columns[resizeCol];
      const ns = offsetColumnSize(column, newWidth, minColumnWidth, maxColumnWidth);
      onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(column, ns, resizeCol, ns + ((_column$growOffset2 = column.growOffset) !== null && _column$growOffset2 !== void 0 ? _column$growOffset2 : 0));
      lastResizeWidthRef.current = newWidth;

      if ((selectedColumns === null || selectedColumns === void 0 ? void 0 : selectedColumns.first()) === resizeCol) {
        for (const c of selectedColumns) {
          var _col$growOffset3;

          if (c === resizeCol) continue;
          const col = columns[c];
          const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
          onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(col, s, c, s + ((_col$growOffset3 = col.growOffset) !== null && _col$growOffset3 !== void 0 ? _col$growOffset3 : 0));
        }
      }
    }
  }, [dragCol, dragStartX, dragRow, dragStartY, resizeCol, resizeColStartX, columns, minColumnWidth, maxColumnWidth, onColumnResize, selectedColumns, canvasRef]);
  const getMangledCellContent = react.useCallback((cell, forceStrict) => {
    if (dragRow === undefined || dropRow === undefined) return getCellContent(cell, forceStrict);
    let [col, row] = cell;

    if (row === dropRow) {
      row = dragRow;
    } else {
      if (row > dropRow) row -= 1;
      if (row >= dragRow) row += 1;
    }

    return getCellContent([col, row], forceStrict);
  }, [dragRow, dropRow, getCellContent]);
  const onDragStartImpl = react.useCallback(args => {
    onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(args);

    if (!args.defaultPrevented()) {
      clearAll();
    }
  }, [clearAll, onDragStart]);
  return react.createElement(data_grid/* default */.Z, {
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    enableGroups: p.enableGroups,
    eventTargetRef: p.eventTargetRef,
    experimental: p.experimental,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    headerIcons: p.headerIcons,
    height: p.height,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isDraggable: p.isDraggable,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDrop: p.onDrop,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    width: p.width,
    getCellContent: getMangledCellContent,
    isResizing: resizeCol !== undefined,
    onHeaderMenuClick: onHeaderMenuClickMangled,
    isDragging: dragColActive,
    onItemHovered: onItemHoveredImpl,
    onDragStart: onDragStartImpl,
    onMouseDown: onMouseDownImpl,
    allowResize: canResize,
    onMouseUp: onMouseUpImpl,
    dragAndDropState: dragOffset,
    onMouseMoveRaw: onMouseMove,
    ref: gridRef
  });
};

/* harmony default export */ const data_grid_dnd = (DataGridDnd);
;// CONCATENATED MODULE: ./packages/core/src/common/resize-detector.ts

function useResizeDetector(initialSize) {
  const ref = (0,react.useRef)(null);
  const [size, setSize] = (0,react.useState)({
    width: initialSize === null || initialSize === void 0 ? void 0 : initialSize[0],
    height: initialSize === null || initialSize === void 0 ? void 0 : initialSize[1]
  });
  (0,react.useLayoutEffect)(() => {
    const resizeCallback = entries => {
      for (const entry of entries) {
        const {
          width,
          height
        } = entry && entry.contentRect || {};
        setSize(cv => cv.width === width && cv.height === height ? cv : {
          width,
          height
        });
      }
    };

    const resizeObserver = new window.ResizeObserver(resizeCallback);

    if (ref.current) {
      resizeObserver.observe(ref.current, undefined);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [ref.current]);
  return {
    ref,
    ...size
  };
}
// EXTERNAL MODULE: ./packages/core/src/common/browser-detect.ts
var browser_detect = __webpack_require__("./packages/core/src/common/browser-detect.ts");
// EXTERNAL MODULE: ./packages/core/src/common/utils.tsx
var utils = __webpack_require__("./packages/core/src/common/utils.tsx");
;// CONCATENATED MODULE: ./packages/core/src/scrolling-data-grid/infinite-scroller.tsx






const _exp = () => p => p.isSafari ? "scroll" : "auto";

const ScrollRegionStyle = (0,styled/* default */.Z)('div')({
  name: "ScrollRegionStyle",
  class: "s3se5hb",
  vars: {
    "s3se5hb-0": [_exp()]
  }
});

function eatEvent(e) {
  e.stopPropagation();
}

function useTouchUpDelayed(delay) {
  const [hasTouches, setHasTouches] = react.useState(false);
  const cbTimer = react.useRef(0);
  (0,utils/* useEventListener */.OR)("touchstart", react.useCallback(() => {
    window.clearTimeout(cbTimer.current);
    setHasTouches(true);
  }, []), window, true, false);
  (0,utils/* useEventListener */.OR)("touchend", react.useCallback(e => {
    if (e.touches.length === 0) {
      cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);
    }
  }, [delay]), window, true, false);
  return hasTouches;
}

const InfiniteScroller = p => {
  var _rightElementProps$st, _rightElementProps$fi, _lastProps$current, _lastProps$current2;

  const {
    children,
    clientHeight,
    scrollHeight,
    scrollWidth,
    update,
    draggable,
    className,
    preventDiagonalScrolling = false,
    paddingBottom = 0,
    paddingRight = 0,
    rightElement,
    rightElementProps,
    scrollRef,
    scrollToEnd,
    initialSize,
    minimap
  } = p;
  const padders = [];
  const rightElementSticky = (_rightElementProps$st = rightElementProps === null || rightElementProps === void 0 ? void 0 : rightElementProps.sticky) !== null && _rightElementProps$st !== void 0 ? _rightElementProps$st : false;
  const rightElementFill = (_rightElementProps$fi = rightElementProps === null || rightElementProps === void 0 ? void 0 : rightElementProps.fill) !== null && _rightElementProps$fi !== void 0 ? _rightElementProps$fi : false;
  const offsetY = react.useRef(0);
  const lastScrollY = react.useRef(0);
  const scroller = react.useRef(null);
  const dpr = window.devicePixelRatio;
  react.useEffect(() => {
    const el = scroller.current;
    if (el === null || scrollToEnd !== true) return;
    el.scrollLeft = el.scrollWidth - el.clientWidth;
  }, [scrollToEnd]);
  const lastScrollPosition = react.useRef({
    scrollLeft: 0,
    scrollTop: 0,
    lockDirection: undefined
  });
  const rightWrapRef = react.useRef(null);
  const hasTouches = useTouchUpDelayed(200);
  const [isIdle, setIsIdle] = react.useState(true);
  const idleTimer = react.useRef(0);
  react.useEffect(() => {
    if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === undefined) return;
    const el = scroller.current;
    if (el === null) return;
    const [lx, ly] = lastScrollPosition.current.lockDirection;

    if (lx !== undefined) {
      el.scrollLeft = lx;
    } else if (ly !== undefined) {
      el.scrollTop = ly;
    }

    lastScrollPosition.current.lockDirection = undefined;
  }, [hasTouches, isIdle]);
  const onScroll = react.useCallback(() => {
    var _lock$, _lock$2, _rightWrapRef$current, _rightWrapRef$current2;

    const el = scroller.current;
    if (el === null) return;
    let scrollTop = el.scrollTop;
    let scrollLeft = el.scrollLeft;
    const lastScrollTop = lastScrollPosition.current.scrollTop;
    const lastScrollLeft = lastScrollPosition.current.scrollLeft;
    const dx = scrollLeft - lastScrollLeft;
    const dy = scrollTop - lastScrollTop;

    if (hasTouches && dx !== 0 && dy !== 0 && (Math.abs(dx) > 3 || Math.abs(dy) > 3) && preventDiagonalScrolling && lastScrollPosition.current.lockDirection === undefined) {
      lastScrollPosition.current.lockDirection = Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, undefined] : [undefined, lastScrollTop];
    }

    const lock = lastScrollPosition.current.lockDirection;
    scrollLeft = (_lock$ = lock === null || lock === void 0 ? void 0 : lock[0]) !== null && _lock$ !== void 0 ? _lock$ : scrollLeft;
    scrollTop = (_lock$2 = lock === null || lock === void 0 ? void 0 : lock[1]) !== null && _lock$2 !== void 0 ? _lock$2 : scrollTop;
    lastScrollPosition.current.scrollLeft = scrollLeft;
    lastScrollPosition.current.scrollTop = scrollTop;
    const newY = scrollTop;
    const delta = lastScrollY.current - newY;
    const scrollableHeight = el.scrollHeight - el.clientHeight;
    lastScrollY.current = newY;

    if (scrollableHeight > 0 && (Math.abs(delta) > 2000 || newY === 0 || newY === scrollableHeight) && scrollHeight > el.scrollHeight + 5) {
      const prog = newY / scrollableHeight;
      const recomputed = (scrollHeight - el.clientHeight) * prog;
      offsetY.current = recomputed - newY;
    }

    if (lock !== undefined) {
      window.clearTimeout(idleTimer.current);
      setIsIdle(false);
      idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);
    }

    update({
      x: scrollLeft,
      y: newY + offsetY.current,
      width: el.clientWidth - paddingRight,
      height: el.clientHeight - paddingBottom,
      paddingRight: (_rightWrapRef$current = (_rightWrapRef$current2 = rightWrapRef.current) === null || _rightWrapRef$current2 === void 0 ? void 0 : _rightWrapRef$current2.clientWidth) !== null && _rightWrapRef$current !== void 0 ? _rightWrapRef$current : 0
    });
  }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);
  const onScrollRef = react.useRef(onScroll);
  onScrollRef.current = onScroll;
  const lastProps = react.useRef();
  const didFirstScroll = react.useRef(false);
  react.useEffect(() => {
    if (didFirstScroll.current) onScroll();else didFirstScroll.current = true;
  }, [onScroll, paddingBottom, paddingRight]);
  const setRefs = react.useCallback(instance => {
    scroller.current = instance;

    if (scrollRef !== undefined) {
      scrollRef.current = instance;
    }
  }, [scrollRef]);
  let key = 0;
  let h = 0;
  padders.push(react.createElement("div", {
    key: key++,
    style: {
      width: scrollWidth,
      height: 0
    }
  }));

  while (h < scrollHeight) {
    const toAdd = Math.min(5000000, scrollHeight - h);
    padders.push(react.createElement("div", {
      key: key++,
      style: {
        width: 0,
        height: toAdd
      }
    }));
    h += toAdd;
  }

  const {
    ref,
    width,
    height
  } = useResizeDetector(initialSize);

  if (((_lastProps$current = lastProps.current) === null || _lastProps$current === void 0 ? void 0 : _lastProps$current.height) !== height || ((_lastProps$current2 = lastProps.current) === null || _lastProps$current2 === void 0 ? void 0 : _lastProps$current2.width) !== width) {
    window.setTimeout(() => onScrollRef.current(), 0);
    lastProps.current = {
      width,
      height
    };
  }

  if ((width !== null && width !== void 0 ? width : 0) === 0 || (height !== null && height !== void 0 ? height : 0) === 0) return react.createElement("div", {
    ref: ref
  });
  return react.createElement("div", {
    ref: ref
  }, react.createElement(ScrollRegionStyle, {
    isSafari: browser_detect/* browserIsSafari.value */.Pq.value
  }, minimap, react.createElement("div", {
    className: "dvn-underlay"
  }, children), react.createElement("div", {
    ref: setRefs,
    style: lastProps.current,
    draggable: draggable,
    onDragStart: e => {
      if (!draggable) {
        e.stopPropagation();
        e.preventDefault();
      }
    },
    className: "dvn-scroller " + (className !== null && className !== void 0 ? className : ""),
    onScroll: onScroll
  }, react.createElement("div", {
    className: "dvn-scroll-inner" + (rightElement === undefined ? " hidden" : "")
  }, react.createElement("div", {
    className: "dvn-stack"
  }, padders), rightElement !== undefined && react.createElement(react.Fragment, null, !rightElementFill && react.createElement("div", {
    className: "dvn-spacer"
  }), react.createElement("div", {
    ref: rightWrapRef,
    onMouseDown: eatEvent,
    onMouseUp: eatEvent,
    onMouseMove: eatEvent,
    style: {
      height,
      maxHeight: clientHeight - Math.ceil(dpr % 1),
      position: "sticky",
      top: 0,
      paddingLeft: 1,
      marginBottom: -40,
      marginRight: paddingRight,
      flexGrow: rightElementFill ? 1 : undefined,
      right: rightElementSticky ? paddingRight !== null && paddingRight !== void 0 ? paddingRight : 0 : undefined,
      pointerEvents: "auto"
    }
  }, rightElement))))));
};

__webpack_require__("./packages/core/src/scrolling-data-grid/infinite-scroller.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/infinite-scroller.tsx");
;// CONCATENATED MODULE: ./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx





const MinimapStyle = (0,styled/* default */.Z)('div')({
  name: "MinimapStyle",
  class: "m3brspx"
});

const GridScroller = p => {
  var _scrollRef$current, _scroller$scrollLeft, _scroller$scrollTop;

  const {
    columns,
    rows,
    rowHeight,
    headerHeight,
    groupHeaderHeight,
    enableGroups,
    freezeColumns,
    experimental,
    clientSize,
    className,
    onVisibleRegionChanged,
    scrollToEnd,
    scrollRef,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    overscrollX,
    overscrollY,
    showMinimap = false,
    initialSize,
    smoothScrollX = false,
    smoothScrollY = false,
    isDraggable
  } = p;
  const {
    paddingRight,
    paddingBottom
  } = experimental !== null && experimental !== void 0 ? experimental : {};
  const [clientWidth, clientHeight] = clientSize;
  const last = react.useRef();
  const lastX = react.useRef();
  const lastY = react.useRef();
  const lastSize = react.useRef();
  const width = react.useMemo(() => {
    let r = Math.max(0, overscrollX !== null && overscrollX !== void 0 ? overscrollX : 0);

    for (const c of columns) {
      r += c.width;
    }

    return r;
  }, [columns, overscrollX]);
  let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;

  if (typeof rowHeight === "number") {
    height += rows * rowHeight;
  } else {
    for (let r = 0; r < rows; r++) {
      height += rowHeight(r);
    }
  }

  if (overscrollY !== undefined) {
    height += overscrollY;
  }

  const lastArgs = react.useRef();
  const processArgs = react.useCallback(() => {
    var _lastSize$current, _lastSize$current2;

    if (lastArgs.current === undefined) return;
    const args = { ...lastArgs.current
    };
    let x = 0;
    let tx = args.x < 0 ? -args.x : 0;
    let cellRight = 0;
    let cellX = 0;
    args.x = args.x < 0 ? 0 : args.x;
    let stickyColWidth = 0;

    for (let i = 0; i < freezeColumns; i++) {
      stickyColWidth += columns[i].width;
    }

    for (const c of columns) {
      const cx = x - stickyColWidth;

      if (args.x >= cx + c.width) {
        x += c.width;
        cellX++;
        cellRight++;
      } else if (args.x > cx) {
        x += c.width;

        if (smoothScrollX) {
          tx += cx - args.x;
        } else {
          cellX++;
        }

        cellRight++;
      } else if (args.x + args.width > cx) {
        x += c.width;
        cellRight++;
      } else {
        break;
      }
    }

    let ty = 0;
    let cellY = 0;
    let cellBottom = 0;

    if (typeof rowHeight === "number") {
      if (smoothScrollY) {
        cellY = Math.floor(args.y / rowHeight);
        ty = cellY * rowHeight - args.y;
      } else {
        cellY = Math.ceil(args.y / rowHeight);
      }

      cellBottom = Math.ceil(args.height / rowHeight) + cellY;
      if (ty < 0) cellBottom++;
    } else {
      let y = 0;

      for (let row = 0; row < rows; row++) {
        const rh = rowHeight(row);
        const cy = y + (smoothScrollY ? 0 : rh / 2);

        if (args.y >= y + rh) {
          y += rh;
          cellY++;
          cellBottom++;
        } else if (args.y > cy) {
          y += rh;

          if (smoothScrollY) {
            ty += cy - args.y;
          } else {
            cellY++;
          }

          cellBottom++;
        } else if (args.y + args.height > rh / 2 + y) {
          y += rh;
          cellBottom++;
        } else {
          break;
        }
      }
    }

    const rect = {
      x: cellX,
      y: cellY,
      width: cellRight - cellX,
      height: cellBottom - cellY
    };
    const oldRect = last.current;

    if (oldRect === undefined || oldRect.y !== rect.y || oldRect.x !== rect.x || oldRect.height !== rect.height || oldRect.width !== rect.width || lastX.current !== tx || lastY.current !== ty || args.width !== ((_lastSize$current = lastSize.current) === null || _lastSize$current === void 0 ? void 0 : _lastSize$current[0]) || args.height !== ((_lastSize$current2 = lastSize.current) === null || _lastSize$current2 === void 0 ? void 0 : _lastSize$current2[1])) {
      var _args$paddingRight;

      onVisibleRegionChanged === null || onVisibleRegionChanged === void 0 ? void 0 : onVisibleRegionChanged({
        x: cellX,
        y: cellY,
        width: cellRight - cellX,
        height: cellBottom - cellY
      }, args.width, args.height, (_args$paddingRight = args.paddingRight) !== null && _args$paddingRight !== void 0 ? _args$paddingRight : 0, tx, ty);
      last.current = rect;
      lastX.current = tx;
      lastY.current = ty;
      lastSize.current = [args.width, args.height];
    }
  }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);
  const onScrollUpdate = react.useCallback(args => {
    lastArgs.current = args;
    processArgs();
  }, [processArgs]);
  react.useEffect(() => {
    processArgs();
  }, [processArgs]);
  const scroller = (_scrollRef$current = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) !== null && _scrollRef$current !== void 0 ? _scrollRef$current : undefined;
  const aspect = clamp_default()(width / height, 2 / 3, 1.5);
  const maxSize = 200;
  const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);
  const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;
  const hRatio = w / width;
  const vRatio = h / height;
  const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);
  const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);
  const left = ((_scroller$scrollLeft = scroller === null || scroller === void 0 ? void 0 : scroller.scrollLeft) !== null && _scroller$scrollLeft !== void 0 ? _scroller$scrollLeft : 0) / (width - clientWidth) * (w - vWidth);
  const top = ((_scroller$scrollTop = scroller === null || scroller === void 0 ? void 0 : scroller.scrollTop) !== null && _scroller$scrollTop !== void 0 ? _scroller$scrollTop : 0) / (height - clientHeight) * (h - vHeight);
  const minimap = react.useMemo(() => {
    if (!showMinimap || vWidth === 0 || vHeight === 0) return undefined;

    const handleMouse = e => {
      if (scroller === undefined) return;
      const bounds = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - bounds.x - vWidth / 2;
      const y = e.clientY - bounds.y - vHeight / 2;
      const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));
      const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));
      scroller.scrollTo({
        left: newScrollLeft,
        top: newScrollTop,
        behavior: e.type === "mousemove" ? "auto" : "smooth"
      });
    };

    return react.createElement(MinimapStyle, {
      style: {
        width: w,
        height: h
      },
      "data-testid": "minimap-container",
      onMouseMove: e => {
        if (e.buttons !== 1) return;
        handleMouse(e);
      },
      onClick: handleMouse
    }, react.createElement("div", {
      className: "header"
    }), react.createElement("div", {
      className: "locationMarker",
      onDragStart: e => e.preventDefault(),
      style: {
        left,
        top,
        width: vWidth,
        height: vHeight,
        borderRadius: Math.min(vWidth, vHeight * 0.2, 9)
      }
    }));
  }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);
  return react.createElement(InfiniteScroller, {
    scrollRef: scrollRef,
    minimap: minimap,
    className: className,
    preventDiagonalScrolling: preventDiagonalScrolling,
    draggable: isDraggable === true || typeof isDraggable === "string",
    scrollWidth: width + (paddingRight !== null && paddingRight !== void 0 ? paddingRight : 0),
    scrollHeight: height + (paddingBottom !== null && paddingBottom !== void 0 ? paddingBottom : 0),
    clientHeight: clientHeight,
    rightElement: rightElement,
    paddingBottom: paddingBottom,
    paddingRight: paddingRight,
    rightElementProps: rightElementProps,
    update: onScrollUpdate,
    initialSize: initialSize,
    scrollToEnd: scrollToEnd
  }, react.createElement(data_grid_dnd, {
    eventTargetRef: scrollRef,
    width: clientWidth,
    height: clientHeight,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY
  }));
};

/* harmony default export */ const scrolling_data_grid = (GridScroller);

__webpack_require__("./packages/core/src/scrolling-data-grid/scrolling-data-grid.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx");

/***/ }),

/***/ "./packages/core/src/stories/story-utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* binding */ SimpleThemeWrapper),
/* harmony export */   "j": () => (/* binding */ BuilderThemeWrapper)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var react_responsive_carousel_lib_styles_carousel_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react-responsive-carousel/lib/styles/carousel.min.css");




const _exp = () => p => p.width;

const _exp2 = () => p => p.height;

const BuilderWrapper = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('div')({
  name: "BuilderWrapper",
  class: "bheiboo",
  vars: {
    "bheiboo-0": [_exp(), "px"],
    "bheiboo-1": [_exp2(), "px"]
  }
});
const SimpleWrapper = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('div')({
  name: "SimpleWrapper",
  class: "s15ez7jv"
});
class BuilderThemeWrapper extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      context,
      children,
      ...rest
    } = this.props;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(BuilderWrapper, rest, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "content"
    }, children)), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      id: "portal"
    }));
  }

}
const SimpleThemeWrapper = p => {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SimpleWrapper, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "content"
  }, p.children));
};

__webpack_require__("./packages/core/src/stories/story-utils.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/stories/story-utils.tsx");

/***/ }),

/***/ "./storybook-init-framework-entry.js":
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _storybook_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/react/dist/esm/client/index.js");


/***/ }),

/***/ "./. sync recursive ^\\.(?:(?:^%7C\\/%7C(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/)src(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.tsx)$":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./packages/cells/src/cell.stories.tsx": "./packages/cells/src/cell.stories.tsx",
	"./packages/core/src/data-editor/stories/data-editor-async.stories.tsx": "./packages/core/src/data-editor/stories/data-editor-async.stories.tsx",
	"./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx": "./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx",
	"./packages/core/src/data-editor/stories/data-editor.stories.tsx": "./packages/core/src/data-editor/stories/data-editor.stories.tsx",
	"./packages/core/src/data-grid/data-grid.stories.tsx": "./packages/core/src/data-grid/data-grid.stories.tsx",
	"./packages/core/src/docs/00-faq.stories.tsx": "./packages/core/src/docs/00-faq.stories.tsx",
	"./packages/core/src/docs/01-getting-started.stories.tsx": "./packages/core/src/docs/01-getting-started.stories.tsx",
	"./packages/core/src/docs/02-editing-data.stories.tsx": "./packages/core/src/docs/02-editing-data.stories.tsx",
	"./packages/core/src/docs/03-grid-column.stories.tsx": "./packages/core/src/docs/03-grid-column.stories.tsx",
	"./packages/core/src/docs/04-streaming-data.stories.tsx": "./packages/core/src/docs/04-streaming-data.stories.tsx",
	"./packages/core/src/docs/05-copy-paste.stories.tsx": "./packages/core/src/docs/05-copy-paste.stories.tsx.tsx",
	"./packages/core/src/docs/06-search.stories.tsx": "./packages/core/src/docs/06-search.stories.tsx",
	"./packages/core/src/docs/07-column-grouping.stories.tsx": "./packages/core/src/docs/07-column-grouping.stories.tsx",
	"./packages/core/src/docs/08-theming.stories.tsx": "./packages/core/src/docs/08-theming.stories.tsx",
	"./packages/core/src/docs/09-menus.stories.tsx": "./packages/core/src/docs/09-menus.stories.tsx",
	"./packages/core/src/docs/examples/add-column.stories.tsx": "./packages/core/src/docs/examples/add-column.stories.tsx",
	"./packages/core/src/docs/examples/add-data-to-middle.stories.tsx": "./packages/core/src/docs/examples/add-data-to-middle.stories.tsx",
	"./packages/core/src/docs/examples/add-data-to-top.stories.tsx": "./packages/core/src/docs/examples/add-data-to-top.stories.tsx",
	"./packages/core/src/docs/examples/add-data.stories.tsx": "./packages/core/src/docs/examples/add-data.stories.tsx",
	"./packages/core/src/docs/examples/all-cell-kinds.stories.tsx": "./packages/core/src/docs/examples/all-cell-kinds.stories.tsx",
	"./packages/core/src/docs/examples/append-row-handle.stories.tsx": "./packages/core/src/docs/examples/append-row-handle.stories.tsx",
	"./packages/core/src/docs/examples/automatic-row-markers.stories.tsx": "./packages/core/src/docs/examples/automatic-row-markers.stories.tsx",
	"./packages/core/src/docs/examples/built-in-search.stories.tsx": "./packages/core/src/docs/examples/built-in-search.stories.tsx",
	"./packages/core/src/docs/examples/cell-activated-event.stories.tsx": "./packages/core/src/docs/examples/cell-activated-event.stories.tsx",
	"./packages/core/src/docs/examples/column-group-collapse.stories.tsx": "./packages/core/src/docs/examples/column-group-collapse.stories.tsx",
	"./packages/core/src/docs/examples/column-groups.stories.tsx": "./packages/core/src/docs/examples/column-groups.stories.tsx",
	"./packages/core/src/docs/examples/content-alignment.stories.tsx": "./packages/core/src/docs/examples/content-alignment.stories.tsx",
	"./packages/core/src/docs/examples/controlled-selection.stories.tsx": "./packages/core/src/docs/examples/controlled-selection.stories.tsx",
	"./packages/core/src/docs/examples/copy-support.stories.tsx": "./packages/core/src/docs/examples/copy-support.stories.tsx",
	"./packages/core/src/docs/examples/custom-header-icons.stories.tsx": "./packages/core/src/docs/examples/custom-header-icons.stories.tsx",
	"./packages/core/src/docs/examples/custom-header.stories.tsx": "./packages/core/src/docs/examples/custom-header.stories.tsx",
	"./packages/core/src/docs/examples/drag-source.stories.tsx": "./packages/core/src/docs/examples/drag-source.stories.tsx",
	"./packages/core/src/docs/examples/draw-custom-cells.stories.tsx": "./packages/core/src/docs/examples/draw-custom-cells.stories.tsx",
	"./packages/core/src/docs/examples/drop-events.stories.tsx": "./packages/core/src/docs/examples/drop-events.stories.tsx",
	"./packages/core/src/docs/examples/fill-handle.stories.tsx": "./packages/core/src/docs/examples/fill-handle.stories.tsx",
	"./packages/core/src/docs/examples/freeze-columns.stories.tsx": "./packages/core/src/docs/examples/freeze-columns.stories.tsx",
	"./packages/core/src/docs/examples/header-menus.stories.tsx": "./packages/core/src/docs/examples/header-menus.stories.tsx",
	"./packages/core/src/docs/examples/highlight-cells.stories.tsx": "./packages/core/src/docs/examples/highlight-cells.stories.tsx",
	"./packages/core/src/docs/examples/imperative-scroll.stories.tsx": "./packages/core/src/docs/examples/imperative-scroll.stories.tsx",
	"./packages/core/src/docs/examples/input-blending.stories.tsx": "./packages/core/src/docs/examples/input-blending.stories.tsx",
	"./packages/core/src/docs/examples/layout-integration.stories.tsx": "./packages/core/src/docs/examples/layout-integration.stories.tsx",
	"./packages/core/src/docs/examples/minimap.stories.tsx": "./packages/core/src/docs/examples/minimap.stories.tsx",
	"./packages/core/src/docs/examples/multi-select-columns.stories.tsx": "./packages/core/src/docs/examples/multi-select-columns.stories.tsx",
	"./packages/core/src/docs/examples/new-column-button.stories.tsx": "./packages/core/src/docs/examples/new-column-button.stories.tsx",
	"./packages/core/src/docs/examples/observe-visible-region.stories.tsx": "./packages/core/src/docs/examples/observe-visible-region.stories.tsx",
	"./packages/core/src/docs/examples/one-hundred-thousand-columns.stories.tsx": "./packages/core/src/docs/examples/one-hundred-thousand-columns.stories.tsx",
	"./packages/core/src/docs/examples/one-million-rows.stories.tsx": "./packages/core/src/docs/examples/one-million-rows.stories.tsx",
	"./packages/core/src/docs/examples/overscroll.stories.tsx": "./packages/core/src/docs/examples/overscroll.stories.tsx",
	"./packages/core/src/docs/examples/padding.stories.tsx": "./packages/core/src/docs/examples/padding.stories.tsx",
	"./packages/core/src/docs/examples/paste-support.stories.tsx": "./packages/core/src/docs/examples/paste-support.stories.tsx",
	"./packages/core/src/docs/examples/prevent-diagonal-scroll.stories.tsx": "./packages/core/src/docs/examples/prevent-diagonal-scroll.stories.tsx",
	"./packages/core/src/docs/examples/rapid-updates.stories.tsx": "./packages/core/src/docs/examples/rapid-updates.stories.tsx",
	"./packages/core/src/docs/examples/rearrange-columns.stories.tsx": "./packages/core/src/docs/examples/rearrange-columns.stories.tsx",
	"./packages/core/src/docs/examples/reorder-rows.stories.tsx": "./packages/core/src/docs/examples/reorder-rows.stories.tsx",
	"./packages/core/src/docs/examples/resizable-columns.stories.tsx": "./packages/core/src/docs/examples/resizable-columns.stories.tsx",
	"./packages/core/src/docs/examples/right-element.stories.tsx": "./packages/core/src/docs/examples/right-element.stories.tsx",
	"./packages/core/src/docs/examples/right-to-left.stories.tsx": "./packages/core/src/docs/examples/right-to-left.stories.tsx",
	"./packages/core/src/docs/examples/row-and-header-sizes.stories.tsx": "./packages/core/src/docs/examples/row-and-header-sizes.stories.tsx",
	"./packages/core/src/docs/examples/row-hover.stories.tsx": "./packages/core/src/docs/examples/row-hover.stories.tsx",
	"./packages/core/src/docs/examples/scaled-view.stories.tsx": "./packages/core/src/docs/examples/scaled-view.stories.tsx",
	"./packages/core/src/docs/examples/scroll-shadows.stories.tsx": "./packages/core/src/docs/examples/scroll-shadows.stories.tsx",
	"./packages/core/src/docs/examples/silly-numbers.stories.tsx": "./packages/core/src/docs/examples/silly-numbers.stories.tsx",
	"./packages/core/src/docs/examples/small-editable-grid.stories.tsx": "./packages/core/src/docs/examples/small-editable-grid.stories.tsx",
	"./packages/core/src/docs/examples/smooth-scrolling-grid.stories.tsx": "./packages/core/src/docs/examples/smooth-scrolling-grid.stories.tsx",
	"./packages/core/src/docs/examples/span-cell.stories.tsx": "./packages/core/src/docs/examples/span-cell.stories.tsx",
	"./packages/core/src/docs/examples/stretch-column-size.stories.tsx": "./packages/core/src/docs/examples/stretch-column-size.stories.tsx",
	"./packages/core/src/docs/examples/ten-million-cells.stories.tsx": "./packages/core/src/docs/examples/ten-million-cells.stories.tsx",
	"./packages/core/src/docs/examples/theme-per-column.stories.tsx": "./packages/core/src/docs/examples/theme-per-column.stories.tsx",
	"./packages/core/src/docs/examples/theme-per-row.stories.tsx": "./packages/core/src/docs/examples/theme-per-row.stories.tsx",
	"./packages/core/src/docs/examples/theme-support.stories.tsx": "./packages/core/src/docs/examples/theme-support.stories.tsx",
	"./packages/core/src/docs/examples/tooltips.stories.tsx": "./packages/core/src/docs/examples/tooltips.stories.tsx",
	"./packages/core/src/docs/examples/trailing-row-options.stories.tsx": "./packages/core/src/docs/examples/trailing-row-options.stories.tsx",
	"./packages/core/src/docs/examples/uneven-rows.stories.tsx": "./packages/core/src/docs/examples/uneven-rows.stories.tsx",
	"./packages/core/src/docs/examples/validate-data.stories.tsx": "./packages/core/src/docs/examples/validate-data.stories.tsx",
	"./packages/core/src/docs/examples/wrapping-text.stories.tsx": "./packages/core/src/docs/examples/wrapping-text.stories.tsx",
	"./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx": "./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx",
	"./packages/source/src/stories/use-data-source.stories.tsx": "./packages/source/src/stories/use-data-source.stories.tsx"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./. sync recursive ^\\.(?:(?:^%7C\\/%7C(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/)src(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.tsx)$";

/***/ }),

/***/ "?4f7e":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./generated-stories-entry.cjs":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _frameworkImportPath = __webpack_require__("./node_modules/@storybook/react/dist/esm/client/index.js");

/* eslint-disable import/no-unresolved */
(0, _frameworkImportPath.configure)([__webpack_require__("./. sync recursive ^\\.(?:(?:^%7C\\/%7C(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/)src(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.tsx)$")], module, false);

/***/ }),

/***/ "./packages/core/dist/js/chunk-UM7QR3LO.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": () => (/* binding */ styled_default)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var memoize_browser_esm_default = memoize;
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var index = memoize_browser_esm_default(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
});
var is_prop_valid_browser_esm_default = index;


var cx = function cx2() {
  const presentClassNames = Array.prototype.slice.call(arguments).filter(Boolean);
  const atomicClasses = {};
  const nonAtomicClasses = [];
  presentClassNames.forEach(arg => {
    const individualClassNames = arg ? arg.split(" ") : [];
    individualClassNames.forEach(className => {
      if (className.startsWith("atm_")) {
        const [, keyHash] = className.split("_");
        atomicClasses[keyHash] = className;
      } else {
        nonAtomicClasses.push(className);
      }
    });
  });
  const result = [];

  for (const keyHash in atomicClasses) {
    if (Object.prototype.hasOwnProperty.call(atomicClasses, keyHash)) {
      result.push(atomicClasses[keyHash]);
    }
  }

  result.push(...nonAtomicClasses);
  return result.join(" ");
};

var cx_default = cx;

var isCapital = ch => ch.toUpperCase() === ch;

var filterKey = keys => key => keys.indexOf(key) === -1;

var omit = (obj, keys) => {
  const res = {};
  Object.keys(obj).filter(filterKey(keys)).forEach(key => {
    res[key] = obj[key];
  });
  return res;
};

function filterProps(component, props, omitKeys) {
  const filteredProps = omit(props, omitKeys);

  if (typeof component === "string" && component.indexOf("-") === -1 && !isCapital(component[0])) {
    Object.keys(filteredProps).forEach(key => {
      if (!is_prop_valid_browser_esm_default(key)) {
        delete filteredProps[key];
      }
    });
  }

  return filteredProps;
}

var warnIfInvalid = (value, componentName) => {
  if (true) {
    if (typeof value === "string" || typeof value === "number" && isFinite(value)) {
      return;
    }

    const stringified = typeof value === "object" ? JSON.stringify(value) : String(value);
    console.warn(`An interpolation evaluated to '${stringified}' in the component '${componentName}', which is probably a mistake. You should explicitly cast or transform the value to a string.`);
  }
};

function styled(tag) {
  return options => {
    if (true) {
      if (Array.isArray(options)) {
        throw new Error('Using the "styled" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup');
      }
    }

    const render = (props, ref) => {
      const {
        as: component = tag,
        class: className
      } = props;
      const filteredProps = filterProps(component, props, ["as", "class"]);
      filteredProps.ref = ref;
      filteredProps.className = options.atomic ? cx_default(options.class, filteredProps.className || className) : cx_default(filteredProps.className || className, options.class);
      const {
        vars
      } = options;

      if (vars) {
        const style = {};

        for (const name in vars) {
          const variable = vars[name];
          const result = variable[0];
          const unit = variable[1] || "";
          const value = typeof result === "function" ? result(props) : result;
          warnIfInvalid(value, options.name);
          style[`--${name}`] = `${value}${unit}`;
        }

        const ownStyle = filteredProps.style || {};
        const keys = Object.keys(ownStyle);

        if (keys.length > 0) {
          keys.forEach(key => {
            style[key] = ownStyle[key];
          });
        }

        filteredProps.style = style;
      }

      if (tag.__linaria && tag !== component) {
        filteredProps.as = component;
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(tag, filteredProps);
      }

      return react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, filteredProps);
    };

    const Result = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef ? react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(render) : props => {
      const rest = omit(props, ["innerRef"]);
      return render(rest, props.innerRef);
    };
    Result.displayName = options.name;
    Result.__linaria = {
      className: options.class,
      extends: tag
    };
    return Result;
  };
}

var styled_default =  true ? new Proxy(styled, {
  get(o, prop) {
    return o(prop);
  }

}) : 0;


/***/ }),

/***/ "./packages/core/dist/js/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Fg": () => (/* binding */ useTheme),
/* harmony export */   "NH": () => (/* binding */ blend),
/* harmony export */   "Nd": () => (/* binding */ DataEditor),
/* harmony export */   "Nz": () => (/* binding */ interpolateColors),
/* harmony export */   "P7": () => (/* binding */ measureTextCached),
/* harmony export */   "PE": () => (/* binding */ GridColumnIcon),
/* harmony export */   "R$": () => (/* binding */ useCustomCells),
/* harmony export */   "T9": () => (/* binding */ isEditableGridCell),
/* harmony export */   "aX": () => (/* binding */ getMiddleCenterBias),
/* harmony export */   "dF": () => (/* binding */ parseToRgba),
/* harmony export */   "f": () => (/* binding */ isTextEditableGridCell),
/* harmony export */   "p6": () => (/* binding */ GridCellKind),
/* harmony export */   "t5": () => (/* binding */ GrowingEntry),
/* harmony export */   "uN": () => (/* binding */ drawTextCellExternal)
/* harmony export */ });
/* unused harmony exports BooleanEmpty, BooleanIndeterminate, CompactSelection, ImageOverlayEditor, InnerGridCellKind, MarkdownDiv, booleanCellIsEditable, default, getDefaultTheme, gridSelectionHasItem, groupHeaderKind, headerCellCheckboxPrefix, headerCellCheckedMarker, headerCellIndeterminateMarker, headerCellUnheckedMarker, headerKind, isInnerOnlyCell, isObjectEditorCallbackResult, isReadWriteCell, isSizedGridColumn, outOfBoundsKind, resolveCellsThunk, useColumnSizer, withAlpha */
/* harmony import */ var _chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/core/dist/js/chunk-UM7QR3LO.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash/clamp.js");
/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/lodash/uniq.js");
/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/lodash/flatten.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/lodash/range.js");
/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/lodash/debounce.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/react-dom/index.js");
/* harmony import */ var lodash_has_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/lodash/has.js");
/* harmony import */ var lodash_throttle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/lodash/throttle.js");
/* harmony import */ var canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/canvas-hypertxt/dist/js/index.js");
/* harmony import */ var lodash_groupBy_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/lodash/groupBy.js");
/* harmony import */ var react_responsive_carousel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/react-responsive-carousel/lib/js/index.js");
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/marked/lib/marked.esm.js");



function proveType(_val) {}

function panic() {
  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "This should not happen";
  throw new Error(message);
}

function assert(fact) {
  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";
  if (fact) return;
  return panic(message);
}

function assertNever(_never) {
  return panic("Hell froze over");
}

function maybe(fn, defaultValue) {
  try {
    return fn();
  } catch (e) {
    return defaultValue;
  }
}

var has = Object.prototype.hasOwnProperty;

function deepEqual(foo, bar) {
  let ctor, len;
  if (foo === bar) return true;

  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();

    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && deepEqual(foo[len], bar[len]));
      }

      return len === -1;
    }

    if (!ctor || typeof foo === "object") {
      len = 0;

      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !deepEqual(foo[ctor], bar[ctor])) return false;
      }

      return Object.keys(bar).length === len;
    }
  }

  return foo !== foo && bar !== bar;
}









var ClickOutsideContainer = class extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor() {
    super(...arguments);
    this.wrapperRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();

    this.clickOutside = event => {
      if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target)) {
        let node = event.target;

        while (node !== null) {
          if (node.classList.contains("click-outside-ignore")) {
            return;
          }

          node = node.parentElement;
        }

        this.props.onClickOutside();
      }
    };
  }

  componentDidMount() {
    document.addEventListener("mousedown", this.clickOutside, true);
    document.addEventListener("contextmenu", this.clickOutside, true);
  }

  componentWillUnmount() {
    document.removeEventListener("mousedown", this.clickOutside);
    document.removeEventListener("contextmenu", this.clickOutside);
  }

  render() {
    const {
      onClickOutside,
      ...rest
    } = this.props;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ...rest,
      ref: this.wrapperRef
    }, this.props.children);
  }

};


function makeCSSStyle(theme) {
  var _a, _b;

  return {
    "--gdg-accent-color": theme.accentColor,
    "--gdg-accent-fg": theme.accentFg,
    "--gdg-accent-light": theme.accentLight,
    "--gdg-text-dark": theme.textDark,
    "--gdg-text-medium": theme.textMedium,
    "--gdg-text-light": theme.textLight,
    "--gdg-text-bubble": theme.textBubble,
    "--gdg-bg-icon-header": theme.bgIconHeader,
    "--gdg-fg-icon-header": theme.fgIconHeader,
    "--gdg-text-header": theme.textHeader,
    "--gdg-text-group-header": (_a = theme.textGroupHeader) != null ? _a : theme.textHeader,
    "--gdg-text-header-selected": theme.textHeaderSelected,
    "--gdg-bg-cell": theme.bgCell,
    "--gdg-bg-cell-medium": theme.bgCellMedium,
    "--gdg-bg-header": theme.bgHeader,
    "--gdg-bg-header-has-focus": theme.bgHeaderHasFocus,
    "--gdg-bg-header-hovered": theme.bgHeaderHovered,
    "--gdg-bg-bubble": theme.bgBubble,
    "--gdg-bg-bubble-selected": theme.bgBubbleSelected,
    "--gdg-bg-search-result": theme.bgSearchResult,
    "--gdg-border-color": theme.borderColor,
    "--gdg-horizontal-border-color": (_b = theme.horizontalBorderColor) != null ? _b : theme.borderColor,
    "--gdg-drilldown-border": theme.drilldownBorder,
    "--gdg-link-color": theme.linkColor,
    "--gdg-cell-horizontal-padding": `${theme.cellHorizontalPadding}px`,
    "--gdg-cell-vertical-padding": `${theme.cellVerticalPadding}px`,
    "--gdg-header-font-style": theme.headerFontStyle,
    "--gdg-base-font-style": theme.baseFontStyle,
    "--gdg-font-family": theme.fontFamily,
    "--gdg-editor-font-size": theme.editorFontSize
  };
}

var dataEditorBaseTheme = {
  accentColor: "#4F5DFF",
  accentFg: "#FFFFFF",
  accentLight: "rgba(62, 116, 253, 0.1)",
  textDark: "#313139",
  textMedium: "#737383",
  textLight: "#B2B2C0",
  textBubble: "#313139",
  bgIconHeader: "#737383",
  fgIconHeader: "#FFFFFF",
  textHeader: "#313139",
  textGroupHeader: "#313139BB",
  textHeaderSelected: "#FFFFFF",
  bgCell: "#FFFFFF",
  bgCellMedium: "#FAFAFB",
  bgHeader: "#F7F7F8",
  bgHeaderHasFocus: "#E9E9EB",
  bgHeaderHovered: "#EFEFF1",
  bgBubble: "#EDEDF3",
  bgBubbleSelected: "#FFFFFF",
  bgSearchResult: "#fff9e3",
  borderColor: "rgba(115, 116, 131, 0.16)",
  drilldownBorder: "rgba(0, 0, 0, 0)",
  linkColor: "#4F5DFF",
  cellHorizontalPadding: 8,
  cellVerticalPadding: 3,
  headerIconSize: 18,
  headerFontStyle: "600 13px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif",
  editorFontSize: "13px",
  lineHeight: 1.4
};

function getDataEditorTheme() {
  return dataEditorBaseTheme;
}

var ThemeContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(dataEditorBaseTheme);

function useTheme() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(ThemeContext);
}



function gridSelectionHasItem(sel, item) {
  const [col, row] = item;
  if (sel.columns.hasIndex(col) || sel.rows.hasIndex(row)) return true;

  if (sel.current !== void 0) {
    if (sel.current.cell[0] === col && sel.current.cell[1] === row) return true;
    const toCheck = [sel.current.range, ...sel.current.rangeStack];

    for (const r of toCheck) {
      if (col >= r.x && col < r.x + r.width && row >= r.y && row < r.y + r.height) return true;
    }
  }

  return false;
}

var BooleanEmpty = null;
var BooleanIndeterminate = void 0;
var headerKind = "header";
var groupHeaderKind = "group-header";
var outOfBoundsKind = "out-of-bounds";
var GridCellKind;

(function (GridCellKind2) {
  GridCellKind2["Uri"] = "uri";
  GridCellKind2["Text"] = "text";
  GridCellKind2["Image"] = "image";
  GridCellKind2["RowID"] = "row-id";
  GridCellKind2["Number"] = "number";
  GridCellKind2["Bubble"] = "bubble";
  GridCellKind2["Boolean"] = "boolean";
  GridCellKind2["Loading"] = "loading";
  GridCellKind2["Markdown"] = "markdown";
  GridCellKind2["Drilldown"] = "drilldown";
  GridCellKind2["Protected"] = "protected";
  GridCellKind2["Custom"] = "custom";
})(GridCellKind || (GridCellKind = {}));

var GridColumnIcon;

(function (GridColumnIcon2) {
  GridColumnIcon2["HeaderRowID"] = "headerRowID";
  GridColumnIcon2["HeaderCode"] = "headerCode";
  GridColumnIcon2["HeaderNumber"] = "headerNumber";
  GridColumnIcon2["HeaderString"] = "headerString";
  GridColumnIcon2["HeaderBoolean"] = "headerBoolean";
  GridColumnIcon2["HeaderAudioUri"] = "headerAudioUri";
  GridColumnIcon2["HeaderVideoUri"] = "headerVideoUri";
  GridColumnIcon2["HeaderEmoji"] = "headerEmoji";
  GridColumnIcon2["HeaderImage"] = "headerImage";
  GridColumnIcon2["HeaderUri"] = "headerUri";
  GridColumnIcon2["HeaderPhone"] = "headerPhone";
  GridColumnIcon2["HeaderMarkdown"] = "headerMarkdown";
  GridColumnIcon2["HeaderDate"] = "headerDate";
  GridColumnIcon2["HeaderTime"] = "headerTime";
  GridColumnIcon2["HeaderEmail"] = "headerEmail";
  GridColumnIcon2["HeaderReference"] = "headerReference";
  GridColumnIcon2["HeaderIfThenElse"] = "headerIfThenElse";
  GridColumnIcon2["HeaderSingleValue"] = "headerSingleValue";
  GridColumnIcon2["HeaderLookup"] = "headerLookup";
  GridColumnIcon2["HeaderTextTemplate"] = "headerTextTemplate";
  GridColumnIcon2["HeaderMath"] = "headerMath";
  GridColumnIcon2["HeaderRollup"] = "headerRollup";
  GridColumnIcon2["HeaderJoinStrings"] = "headerJoinStrings";
  GridColumnIcon2["HeaderSplitString"] = "headerSplitString";
  GridColumnIcon2["HeaderGeoDistance"] = "headerGeoDistance";
  GridColumnIcon2["HeaderArray"] = "headerArray";
  GridColumnIcon2["RowOwnerOverlay"] = "rowOwnerOverlay";
  GridColumnIcon2["ProtectedColumnOverlay"] = "protectedColumnOverlay";
})(GridColumnIcon || (GridColumnIcon = {}));

var headerCellCheckboxPrefix = "___gdg_header_cell_";
var headerCellCheckedMarker = headerCellCheckboxPrefix + "checked";
var headerCellUnheckedMarker = headerCellCheckboxPrefix + "unchecked";
var headerCellIndeterminateMarker = headerCellCheckboxPrefix + "indeterminate";

function isSizedGridColumn(c) {
  return "width" in c && typeof c.width === "number";
}

async function resolveCellsThunk(thunk) {
  if (typeof thunk === "object") return thunk;
  return await thunk();
}

function isEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown) {
    return false;
  }

  proveType(cell);
  return true;
}

function isTextEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown || cell.kind === GridCellKind.Boolean || cell.kind === GridCellKind.Image || cell.kind === GridCellKind.Custom) {
    return false;
  }

  proveType(cell);
  return true;
}

function isInnerOnlyCell(cell) {
  return cell.kind === InnerGridCellKind.Marker || cell.kind === InnerGridCellKind.NewRow;
}

function isReadWriteCell(cell) {
  if (!isEditableGridCell(cell) || cell.kind === GridCellKind.Image) return false;

  if (cell.kind === GridCellKind.Text || cell.kind === GridCellKind.Number || cell.kind === GridCellKind.Markdown || cell.kind === GridCellKind.Uri || cell.kind === GridCellKind.Custom || cell.kind === GridCellKind.Boolean) {
    return cell.readonly !== true;
  }

  assertNever(cell);
}

function isObjectEditorCallbackResult(obj) {
  return lodash_has_js__WEBPACK_IMPORTED_MODULE_7__(obj, "editor");
}

function booleanCellIsEditable(cell) {
  var _a;

  return !((_a = cell.readonly) != null ? _a : false);
}

var InnerGridCellKind;

(function (InnerGridCellKind2) {
  InnerGridCellKind2["NewRow"] = "new-row";
  InnerGridCellKind2["Marker"] = "marker";
})(InnerGridCellKind || (InnerGridCellKind = {}));

function mergeRanges(input) {
  if (input.length === 0) {
    return [];
  }

  const ranges = [...input];
  const stack = [];
  ranges.sort(function (a, b) {
    return a[0] - b[0];
  });
  stack.push([...ranges[0]]);

  for (const range2 of ranges.slice(1)) {
    const top = stack[stack.length - 1];

    if (top[1] < range2[0]) {
      stack.push([...range2]);
    } else if (top[1] < range2[1]) {
      top[1] = range2[1];
    }
  }

  return stack;
}

var emptyCompactSelection;

var _CompactSelection = class {
  constructor(items) {
    this.items = items;

    this.offset = amount => {
      if (amount === 0) return this;
      const newItems = this.items.map(x => [x[0] + amount, x[1] + amount]);
      return new _CompactSelection(newItems);
    };

    this.add = selection => {
      const slice = typeof selection === "number" ? [selection, selection + 1] : selection;
      const newItems = mergeRanges([...this.items, slice]);
      return new _CompactSelection(newItems);
    };

    this.remove = selection => {
      const items2 = [...this.items];
      const selMin = typeof selection === "number" ? selection : selection[0];
      const selMax = typeof selection === "number" ? selection + 1 : selection[1];

      for (const [i, slice] of items2.entries()) {
        const [start, end] = slice;

        if (start <= selMax && selMin <= end) {
          const toAdd = [];

          if (start < selMin) {
            toAdd.push([start, selMin]);
          }

          if (selMax < end) {
            toAdd.push([selMax, end]);
          }

          items2.splice(i, 1, ...toAdd);
        }
      }

      return new _CompactSelection(items2);
    };

    this.first = () => {
      if (this.items.length === 0) return void 0;
      return this.items[0][0];
    };

    this.last = () => {
      if (this.items.length === 0) return void 0;
      return this.items.slice(-1)[0][1] - 1;
    };

    this.hasIndex = index => {
      for (let i = 0; i < this.items.length; i++) {
        const [start, end] = this.items[i];
        if (index >= start && index < end) return true;
      }

      return false;
    };

    this.hasAll = index => {
      for (let x = index[0]; x < index[1]; x++) {
        if (!this.hasIndex(x)) return false;
      }

      return true;
    };

    this.some = predicate => {
      for (const i of this) {
        if (predicate(i)) return true;
      }

      return false;
    };

    this.equals = other => {
      if (other === this) return true;
      if (other.items.length !== this.items.length) return false;

      for (let i = 0; i < this.items.length; i++) {
        const left = other.items[i];
        const right = this.items[i];
        if (left[0] !== right[0] || left[1] !== right[1]) return false;
      }

      return true;
    };

    this.toArray = () => {
      const result = [];

      for (const [start, end] of this.items) {
        for (let x = start; x < end; x++) {
          result.push(x);
        }
      }

      return result;
    };
  }

  get length() {
    let len = 0;

    for (const [start, end] of this.items) {
      len += end - start;
    }

    return len;
  }

  *[Symbol.iterator]() {
    for (const [start, end] of this.items) {
      for (let x = start; x < end; x++) {
        yield x;
      }
    }
  }

};

var CompactSelection = _CompactSelection;

CompactSelection.empty = () => {
  return emptyCompactSelection != null ? emptyCompactSelection : emptyCompactSelection = new _CompactSelection([]);
};

CompactSelection.fromSingleSelection = selection => {
  return _CompactSelection.empty().add(selection);
};

var _exp = () => p => p.targetY;

var _exp2 = () => p => p.targetX - 1;

var _exp3 = () => p => p.targetY - 1;

var _exp4 = () => p => p.targetWidth + 2;

var _exp5 = () => p => p.targetHeight + 2;

var _exp6 = () => p => p.targetY + 10;

var _exp7 = () => p => Math.max(0, (p.targetHeight - 28) / 2);

var DataGridOverlayEditorStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "DataGridOverlayEditorStyle",
  class: "d1t1th9s",
  vars: {
    "d1t1th9s-0": [_exp(), "px"],
    "d1t1th9s-1": [_exp2(), "px"],
    "d1t1th9s-2": [_exp3(), "px"],
    "d1t1th9s-3": [_exp4(), "px"],
    "d1t1th9s-4": [_exp5(), "px"],
    "d1t1th9s-5": [_exp6(), "px"],
    "d1t1th9s-6": [_exp7(), "px"]
  }
});


function useRefState() {
  const [refState, setRefState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  return [refState != null ? refState : void 0, setRefState];
}

function useStayOnScreen() {
  const [ref, setRef] = useRefState();
  const [xOffset, setXOffset] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [isIntersecting, setIsIntersecting] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (ref === void 0) return;
    if (!("IntersectionObserver" in window)) return;
    const observer = new IntersectionObserver(ents => {
      if (ents.length === 0) return;
      setIsIntersecting(ents[0].isIntersecting);
    }, {
      threshold: 1
    });
    observer.observe(ref);
    return () => observer.disconnect();
  }, [ref]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (isIntersecting || ref === void 0) return;
    let rafHandle;

    const fn = () => {
      const {
        right: refRight
      } = ref.getBoundingClientRect();
      setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));
      rafHandle = requestAnimationFrame(fn);
    };

    rafHandle = requestAnimationFrame(fn);
    return () => {
      if (rafHandle !== void 0) {
        cancelAnimationFrame(rafHandle);
      }
    };
  }, [ref, isIntersecting]);
  const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      transform: `translateX(${xOffset}px)`
    };
  }, [xOffset]);
  return {
    ref: setRef,
    style
  };
}

var DataGridOverlayEditor = p => {
  const {
    target,
    content,
    onFinishEditing: onFinishEditingIn,
    forceEditMode,
    initialValue,
    imageEditorOverride,
    markdownDivCreateNode,
    highlight,
    className,
    theme,
    id,
    cell,
    validateCell,
    getCellRenderer,
    provideEditor
  } = p;
  const [tempValue, setTempValueRaw] = react__WEBPACK_IMPORTED_MODULE_0__.useState(forceEditMode ? content : void 0);
  const lastValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(tempValue != null ? tempValue : content);
  lastValueRef.current = tempValue != null ? tempValue : content;
  const [isValid, setIsValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    if (validateCell === void 0) return true;
    return !(isEditableGridCell(content) && (validateCell == null ? void 0 : validateCell(cell, content, lastValueRef.current)) === false);
  });
  const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCell, movement) => {
    onFinishEditingIn(isValid ? newCell : void 0, movement);
  }, [isValid, onFinishEditingIn]);
  const setTempValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newVal => {
    if (validateCell !== void 0 && newVal !== void 0 && isEditableGridCell(newVal)) {
      const validResult = validateCell(cell, newVal, lastValueRef.current);

      if (validResult === false) {
        setIsValid(false);
      } else if (typeof validResult === "object") {
        newVal = validResult;
        setIsValid(true);
      } else {
        setIsValid(true);
      }
    }

    setTempValueRaw(newVal);
  }, [cell, validateCell]);
  const finished = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const customMotion = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);
  const onClickOutside = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    onFinishEditing(tempValue, [0, 0]);
    finished.current = true;
  }, [tempValue, onFinishEditing]);
  const onEditorFinished = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newValue => {
    var _a;

    onFinishEditing(newValue, (_a = customMotion.current) != null ? _a : [0, 0]);
    finished.current = true;
  }, [onFinishEditing]);
  const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async event => {
    let save = false;

    if (event.key === "Escape") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 0];
    } else if (event.key === "Enter" && !event.shiftKey) {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 1];
      save = true;
    } else if (event.key === "Tab") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [event.shiftKey ? -1 : 1, 0];
      save = true;
    }

    window.setTimeout(() => {
      if (!finished.current && customMotion.current !== void 0) {
        onFinishEditing(save ? tempValue : void 0, customMotion.current);
        finished.current = true;
      }
    }, 0);
  }, [onFinishEditing, tempValue]);
  const targetValue = tempValue != null ? tempValue : content;
  const [editorProvider, useLabel] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a, _b;

    if (isInnerOnlyCell(content)) return [];
    const external = provideEditor == null ? void 0 : provideEditor(content);
    if (external !== void 0) return [external, false];
    return [(_b = (_a = getCellRenderer(content)) == null ? void 0 : _a.provideEditor) == null ? void 0 : _b.call(_a, content), false];
  }, [content, getCellRenderer, provideEditor]);
  const {
    ref,
    style: stayOnScreenStyle
  } = useStayOnScreen();
  let pad = true;
  let editor;
  let style = true;
  let styleOverride;

  if (editorProvider !== void 0) {
    pad = editorProvider.disablePadding !== true;
    style = editorProvider.disableStyling !== true;
    const isObjectEditor = isObjectEditorCallbackResult(editorProvider);

    if (isObjectEditor) {
      styleOverride = editorProvider.styleOverride;
    }

    const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;
    editor = react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomEditor, {
      isHighlighted: highlight,
      onChange: setTempValue,
      value: targetValue,
      initialValue,
      onFinishedEditing: onEditorFinished,
      validatedSelection: isEditableGridCell(targetValue) ? targetValue.selectionRange : void 0,
      forceEditMode,
      target,
      imageEditorOverride,
      markdownDivCreateNode,
      isValid
    });
  }

  styleOverride = { ...styleOverride,
    ...stayOnScreenStyle
  };
  const portalElement = document.getElementById("portal");

  if (portalElement === null) {
    console.error('Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id="portal" />` as the last child of your `<body>`.');
    return null;
  }

  let classWrap = style ? "gdg-style" : "gdg-unstyle";

  if (!isValid) {
    classWrap += " invalid";
  }

  if (pad) {
    classWrap += " pad";
  }

  return (0,react_dom__WEBPACK_IMPORTED_MODULE_6__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThemeContext.Provider, {
    value: theme
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClickOutsideContainer, {
    style: makeCSSStyle(theme),
    className,
    onClickOutside
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataGridOverlayEditorStyle, {
    ref,
    id,
    className: classWrap,
    style: styleOverride,
    as: useLabel === true ? "label" : void 0,
    targetX: target.x,
    targetY: target.y,
    targetWidth: target.width,
    targetHeight: target.height
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "clip-region",
    onKeyDown
  }, editor)))), portalElement);
};

var data_grid_overlay_editor_default = DataGridOverlayEditor;






var rowShift = 1 << 16;
var imgPool = [];

function packColRowToNumber(col, row) {
  return row * rowShift + col;
}

function unpackCol(packed) {
  return packed % rowShift;
}

function unpackRow(packed, col) {
  return (packed - col) / rowShift;
}

function unpackNumberToColRow(packed) {
  const col = unpackCol(packed);
  const row = unpackRow(packed, col);
  return [col, row];
}

var ImageWindowLoaderImpl = class {
  constructor() {
    this.imageLoaded = () => void 0;

    this.loadedLocations = [];
    this.visibleWindow = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    this.freezeCols = 0;

    this.isInWindow = packed => {
      const col = unpackCol(packed);
      const row = unpackRow(packed, col);
      const w = this.visibleWindow;
      if (col < this.freezeCols && row >= w.y && row <= w.y + w.height) return true;
      return col >= w.x && col <= w.x + w.width && row >= w.y && row <= w.y + w.height;
    };

    this.cache = {};
    this.sendLoaded = lodash_throttle_js__WEBPACK_IMPORTED_MODULE_9__(() => {
      this.imageLoaded(this.loadedLocations);
      this.loadedLocations = [];
    }, 20);

    this.clearOutOfWindow = () => {
      const keys = Object.keys(this.cache);

      for (const key of keys) {
        const obj = this.cache[key];
        let keep = false;

        for (let j = 0; j < obj.cells.length; j++) {
          const packed = obj.cells[j];

          if (this.isInWindow(packed)) {
            keep = true;
            break;
          }
        }

        if (keep) {
          obj.cells = obj.cells.filter(this.isInWindow);
        } else {
          obj.cancel();
          delete this.cache[key];
        }
      }
    };
  }

  setCallback(imageLoaded) {
    this.imageLoaded = imageLoaded;
  }

  setWindow(newWindow, freezeCols) {
    if (this.visibleWindow.x === newWindow.x && this.visibleWindow.y === newWindow.y && this.visibleWindow.width === newWindow.width && this.visibleWindow.height === newWindow.height && this.freezeCols === freezeCols) return;
    this.visibleWindow = newWindow;
    this.freezeCols = freezeCols;
    this.clearOutOfWindow();
  }

  loadImage(url, col, row, key) {
    var _a;

    let loaded = false;
    const img = (_a = imgPool.pop()) != null ? _a : new Image();
    let canceled = false;
    const result = {
      img: void 0,
      cells: [packColRowToNumber(col, row)],
      url,
      cancel: () => {
        if (canceled) return;
        canceled = true;

        if (imgPool.length < 12) {
          imgPool.unshift(img);
        } else if (!loaded) {
          img.src = "";
        }
      }
    };
    const loadPromise = new Promise(r => img.addEventListener("load", () => r(null)));
    requestAnimationFrame(async () => {
      try {
        img.src = url;
        await loadPromise;
        await img.decode();
        const toWrite = this.cache[key];

        if (toWrite !== void 0 && !canceled) {
          toWrite.img = img;

          for (const packed of toWrite.cells) {
            this.loadedLocations.push(unpackNumberToColRow(packed));
          }

          loaded = true;
          this.sendLoaded();
        }
      } catch (e) {
        result.cancel();
      }
    });
    this.cache[key] = result;
  }

  loadOrGetImage(url, col, row) {
    const key = url;
    const current = this.cache[key];

    if (current !== void 0) {
      const packed = packColRowToNumber(col, row);

      if (!current.cells.includes(packed)) {
        current.cells.push(packed);
      }

      return current.img;
    } else {
      this.loadImage(url, col, row, key);
    }

    return void 0;
  }

};
var image_window_loader_default = ImageWindowLoaderImpl;



function useEventListener(eventName, handler, element, passive) {
  let capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  const savedHandler = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  savedHandler.current = handler;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (element === null || element.addEventListener === void 0) return;
    const el = element;

    const eventListener = event => {
      var _a;

      (_a = savedHandler.current) == null ? void 0 : _a.call(el, event);
    };

    el.addEventListener(eventName, eventListener, {
      passive,
      capture
    });
    return () => {
      el.removeEventListener(eventName, eventListener, {
        capture
      });
    };
  }, [eventName, element, passive, capture]);
}

function whenDefined(obj, result) {
  return obj === void 0 ? void 0 : result;
}

var PI = Math.PI;

function degreesToRadians(degrees) {
  return degrees * PI / 180;
}

var EditPencil = props => {
  var _a;

  const fg = (_a = props.fgColor) != null ? _a : "currentColor";
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }));
};

var Checkmark = props => {
  var _a;

  const fg = (_a = props.fgColor) != null ? _a : "currentColor";
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M19 6L10.3802 17L5.34071 11.8758",
    vectorEffect: "non-scaling-stroke",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};

function useDebouncedMemo(factory, deps, time) {
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(factory);
  const mountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => {
    mountedRef.current = false;
  }, []);
  const debouncedSetState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__(x => {
    if (mountedRef.current) {
      setState(x);
    }
  }, time));
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (mountedRef.current) {
      debouncedSetState.current(() => factory());
    }
  }, deps);
  return state;
}

var rtlRange = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
var ltrRange = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
var rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
var ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");

function direction(value) {
  return rtl.test(value) ? "rtl" : ltr.test(value) ? "ltr" : "neutral";
}

var scrollbarWidthCache = void 0;

function getScrollBarWidth() {
  if (scrollbarWidthCache !== void 0) return scrollbarWidthCache;
  const inner = document.createElement("p");
  inner.style.width = "100%";
  inner.style.height = "200px";
  const outer = document.createElement("div");
  outer.id = "testScrollbar";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.append(inner);
  document.body.append(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;

  if (w1 === w2) {
    w2 = outer.clientWidth;
  }

  outer.remove();
  scrollbarWidthCache = w1 - w2;
  return scrollbarWidthCache;
}

var empty = Symbol();

function useStateWithReactiveInput(inputState) {
  const inputStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([empty, inputState]);

  if (inputStateRef.current[1] !== inputState) {
    inputStateRef.current[0] = inputState;
  }

  inputStateRef.current[1] = inputState;
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(inputState);
  const [, forceRender] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const setStateOuter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(nv => {
    const s = inputStateRef.current[0];

    if (s !== empty) {
      nv = typeof nv === "function" ? nv(s) : nv;
      if (nv === s) return;
    }

    if (s !== empty) forceRender({});
    setState(pv => {
      if (typeof nv === "function") {
        return nv(s === empty ? pv : s);
      }

      return nv;
    });
    inputStateRef.current[0] = empty;
  }, []);
  const onEmpty = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    inputStateRef.current[0] = empty;
    forceRender({});
  }, []);
  return [inputStateRef.current[0] === empty ? state : inputStateRef.current[0], setStateOuter, onEmpty];
}




function useMappedColumns(columns, freezeColumns) {
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => columns.map((c, i) => ({ ...c,
    sourceIndex: i,
    sticky: i < freezeColumns
  })), [columns, freezeColumns]);
}

function isGroupEqual(left, right) {
  return (left != null ? left : "") === (right != null ? right : "");
}

function cellIsSelected(location, cell, selection) {
  if ((selection == null ? void 0 : selection.current) === void 0) return false;
  const [col, row] = selection.current.cell;
  const [cellCol, cellRow] = location;
  if (cellRow !== row) return false;

  if (cell.span === void 0) {
    return col === cellCol;
  }

  return col >= cell.span[0] && col <= cell.span[1];
}

function cellIsInRect(location, cell, rect) {
  const startX = rect.x;
  const endX = rect.x + rect.width - 1;
  const startY = rect.y;
  const endY = rect.y + rect.height - 1;
  const [cellCol, cellRow] = location;
  if (cellRow < startY || cellRow > endY) return false;

  if (cell.span === void 0) {
    return cellCol >= startX && cellCol <= endX;
  }

  const [spanStart, spanEnd] = cell.span;
  return spanStart >= startX && spanStart <= endX || spanEnd >= startX && spanStart <= endX || spanStart < startX && spanEnd > endX;
}

function cellIsInRange(location, cell, selection) {
  let result = 0;
  if (selection.current === void 0) return result;
  if (cellIsInRect(location, cell, selection.current.range)) result++;

  for (const r of selection.current.rangeStack) {
    if (cellIsInRect(location, cell, r)) {
      result++;
    }
  }

  return result;
}

function remapForDnDState(columns, dndState) {
  let mappedCols = columns;

  if (dndState !== void 0) {
    let writable = [...columns];
    const temp = mappedCols[dndState.src];

    if (dndState.src > dndState.dest) {
      writable.splice(dndState.src, 1);
      writable.splice(dndState.dest, 0, temp);
    } else {
      writable.splice(dndState.dest + 1, 0, temp);
      writable.splice(dndState.src, 1);
    }

    writable = writable.map((c, i) => ({ ...c,
      sticky: columns[i].sticky
    }));
    mappedCols = writable;
  }

  return mappedCols;
}

function getStickyWidth(columns, dndState) {
  let result = 0;
  const remapped = remapForDnDState(columns, dndState);

  for (let i = 0; i < remapped.length; i++) {
    const c = remapped[i];
    if (c.sticky) result += c.width;else break;
  }

  return result;
}

function getEffectiveColumns(columns, cellXOffset, width, dndState, tx) {
  const mappedCols = remapForDnDState(columns, dndState);
  const sticky = [];

  for (const c of mappedCols) {
    if (c.sticky) {
      sticky.push(c);
    } else {
      break;
    }
  }

  if (sticky.length > 0) {
    for (const c of sticky) {
      width -= c.width;
    }
  }

  let endIndex = cellXOffset;
  let curX = tx != null ? tx : 0;

  while (curX <= width && endIndex < mappedCols.length) {
    curX += mappedCols[endIndex].width;
    endIndex++;
  }

  for (let i = cellXOffset; i < endIndex; i++) {
    const c = mappedCols[i];

    if (!c.sticky) {
      sticky.push(c);
    }
  }

  return sticky;
}

function getColumnIndexForX(targetX, effectiveColumns, translateX) {
  let x = 0;

  for (const c of effectiveColumns) {
    const cx = c.sticky ? x : x + (translateX != null ? translateX : 0);

    if (targetX <= cx + c.width) {
      return c.sourceIndex;
    }

    x += c.width;
  }

  return -1;
}

function getRowIndexForY(targetY, height, hasGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, lastRowSticky) {
  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (hasGroups && targetY <= groupHeaderHeight) return -2;
  if (targetY <= totalHeaderHeight) return -1;
  const lastRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows - 1);

  if (lastRowSticky && targetY > height - lastRowHeight) {
    return rows - 1;
  }

  const effectiveRows = rows - (lastRowSticky ? 1 : 0);
  const ty = targetY - (translateY != null ? translateY : 0);

  if (typeof rowHeight === "number") {
    const target = Math.floor((ty - totalHeaderHeight) / rowHeight) + cellYOffset;
    if (target >= effectiveRows) return void 0;
    return target;
  } else {
    let curY = totalHeaderHeight;

    for (let i = cellYOffset; i < effectiveRows; i++) {
      const rh = rowHeight(i);
      if (ty <= curY + rh) return i;
      curY += rh;
    }

    return void 0;
  }
}

var metricsSize = 0;
var metricsCache = {};
var isSSR = typeof window === "undefined";

async function clearCacheOnLoad() {
  var _a;

  if (isSSR || ((_a = document == null ? void 0 : document.fonts) == null ? void 0 : _a.ready) === void 0) return;
  await document.fonts.ready;
  metricsSize = 0;
  metricsCache = {};
  (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__/* .clearCache */ .L)();
}

void clearCacheOnLoad();

function makeCacheKey(s, ctx, baseline, font) {
  return `${s}_${font != null ? font : ctx.font}_${baseline}`;
}

function measureTextCached(s, ctx, font) {
  const key = makeCacheKey(s, ctx, "middle", font);
  let metrics = metricsCache[key];

  if (metrics === void 0) {
    metrics = ctx.measureText(s);
    metricsCache[key] = metrics;
    metricsSize++;
  }

  if (metricsSize > 1e4) {
    metricsCache = {};
    metricsSize = 0;
  }

  return metrics;
}

function getMiddleCenterBias(ctx, font) {
  if (typeof font !== "string") {
    font = `${font.baseFontStyle} ${font.fontFamily}`;
  }

  return getMiddleCenterBiasInner(ctx, font);
}

function loadMetric(ctx, baseline) {
  const sample = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  ctx.save();
  ctx.textBaseline = baseline;
  const result = ctx.measureText(sample);
  ctx.restore();
  return result;
}

var biasCache = [];

function getMiddleCenterBiasInner(ctx, font) {
  for (const x of biasCache) {
    if (x.key === font) return x.val;
  }

  const alphabeticMetrics = loadMetric(ctx, "alphabetic");
  const middleMetrics = loadMetric(ctx, "middle");
  const bias = -(middleMetrics.actualBoundingBoxDescent - alphabeticMetrics.actualBoundingBoxDescent) + alphabeticMetrics.actualBoundingBoxAscent / 2;
  biasCache.push({
    key: font,
    val: bias
  });
  return bias;
}

function drawWithLastUpdate(args, lastUpdate, frameTime, lastPrep, draw) {
  const {
    ctx,
    rect,
    theme
  } = args;
  let progress = Number.MAX_SAFE_INTEGER;
  const animTime = 500;

  if (lastUpdate !== void 0) {
    progress = frameTime - lastUpdate;

    if (progress < animTime) {
      const fade = 1 - progress / animTime;
      ctx.globalAlpha = fade;
      ctx.fillStyle = theme.bgSearchResult;
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
      ctx.globalAlpha = 1;

      if (lastPrep !== void 0) {
        lastPrep.fillStyle = theme.bgSearchResult;
      }
    }
  }

  draw();
  return progress < animTime;
}

function prepTextCell(args, lastPrep, overrideColor) {
  const {
    ctx,
    theme
  } = args;
  const result = lastPrep != null ? lastPrep : {};
  const newFill = overrideColor != null ? overrideColor : theme.textDark;

  if (newFill !== result.fillStyle) {
    ctx.fillStyle = newFill;
    result.fillStyle = newFill;
  }

  return result;
}

function drawTextCellExternal(args, data, contentAlign) {
  const {
    rect,
    ctx,
    theme
  } = args;
  ctx.fillStyle = theme.textDark;
  drawTextCell({
    ctx,
    rect,
    theme
  }, data, contentAlign);
}

function drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign) {
  if (contentAlign === "right") {
    ctx.fillText(data, x + w - (theme.cellHorizontalPadding + 0.5), y + h / 2 + bias);
  } else if (contentAlign === "center") {
    ctx.fillText(data, x + w / 2, y + h / 2 + bias);
  } else {
    ctx.fillText(data, x + theme.cellHorizontalPadding + 0.5, y + h / 2 + bias);
  }
}

function getEmHeight(ctx, fontStyle) {
  const textMetrics = measureTextCached("ABCi09jgqpy", ctx, fontStyle);
  return textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
}

function drawTextCell(args, data, contentAlign, allowWrapping, hyperWrapping) {
  const {
    ctx,
    rect,
    theme
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  allowWrapping = allowWrapping != null ? allowWrapping : false;

  if (!allowWrapping) {
    if (data.includes("\n")) {
      data = data.split(/\r?\n/)[0];
    }

    const max = w / 4;

    if (data.length > max) {
      data = data.slice(0, max);
    }
  }

  const bias = getMiddleCenterBias(ctx, theme);
  const isRtl = direction(data) === "rtl";

  if (contentAlign === void 0 && isRtl) {
    contentAlign = "right";
  }

  if (isRtl) {
    ctx.direction = "rtl";
  }

  if (data.length > 0) {
    let changed = false;

    if (contentAlign === "right") {
      ctx.textAlign = "right";
      changed = true;
    } else if (contentAlign !== void 0 && contentAlign !== "left") {
      ctx.textAlign = contentAlign;
      changed = true;
    }

    if (!allowWrapping) {
      drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign);
    } else {
      const fontStyle = `${theme.fontFamily} ${theme.baseFontStyle}`;
      const split = (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__/* .split */ .V)(ctx, data, fontStyle, w - theme.cellHorizontalPadding * 2, hyperWrapping != null ? hyperWrapping : false);
      const emHeight = getEmHeight(ctx, fontStyle);
      const lineHeight = theme.lineHeight * emHeight;
      const actualHeight = emHeight + lineHeight * (split.length - 1);
      const mustClip = actualHeight + theme.cellVerticalPadding > h;

      if (mustClip) {
        ctx.save();
        ctx.rect(x, y, w, h);
        ctx.clip();
      }

      const optimalY = y + h / 2 - actualHeight / 2;
      let drawY = Math.max(y + theme.cellVerticalPadding, optimalY);

      for (const line of split) {
        drawSingleTextLine(ctx, line, x, drawY, w, emHeight, bias, theme, contentAlign);
        drawY += lineHeight;
        if (drawY > y + h) break;
      }

      if (mustClip) {
        ctx.restore();
      }
    }

    if (changed) {
      ctx.textAlign = "start";
    }

    if (isRtl) {
      ctx.direction = "inherit";
    }
  }
}

function drawNewRowCell(args, data, icon) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme,
    spriteManager
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  ctx.beginPath();
  ctx.globalAlpha = hoverAmount;
  ctx.rect(x, y, w, h);
  ctx.fillStyle = theme.bgHeaderHovered;
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.beginPath();
  const alwaysShowIcon = data !== "";
  let textX = 0;

  if (icon !== void 0) {
    const padding = 8;
    const size = h - padding;
    const px = x + padding / 2;
    const py = y + padding / 2;
    spriteManager.drawSprite(icon, "normal", ctx, px, py, size, theme, alwaysShowIcon ? 1 : hoverAmount);
    textX = size;
  } else {
    textX = 24;
    const finalLineSize = 12;
    const lineSize = alwaysShowIcon ? finalLineSize : hoverAmount * finalLineSize;
    const xTranslate = alwaysShowIcon ? 0 : (1 - hoverAmount) * finalLineSize * 0.5;
    const padPlus = theme.cellHorizontalPadding + 4;

    if (lineSize > 0) {
      ctx.moveTo(x + padPlus + xTranslate, y + h / 2);
      ctx.lineTo(x + padPlus + xTranslate + lineSize, y + h / 2);
      ctx.moveTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 - lineSize * 0.5);
      ctx.lineTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 + lineSize * 0.5);
      ctx.lineWidth = 2;
      ctx.strokeStyle = theme.bgIconHeader;
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }

  ctx.fillStyle = theme.textMedium;
  ctx.fillText(data, textX + x + theme.cellHorizontalPadding + 0.5, y + h / 2 + getMiddleCenterBias(ctx, theme));
  ctx.beginPath();
}

function drawCheckbox(ctx, theme, checked, x, y, width, height, highlighted) {
  let hoverX = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : -20;
  let hoverY = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : -20;
  let maxSize = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 32;
  const centerX = Math.floor(x + width / 2);
  const centerY = Math.floor(y + height / 2);
  const checkBoxWidth = Math.min(maxSize, height - theme.cellVerticalPadding * 2);
  const hoverHelper = checkBoxWidth / 2;
  const hovered = Math.abs(hoverX - width / 2) < hoverHelper && Math.abs(hoverY - height / 2) < hoverHelper;
  const rectBordRadius = 4;
  const posHelperChecked = checkBoxWidth / 2;

  switch (checked) {
    case true:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);
        ctx.fillStyle = highlighted ? theme.accentColor : theme.textMedium;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - posHelperChecked + checkBoxWidth / 4.23, centerY - posHelperChecked + checkBoxWidth / 1.97);
        ctx.lineTo(centerX - posHelperChecked + checkBoxWidth / 2.42, centerY - posHelperChecked + checkBoxWidth / 1.44);
        ctx.lineTo(centerX - posHelperChecked + checkBoxWidth / 1.29, centerY - posHelperChecked + checkBoxWidth / 3.25);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }

    case BooleanEmpty:
    case false:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2 + 0.5, centerY - checkBoxWidth / 2 + 0.5, checkBoxWidth - 1, checkBoxWidth - 1, rectBordRadius);
        ctx.lineWidth = 1;
        ctx.strokeStyle = hovered ? theme.textDark : theme.textMedium;
        ctx.stroke();
        break;
      }

    case BooleanIndeterminate:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);
        ctx.fillStyle = hovered ? theme.textMedium : theme.textLight;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - checkBoxWidth / 3, centerY);
        ctx.lineTo(centerX + checkBoxWidth / 3, centerY);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }

    default:
      assertNever(checked);
  }
}

function prepMarkerRowCell(args, lastPrep) {
  const {
    ctx,
    theme
  } = args;
  const newFont = `9px ${theme.fontFamily}`;
  const result = lastPrep != null ? lastPrep : {};

  if ((result == null ? void 0 : result.font) !== newFont) {
    ctx.font = newFont;
    result.font = newFont;
  }

  result.deprep = deprepMarkerRowCell;
  ctx.textAlign = "center";
  return result;
}

function deprepMarkerRowCell(args) {
  const {
    ctx
  } = args;
  ctx.textAlign = "start";
}

function drawMarkerRowCell(args, index, checked, markerKind, drawHandle) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme
  } = args;
  const {
    x,
    y,
    width,
    height
  } = rect;
  const checkedboxAlpha = checked ? 1 : markerKind === "checkbox-visible" ? 0.6 + 0.4 * hoverAmount : hoverAmount;

  if (markerKind !== "number" && checkedboxAlpha > 0) {
    ctx.globalAlpha = checkedboxAlpha;
    const offsetAmount = 7 * (checked ? hoverAmount : 1);
    drawCheckbox(ctx, theme, checked, drawHandle ? x + offsetAmount : x, y, drawHandle ? width - offsetAmount : width, height, true, void 0, void 0, 18);

    if (drawHandle) {
      ctx.globalAlpha = hoverAmount;
      ctx.beginPath();

      for (const xOffset of [3, 6]) {
        for (const yOffset of [-5, -1, 3]) {
          ctx.rect(x + xOffset, y + height / 2 + yOffset, 2, 2);
        }
      }

      ctx.fillStyle = theme.textLight;
      ctx.fill();
      ctx.beginPath();
    }

    ctx.globalAlpha = 1;
  }

  if (markerKind === "number" || markerKind === "both" && !checked) {
    const text = index.toString();
    const start = x + width / 2;

    if (markerKind === "both" && hoverAmount !== 0) {
      ctx.globalAlpha = 1 - hoverAmount;
    }

    ctx.fillStyle = theme.textLight;
    ctx.fillText(text, start, y + height / 2 + getMiddleCenterBias(ctx, `9px ${theme.fontFamily}`));

    if (hoverAmount !== 0) {
      ctx.globalAlpha = 1;
    }
  }
}

function drawProtectedCell(args) {
  const {
    ctx,
    theme,
    rect
  } = args;
  const {
    x,
    y,
    height: h
  } = rect;
  ctx.beginPath();
  const radius = 2.5;
  let xStart = x + theme.cellHorizontalPadding + radius;
  const center = y + h / 2;
  const p = Math.cos(degreesToRadians(30)) * radius;
  const q = Math.sin(degreesToRadians(30)) * radius;

  for (let i = 0; i < 12; i++) {
    ctx.moveTo(xStart, center - radius);
    ctx.lineTo(xStart, center + radius);
    ctx.moveTo(xStart + p, center - q);
    ctx.lineTo(xStart - p, center + q);
    ctx.moveTo(xStart - p, center - q);
    ctx.lineTo(xStart + p, center + q);
    xStart += 8;
  }

  ctx.lineWidth = 1.1;
  ctx.lineCap = "square";
  ctx.strokeStyle = theme.textLight;
  ctx.stroke();
}

function roundedRect(ctx, x, y, width, height, radius) {
  if (typeof radius === "number") {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius
    };
  }

  radius = {
    tl: Math.min(radius.tl, height / 2, width / 2),
    tr: Math.min(radius.tr, height / 2, width / 2),
    bl: Math.min(radius.bl, height / 2, width / 2),
    br: Math.min(radius.br, height / 2, width / 2)
  };
  ctx.moveTo(x + radius.tl, y);
  ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);
  ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);
  ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);
  ctx.arcTo(x, y, x + radius.tl, y, radius.tl);
}

function drawBoolean(args, data, canEdit, maxSize) {
  if (!canEdit && data === BooleanEmpty) {
    return;
  }

  const {
    ctx,
    hoverAmount,
    theme,
    rect,
    highlighted,
    hoverX,
    hoverY
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const hoverEffect = 0.35;
  let alpha = canEdit ? 1 - hoverEffect + hoverEffect * hoverAmount : 0.4;

  if (data === BooleanEmpty) {
    alpha *= hoverAmount;
  }

  if (alpha === 0) {
    return;
  }

  ctx.globalAlpha = alpha;
  drawCheckbox(ctx, theme, data, x, y, w, h, highlighted, hoverX, hoverY, maxSize);
  ctx.globalAlpha = 1;
}

var itemMargin = 4;

function drawBubbles(args, data) {
  const {
    rect,
    theme,
    ctx,
    highlighted
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const bubbleHeight = 20;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const renderBoxes = [];

  for (const s of data) {
    if (renderX > x + w) break;
    const textWidth = measureTextCached(s, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;
    renderBoxes.push({
      x: renderX,
      width: textWidth
    });
    renderX += textWidth + bubblePad * 2 + bubbleMargin;
  }

  ctx.beginPath();

  for (const rectInfo of renderBoxes) {
    roundedRect(ctx, rectInfo.x, y + (h - bubbleHeight) / 2, rectInfo.width + bubblePad * 2, bubbleHeight, bubbleHeight / 2);
  }

  ctx.fillStyle = highlighted ? theme.bgBubbleSelected : theme.bgBubble;
  ctx.fill();

  for (const [i, rectInfo] of renderBoxes.entries()) {
    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(data[i], rectInfo.x + bubblePad, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}

var drilldownCache = {};

function getAndCacheDrilldownBorder(bgCell, border, height) {
  const dpr = Math.ceil(window.devicePixelRatio);
  const shadowBlur = 5;
  const targetHeight = height - shadowBlur * 2;
  const middleWidth = 4;
  const rounding = 6;
  const innerHeight = height * dpr;
  const sideWidth = rounding + shadowBlur;
  const targetWidth = rounding * 3;
  const innerWidth = (targetWidth + shadowBlur * 2) * dpr;
  const key = `${bgCell},${border},${dpr},${height}`;

  if (drilldownCache[key] !== void 0) {
    return {
      el: drilldownCache[key],
      height: innerHeight,
      width: innerWidth,
      middleWidth: middleWidth * dpr,
      sideWidth: sideWidth * dpr,
      padding: shadowBlur * dpr,
      dpr
    };
  }

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (ctx === null) return null;
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  ctx.scale(dpr, dpr);
  drilldownCache[key] = canvas;
  const trueRounding = Math.min(rounding, targetWidth / 2, targetHeight / 2);
  ctx.beginPath();
  roundedRect(ctx, shadowBlur, shadowBlur, targetWidth, targetHeight, trueRounding);
  ctx.shadowColor = "rgba(24, 25, 34, 0.4)";
  ctx.shadowBlur = 1;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowColor = "rgba(24, 25, 34, 0.3)";
  ctx.shadowOffsetY = 1;
  ctx.shadowBlur = 5;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
  ctx.shadowBlur = 0;
  ctx.beginPath();
  roundedRect(ctx, shadowBlur + 0.5, shadowBlur + 0.5, targetWidth, targetHeight, trueRounding);
  ctx.strokeStyle = border;
  ctx.lineWidth = 1;
  ctx.stroke();
  return {
    el: canvas,
    height: innerHeight,
    width: innerWidth,
    sideWidth: sideWidth * dpr,
    middleWidth: rounding * dpr,
    padding: shadowBlur * dpr,
    dpr
  };
}

function drawDrilldownCell(args, data) {
  const {
    rect,
    theme,
    ctx,
    imageLoader,
    col,
    row
  } = args;
  const {
    x,
    width: w
  } = rect;
  const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
  const emHeight = getEmHeight(ctx, font);
  const h = Math.min(rect.height, Math.max(16, Math.ceil(emHeight * theme.lineHeight) * 2));
  const y = Math.floor(rect.y + (rect.height - h) / 2);
  const bubbleHeight = h - 10;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const tileMap = getAndCacheDrilldownBorder(theme.bgCell, theme.drilldownBorder, h);
  const renderBoxes = [];

  for (const el of data) {
    if (renderX > x + w) break;
    const textMetrics = measureTextCached(el.text, ctx, font);
    const textWidth = textMetrics.width;
    let imgWidth = 0;

    if (el.img !== void 0) {
      const img = imageLoader.loadOrGetImage(el.img, col, row);

      if (img !== void 0) {
        imgWidth = bubbleHeight - 8 + 4;
      }
    }

    const renderWidth = textWidth + imgWidth + bubblePad * 2;
    renderBoxes.push({
      x: renderX,
      width: renderWidth
    });
    renderX += renderWidth + bubbleMargin;
  }

  if (tileMap !== null) {
    const {
      el,
      height,
      middleWidth,
      sideWidth,
      width,
      dpr,
      padding
    } = tileMap;
    const outerSideWidth = sideWidth / dpr;
    const outerPadding = padding / dpr;

    for (const rectInfo of renderBoxes) {
      const rx = Math.floor(rectInfo.x);
      const rw = Math.floor(rectInfo.width);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(el, 0, 0, sideWidth, height, rx - outerPadding, y, outerSideWidth, h);
      if (rectInfo.width > sideWidth * 2) ctx.drawImage(el, sideWidth, 0, middleWidth, height, rx + (outerSideWidth - outerPadding), y, rw - (outerSideWidth - outerPadding) * 2, h);
      ctx.drawImage(el, width - sideWidth, 0, sideWidth, height, rx + rw - (outerSideWidth - outerPadding), y, outerSideWidth, h);
      ctx.imageSmoothingEnabled = true;
    }
  }

  ctx.beginPath();

  for (const [i, rectInfo] of renderBoxes.entries()) {
    const d = data[i];
    let drawX = rectInfo.x + bubblePad;

    if (d.img !== void 0) {
      const img = imageLoader.loadOrGetImage(d.img, col, row);

      if (img !== void 0) {
        const imgSize = bubbleHeight - 8;
        let srcX = 0;
        let srcY = 0;
        let srcWidth = img.width;
        let srcHeight = img.height;

        if (srcWidth > srcHeight) {
          srcX += (srcWidth - srcHeight) / 2;
          srcWidth = srcHeight;
        } else if (srcHeight > srcWidth) {
          srcY += (srcHeight - srcWidth) / 2;
          srcHeight = srcWidth;
        }

        ctx.beginPath();
        roundedRect(ctx, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize, 3);
        ctx.save();
        ctx.clip();
        ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize);
        ctx.restore();
        drawX += imgSize + 4;
      }
    }

    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(d.text, drawX, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}

function drawImage(args, data) {
  let rounding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
  let contentAlign = arguments.length > 3 ? arguments[3] : undefined;
  const {
    rect,
    col,
    row,
    theme,
    ctx,
    imageLoader
  } = args;
  const {
    x,
    y,
    height: h,
    width: w
  } = rect;
  const imgHeight = h - theme.cellVerticalPadding * 2;
  const images = [];
  let totalWidth = 0;

  for (let index = 0; index < data.length; index++) {
    const i = data[index];
    if (i.length === 0) continue;
    const img = imageLoader.loadOrGetImage(i, col, row);

    if (img !== void 0) {
      images[index] = img;
      const imgWidth = img.width * (imgHeight / img.height);
      totalWidth += imgWidth + itemMargin;
    }
  }

  if (totalWidth === 0) return;
  totalWidth -= itemMargin;
  let drawX = x + theme.cellHorizontalPadding;
  if (contentAlign === "right") drawX = Math.floor(x + w - theme.cellHorizontalPadding - totalWidth);else if (contentAlign === "center") drawX = Math.floor(x + w / 2 - totalWidth / 2);

  for (const img of images) {
    if (img === void 0) continue;
    const imgWidth = img.width * (imgHeight / img.height);

    if (rounding > 0) {
      roundedRect(ctx, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight, rounding);
      ctx.save();
      ctx.clip();
    }

    ctx.drawImage(img, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight);

    if (rounding > 0) {
      ctx.restore();
    }

    drawX += imgWidth + itemMargin;
  }
}

function roundedPoly(ctx, points, radiusAll) {
  const asVec = function (p, pp) {
    const vx = pp.x - p.x;
    const vy = pp.y - p.y;
    const vlen = Math.sqrt(vx * vx + vy * vy);
    const vnx = vx / vlen;
    const vny = vy / vlen;
    return {
      x: vx,
      y: pp.y - p.y,
      len: vlen,
      nx: vnx,
      ny: vny,
      ang: Math.atan2(vny, vnx)
    };
  };

  let radius;
  const len = points.length;
  let p1 = points[len - 1];

  for (let i = 0; i < len; i++) {
    let p2 = points[i % len];
    const p3 = points[(i + 1) % len];
    const v1 = asVec(p2, p1);
    const v2 = asVec(p2, p3);
    const sinA = v1.nx * v2.ny - v1.ny * v2.nx;
    const sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
    let angle = Math.asin(sinA < -1 ? -1 : sinA > 1 ? 1 : sinA);
    let radDirection = 1;
    let drawDirection = false;

    if (sinA90 < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else {
      if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
    }

    radius = p2.radius !== void 0 ? p2.radius : radiusAll;
    const halfAngle = angle / 2;
    let lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    let cRadius;

    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }

    let x = p2.x + v2.nx * lenOut;
    let y = p2.y + v2.ny * lenOut;
    x += -v2.ny * cRadius * radDirection;
    y += v2.nx * cRadius * radDirection;
    ctx.arc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
    p1 = p2;
    p2 = p3;
  }

  ctx.closePath();
}

function computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight) {
  const result = {
    x: 0,
    y: totalHeaderHeight + translateY,
    width: 0,
    height: 0
  };
  const headerHeight = totalHeaderHeight - groupHeaderHeight;

  if (col >= freezeColumns) {
    const dir = cellXOffset > col ? -1 : 1;
    const freezeWidth = getStickyWidth(mappedColumns);
    result.x += freezeWidth + translateX;

    for (let i = cellXOffset; i !== col; i += dir) {
      result.x += mappedColumns[dir === 1 ? i : i - 1].width * dir;
    }
  } else {
    for (let i = 0; i < col; i++) {
      result.x += mappedColumns[i].width;
    }
  }

  result.width = mappedColumns[col].width + 1;

  if (row === -1) {
    result.y = groupHeaderHeight;
    result.height = headerHeight;
  } else if (row === -2) {
    result.y = 0;
    result.height = groupHeaderHeight;
    let start = col;
    const group = mappedColumns[col].group;
    const sticky = mappedColumns[col].sticky;

    while (start > 0 && isGroupEqual(mappedColumns[start - 1].group, group) && mappedColumns[start - 1].sticky === sticky) {
      const c = mappedColumns[start - 1];
      result.x -= c.width;
      result.width += c.width;
      start--;
    }

    let end = col;

    while (end + 1 < mappedColumns.length && isGroupEqual(mappedColumns[end + 1].group, group) && mappedColumns[end + 1].sticky === sticky) {
      const c = mappedColumns[end + 1];
      result.width += c.width;
      end++;
    }

    if (!sticky) {
      const freezeWidth = getStickyWidth(mappedColumns);
      const clip = result.x - freezeWidth;

      if (clip < 0) {
        result.x -= clip;
        result.width += clip;
      }

      if (result.x + result.width > width) {
        result.width = width - result.x;
      }
    }
  } else if (lastRowSticky && row === rows - 1) {
    const stickyHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(row);
    result.y = height - stickyHeight;
    result.height = stickyHeight;
  } else {
    const dir = cellYOffset > row ? -1 : 1;

    if (typeof rowHeight === "number") {
      const delta = row - cellYOffset;
      result.y += delta * rowHeight;
    } else {
      for (let r = cellYOffset; r !== row; r += dir) {
        result.y += rowHeight(r) * dir;
      }
    }

    result.height = (typeof rowHeight === "number" ? rowHeight : rowHeight(row)) + 1;
  }

  return result;
}

var iconHead = `<svg width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">`;

var headerRowID = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/><path d="M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z" fill="${fg}"/></svg>`;
};

var headerCode = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="4" fill="${bg}"/><path d="m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z" fill="${fg}"/></svg>`;
};

var headerNumber = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z" fill="${fg}"/>
  </svg>`;
};

var headerString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z" fill="${fg}"/>
</svg>`;
};

var headerBoolean = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path
        d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
        fill="${bg}"
    />
    <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z"
        fill="${fg}"
    />
</svg>`;
};

var headerUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
<path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z" fill="${fg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z" fill="${fg}"/>
</svg>
  `;
};

var renameIcon = props => {
  const bg = props.bgColor;
  return `${iconHead}
    <path stroke="${bg}" stroke-width="2" d="M12 3v14"/>
    <path stroke="${bg}" stroke-width="2" stroke-linecap="round" d="M10 4h4m-4 12h4"/>
    <path d="M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z" fill="${bg}"/>
  </svg>
`;
};

var headerAudioUri = headerUri;

var headerVideoUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z" fill="${fg}"/>
</svg>`;
};

var headerEmoji = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z" fill="${fg}"/>
    <path d="M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z" fill="${fg}"/>
    <path d="M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
  </svg>`;
};

var headerImage = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path opacity=".5" fill-rule="evenodd" clip-rule="evenodd" d="M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z" fill="${fg}"/>
</svg>`;
};

var headerPhone = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path fill="${fg}" d="M3 3h14v14H3z"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z" fill="${bg}"/>
  </svg>`;
};

var headerMarkdown = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z" fill="${fg}"/>
  </svg>`;
};

var headerDate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z" fill="${fg}"/>
</svg>`;
};

var headerTime = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z" fill="${fg}"/>
    <path d="M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z" fill="${fg}"/>
  </svg>`;
};

var headerEmail = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z" fill="${fg}"/>
</svg>`;
};

var headerReference = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="8" width="10" height="8" rx="2" fill="${bg}"/>
    <rect x="8" y="4" width="10" height="8" rx="2" fill="${bg}"/>
    <path d="M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z" fill="${fg}"/>
  </svg>`;
};

var headerIfThenElse = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path fill="${fg}" d="M4 3h12v14H4z"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z" fill="${bg}"/>
</svg>`;
};

var headerSingleValue = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z" fill="${fg}"/>
  </svg>`;
};

var headerLookup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z" fill="${fg}"/>
  </svg>`;
};

var headerTextTemplate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z" fill="${fg}"/>
</svg>`;
};

var headerMath = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z" fill="${fg}"/>
  <path d="M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z" fill="${fg}"/>
</svg>`;
};

var headerRollup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z" fill="${fg}"/>
  </svg>`;
};

var headerJoinStrings = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z" fill="${fg}"/>
</svg>`;
};

var headerSplitString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z" fill="${fg}"/>
  </svg>`;
};

var headerGeoDistance = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z" fill="${fg}"/>
</svg>`;
};

var headerArray = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z" fill="${fg}"/>
</svg>`;
};

var rowOwnerOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>`;
};

var protectedColumnOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>
`;
};

var sprites = {
  headerRowID,
  headerNumber,
  headerCode,
  headerString,
  headerBoolean,
  headerAudioUri,
  headerVideoUri,
  headerEmoji,
  headerImage,
  headerUri,
  headerPhone,
  headerMarkdown,
  headerDate,
  headerTime,
  headerEmail,
  headerReference,
  headerIfThenElse,
  headerSingleValue,
  headerLookup,
  headerTextTemplate,
  headerMath,
  headerRollup,
  headerJoinStrings,
  headerSplitString,
  headerGeoDistance,
  headerArray,
  rowOwnerOverlay,
  protectedColumnOverlay,
  renameIcon
};

function getColors(variant, theme) {
  if (variant === "normal") {
    return [theme.bgIconHeader, theme.fgIconHeader];
  } else if (variant === "selected") {
    return ["white", theme.accentColor];
  } else {
    return [theme.accentColor, theme.bgHeader];
  }
}

var SpriteManager = class {
  constructor(headerIcons, onSettled) {
    this.onSettled = onSettled;
    this.spriteMap = new Map();
    this.inFlight = 0;
    this.headerIcons = { ...sprites,
      ...headerIcons
    };
  }

  drawSprite(sprite, variant, ctx, x, y, size, theme) {
    let alpha = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
    const [bgColor, fgColor] = getColors(variant, theme);
    const rSize = size * Math.ceil(window.devicePixelRatio);
    const key = `${bgColor}_${fgColor}_${rSize}_${sprite}`;
    let spriteCanvas = this.spriteMap.get(key);

    if (spriteCanvas === void 0) {
      const spriteCb = this.headerIcons[sprite];
      if (spriteCb === void 0) return;
      spriteCanvas = document.createElement("canvas");
      const spriteCtx = spriteCanvas.getContext("2d");
      if (spriteCtx === null) return;
      const imgSource = new Image();
      imgSource.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(spriteCb({
        fgColor,
        bgColor
      }))}`;
      this.spriteMap.set(key, spriteCanvas);
      const promise = imgSource.decode();
      if (promise === void 0) return;
      this.inFlight++;
      promise.then(() => {
        spriteCtx.drawImage(imgSource, 0, 0, rSize, rSize);
      }).finally(() => {
        this.inFlight--;

        if (this.inFlight === 0) {
          this.onSettled();
        }
      });
    } else {
      if (alpha < 1) {
        ctx.globalAlpha = alpha;
      }

      ctx.drawImage(spriteCanvas, 0, 0, rSize, rSize, x, y, size, size);

      if (alpha < 1) {
        ctx.globalAlpha = 1;
      }
    }
  }

};



var cache = {};
var div = null;

function createDiv() {
  const d = document.createElement("div");
  d.style.opacity = "0";
  d.style.pointerEvents = "none";
  d.style.position = "fixed";
  document.body.append(d);
  return d;
}

function parseToRgba(color) {
  const normalizedColor = color.toLowerCase().trim();
  if (cache[normalizedColor] !== void 0) return cache[normalizedColor];
  div = div || createDiv();
  div.style.color = "#000";
  div.style.color = normalizedColor;
  const control = getComputedStyle(div).color;
  div.style.color = "#fff";
  div.style.color = normalizedColor;
  const computedColor = getComputedStyle(div).color;
  if (computedColor !== control) return [0, 0, 0, 1];
  let result = computedColor.replace(/[^\d.,]/g, "").split(",").map(Number.parseFloat);

  if (result.length < 4) {
    result.push(1);
  }

  result = result.map(x => {
    const isNaN = Number.isNaN(x);

    if (isNaN) {
      console.warn("Could not parse color", color);
    }

    return isNaN ? 0 : x;
  });
  cache[normalizedColor] = result;
  return result;
}

function withAlpha(color, alpha) {
  const [r, g, b] = parseToRgba(color);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function blend(color, background) {
  if (background === void 0) return color;
  const [r, g, b, a] = parseToRgba(color);
  if (a === 1) return color;
  const [br, bg, bb, ba] = parseToRgba(background);
  const ao = a + ba * (1 - a);
  const ro = (a * r + ba * br * (1 - a)) / ao;
  const go = (a * g + ba * bg * (1 - a)) / ao;
  const bo = (a * b + ba * bb * (1 - a)) / ao;
  return `rgba(${ro}, ${go}, ${bo}, ${ao})`;
}

function interpolateColors(leftColor, rightColor, val) {
  if (val <= 0) return leftColor;
  if (val >= 1) return rightColor;
  const left = [...parseToRgba(leftColor)];
  left[0] = left[0] * left[3];
  left[1] = left[1] * left[3];
  left[2] = left[2] * left[3];
  const right = [...parseToRgba(rightColor)];
  right[0] = right[0] * right[3];
  right[1] = right[1] * right[3];
  right[2] = right[2] * right[3];
  const hScaler = val;
  const nScaler = 1 - val;
  const a = left[3] * nScaler + right[3] * hScaler;
  const r = Math.floor((left[0] * nScaler + right[0] * hScaler) / a);
  const g = Math.floor((left[1] * nScaler + right[1] * hScaler) / a);
  const b = Math.floor((left[2] * nScaler + right[2] * hScaler) / a);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}

var loadingCell = {
  kind: GridCellKind.Loading,
  allowOverlay: false
};

function drawCell(ctx, row, cell, col, x, y, w, h, highlighted, theme, drawCustomCell, imageLoader, spriteManager, hoverAmount, hoverInfo, hyperWrapping, frameTime, lastPrep, enqueue, getCellRenderer) {
  let hoverX;
  let hoverY;

  if (hoverInfo !== void 0 && hoverInfo[0][0] === col && hoverInfo[0][1] === row) {
    hoverX = hoverInfo[1][0];
    hoverY = hoverInfo[1][1];
  }

  let result = void 0;
  const args = {
    ctx,
    theme,
    col,
    row,
    cell,
    rect: {
      x,
      y,
      width: w,
      height: h
    },
    highlighted,
    hoverAmount,
    hoverX,
    hoverY,
    imageLoader,
    spriteManager,
    hyperWrapping,
    requestAnimationFrame: () => {
      forceAnim = true;
    }
  };
  let forceAnim = false;
  const needsAnim = drawWithLastUpdate(args, cell.lastUpdated, frameTime, lastPrep, () => {
    var _a, _b;

    const drawn = isInnerOnlyCell(cell) ? false : (drawCustomCell == null ? void 0 : drawCustomCell(args)) === true;

    if (!drawn) {
      const r = getCellRenderer(cell);

      if (r !== void 0) {
        if ((lastPrep == null ? void 0 : lastPrep.renderer) !== r) {
          (_a = lastPrep == null ? void 0 : lastPrep.deprep) == null ? void 0 : _a.call(lastPrep, args);
          lastPrep = void 0;
        }

        const partialPrepResult = (_b = r.drawPrep) == null ? void 0 : _b.call(r, args, lastPrep);
        r.draw(args, cell);
        result = {
          deprep: partialPrepResult == null ? void 0 : partialPrepResult.deprep,
          fillStyle: partialPrepResult == null ? void 0 : partialPrepResult.fillStyle,
          font: partialPrepResult == null ? void 0 : partialPrepResult.font,
          renderer: r
        };
      }
    }
  });
  if (needsAnim || forceAnim) enqueue == null ? void 0 : enqueue([col, row]);
  return result;
}

function blitLastFrame(ctx, canvas, last, cellXOffset, cellYOffset, translateX, translateY, lastRowSticky, width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, getRowHeight, doubleBuffer) {
  const drawRegions = [];
  let blittedYOnly = false;
  ctx.imageSmoothingEnabled = false;
  const minY = Math.min(last.cellYOffset, cellYOffset);
  const maxY = Math.max(last.cellYOffset, cellYOffset);
  let deltaY = 0;

  if (typeof getRowHeight === "number") {
    deltaY += (maxY - minY) * getRowHeight;
  } else {
    for (let i = minY; i < maxY; i++) {
      deltaY += getRowHeight(i);
    }
  }

  if (cellYOffset > last.cellYOffset) {
    deltaY = -deltaY;
  }

  deltaY += translateY - last.translateY;
  const minX = Math.min(last.cellXOffset, cellXOffset);
  const maxX = Math.max(last.cellXOffset, cellXOffset);
  let deltaX = 0;

  for (let i = minX; i < maxX; i++) {
    deltaX += mappedColumns[i].width;
  }

  if (cellXOffset > last.cellXOffset) {
    deltaX = -deltaX;
  }

  deltaX += translateX - last.translateX;
  let stickyWidth = getStickyWidth(effectiveCols);
  if (stickyWidth > 0) stickyWidth++;

  if (deltaX !== 0 && deltaY !== 0) {
    return {
      regions: [],
      yOnly: false
    };
  }

  const stickyRowHeight = lastRowSticky ? typeof getRowHeight === "number" ? getRowHeight : getRowHeight(rows - 1) : 0;
  const blitWidth = width - stickyWidth - Math.abs(deltaX);
  const blitHeight = height - totalHeaderHeight - stickyRowHeight - Math.abs(deltaY) - 1;

  if (blitWidth > 150 && blitHeight > 150) {
    blittedYOnly = deltaX === 0;
    const args = {
      sx: 0,
      sy: 0,
      sw: width * dpr,
      sh: height * dpr,
      dx: 0,
      dy: 0,
      dw: width * dpr,
      dh: height * dpr
    };

    if (deltaY > 0) {
      args.sy = (totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (deltaY + totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: totalHeaderHeight,
        width,
        height: deltaY + 1
      });
    } else if (deltaY < 0) {
      args.sy = (-deltaY + totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: height + deltaY - stickyRowHeight,
        width,
        height: -deltaY + stickyRowHeight
      });
    }

    if (deltaX > 0) {
      args.sx = stickyWidth * dpr;
      args.sw = blitWidth * dpr;
      args.dx = (deltaX + stickyWidth) * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: stickyWidth - 1,
        y: 0,
        width: deltaX + 2,
        height
      });
    } else if (deltaX < 0) {
      args.sx = (stickyWidth - deltaX) * dpr;
      args.sw = blitWidth * dpr;
      args.dx = stickyWidth * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: width + deltaX,
        y: 0,
        width: -deltaX,
        height
      });
    }

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    if (stickyWidth > 0 && deltaX !== 0 && deltaY === 0 && doubleBuffer) {
      ctx.drawImage(canvas, 0, 0, stickyWidth * dpr, height * dpr, 0, 0, stickyWidth * dpr, height * dpr);
    }

    ctx.drawImage(canvas, args.sx, args.sy, args.sw, args.sh, args.dx, args.dy, args.dw, args.dh);
    ctx.scale(dpr, dpr);
  }

  ctx.imageSmoothingEnabled = true;
  return {
    regions: drawRegions,
    yOnly: blittedYOnly
  };
}

function blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedIndex) {
  const drawRegions = [];

  if (cellXOffset !== last.cellXOffset || cellYOffset !== last.cellYOffset || translateX !== last.translateX || translateY !== last.translateY) {
    return drawRegions;
  }

  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _drawY, clipX) => {
    if (c.sourceIndex === resizedIndex) {
      const x = Math.max(drawX, clipX) + 1;
      drawRegions.push({
        x,
        y: 0,
        width: width - x,
        height
      });
      return true;
    }
  });
  return drawRegions;
}

function drawGridLines(ctx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme) {
  let verticalOnly = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : false;

  var _a, _b, _c;

  if (spans !== void 0) {
    ctx.beginPath();
    ctx.save();
    ctx.rect(0, 0, width, height);

    for (const span of spans) {
      ctx.rect(span.x + 1, span.y + 1, span.width - 1, span.height - 1);
    }

    ctx.clip("evenodd");
  }

  const hColor = (_a = theme.horizontalBorderColor) != null ? _a : theme.borderColor;
  const vColor = theme.borderColor;
  let minX = 0;
  let maxX = width;
  let minY = 0;
  let maxY = height;

  if (drawRegions !== void 0 && drawRegions.length > 0) {
    minX = Number.MAX_SAFE_INTEGER;
    minY = Number.MAX_SAFE_INTEGER;
    maxX = Number.MIN_SAFE_INTEGER;
    maxY = Number.MIN_SAFE_INTEGER;

    for (const r of drawRegions) {
      minX = Math.min(minX, r.x - 1);
      maxX = Math.max(maxX, r.x + r.width + 1);
      minY = Math.min(minY, r.y - 1);
      maxY = Math.max(maxY, r.y + r.height + 1);
    }
  }

  const toDraw = [];
  ctx.beginPath();
  let x = 0.5;

  for (let index = 0; index < effectiveCols.length; index++) {
    const c = effectiveCols[index];
    if (c.width === 0) continue;
    x += c.width;
    const tx = c.sticky ? x : x + translateX;

    if (tx >= minX && tx <= maxX && verticalBorder(index + 1)) {
      toDraw.push({
        x1: tx,
        y1: Math.max(groupHeaderHeight, minY),
        x2: tx,
        y2: Math.min(height, maxY),
        color: vColor
      });
    }
  }

  const stickyHeight = getRowHeight(rows - 1);
  const stickyRowY = height - stickyHeight + 0.5;
  const lastRowSticky = trailingRowType === "sticky";

  if (lastRowSticky) {
    toDraw.push({
      x1: minX,
      y1: stickyRowY,
      x2: maxX,
      y2: stickyRowY,
      color: hColor
    });
  }

  if (verticalOnly !== true) {
    let y = totalHeaderHeight + 0.5;
    let row = cellYOffset;
    const target = lastRowSticky ? height - stickyHeight : height;

    while (y + translateY <= target) {
      const ty = y + translateY;

      if (ty >= minY && ty <= maxY - 1 && (!lastRowSticky || row !== rows - 1 || Math.abs(ty - stickyRowY) > 1)) {
        const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
        toDraw.push({
          x1: minX,
          y1: ty,
          x2: maxX,
          y2: ty,
          color: (_c = (_b = rowTheme == null ? void 0 : rowTheme.horizontalBorderColor) != null ? _b : rowTheme == null ? void 0 : rowTheme.borderColor) != null ? _c : hColor
        });
      }

      y += getRowHeight(row);
      row++;
    }
  }

  const groups = lodash_groupBy_js__WEBPACK_IMPORTED_MODULE_11__(toDraw, line => line.color);

  for (const g of Object.keys(groups)) {
    ctx.strokeStyle = g;

    for (const line of groups[g]) {
      ctx.moveTo(line.x1, line.y1);
      ctx.lineTo(line.x2, line.y2);
    }

    ctx.stroke();
    ctx.beginPath();
  }

  if (spans !== void 0) {
    ctx.restore();
  }
}

function getActionBoundsForGroup(box, actions) {
  const result = [];
  let x = box.x + box.width - 26 * actions.length;
  const y = box.y + box.height / 2 - 13;
  const height = 26;
  const width = 26;

  for (let i = 0; i < actions.length; i++) {
    result.push({
      x,
      y,
      width,
      height
    });
    x += 26;
  }

  return result;
}

function pointInRect(rect, x, y) {
  return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
}

function drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, theme, spriteManager, _hoverValues, verticalBorder, getGroupDetails, damage) {
  var _a;

  const xPad = 8;
  const [hCol, hRow] = (_a = hovered == null ? void 0 : hovered[0]) != null ? _a : [];
  let finalX = 0;
  walkGroups(effectiveCols, width, translateX, groupHeaderHeight, (span, groupName, x, y, w, h) => {
    var _a2, _b;

    if (damage !== void 0 && !damage.some(d => d[1] === -2 && d[0] >= span[0] && d[0] <= span[1])) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip();
    const group = getGroupDetails(groupName);
    const groupTheme = (group == null ? void 0 : group.overrideTheme) === void 0 ? theme : { ...theme,
      ...group.overrideTheme
    };
    const isHovered = hRow === -2 && hCol !== void 0 && hCol >= span[0] && hCol <= span[1];
    const fillColor = isHovered ? groupTheme.bgHeaderHovered : groupTheme.bgHeader;

    if (fillColor !== theme.bgHeader) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }

    ctx.fillStyle = (_a2 = groupTheme.textGroupHeader) != null ? _a2 : groupTheme.textHeader;

    if (group !== void 0) {
      let drawX = x;

      if (group.icon !== void 0) {
        spriteManager.drawSprite(group.icon, "normal", ctx, drawX + xPad, (groupHeaderHeight - 20) / 2, 20, groupTheme);
        drawX += 26;
      }

      ctx.fillText(group.name, drawX + xPad, groupHeaderHeight / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));

      if (group.actions !== void 0 && isHovered) {
        const actionBoxes = getActionBoundsForGroup({
          x,
          y,
          width: w,
          height: h
        }, group.actions);
        ctx.beginPath();
        const fadeStartX = actionBoxes[0].x - 10;
        const fadeWidth = x + w - fadeStartX;
        ctx.rect(fadeStartX, 0, fadeWidth, groupHeaderHeight);
        const grad = ctx.createLinearGradient(fadeStartX, 0, fadeStartX + fadeWidth, 0);
        const trans = withAlpha(fillColor, 0);
        grad.addColorStop(0, trans);
        grad.addColorStop(10 / fadeWidth, fillColor);
        grad.addColorStop(1, fillColor);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 0.6;
        const [mouseX, mouseY] = (_b = hovered == null ? void 0 : hovered[1]) != null ? _b : [-1, -1];

        for (let i = 0; i < group.actions.length; i++) {
          const action = group.actions[i];
          const box = actionBoxes[i];
          const actionHovered = pointInRect(box, mouseX + x, mouseY);

          if (actionHovered) {
            ctx.globalAlpha = 1;
          }

          spriteManager.drawSprite(action.icon, "normal", ctx, box.x + box.width / 2 - 10, box.y + box.height / 2 - 10, 20, groupTheme);

          if (actionHovered) {
            ctx.globalAlpha = 0.6;
          }
        }

        ctx.globalAlpha = 1;
      }
    }

    if (x !== 0 && verticalBorder(span[0])) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, groupHeaderHeight);
      ctx.strokeStyle = theme.borderColor;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.restore();
    finalX = x + w;
  });
  ctx.beginPath();
  ctx.moveTo(finalX + 0.5, 0);
  ctx.lineTo(finalX + 0.5, groupHeaderHeight);
  ctx.moveTo(0, groupHeaderHeight + 0.5);
  ctx.lineTo(width, groupHeaderHeight + 0.5);
  ctx.strokeStyle = theme.borderColor;
  ctx.lineWidth = 1;
  ctx.stroke();
}

var menuButtonSize = 30;

function getHeaderMenuBounds(x, y, width, height) {
  return {
    x: x + width - menuButtonSize,
    y: Math.max(y, y + height / 2 - menuButtonSize / 2),
    width: menuButtonSize,
    height: Math.min(menuButtonSize, height)
  };
}

function drawHeader(ctx, x, y, width, height, c, selected, theme, isHovered, hasSelectedCell, hoverAmount, spriteManager, drawHeaderCallback, touchMode) {
  const isCheckboxHeader = c.title.startsWith(headerCellCheckboxPrefix);
  const menuBounds = getHeaderMenuBounds(x, y, width, height);

  if (drawHeaderCallback !== void 0) {
    let passCol = c;

    if (isCheckboxHeader) {
      passCol = { ...c,
        title: ""
      };
    }

    if (drawHeaderCallback({
      ctx,
      theme,
      rect: {
        x,
        y,
        width,
        height
      },
      column: passCol,
      columnIndex: passCol.sourceIndex,
      isSelected: selected,
      hoverAmount,
      isHovered,
      hasSelectedCell,
      spriteManager,
      menuBounds
    })) {
      return;
    }
  }

  if (isCheckboxHeader) {
    let checked = void 0;
    if (c.title === headerCellCheckedMarker) checked = true;
    if (c.title === headerCellUnheckedMarker) checked = false;

    if (checked !== true) {
      ctx.globalAlpha = hoverAmount;
    }

    drawCheckbox(ctx, theme, checked, x, y, width, height, false, void 0, void 0, 18);

    if (checked !== true) {
      ctx.globalAlpha = 1;
    }

    return;
  }

  const xPad = theme.cellHorizontalPadding;
  const fillStyle = selected ? theme.textHeaderSelected : theme.textHeader;
  const shouldDrawMenu = c.hasMenu === true && (isHovered || touchMode && selected);
  let drawX = x + xPad;

  if (c.icon !== void 0) {
    let variant = selected ? "selected" : "normal";

    if (c.style === "highlight") {
      variant = selected ? "selected" : "special";
    }

    const headerSize = theme.headerIconSize;
    spriteManager.drawSprite(c.icon, variant, ctx, drawX, y + (height - headerSize) / 2, headerSize, theme);

    if (c.overlayIcon !== void 0) {
      spriteManager.drawSprite(c.overlayIcon, selected ? "selected" : "special", ctx, drawX + 9, y + ((height - 18) / 2 + 6), 18, theme);
    }

    drawX += Math.ceil(headerSize * 1.3);
  }

  if (shouldDrawMenu && c.hasMenu === true && width > 35) {
    const fadeWidth = 35;
    const fadeStart = width - fadeWidth;
    const fadeEnd = width - fadeWidth * 0.7;
    const fadeStartPercent = fadeStart / width;
    const fadeEndPercent = fadeEnd / width;
    const grad = ctx.createLinearGradient(x, 0, x + width, 0);
    const trans = withAlpha(fillStyle, 0);
    grad.addColorStop(0, fillStyle);
    grad.addColorStop(fadeStartPercent, fillStyle);
    grad.addColorStop(fadeEndPercent, trans);
    grad.addColorStop(1, trans);
    ctx.fillStyle = grad;
  } else {
    ctx.fillStyle = fillStyle;
  }

  ctx.fillText(c.title, drawX, y + height / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));

  if (shouldDrawMenu && c.hasMenu === true) {
    ctx.beginPath();
    const triangleX = menuBounds.x + menuBounds.width / 2 - 5.5;
    const triangleY = menuBounds.y + menuBounds.height / 2 - 3;
    roundedPoly(ctx, [{
      x: triangleX,
      y: triangleY
    }, {
      x: triangleX + 11,
      y: triangleY
    }, {
      x: triangleX + 5.5,
      y: triangleY + 6
    }], 1);
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }
}

function drawGridHeaders(ctx, effectiveCols, enableGroups, hovered, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode) {
  var _a;

  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (totalHeaderHeight <= 0) return;
  ctx.fillStyle = outerTheme.bgHeader;
  ctx.fillRect(0, 0, width, totalHeaderHeight);
  const [hCol, hRow] = (_a = hovered == null ? void 0 : hovered[0]) != null ? _a : [];
  const font = `${outerTheme.headerFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  walkColumns(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x, _y, clipX) => {
    var _a2, _b, _c;

    if (damage !== void 0 && !damage.some(d => d[1] === -1 && d[0] === c.sourceIndex)) return;
    const diff = Math.max(0, clipX - x);
    ctx.save();
    ctx.beginPath();
    ctx.rect(x + diff, groupHeaderHeight, c.width - diff, headerHeight);
    ctx.clip();
    const groupTheme = getGroupDetails((_a2 = c.group) != null ? _a2 : "").overrideTheme;
    const theme = c.themeOverride === void 0 && groupTheme === void 0 ? outerTheme : { ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };

    if (theme.bgHeader !== outerTheme.bgHeader) {
      ctx.fillStyle = theme.bgHeader;
      ctx.fill();
    }

    const f = `${theme.headerFontStyle} ${theme.fontFamily}`;

    if (font !== f) {
      ctx.font = f;
    }

    const selected = selection.columns.hasIndex(c.sourceIndex);
    const noHover = dragAndDropState !== void 0 || isResizing;
    const hoveredBoolean = !noHover && hRow === -1 && hCol === c.sourceIndex;
    const hover = noHover ? 0 : (_c = (_b = hoverValues.find(s => s.item[0] === c.sourceIndex && s.item[1] === -1)) == null ? void 0 : _b.hoverAmount) != null ? _c : 0;
    const hasSelectedCell = (selection == null ? void 0 : selection.current) !== void 0 && selection.current.cell[0] === c.sourceIndex;
    const bgFillStyle = selected ? theme.accentColor : hasSelectedCell ? theme.bgHeaderHasFocus : theme.bgHeader;
    const y = enableGroups ? groupHeaderHeight : 0;
    const xOffset = c.sourceIndex === 0 ? 0 : 1;

    if (selected) {
      ctx.fillStyle = bgFillStyle;
      ctx.fillRect(x + xOffset, y, c.width - xOffset, headerHeight);
    } else if (hasSelectedCell || hover > 0) {
      ctx.beginPath();
      ctx.rect(x + xOffset, y, c.width - xOffset, headerHeight);

      if (hasSelectedCell) {
        ctx.fillStyle = theme.bgHeaderHasFocus;
        ctx.fill();
      }

      if (hover > 0) {
        ctx.globalAlpha = hover;
        ctx.fillStyle = theme.bgHeaderHovered;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    drawHeader(ctx, x, y, c.width, headerHeight, c, selected, theme, hoveredBoolean, hasSelectedCell, hover, spriteManager, drawHeaderCallback, touchMode);
    ctx.restore();
  });

  if (enableGroups) {
    drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage);
  }
}

function intersectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
  return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;
}

function clipDamage(ctx, effectiveColumns, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, includeCells) {
  if (damage === void 0 || damage.length === 0) return;
  const stickyRowHeight = trailingRowType === "sticky" ? getRowHeight(rows - 1) : 0;
  ctx.beginPath();
  walkGroups(effectiveColumns, width, translateX, groupHeaderHeight, (span, _group, x, y, w, h) => {
    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];

      if (d[1] === -2 && d[0] >= span[0] && d[0] <= span[1]) {
        ctx.rect(x, y, w, h);
        break;
      }
    }
  });
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    const diff = Math.max(0, clipX - drawX);
    const finalX = drawX + diff + 1;
    const finalWidth = c.width - diff - 1;

    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];

      if (d[0] === c.sourceIndex && (d[1] === -1 || d[1] === void 0)) {
        ctx.rect(finalX, groupHeaderHeight, finalWidth, totalHeaderHeight - groupHeaderHeight);
        break;
      }
    }

    if (!includeCells) return;
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      let isDamaged = false;

      for (let i = 0; i < damage.length; i++) {
        const d = damage[i];

        if (d[0] === c.sourceIndex && d[1] === row) {
          isDamaged = true;
          break;
        }
      }

      if (isDamaged) {
        const top = drawY + 1;
        const bottom = isSticky ? top + rh - 1 : Math.min(top + rh - 1, height - stickyRowHeight);
        const h = bottom - top;

        if (h > 0) {
          ctx.rect(finalX, top, finalWidth, h);
        }
      }
    });
  });
  ctx.clip();
}

function getSpanBounds(span, cellX, cellY, cellW, cellH, column, allColumns) {
  var _a, _b;

  const [startCol, endCol] = span;
  let frozenRect;
  let contentRect;
  const firstNonSticky = (_b = (_a = allColumns.find(x => !x.sticky)) == null ? void 0 : _a.sourceIndex) != null ? _b : 0;

  if (endCol > firstNonSticky) {
    const renderFromCol = Math.max(startCol, firstNonSticky);
    let tempX = cellX;
    let tempW = cellW;

    for (let x = column.sourceIndex - 1; x >= renderFromCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }

    for (let x = column.sourceIndex + 1; x <= endCol; x++) {
      tempW += allColumns[x].width;
    }

    contentRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }

  if (firstNonSticky > startCol) {
    const renderToCol = Math.min(endCol, firstNonSticky - 1);
    let tempX = cellX;
    let tempW = cellW;

    for (let x = column.sourceIndex - 1; x >= startCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }

    for (let x = column.sourceIndex + 1; x <= renderToCol; x++) {
      tempW += allColumns[x].width;
    }

    frozenRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }

  return [frozenRect, contentRect];
}

function drawCells(ctx, effectiveColumns, allColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, outerTheme, enqueue, getCellRenderer) {
  var _a;

  let toDraw = (_a = damage == null ? void 0 : damage.length) != null ? _a : Number.MAX_SAFE_INTEGER;
  const frameTime = performance.now();
  let font = `${outerTheme.baseFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  let result;
  const handledSpans = new Set();
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawStartY, clipX, startRow) => {
    var _a2;

    const diff = Math.max(0, clipX - drawX);
    const colDrawX = drawX + diff;
    const colDrawY = totalHeaderHeight + 1;
    const colWidth = c.width - diff;
    const colHeight = height - totalHeaderHeight - 1;

    if (drawRegions.length > 0) {
      let found = false;

      for (let i = 0; i < drawRegions.length; i++) {
        const dr = drawRegions[i];

        if (intersectRect(colDrawX, colDrawY, colWidth, colHeight, dr.x, dr.y, dr.width, dr.height)) {
          found = true;
          break;
        }
      }

      if (!found) return;
    }

    const reclip = () => {
      ctx.save();
      ctx.beginPath();
      ctx.rect(colDrawX, colDrawY, colWidth, colHeight);
      ctx.clip();
    };

    const colSelected = selection.columns.hasIndex(c.sourceIndex);
    const groupTheme = getGroupDetails((_a2 = c.group) != null ? _a2 : "").overrideTheme;
    const colTheme = c.themeOverride === void 0 && groupTheme === void 0 ? outerTheme : { ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };
    const colFont = `${colTheme.baseFontStyle} ${colTheme.fontFamily}`;

    if (colFont !== font) {
      font = colFont;
      ctx.font = colFont;
    }

    reclip();
    let prepResult = void 0;
    walkRowsInCol(startRow, colDrawStartY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky, isTrailingRow) => {
      var _a3, _b, _c, _d;

      if (row < 0) return;

      if (damage !== void 0) {
        let found = false;

        for (let i = 0; i < damage.length; i++) {
          const d = damage[i];

          if (d[0] === c.sourceIndex && d[1] === row) {
            found = true;
            break;
          }
        }

        if (!found) return;
      }

      if (drawRegions.length > 0) {
        let found = false;

        for (let i = 0; i < drawRegions.length; i++) {
          const dr = drawRegions[i];

          if (intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height)) {
            found = true;
            break;
          }
        }

        if (!found) return;
      }

      const rowSelected = selection.rows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      const cell = row < rows ? getCellContent([c.sourceIndex, row]) : loadingCell;
      let cellX = drawX;
      let cellWidth = c.width;
      let drawingSpan = false;
      let skipContents = false;

      if (cell.span !== void 0) {
        const [startCol, endCol] = cell.span;
        const spanKey = `${row},${startCol},${endCol},${c.sticky}`;

        if (!handledSpans.has(spanKey)) {
          const areas = getSpanBounds(cell.span, drawX, drawY, c.width, rh, c, allColumns);
          const area = c.sticky ? areas[0] : areas[1];

          if (!c.sticky && areas[0] !== void 0) {
            skipContents = true;
          }

          if (area !== void 0) {
            cellX = area.x;
            cellWidth = area.width;
            handledSpans.add(spanKey);
            ctx.restore();
            prepResult = void 0;
            ctx.save();
            ctx.beginPath();
            const d = Math.max(0, clipX - area.x);
            ctx.rect(area.x + d, drawY, area.width - d, rh);

            if (result === void 0) {
              result = [];
            }

            result.push({
              x: area.x + d,
              y: drawY,
              width: area.width - d,
              height: rh
            });
            ctx.clip();
            drawingSpan = true;
          }
        } else {
          toDraw--;
          return;
        }
      }

      const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
      const trailingTheme = isTrailingRow && ((_a3 = c.trailingRowOptions) == null ? void 0 : _a3.themeOverride) !== void 0 ? (_b = c.trailingRowOptions) == null ? void 0 : _b.themeOverride : void 0;
      const theme = cell.themeOverride === void 0 && rowTheme === void 0 && trailingTheme === void 0 ? colTheme : { ...colTheme,
        ...rowTheme,
        ...trailingTheme,
        ...cell.themeOverride
      };
      ctx.beginPath();
      const cellIndex = [c.sourceIndex, row];
      const isSelected = cellIsSelected(cellIndex, cell, selection);
      let accentCount = cellIsInRange(cellIndex, cell, selection);
      const spanIsHighlighted = cell.span !== void 0 && selection.columns.some(index => cell.span !== void 0 && index >= cell.span[0] && index <= cell.span[1]);

      if (isSelected && !isFocused && drawFocus) {
        accentCount = 0;
      } else if (isSelected) {
        accentCount = Math.max(accentCount, 1);
      }

      if (spanIsHighlighted) {
        accentCount++;
      }

      if (!isSelected) {
        if (rowSelected) accentCount++;
        if (colSelected && !isSticky) accentCount++;
      }

      const bgCell = cell.kind === GridCellKind.Protected ? theme.bgCellMedium : theme.bgCell;
      let fill;

      if (isSticky || bgCell !== outerTheme.bgCell) {
        fill = blend(bgCell, fill);
      }

      if (accentCount > 0 || rowDisabled) {
        if (rowDisabled) {
          fill = blend(theme.bgHeader, fill);
        }

        for (let i = 0; i < accentCount; i++) {
          fill = blend(theme.accentLight, fill);
        }
      } else {
        if ((prelightCells == null ? void 0 : prelightCells.some(pre => pre[0] === c.sourceIndex && pre[1] === row)) === true) {
          fill = blend(theme.bgSearchResult, fill);
        }
      }

      if (highlightRegions !== void 0) {
        for (const region of highlightRegions) {
          const r = region.range;

          if (r.x <= c.sourceIndex && c.sourceIndex < r.x + r.width && r.y <= row && row < r.y + r.height) {
            fill = blend(region.color, fill);
          }
        }
      }

      if (fill !== void 0) {
        ctx.fillStyle = fill;

        if (prepResult !== void 0) {
          prepResult.fillStyle = fill;
        }

        ctx.fillRect(cellX, drawY, cellWidth, rh);
      }

      if (cell.style === "faded") {
        ctx.globalAlpha = 0.6;
      }

      const hoverValue = hoverValues.find(hv => hv.item[0] === c.sourceIndex && hv.item[1] === row);

      if (cellWidth > 10 && !skipContents) {
        const cellFont = `${theme.baseFontStyle} ${theme.fontFamily}`;

        if (cellFont !== font) {
          ctx.font = cellFont;
          font = cellFont;
        }

        prepResult = drawCell(ctx, row, cell, c.sourceIndex, cellX, drawY, cellWidth, rh, accentCount > 0, theme, drawCustomCell, imageLoader, spriteManager, (_c = hoverValue == null ? void 0 : hoverValue.hoverAmount) != null ? _c : 0, hoverInfo, hyperWrapping, frameTime, prepResult, enqueue, getCellRenderer);
      }

      if (cell.style === "faded") {
        ctx.globalAlpha = 1;
      }

      toDraw--;

      if (drawingSpan) {
        ctx.restore();
        (_d = prepResult == null ? void 0 : prepResult.deprep) == null ? void 0 : _d.call(prepResult, {
          ctx
        });
        prepResult = void 0;
        reclip();
        font = colFont;
        ctx.font = colFont;
      }

      return toDraw <= 0;
    });
    ctx.restore();
    return toDraw <= 0;
  });
  return result;
}

function drawBlanks(ctx, effectiveColumns, allColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowTheme, selectedRows, disabledRows, trailingRowType, drawRegions, damage, theme) {
  if (damage !== void 0 || effectiveColumns[effectiveColumns.length - 1] !== allColumns[effectiveColumns.length - 1]) return;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    if (c !== effectiveColumns[effectiveColumns.length - 1]) return;
    drawX += c.width;
    const x = Math.max(drawX, clipX);
    if (x > width) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, totalHeaderHeight + 1, 1e4, height - totalHeaderHeight - 1);
    ctx.clip();
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      if (!isSticky && drawRegions.length > 0 && !drawRegions.some(dr => intersectRect(drawX, drawY, 1e4, rh, dr.x, dr.y, dr.width, dr.height))) {
        return;
      }

      const rowSelected = selectedRows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      ctx.beginPath();
      const rowTheme = getRowTheme == null ? void 0 : getRowTheme(row);
      const blankTheme = rowTheme === void 0 ? theme : { ...theme,
        ...rowTheme
      };

      if (blankTheme.bgCell !== theme.bgCell) {
        ctx.fillStyle = blankTheme.bgCell;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }

      if (rowDisabled) {
        ctx.fillStyle = blankTheme.bgHeader;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }

      if (rowSelected) {
        ctx.fillStyle = blankTheme.accentLight;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }
    });
    ctx.restore();
  });
}

function overdrawStickyBoundaries(ctx, effectiveCols, width, height, lastRowSticky, rows, verticalBorder, getRowHeight, theme) {
  var _a;

  let drawFreezeBorder = false;

  for (const c of effectiveCols) {
    if (c.sticky) continue;
    drawFreezeBorder = verticalBorder(c.sourceIndex);
    break;
  }

  const hColor = (_a = theme.horizontalBorderColor) != null ? _a : theme.borderColor;
  const vColor = theme.borderColor;
  const drawX = drawFreezeBorder ? getStickyWidth(effectiveCols) : 0;

  if (drawX !== 0) {
    ctx.beginPath();
    ctx.moveTo(drawX + 0.5, 0);
    ctx.lineTo(drawX + 0.5, height);
    ctx.strokeStyle = blend(vColor, theme.bgCell);
    ctx.stroke();
  }

  if (lastRowSticky) {
    const h = getRowHeight(rows - 1);
    ctx.beginPath();
    ctx.moveTo(0, height - h + 0.5);
    ctx.lineTo(width, height - h + 0.5);
    ctx.strokeStyle = blend(hColor, theme.bgCell);
    ctx.stroke();
  }
}

function drawHighlightRings(ctx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, lastRowSticky, rows, allHighlightRegions) {
  const highlightRegions = allHighlightRegions == null ? void 0 : allHighlightRegions.filter(x => x.style !== "no-outline");
  if (highlightRegions === void 0 || highlightRegions.length === 0) return void 0;
  const drawRects = highlightRegions.map(h => {
    var _a, _b, _c, _d, _e;

    const r = h.range;
    const topLeftBounds = computeBounds(r.x, r.y, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);

    if (r.width === 1 && r.height === 1) {
      if (r.x < freezeColumns) {
        return [{
          color: h.color,
          style: (_a = h.style) != null ? _a : "dashed",
          rect: topLeftBounds
        }, void 0];
      }

      return [void 0, {
        color: h.color,
        style: (_b = h.style) != null ? _b : "dashed",
        rect: topLeftBounds
      }];
    }

    const bottomRightBounds = computeBounds(r.x + r.width - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);

    if (r.x < freezeColumns && r.x + r.width >= freezeColumns) {
      const freezeSectionRightBounds = computeBounds(freezeColumns - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      const unfreezeSectionleftBounds = computeBounds(freezeColumns, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      return [{
        color: h.color,
        style: (_c = h.style) != null ? _c : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: freezeSectionRightBounds.x + freezeSectionRightBounds.width - topLeftBounds.x,
          height: freezeSectionRightBounds.y + freezeSectionRightBounds.height - topLeftBounds.y
        }
      }, {
        color: h.color,
        style: (_d = h.style) != null ? _d : "dashed",
        rect: {
          x: unfreezeSectionleftBounds.x,
          y: unfreezeSectionleftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - unfreezeSectionleftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - unfreezeSectionleftBounds.y
        }
      }];
    } else {
      return [void 0, {
        color: h.color,
        style: (_e = h.style) != null ? _e : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - topLeftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - topLeftBounds.y
        }
      }];
    }
  });
  const stickyWidth = getStickyWidth(mappedColumns);

  const drawCb = () => {
    ctx.beginPath();
    ctx.save();
    let dashed = false;

    const setDashed = dash => {
      if (dashed === dash) return;
      ctx.setLineDash(dash ? [5, 3] : []);
      dashed = dash;
    };

    ctx.lineWidth = 1;

    for (const dr of drawRects) {
      const [s] = dr;

      if (s !== void 0 && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");
        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }

    let clipped = false;

    for (const dr of drawRects) {
      const [, s] = dr;

      if (s !== void 0 && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");

        if (!clipped && s.rect.x < stickyWidth) {
          ctx.rect(stickyWidth, 0, width, height);
          ctx.clip();
          clipped = true;
        }

        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }

    ctx.restore();
  };

  drawCb();
  return drawCb;
}

function drawFocusRing(ctx, width, height, cellYOffset, translateX, translateY, effectiveCols, allColumns, theme, totalHeaderHeight, selectedCell, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) {
  var _a;

  if (selectedCell.current === void 0 || !effectiveCols.some(c => {
    var _a2;

    return c.sourceIndex === ((_a2 = selectedCell.current) == null ? void 0 : _a2.cell[0]);
  })) return void 0;
  const [targetCol, targetRow] = selectedCell.current.cell;
  const cell = getCellContent(selectedCell.current.cell);
  const targetColSpan = (_a = cell.span) != null ? _a : [targetCol, targetCol];
  const isStickyRow = trailingRowType === "sticky" && targetRow === rows - 1;
  const stickRowHeight = trailingRowType === "sticky" && !isStickyRow ? getRowHeight(rows - 1) - 1 : 0;
  let drawCb = void 0;
  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (col, drawX, colDrawY, clipX, startRow) => {
    if (col.sticky && targetCol > col.sourceIndex) return;

    if (col.sourceIndex < targetColSpan[0] || col.sourceIndex > targetColSpan[1]) {
      return;
    }

    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh) => {
      if (row !== targetRow) return;
      let cellX = drawX;
      let cellWidth = col.width;

      if (cell.span !== void 0) {
        const areas = getSpanBounds(cell.span, drawX, drawY, col.width, rh, col, allColumns);
        const area = col.sticky ? areas[0] : areas[1];

        if (area !== void 0) {
          cellX = area.x;
          cellWidth = area.width;
        }
      }

      drawCb = () => {
        var _a2, _b, _c, _d;

        if (clipX > cellX && !col.sticky) {
          ctx.beginPath();
          ctx.rect(clipX, 0, width - clipX, height);
          ctx.clip();
        }

        ctx.beginPath();
        ctx.rect(cellX + 0.5, drawY + 0.5, cellWidth, rh);
        ctx.strokeStyle = (_b = (_a2 = col.themeOverride) == null ? void 0 : _a2.accentColor) != null ? _b : theme.accentColor;
        ctx.lineWidth = 1;
        ctx.stroke();

        if (fillHandle) {
          ctx.beginPath();
          ctx.rect(cellX + cellWidth - 4, drawY + rh - 4, 4, 4);
          ctx.fillStyle = (_d = (_c = col.themeOverride) == null ? void 0 : _c.accentColor) != null ? _d : theme.accentColor;
          ctx.fill();
        }
      };

      return true;
    });
    return true;
  });
  if (drawCb === void 0) return void 0;

  const result = () => {
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, totalHeaderHeight, width, height - totalHeaderHeight - stickRowHeight);
    ctx.clip();
    drawCb == null ? void 0 : drawCb();
    ctx.restore();
  };

  result();
  return result;
}

function getLastRow(effectiveColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType) {
  let result = 0;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (_c, __drawX, colDrawY, _clipX, startRow) => {
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (_drawY, row, _rh, isSticky) => {
      if (!isSticky) {
        result = Math.max(row, result);
      }
    });
    return true;
  });
  return result;
}

function computeCanBlit(current, last) {
  if (last === void 0) return false;

  if (current.width !== last.width || current.height !== last.height || current.theme !== last.theme || current.headerHeight !== last.headerHeight || current.rowHeight !== last.rowHeight || current.rows !== last.rows || current.getRowThemeOverride !== last.getRowThemeOverride || current.isFocused !== last.isFocused || current.isResizing !== last.isResizing || current.verticalBorder !== last.verticalBorder || current.getCellContent !== last.getCellContent || current.highlightRegions !== last.highlightRegions || current.selection !== last.selection || current.dragAndDropState !== last.dragAndDropState || current.prelightCells !== last.prelightCells || current.touchMode !== last.touchMode || current.scrolling !== last.scrolling) {
    return false;
  }

  if (current.mappedColumns !== last.mappedColumns) {
    if (current.mappedColumns.length > 100 || current.mappedColumns.length !== last.mappedColumns.length) {
      return false;
    }

    let resized;

    for (let i = 0; i < current.mappedColumns.length; i++) {
      const curCol = current.mappedColumns[i];
      const lastCol = last.mappedColumns[i];
      if (deepEqual(curCol, lastCol)) continue;
      if (resized !== void 0) return false;
      if (curCol.width === lastCol.width) return false;
      const {
        width,
        ...curRest
      } = curCol;
      const {
        width: lastWidth,
        ...lastRest
      } = lastCol;
      if (!deepEqual(curRest, lastRest)) return false;
      resized = i;
    }

    if (resized === void 0) {
      return true;
    }

    return resized;
  }

  return true;
}

function drawGrid(arg, lastArg) {
  var _a, _b;

  const {
    canvas,
    headerCanvas,
    width,
    height,
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mappedColumns,
    enableGroups,
    freezeColumns,
    dragAndDropState,
    theme,
    drawFocus,
    headerHeight,
    groupHeaderHeight,
    disabledRows,
    rowHeight,
    verticalBorder,
    isResizing,
    selection,
    fillHandle,
    lastRowSticky: trailingRowType,
    rows,
    getCellContent,
    getGroupDetails,
    getRowThemeOverride,
    isFocused,
    drawCustomCell,
    drawHeaderCallback,
    prelightCells,
    highlightRegions,
    imageLoader,
    lastBlitData,
    hoverValues,
    hyperWrapping,
    hoverInfo,
    spriteManager,
    scrolling,
    touchMode,
    enqueue,
    getCellRenderer,
    renderStrategy,
    bufferA,
    bufferB
  } = arg;
  let {
    damage
  } = arg;
  if (width === 0 || height === 0) return;
  const doubleBuffer = renderStrategy === "double-buffer";
  const dpr = scrolling ? 1 : Math.ceil((_a = window.devicePixelRatio) != null ? _a : 1);
  const canBlit = renderStrategy !== "direct" && computeCanBlit(arg, lastArg);

  if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
  }

  const overlayCanvas = headerCanvas;
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const overlayHeight = totalHeaderHeight + 1;

  if (overlayCanvas.width !== width * dpr || overlayCanvas.height !== overlayHeight * dpr) {
    overlayCanvas.width = width * dpr;
    overlayCanvas.height = overlayHeight * dpr;
    overlayCanvas.style.width = width + "px";
    overlayCanvas.style.height = overlayHeight + "px";
  }

  if (doubleBuffer && (bufferA.width !== width * dpr || bufferA.height !== height * dpr)) {
    bufferA.width = width * dpr;
    bufferA.height = height * dpr;
  }

  if (doubleBuffer && (bufferB.width !== width * dpr || bufferB.height !== height * dpr)) {
    bufferB.width = width * dpr;
    bufferB.height = height * dpr;
  }

  const last = lastBlitData.current;
  if (canBlit === true && cellXOffset === (last == null ? void 0 : last.cellXOffset) && cellYOffset === (last == null ? void 0 : last.cellYOffset) && translateX === (last == null ? void 0 : last.translateX) && translateY === (last == null ? void 0 : last.translateY)) return;
  let mainCtx = null;

  if (doubleBuffer) {
    mainCtx = canvas.getContext("2d", {
      alpha: false
    });
  }

  const overlayCtx = overlayCanvas.getContext("2d", {
    alpha: false
  });
  let targetBuffer;

  if (!doubleBuffer) {
    targetBuffer = canvas;
  } else if (damage !== void 0) {
    targetBuffer = (last == null ? void 0 : last.lastBuffer) === "b" ? bufferB : bufferA;
  } else {
    targetBuffer = (last == null ? void 0 : last.lastBuffer) === "b" ? bufferA : bufferB;
  }

  const targetCtx = targetBuffer.getContext("2d", {
    alpha: false
  });
  const blitSource = doubleBuffer ? targetBuffer === bufferA ? bufferB : bufferA : canvas;
  if (overlayCtx === null || targetCtx === null) return;
  const getRowHeight = typeof rowHeight === "number" ? () => rowHeight : rowHeight;
  overlayCtx.save();
  overlayCtx.beginPath();
  targetCtx.save();
  targetCtx.beginPath();
  overlayCtx.textBaseline = "middle";
  targetCtx.textBaseline = "middle";

  if (dpr !== 1) {
    overlayCtx.scale(dpr, dpr);
    targetCtx.scale(dpr, dpr);
  }

  const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
  let drawRegions = [];
  const mustDrawFocusOnHeader = drawFocus && ((_b = selection.current) == null ? void 0 : _b.cell[1]) === cellYOffset && translateY === 0;

  const drawHeaderTexture = () => {
    var _a2, _b2;

    drawGridHeaders(overlayCtx, effectiveCols, enableGroups, hoverInfo, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, theme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode);
    drawGridLines(overlayCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, void 0, void 0, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme, true);
    overlayCtx.beginPath();
    overlayCtx.moveTo(0, overlayHeight - 0.5);
    overlayCtx.lineTo(width, overlayHeight - 0.5);
    overlayCtx.strokeStyle = blend((_b2 = (_a2 = theme.headerBottomBorderColor) != null ? _a2 : theme.horizontalBorderColor) != null ? _b2 : theme.borderColor, theme.bgHeader);
    overlayCtx.stroke();

    if (mustDrawFocusOnHeader) {
      drawFocusRing(overlayCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
    }
  };

  if (damage !== void 0) {
    let doHeaders = false;
    damage = damage.filter(x => {
      doHeaders = doHeaders || x[1] < 0;
      return x[1] < 0 || intersectRect(cellXOffset, cellYOffset, effectiveCols.length, 300, x[0], x[1], 1, 1) || intersectRect(0, cellYOffset, freezeColumns, 300, x[0], x[1], 1, 1) || trailingRowType && intersectRect(cellXOffset, rows - 1, effectiveCols.length, 1, x[0], x[1], 1, 1);
    });

    if (damage.length > 0) {
      clipDamage(targetCtx, effectiveCols, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, true);
      targetCtx.fillStyle = theme.bgCell;
      targetCtx.fillRect(0, totalHeaderHeight + 1, width, height - totalHeaderHeight - 1);
      drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);

      if (fillHandle && drawFocus && selection.current !== void 0 && damage.some(x => {
        var _a2, _b2;

        return x[0] === ((_a2 = selection.current) == null ? void 0 : _a2.cell[0]) && x[1] === ((_b2 = selection.current) == null ? void 0 : _b2.cell[1]);
      })) {
        drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
      }
    }

    if (doHeaders) {
      clipDamage(overlayCtx, effectiveCols, width, totalHeaderHeight, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, false);
      drawHeaderTexture();
    }

    targetCtx.restore();
    overlayCtx.restore();

    if (mainCtx !== null) {
      mainCtx.fillStyle = theme.bgCell;
      mainCtx.fillRect(0, 0, width, height);
      mainCtx.drawImage(targetCtx.canvas, 0, 0);
    }

    return;
  }

  if (canBlit !== true || cellXOffset !== (last == null ? void 0 : last.cellXOffset) || translateX !== (last == null ? void 0 : last.translateX) || mustDrawFocusOnHeader !== (last == null ? void 0 : last.mustDrawFocusOnHeader)) {
    drawHeaderTexture();
  }

  if (canBlit === true) {
    assert(blitSource !== void 0 && last !== void 0);
    const {
      regions
    } = blitLastFrame(targetCtx, blitSource, last, cellXOffset, cellYOffset, translateX, translateY, trailingRowType === "sticky", width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, rowHeight, doubleBuffer);
    drawRegions = regions;
  } else if (canBlit !== false) {
    assert(last !== void 0);
    const resizedCol = canBlit;
    drawRegions = blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedCol);
  }

  overdrawStickyBoundaries(targetCtx, effectiveCols, width, height, trailingRowType === "sticky", rows, verticalBorder, getRowHeight, theme);
  const focusRedraw = drawFocus ? drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) : void 0;
  const highlightRedraw = drawHighlightRings(targetCtx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, trailingRowType === "sticky", rows, highlightRegions);
  targetCtx.fillStyle = theme.bgCell;

  if (drawRegions.length > 0) {
    targetCtx.beginPath();

    for (const r of drawRegions) {
      targetCtx.rect(r.x, r.y, r.width, r.height);
    }

    targetCtx.clip();
    targetCtx.fill();
    targetCtx.beginPath();
  } else {
    targetCtx.fillRect(0, 0, width, height);
  }

  const spans = drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);
  drawBlanks(targetCtx, effectiveCols, mappedColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowThemeOverride, selection.rows, disabledRows, trailingRowType, drawRegions, damage, theme);
  drawGridLines(targetCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme);
  focusRedraw == null ? void 0 : focusRedraw();
  highlightRedraw == null ? void 0 : highlightRedraw();

  if (mainCtx !== null) {
    mainCtx.fillStyle = theme.bgCell;
    mainCtx.fillRect(0, 0, width, height);
    mainCtx.drawImage(targetCtx.canvas, 0, 0);
  }

  const lastRowDrawn = getLastRow(effectiveCols, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType);
  imageLoader == null ? void 0 : imageLoader.setWindow({
    x: cellXOffset,
    y: cellYOffset,
    width: effectiveCols.length,
    height: lastRowDrawn - cellYOffset
  }, freezeColumns);
  lastBlitData.current = {
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mustDrawFocusOnHeader,
    lastBuffer: doubleBuffer ? targetBuffer === bufferA ? "a" : "b" : void 0
  };
  targetCtx.restore();
  overlayCtx.restore();
}

function walkRowsInCol(startRow, drawY, height, rows, getRowHeight, trailingRowType, cb) {
  let y = drawY;
  let row = startRow;
  let doSticky = trailingRowType === "sticky";

  while (y < height || doSticky) {
    const doingSticky = doSticky && y >= height;

    if (doingSticky) {
      doSticky = false;
      row = rows - 1;
    }

    const rh = getRowHeight(row);

    if (doingSticky) {
      y = height - rh;
    }

    const isMovedStickyRow = doSticky && row === rows - 1;

    if (!isMovedStickyRow && cb(y, row, rh, doingSticky, trailingRowType !== "none" && row === rows - 1) === true) {
      break;
    }

    if (doingSticky) {
      break;
    }

    y += rh;
    row++;
  }
}

function walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, cb) {
  let x = 0;
  let clipX = 0;
  const drawY = totalHeaderHeight + translateY;

  for (const c of effectiveCols) {
    const drawX = c.sticky ? clipX : x + translateX;

    if (cb(c, drawX, drawY, clipX, cellYOffset) === true) {
      break;
    }

    x += c.width;
    clipX += c.sticky ? c.width : 0;
  }
}

function walkGroups(effectiveCols, width, translateX, groupHeaderHeight, cb) {
  var _a;

  let x = 0;
  let clipX = 0;

  for (let index = 0; index < effectiveCols.length; index++) {
    const startCol = effectiveCols[index];
    let end = index + 1;
    let boxWidth = startCol.width;

    if (startCol.sticky) {
      clipX += boxWidth;
    }

    while (end < effectiveCols.length && isGroupEqual(effectiveCols[end].group, startCol.group) && effectiveCols[end].sticky === effectiveCols[index].sticky) {
      const endCol = effectiveCols[end];
      boxWidth += endCol.width;
      end++;
      index++;

      if (endCol.sticky) {
        clipX += endCol.width;
      }
    }

    const t = startCol.sticky ? 0 : translateX;
    const localX = x + t;
    const delta = startCol.sticky ? 0 : Math.max(0, clipX - localX);
    const w = Math.min(boxWidth - delta, width - (localX + delta));
    cb([startCol.sourceIndex, effectiveCols[end - 1].sourceIndex], (_a = startCol.group) != null ? _a : "", localX + delta, 0, w, groupHeaderHeight);
    x += boxWidth;
  }
}


var hoverTime = 80;

function easeOutCubic(x) {
  const x1 = x - 1;
  return x1 * x1 * x1 + 1;
}

var AnimationManager = class {
  constructor(callback) {
    this.callback = callback;
    this.currentHoveredItem = void 0;
    this.leavingItems = [];

    this.areSameItems = (left, right) => {
      return (left == null ? void 0 : left[0]) === (right == null ? void 0 : right[0]) && (left == null ? void 0 : left[1]) === (right == null ? void 0 : right[1]);
    };

    this.addToLeavingItems = item => {
      const isAlreadyLeaving = this.leavingItems.some(i => this.areSameItems(i.item, item.item));

      if (isAlreadyLeaving) {
        return;
      }

      this.leavingItems.push(item);
    };

    this.removeFromLeavingItems = item => {
      var _a;

      const leavingItem = this.leavingItems.find(e => this.areSameItems(e.item, item));
      this.leavingItems = this.leavingItems.filter(i => i !== leavingItem);
      return (_a = leavingItem == null ? void 0 : leavingItem.hoverAmount) != null ? _a : 0;
    };

    this.cleanUpLeavingElements = () => {
      this.leavingItems = this.leavingItems.filter(i => i.hoverAmount > 0);
    };

    this.shouldStep = () => {
      const hasLeavingItems = this.leavingItems.length > 0;
      const currentHoveredIsAnimating = this.currentHoveredItem !== void 0 && this.currentHoveredItem.hoverAmount < 1;
      return hasLeavingItems || currentHoveredIsAnimating;
    };

    this.getAnimatingItems = () => {
      if (this.currentHoveredItem !== void 0) {
        return [...this.leavingItems, this.currentHoveredItem];
      }

      return this.leavingItems.map(x => ({ ...x,
        hoverAmount: easeOutCubic(x.hoverAmount)
      }));
    };

    this.step = timestamp => {
      if (this.lastAnimationTime === void 0) {
        this.lastAnimationTime = timestamp;
      } else {
        const step = timestamp - this.lastAnimationTime;
        const delta = step / hoverTime;

        for (const item of this.leavingItems) {
          item.hoverAmount = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(item.hoverAmount - delta, 0, 1);
        }

        if (this.currentHoveredItem !== void 0) {
          this.currentHoveredItem.hoverAmount = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(this.currentHoveredItem.hoverAmount + delta, 0, 1);
        }

        const animating = this.getAnimatingItems();
        this.callback(animating);
        this.cleanUpLeavingElements();
      }

      if (this.shouldStep()) {
        this.lastAnimationTime = timestamp;
        window.requestAnimationFrame(this.step);
      } else {
        this.lastAnimationTime = void 0;
      }
    };

    this.setHovered = item => {
      var _a;

      if (this.areSameItems((_a = this.currentHoveredItem) == null ? void 0 : _a.item, item)) {
        return;
      }

      if (this.currentHoveredItem !== void 0) {
        this.addToLeavingItems(this.currentHoveredItem);
      }

      if (item !== void 0) {
        const hoverAmount = this.removeFromLeavingItems(item);
        this.currentHoveredItem = {
          item,
          hoverAmount
        };
      } else {
        this.currentHoveredItem = void 0;
      }

      if (this.lastAnimationTime === void 0) {
        window.requestAnimationFrame(this.step);
      }
    };
  }

};
var Lazy = class {
  constructor(fn) {
    this.fn = fn;
  }

  get value() {
    var _a;

    return (_a = this.val) != null ? _a : this.val = this.fn();
  }

};

function lazy(fn) {
  return new Lazy(fn);
}

var browserIsFirefox = lazy(() => window.navigator.userAgent.includes("Firefox"));
var browserIsSafari = lazy(() => window.navigator.userAgent.includes("Mac OS") && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome"));
var browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith("mac"));


function hasItem(arr, item) {
  for (const element of arr) {
    if (element[0] === item[0] && element[1] === item[1]) return true;
  }

  return false;
}

function useAnimationQueue(draw) {
  const queue = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const seq = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const drawRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(draw);
  drawRef.current = draw;
  const loop = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const requeue = () => window.requestAnimationFrame(fn);

    const fn = () => {
      const toDraw = queue.current;
      queue.current = [];
      drawRef.current(toDraw);

      if (queue.current.length > 0) {
        seq.current++;
      } else {
        seq.current = 0;
      }
    };

    window.requestAnimationFrame(seq.current > 600 ? requeue : fn);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(item => {
    if (hasItem(queue.current, item)) return;

    if (queue.current.length === 0) {
      loop();
    }

    queue.current.push(item);
  }, [loop]);
}

var getRowData = (cell, getCellRenderer) => {
  var _a;

  if (cell.kind === GridCellKind.Custom) return cell.copyData;
  const r = getCellRenderer == null ? void 0 : getCellRenderer(cell);
  return (_a = r == null ? void 0 : r.getAccessibilityString(cell)) != null ? _a : "";
};

var DataGrid = (p, forwardedRef) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;

  const {
    width,
    height,
    accessibilityHeight,
    columns,
    cellXOffset: cellXOffsetReal,
    cellYOffset,
    headerHeight,
    fillHandle = false,
    groupHeaderHeight,
    rowHeight,
    rows,
    getCellContent,
    getRowThemeOverride,
    onHeaderMenuClick,
    enableGroups,
    isFilling,
    onCanvasFocused,
    onCanvasBlur,
    isFocused,
    selection,
    freezeColumns,
    onContextMenu,
    trailingRowType,
    fixedShadowX = true,
    fixedShadowY = true,
    drawFocusRing: drawFocusRing2 = true,
    onMouseDown,
    onMouseUp,
    onMouseMoveRaw,
    onMouseMove,
    onItemHovered,
    dragAndDropState,
    firstColAccessible,
    onKeyDown,
    onKeyUp,
    highlightRegions,
    canvasRef,
    onDragStart,
    onDragEnd,
    eventTargetRef,
    isResizing,
    isDragging,
    isDraggable = false,
    allowResize,
    disabledRows,
    getGroupDetails,
    theme,
    prelightCells,
    headerIcons,
    verticalBorder,
    drawHeader: drawHeaderCallback,
    drawCustomCell,
    onCellFocused,
    onDragOverCell,
    onDrop,
    onDragLeave,
    imageWindowLoader,
    smoothScrollX = false,
    smoothScrollY = false,
    experimental,
    getCellRenderer
  } = p;
  const translateX = (_a = p.translateX) != null ? _a : 0;
  const translateY = (_b = p.translateY) != null ? _b : 0;
  const cellXOffset = Math.max(freezeColumns, Math.min(columns.length - 1, cellXOffsetReal));
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const imageWindowLoaderInternal = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new image_window_loader_default(), []);
  const imageLoader = imageWindowLoader != null ? imageWindowLoader : imageWindowLoaderInternal;
  const damageRegion = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [scrolling, setScrolling] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const hoverValues = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const lastBlitData = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [hoveredItemInfo, setHoveredItemInfo] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [hoveredOnEdge, setHoveredOnEdge] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const overlayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const [lastWasTouch, setLastWasTouch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const lastWasTouchRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lastWasTouch);
  lastWasTouchRef.current = lastWasTouch;
  const spriteManager = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new SpriteManager(headerIcons, () => {
    lastArgsRef.current = void 0;
    lastDrawRef.current();
  }), [headerIcons]);
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const scrollingStopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);
  const disableFirefoxRescaling = (experimental == null ? void 0 : experimental.enableFirefoxRescaling) !== true;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (!browserIsFirefox.value || window.devicePixelRatio === 1 || disableFirefoxRescaling) return;

    if (scrollingStopRef.current !== -1) {
      setScrolling(true);
    }

    window.clearTimeout(scrollingStopRef.current);
    scrollingStopRef.current = window.setTimeout(() => {
      setScrolling(false);
      scrollingStopRef.current = -1;
    }, 200);
  }, [cellYOffset, cellXOffset, translateX, translateY, disableFirefoxRescaling]);
  const mappedColumns = useMappedColumns(columns, freezeColumns);
  const getBoundsForItem = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, col, row) => {
    const rect = canvas.getBoundingClientRect();

    if (col >= mappedColumns.length || row >= rows) {
      return void 0;
    }

    const scale = rect.width / width;
    const result = computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType === "sticky", mappedColumns, rowHeight);

    if (scale !== 1) {
      result.x *= scale;
      result.y *= scale;
      result.width *= scale;
      result.height *= scale;
    }

    result.x += rect.x;
    result.y += rect.y;
    return result;
  }, [width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType, mappedColumns, rowHeight]);
  const getMouseArgsForPosition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, posX, posY, ev) => {
    var _a2, _b2;

    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / width;
    const x = (posX - rect.left) / scale;
    const y = (posY - rect.top) / scale;
    const edgeDetectionBuffer = 5;
    const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, void 0, translateX);
    let button = 0;

    if (ev instanceof MouseEvent) {
      button = ev.button;
    }

    const col = getColumnIndexForX(x, effectiveCols, translateX);
    const row = getRowIndexForY(y, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType === "sticky");
    const shiftKey = (ev == null ? void 0 : ev.shiftKey) === true;
    const ctrlKey = (ev == null ? void 0 : ev.ctrlKey) === true;
    const metaKey = (ev == null ? void 0 : ev.metaKey) === true;
    const isTouch = ev !== void 0 && !(ev instanceof MouseEvent) || (ev == null ? void 0 : ev.pointerType) === "touch";
    const edgeSize = 20;
    const scrollEdge = [Math.abs(x) < edgeSize ? -1 : Math.abs(rect.width - x) < edgeSize ? 1 : 0, Math.abs(y) < edgeSize ? -1 : Math.abs(rect.height - y) < edgeSize ? 1 : 0];
    let result;

    if (col === -1 || y < 0 || x < 0 || row === void 0 || x > width || y > height) {
      const horizontal = x > width ? -1 : x < 0 ? 1 : 0;
      const vertical = y > height ? 1 : y < 0 ? -1 : 0;
      let isEdge = false;

      if (col === -1 && row === -1) {
        const b = getBoundsForItem(canvas, mappedColumns.length - 1, -1);
        assert(b !== void 0);
        isEdge = posX < b.x + b.width + edgeDetectionBuffer;
      }

      result = {
        kind: outOfBoundsKind,
        location: [col !== -1 ? col : x < 0 ? 0 : mappedColumns.length - 1, row != null ? row : rows - 1],
        direction: [horizontal, vertical],
        shiftKey,
        ctrlKey,
        metaKey,
        isEdge,
        isTouch,
        button,
        scrollEdge
      };
    } else if (row <= -1) {
      let bounds = getBoundsForItem(canvas, col, row);
      assert(bounds !== void 0);
      let isEdge = bounds !== void 0 && bounds.x + bounds.width - posX <= edgeDetectionBuffer;
      const previousCol = col - 1;

      if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= 0) {
        isEdge = true;
        bounds = getBoundsForItem(canvas, previousCol, row);
        assert(bounds !== void 0);
        result = {
          kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,
          location: [previousCol, row],
          bounds,
          group: (_a2 = mappedColumns[previousCol].group) != null ? _a2 : "",
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      } else {
        result = {
          kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,
          group: (_b2 = mappedColumns[col].group) != null ? _b2 : "",
          location: [col, row],
          bounds,
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      }
    } else {
      const bounds = getBoundsForItem(canvas, col, row);
      assert(bounds !== void 0);
      const isEdge = bounds !== void 0 && bounds.x + bounds.width - posX < edgeDetectionBuffer;
      const isFillHandle = fillHandle && bounds !== void 0 && bounds.x + bounds.width - posX < 6 && bounds.y + bounds.height - posY < 6;
      result = {
        kind: "cell",
        location: [col, row],
        bounds,
        isEdge,
        shiftKey,
        ctrlKey,
        isFillHandle,
        metaKey,
        isTouch,
        localEventX: posX - bounds.x,
        localEventY: posY - bounds.y,
        button,
        scrollEdge
      };
    }

    return result;
  }, [mappedColumns, cellXOffset, width, translateX, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType, getBoundsForItem, fillHandle]);

  function isSameItem(item, other) {
    if (item === other) return true;
    return (item == null ? void 0 : item.kind) === (other == null ? void 0 : other.kind) && (item == null ? void 0 : item.location[0]) === (other == null ? void 0 : other.location[0]) && (item == null ? void 0 : item.location[1]) === (other == null ? void 0 : other.location[1]);
  }

  const [hoveredItem] = hoveredItemInfo != null ? hoveredItemInfo : [];
  const enqueueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(_item => {});
  const hoverInfoRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(hoveredItemInfo);
  hoverInfoRef.current = hoveredItemInfo;
  const [bufferA, bufferB] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const a = document.createElement("canvas");
    const b = document.createElement("canvas");
    a.style["display"] = "none";
    a.style["opacity"] = "0";
    a.style["position"] = "fixed";
    b.style["display"] = "none";
    b.style["opacity"] = "0";
    b.style["position"] = "fixed";
    return [a, b];
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    document.documentElement.append(bufferA);
    document.documentElement.append(bufferB);
    return () => {
      bufferA.remove();
      bufferB.remove();
    };
  }, [bufferA, bufferB]);
  const lastArgsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const draw = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2;

    const canvas = ref.current;
    const overlay = overlayRef.current;
    if (canvas === null || overlay === null) return;
    const last = lastArgsRef.current;
    const current = {
      canvas,
      bufferA,
      bufferB,
      headerCanvas: overlay,
      width,
      height,
      cellXOffset,
      cellYOffset,
      translateX: Math.round(translateX),
      translateY: Math.round(translateY),
      mappedColumns,
      enableGroups,
      freezeColumns,
      dragAndDropState,
      theme,
      headerHeight,
      groupHeaderHeight,
      disabledRows: disabledRows != null ? disabledRows : CompactSelection.empty(),
      rowHeight,
      verticalBorder,
      isResizing,
      isFocused,
      selection,
      fillHandle,
      lastRowSticky: trailingRowType,
      rows,
      drawFocus: drawFocusRing2,
      getCellContent,
      getGroupDetails: getGroupDetails != null ? getGroupDetails : name => ({
        name
      }),
      getRowThemeOverride,
      drawCustomCell,
      drawHeaderCallback,
      prelightCells,
      highlightRegions,
      imageLoader,
      lastBlitData,
      damage: damageRegion.current,
      hoverValues: hoverValues.current,
      hoverInfo: hoverInfoRef.current,
      spriteManager,
      scrolling,
      hyperWrapping: (_a2 = experimental == null ? void 0 : experimental.hyperWrapping) != null ? _a2 : false,
      touchMode: lastWasTouch,
      enqueue: enqueueRef.current,
      renderStrategy: (_b2 = experimental == null ? void 0 : experimental.renderStrategy) != null ? _b2 : browserIsSafari.value ? "double-buffer" : "single-buffer",
      getCellRenderer
    };

    if (current.damage === void 0) {
      lastArgsRef.current = current;
      drawGrid(current, last);
    } else {
      drawGrid(current, void 0);
    }
  }, [bufferA, bufferB, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, enableGroups, freezeColumns, dragAndDropState, theme, headerHeight, groupHeaderHeight, disabledRows, rowHeight, verticalBorder, isResizing, isFocused, selection, fillHandle, trailingRowType, rows, drawFocusRing2, getCellContent, getGroupDetails, getRowThemeOverride, drawCustomCell, drawHeaderCallback, prelightCells, highlightRegions, imageLoader, spriteManager, scrolling, experimental == null ? void 0 : experimental.hyperWrapping, experimental == null ? void 0 : experimental.renderStrategy, lastWasTouch, getCellRenderer]);
  const lastDrawRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(draw);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    draw();
    lastDrawRef.current = draw;
  }, [draw]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const fn = async () => {
      var _a2;

      if (((_a2 = document == null ? void 0 : document.fonts) == null ? void 0 : _a2.ready) === void 0) return;
      await document.fonts.ready;
      lastArgsRef.current = void 0;
      lastDrawRef.current();
    };

    void fn();
  }, []);
  const damageInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(locations => {
    damageRegion.current = locations;
    lastDrawRef.current();
    damageRegion.current = void 0;
  }, []);
  const enqueue = useAnimationQueue(damageInternal);
  enqueueRef.current = enqueue;
  const damage = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cells => {
    damageInternal(cells.map(x => x.cell));
  }, [damageInternal]);
  imageLoader.setCallback(damageInternal);
  const [overFill, setOverFill] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [hCol, hRow] = hoveredItem != null ? hoveredItem : [];
  const headerHovered = hCol !== void 0 && hRow === -1;
  const groupHeaderHovered = hCol !== void 0 && hRow === -2;
  let clickableInnerCellHovered = false;
  let editableBoolHovered = false;
  let cursorOverride;

  if (hCol !== void 0 && hRow !== void 0 && hRow > -1) {
    const cell = getCellContent([hCol, hRow], true);
    clickableInnerCellHovered = cell.kind === InnerGridCellKind.NewRow || cell.kind === InnerGridCellKind.Marker && cell.markerKind !== "number";
    editableBoolHovered = cell.kind === GridCellKind.Boolean && booleanCellIsEditable(cell);
    cursorOverride = cell.cursor;
  }

  const canDrag = hoveredOnEdge != null ? hoveredOnEdge : false;
  const cursor = isDragging ? "grabbing" : canDrag || isResizing ? "col-resize" : overFill || isFilling ? "crosshair" : cursorOverride !== void 0 ? cursorOverride : headerHovered || clickableInnerCellHovered || editableBoolHovered || groupHeaderHovered ? "pointer" : "default";
  const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    contain: "strict",
    display: "block",
    cursor
  }), [cursor]);
  const lastSetCursor = react__WEBPACK_IMPORTED_MODULE_0__.useRef("default");
  const target = eventTargetRef == null ? void 0 : eventTargetRef.current;

  if (target !== null && target !== void 0 && lastSetCursor.current !== style.cursor) {
    target.style.cursor = lastSetCursor.current = style.cursor;
  }

  const groupHeaderActionForEvent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((group, bounds, localEventX, localEventY) => {
    if (getGroupDetails === void 0) return void 0;
    const groupDesc = getGroupDetails(group);

    if (groupDesc.actions !== void 0) {
      const boxes = getActionBoundsForGroup(bounds, groupDesc.actions);

      for (const [i, box] of boxes.entries()) {
        if (pointInRect(box, localEventX + bounds.x, localEventY + box.y)) {
          return groupDesc.actions[i];
        }
      }
    }

    return void 0;
  }, [getGroupDetails]);
  const isOverHeaderMenu = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, col, clientX, clientY) => {
    const header = columns[col];

    if (!isDragging && !isResizing && header.hasMenu === true && !(hoveredOnEdge != null ? hoveredOnEdge : false)) {
      const headerBounds = getBoundsForItem(canvas, col, -1);
      assert(headerBounds !== void 0);
      const menuBounds = getHeaderMenuBounds(headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height);

      if (clientX > menuBounds.x && clientX < menuBounds.x + menuBounds.width && clientY > menuBounds.y && clientY < menuBounds.y + menuBounds.height) {
        return headerBounds;
      }
    }

    return void 0;
  }, [columns, getBoundsForItem, hoveredOnEdge, isDragging, isResizing]);
  const downTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const downPosition = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    const canvas = ref.current;
    const eventTarget = eventTargetRef == null ? void 0 : eventTargetRef.current;
    if (canvas === null || ev.target !== canvas && ev.target !== eventTarget) return;
    let clientX;
    let clientY;

    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;
    } else {
      clientX = ev.touches[0].clientX;
      clientY = ev.touches[0].clientY;
    }

    if (ev.target === eventTarget && eventTarget !== null) {
      const bounds = eventTarget.getBoundingClientRect();
      if (clientX > bounds.left + eventTarget.clientWidth) return;
      if (clientY > bounds.top + eventTarget.clientHeight) return;
    }

    const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);
    downPosition.current = args.location;

    if (args.isTouch) {
      downTime.current = Date.now();
    }

    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }

    if (args.kind === headerKind && isOverHeaderMenu(canvas, args.location[0], clientX, clientY) !== void 0) {
      return;
    } else if (args.kind === groupHeaderKind) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);

      if (action !== void 0) {
        return;
      }
    }

    onMouseDown == null ? void 0 : onMouseDown(args);

    if (!args.isTouch && isDraggable !== true && isDraggable !== args.kind) {
      ev.preventDefault();
    }
  }, [eventTargetRef, isDraggable, getMouseArgsForPosition, groupHeaderActionForEvent, isOverHeaderMenu, onMouseDown]);
  useEventListener("touchstart", onMouseDownImpl, window, false);
  useEventListener("mousedown", onMouseDownImpl, window, false);
  const onMouseUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a2, _b2;

    const canvas = ref.current;
    if (onMouseUp === void 0 || canvas === null) return;
    const eventTarget = eventTargetRef == null ? void 0 : eventTargetRef.current;
    const isOutside = ev.target !== canvas && ev.target !== eventTarget;
    let clientX;
    let clientY;

    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;

      if (ev.pointerType === "touch") {
        return;
      }
    } else {
      clientX = ev.changedTouches[0].clientX;
      clientY = ev.changedTouches[0].clientY;
    }

    let args = getMouseArgsForPosition(canvas, clientX, clientY, ev);

    if (args.isTouch && downTime.current !== 0 && Date.now() - downTime.current > 500) {
      args = { ...args,
        isLongTouch: true
      };
    }

    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }

    if (!isOutside && ev.cancelable) {
      ev.preventDefault();
    }

    if (args.kind === headerKind && isOverHeaderMenu(canvas, args.location[0], clientX, clientY)) {
      const [col] = args.location;
      const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);

      if (headerBounds !== void 0) {
        if (args.button === 0 && ((_a2 = downPosition.current) == null ? void 0 : _a2[0]) === col && ((_b2 = downPosition.current) == null ? void 0 : _b2[1]) === -1) {
          onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col, headerBounds);
        } else {
          onMouseUp(args, true);
        }

        return;
      }
    } else if (args.kind === groupHeaderKind) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);

      if (action !== void 0) {
        if (args.button === 0) {
          action.onClick(args);
        }

        return;
      }
    }

    onMouseUp(args, isOutside);
  }, [onMouseUp, eventTargetRef, getMouseArgsForPosition, isOverHeaderMenu, onHeaderMenuClick, groupHeaderActionForEvent]);
  useEventListener("click", onMouseUpImpl, window, false);
  useEventListener("touchend", onMouseUpImpl, window, false);
  const onContextMenuImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    const canvas = ref.current;
    if (canvas === null || onContextMenu === void 0) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);
    onContextMenu(args, () => {
      if (ev.cancelable) ev.preventDefault();
    });
  }, [getMouseArgsForPosition, onContextMenu]);
  useEventListener("contextmenu", onContextMenuImpl, (_c = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _c : null, false);
  const onAnimationFrame = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(values => {
    damageRegion.current = values.map(x => x.item);
    hoverValues.current = values;
    lastDrawRef.current();
    damageRegion.current = void 0;
  }, []);
  const animManagerValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new AnimationManager(onAnimationFrame), [onAnimationFrame]);
  const animationManager = react__WEBPACK_IMPORTED_MODULE_0__.useRef(animManagerValue);
  animationManager.current = animManagerValue;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const am = animationManager.current;

    if (hoveredItem === void 0 || hoveredItem[1] < 0) {
      am.setHovered(hoveredItem);
      return;
    }

    const cell = getCellContent(hoveredItem);
    const r = getCellRenderer(cell);
    am.setHovered(r === void 0 && cell.kind === GridCellKind.Custom || (r == null ? void 0 : r.needsHover) === true ? hoveredItem : void 0);
  }, [getCellContent, getCellRenderer, hoveredItem]);
  const hoveredRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseMoveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a2;

    const canvas = ref.current;
    if (canvas === null) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);

    if (!isSameItem(args, hoveredRef.current)) {
      onItemHovered == null ? void 0 : onItemHovered(args);
      setHoveredItemInfo(args.kind === outOfBoundsKind ? void 0 : [args.location, [args.localEventX, args.localEventY]]);
      hoveredRef.current = args;
    } else if (args.kind === "cell" || args.kind === headerKind || args.kind === groupHeaderKind) {
      const newInfo = [args.location, [args.localEventX, args.localEventY]];
      setHoveredItemInfo(newInfo);
      hoverInfoRef.current = newInfo;

      if (args.kind === "cell") {
        const toCheck = getCellContent(args.location);

        if (toCheck.kind === GridCellKind.Custom || ((_a2 = getCellRenderer(toCheck)) == null ? void 0 : _a2.needsHoverPosition) === true) {
          damageInternal([args.location]);
        }
      } else if (args.kind === groupHeaderKind) {
        damageInternal([args.location]);
      }
    }

    const notRowMarkerCol = args.location[0] >= (firstColAccessible ? 0 : 1);
    setHoveredOnEdge(args.kind === headerKind && args.isEdge && notRowMarkerCol && allowResize === true);

    if (fillHandle && selection.current !== void 0) {
      const [col, row] = selection.current.cell;
      const sb = getBoundsForItem(canvas, col, row);
      const x = ev.clientX;
      const y = ev.clientY;
      assert(sb !== void 0);
      setOverFill(x >= sb.x + sb.width - 6 && x <= sb.x + sb.width && y >= sb.y + sb.height - 6 && y <= sb.y + sb.height);
    } else {
      setOverFill(false);
    }

    onMouseMoveRaw == null ? void 0 : onMouseMoveRaw(ev);
    onMouseMove(args);
  }, [getMouseArgsForPosition, allowResize, fillHandle, selection, onMouseMoveRaw, onMouseMove, onItemHovered, getCellContent, getCellRenderer, damageInternal, getBoundsForItem, firstColAccessible]);
  useEventListener("mousemove", onMouseMoveImpl, window, true);
  const onKeyDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;

    if (selection.current !== void 0) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }

    onKeyDown == null ? void 0 : onKeyDown({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => void 0,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyDown, selection, getBoundsForItem]);
  const onKeyUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;

    if (selection.current !== void 0) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }

    onKeyUp == null ? void 0 : onKeyUp({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => void 0,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyUp, selection, getBoundsForItem]);
  const refImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(instance => {
    ref.current = instance;

    if (canvasRef !== void 0) {
      canvasRef.current = instance;
    }
  }, [canvasRef]);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;

    if (canvas === null || isDraggable === false || isResizing) {
      event.preventDefault();
      return;
    }

    let dragMime;
    let dragData;
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);

    if (isDraggable !== true && args.kind !== isDraggable) {
      event.preventDefault();
      return;
    }

    const setData = (mime, payload) => {
      dragMime = mime;
      dragData = payload;
    };

    let dragImage;
    let dragImageX;
    let dragImageY;

    const setDragImage = (image, x, y) => {
      dragImage = image;
      dragImageX = x;
      dragImageY = y;
    };

    let prevented = false;
    onDragStart == null ? void 0 : onDragStart({ ...args,
      setData,
      setDragImage,
      preventDefault: () => prevented = true,
      defaultPrevented: () => prevented
    });

    if (!prevented && dragMime !== void 0 && dragData !== void 0 && event.dataTransfer !== null) {
      event.dataTransfer.setData(dragMime, dragData);
      event.dataTransfer.effectAllowed = "copyLink";

      if (dragImage !== void 0 && dragImageX !== void 0 && dragImageY !== void 0) {
        event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);
      } else {
        const [col, row] = args.location;

        if (row !== void 0) {
          const offscreen = document.createElement("canvas");
          const boundsForDragTarget = getBoundsForItem(canvas, col, row);
          assert(boundsForDragTarget !== void 0);
          offscreen.width = boundsForDragTarget.width;
          offscreen.height = boundsForDragTarget.height;
          const ctx = offscreen.getContext("2d");

          if (ctx !== null) {
            ctx.textBaseline = "middle";

            if (row === -1) {
              ctx.font = `${theme.headerFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgHeader;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawHeader(ctx, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, mappedColumns[col], false, theme, false, false, 0, spriteManager, drawHeaderCallback, false);
            } else {
              ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgCell;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawCell(ctx, row, getCellContent([col, row]), 0, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, false, theme, drawCustomCell, imageLoader, spriteManager, 1, void 0, false, 0, void 0, void 0, getCellRenderer);
            }
          }

          offscreen.style.left = "-100%";
          offscreen.style.position = "absolute";
          document.body.append(offscreen);
          event.dataTransfer.setDragImage(offscreen, boundsForDragTarget.width / 2, boundsForDragTarget.height / 2);
          window.setTimeout(() => {
            offscreen.remove();
          }, 0);
        }
      }
    } else {
      event.preventDefault();
    }
  }, [isDraggable, isResizing, getMouseArgsForPosition, onDragStart, getBoundsForItem, theme, mappedColumns, spriteManager, drawHeaderCallback, getCellContent, drawCustomCell, imageLoader, getCellRenderer]);
  useEventListener("dragstart", onDragStartImpl, (_d = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _d : null, false, false);
  const activeDropTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onDragOverImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    var _a2;

    const canvas = ref.current;

    if (onDrop !== void 0) {
      event.preventDefault();
    }

    if (canvas === null || onDragOverCell === void 0) {
      return;
    }

    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    const [activeCol, activeRow] = (_a2 = activeDropTarget.current) != null ? _a2 : [];

    if (activeCol !== col || activeRow !== row) {
      activeDropTarget.current = [col, row];
      onDragOverCell([col, row], event.dataTransfer);
    }
  }, [firstColAccessible, getMouseArgsForPosition, onDragOverCell, onDrop]);
  useEventListener("dragover", onDragOverImpl, (_e = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _e : null, false, false);
  const onDragEndImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    activeDropTarget.current = void 0;
    onDragEnd == null ? void 0 : onDragEnd();
  }, [onDragEnd]);
  useEventListener("dragend", onDragEndImpl, (_f = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _f : null, false, false);
  const onDropImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;

    if (canvas === null || onDrop === void 0) {
      return;
    }

    event.preventDefault();
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    onDrop([col, row], event.dataTransfer);
  }, [firstColAccessible, getMouseArgsForPosition, onDrop]);
  useEventListener("drop", onDropImpl, (_g = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _g : null, false, false);
  const onDragLeaveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    onDragLeave == null ? void 0 : onDragLeave();
  }, [onDragLeave]);
  useEventListener("dragleave", onDragLeaveImpl, (_h = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _h : null, false, false);
  const selectionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selection);
  selectionRef.current = selection;
  const focusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const focusElement = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(el => {
    var _a2;

    if (ref.current === null || !ref.current.contains(document.activeElement)) return;

    if (el === null && selectionRef.current.current !== void 0) {
      (_a2 = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a2.focus({
        preventScroll: true
      });
    } else if (el !== null) {
      el.focus({
        preventScroll: true
      });
    }

    focusRef.current = el;
  }, [canvasRef]);
  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardedRef, () => ({
    focus: () => {
      var _a2;

      const el = focusRef.current;

      if (el === null || !document.contains(el)) {
        (_a2 = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a2.focus({
          preventScroll: true
        });
      } else {
        el.focus({
          preventScroll: true
        });
      }
    },
    getBounds: (col, row) => {
      if (canvasRef === void 0 || canvasRef.current === null) {
        return void 0;
      }

      return getBoundsForItem(canvasRef.current, col, row != null ? row : -1);
    },
    damage
  }), [canvasRef, damage, getBoundsForItem]);
  const lastFocusedSubdomNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const accessibilityTree = useDebouncedMemo(() => {
    var _a2, _b2, _c2, _d2;

    if (width < 50) return null;
    let effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
    const colOffset = firstColAccessible ? 0 : -1;

    if (!firstColAccessible && ((_a2 = effectiveCols[0]) == null ? void 0 : _a2.sourceIndex) === 0) {
      effectiveCols = effectiveCols.slice(1);
    }

    const [fCol, fRow] = (_c2 = (_b2 = selection.current) == null ? void 0 : _b2.cell) != null ? _c2 : [];
    const range2 = (_d2 = selection.current) == null ? void 0 : _d2.range;
    const visibleCols = effectiveCols.map(c => c.sourceIndex);
    const visibleRows = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(cellYOffset, Math.min(rows, cellYOffset + accessibilityHeight));

    if (fCol !== void 0 && fRow !== void 0 && !(visibleCols.includes(fCol) && visibleRows.includes(fRow))) {
      focusElement(null);
    }

    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", {
      key: "access-tree",
      role: "grid",
      "aria-rowcount": rows + 1,
      "aria-multiselectable": "true",
      "aria-colcount": mappedColumns.length + colOffset
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("thead", {
      role: "rowgroup"
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
      role: "row",
      "aria-rowindex": 1
    }, effectiveCols.map(c => react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
      role: "columnheader",
      "aria-selected": selection.columns.hasIndex(c.sourceIndex),
      "aria-colindex": c.sourceIndex + 1 + colOffset,
      tabIndex: -1,
      onFocus: e => {
        if (e.target === focusRef.current) return;
        return onCellFocused == null ? void 0 : onCellFocused([c.sourceIndex, -1]);
      },
      key: c.sourceIndex
    }, c.title)))), react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", {
      role: "rowgroup"
    }, visibleRows.map(row => react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
      role: "row",
      "aria-selected": selection.rows.hasIndex(row),
      key: row,
      "aria-rowindex": row + 2
    }, effectiveCols.map(c => {
      const col = c.sourceIndex;
      const key = `${col},${row}`;
      const focused = fCol === col && fRow === row;
      const selected = range2 !== void 0 && col >= range2.x && col < range2.x + range2.width && row >= range2.y && row < range2.y + range2.height;
      const id = `glide-cell-${col}-${row}`;
      const cellContent = getCellContent([col, row], true);
      return react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
        key,
        role: "gridcell",
        "aria-colindex": col + 1 + colOffset,
        "aria-selected": selected,
        "aria-readonly": isInnerOnlyCell(cellContent) || !isReadWriteCell(cellContent),
        id,
        "data-testid": id,
        onClick: () => {
          const canvas = canvasRef == null ? void 0 : canvasRef.current;
          if (canvas === null || canvas === void 0) return;
          return onKeyDown == null ? void 0 : onKeyDown({
            bounds: getBoundsForItem(canvas, col, row),
            cancel: () => void 0,
            preventDefault: () => void 0,
            stopPropagation: () => void 0,
            ctrlKey: false,
            key: "Enter",
            keyCode: 13,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
        },
        onFocusCapture: e => {
          var _a3, _b3;

          if (e.target === focusRef.current || ((_a3 = lastFocusedSubdomNode.current) == null ? void 0 : _a3[0]) === col && ((_b3 = lastFocusedSubdomNode.current) == null ? void 0 : _b3[1]) === row) return;
          lastFocusedSubdomNode.current = [col, row];
          return onCellFocused == null ? void 0 : onCellFocused([col, row]);
        },
        ref: focused ? focusElement : void 0,
        tabIndex: -1
      }, getRowData(cellContent, getCellRenderer));
    })))));
  }, [width, mappedColumns, cellXOffset, dragAndDropState, translateX, rows, cellYOffset, accessibilityHeight, selection, focusElement, getCellContent, canvasRef, onKeyDown, getBoundsForItem, onCellFocused], 200);
  const stickyX = fixedShadowX ? getStickyWidth(mappedColumns, dragAndDropState) : 0;
  const opacityX = freezeColumns === 0 || !fixedShadowX ? 0 : cellXOffset > freezeColumns ? 1 : lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(-translateX / 100, 0, 1);
  const absoluteOffsetY = -cellYOffset * 32 + translateY;
  const opacityY = !fixedShadowY ? 0 : lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(-absoluteOffsetY / 100, 0, 1);
  const stickyShadow = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!opacityX && !opacityY) {
      return null;
    }

    const styleX = {
      position: "absolute",
      top: 0,
      left: stickyX,
      width: width - stickyX,
      height,
      opacity: opacityX,
      pointerEvents: "none",
      transition: !smoothScrollX ? "opacity 0.2s" : void 0,
      boxShadow: "inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)"
    };
    const styleY = {
      position: "absolute",
      top: totalHeaderHeight,
      left: 0,
      width,
      height,
      opacity: opacityY,
      pointerEvents: "none",
      transition: !smoothScrollY ? "opacity 0.2s" : void 0,
      boxShadow: "inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)"
    };
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, opacityX > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      id: "shadow-x",
      style: styleX
    }), opacityY > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      id: "shadow-y",
      style: styleY
    }));
  }, [opacityX, opacityY, stickyX, width, smoothScrollX, totalHeaderHeight, height, smoothScrollY]);
  const overlayStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    position: "absolute",
    top: 0,
    left: 0
  }), []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("canvas", {
    "data-testid": "data-grid-canvas",
    tabIndex: 0,
    onKeyDown: onKeyDownImpl,
    onKeyUp: onKeyUpImpl,
    onFocus: onCanvasFocused,
    onBlur: onCanvasBlur,
    ref: refImpl,
    style
  }, accessibilityTree), react__WEBPACK_IMPORTED_MODULE_0__.createElement("canvas", {
    ref: overlayRef,
    style: overlayStyle
  }), stickyShadow);
};

var data_grid_default = react__WEBPACK_IMPORTED_MODULE_0__.memo(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataGrid));

function offsetColumnSize(column, width, min, max) {
  var _a;

  return lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(Math.round(width - ((_a = column.growOffset) != null ? _a : 0)), Math.ceil(min), Math.floor(max));
}

var DataGridDnd = p => {
  var _a;

  const [resizeColStartX, setResizeColStartX] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [resizeCol, setResizeCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragCol, setDragCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dropCol, setDropCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragColActive, setDragColActive] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [dragStartX, setDragStartX] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragRow, setDragRow] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dropRow, setDropRow] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragRowActive, setDragRowActive] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [dragStartY, setDragStartY] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const {
    onHeaderMenuClick,
    getCellContent,
    onColumnMoved,
    onColumnResize,
    onColumnResizeStart,
    onColumnResizeEnd,
    gridRef,
    maxColumnWidth,
    minColumnWidth,
    onRowMoved,
    lockColumns,
    onMouseDown,
    onMouseUp,
    onItemHovered,
    onDragStart,
    canvasRef
  } = p;
  const canResize = ((_a = onColumnResize != null ? onColumnResize : onColumnResizeEnd) != null ? _a : onColumnResizeStart) !== void 0;
  const {
    columns,
    selection
  } = p;
  const selectedColumns = selection.columns;
  const onItemHoveredImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const [col, row] = args.location;

    if (dragCol !== void 0 && dropCol !== col && col >= lockColumns) {
      setDragColActive(true);
      setDropCol(col);
    } else if (dragRow !== void 0 && row !== void 0) {
      setDragRowActive(true);
      setDropRow(Math.max(0, row));
    } else {
      onItemHovered == null ? void 0 : onItemHovered(args);
    }
  }, [dragCol, dragRow, dropCol, onItemHovered, lockColumns]);
  const canDragCol = onColumnMoved !== void 0;
  const onMouseDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b;

    if (args.button === 0) {
      const [col, row] = args.location;

      if (args.kind === "out-of-bounds" && args.isEdge && canResize) {
        const bounds = (_a2 = gridRef == null ? void 0 : gridRef.current) == null ? void 0 : _a2.getBounds(columns.length - 1, -1);

        if (bounds !== void 0) {
          setResizeColStartX(bounds.x);
          setResizeCol(columns.length - 1);
        }
      } else if (args.kind === "header" && col >= lockColumns) {
        const canvas = canvasRef == null ? void 0 : canvasRef.current;

        if (args.isEdge && canResize && canvas) {
          setResizeColStartX(args.bounds.x);
          setResizeCol(col);
          const rect = canvas.getBoundingClientRect();
          const scale = rect.width / canvas.offsetWidth;
          const width = args.bounds.width / scale;
          onColumnResizeStart == null ? void 0 : onColumnResizeStart(columns[col], width, col, width + ((_b = columns[col].growOffset) != null ? _b : 0));
        } else if (args.kind === "header" && canDragCol) {
          setDragStartX(args.bounds.x);
          setDragCol(col);
        }
      } else if (args.kind === "cell" && lockColumns > 0 && col === 0 && row !== void 0 && onRowMoved !== void 0) {
        setDragStartY(args.bounds.y);
        setDragRow(row);
      }
    }

    onMouseDown == null ? void 0 : onMouseDown(args);
  }, [onMouseDown, canResize, lockColumns, onRowMoved, gridRef, columns, canDragCol, onColumnResizeStart, canvasRef]);
  const onHeaderMenuClickMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, screenPosition) => {
    if (dragColActive || dragRowActive) return;
    onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col, screenPosition);
  }, [dragColActive, dragRowActive, onHeaderMenuClick]);
  const lastResizeWidthRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);
  const clearAll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    lastResizeWidthRef.current = -1;
    setDragRow(void 0);
    setDropRow(void 0);
    setDragStartY(void 0);
    setDragRowActive(false);
    setDragCol(void 0);
    setDropCol(void 0);
    setDragStartX(void 0);
    setDragColActive(false);
    setResizeCol(void 0);
    setResizeColStartX(void 0);
  }, []);
  const onMouseUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, isOutside) => {
    var _a2, _b, _c;

    if (args.button === 0) {
      if (resizeCol !== void 0) {
        if ((selectedColumns == null ? void 0 : selectedColumns.hasIndex(resizeCol)) === true) {
          for (const c of selectedColumns) {
            if (c === resizeCol) continue;
            const col = columns[c];
            const newSize = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
            onColumnResize == null ? void 0 : onColumnResize(col, newSize, c, newSize + ((_a2 = col.growOffset) != null ? _a2 : 0));
          }
        }

        const ns = offsetColumnSize(columns[resizeCol], lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
        onColumnResizeEnd == null ? void 0 : onColumnResizeEnd(columns[resizeCol], ns, resizeCol, ns + ((_b = columns[resizeCol].growOffset) != null ? _b : 0));

        if (selectedColumns.hasIndex(resizeCol)) {
          for (const c of selectedColumns) {
            if (c === resizeCol) continue;
            const col = columns[c];
            const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
            onColumnResizeEnd == null ? void 0 : onColumnResizeEnd(col, s, c, s + ((_c = col.growOffset) != null ? _c : 0));
          }
        }
      }

      clearAll();

      if (dragCol !== void 0 && dropCol !== void 0) {
        onColumnMoved == null ? void 0 : onColumnMoved(dragCol, dropCol);
      }

      if (dragRow !== void 0 && dropRow !== void 0) {
        onRowMoved == null ? void 0 : onRowMoved(dragRow, dropRow);
      }
    }

    onMouseUp == null ? void 0 : onMouseUp(args, isOutside);
  }, [onMouseUp, resizeCol, dragCol, dropCol, dragRow, dropRow, selectedColumns, onColumnResizeEnd, columns, minColumnWidth, maxColumnWidth, onColumnResize, onColumnMoved, onRowMoved, clearAll]);
  const dragOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (dragCol === void 0 || dropCol === void 0) return void 0;
    if (dragCol === dropCol) return void 0;
    return {
      src: dragCol,
      dest: dropCol
    };
  }, [dragCol, dropCol]);
  const onMouseMove = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    var _a2, _b;

    const canvas = canvasRef == null ? void 0 : canvasRef.current;

    if (dragCol !== void 0 && dragStartX !== void 0) {
      const diff = Math.abs(event.clientX - dragStartX);

      if (diff > 20) {
        setDragColActive(true);
      }
    } else if (dragRow !== void 0 && dragStartY !== void 0) {
      const diff = Math.abs(event.clientY - dragStartY);

      if (diff > 20) {
        setDragRowActive(true);
      }
    } else if (resizeCol !== void 0 && resizeColStartX !== void 0 && canvas) {
      const rect = canvas.getBoundingClientRect();
      const scale = rect.width / canvas.offsetWidth;
      const newWidth = (event.clientX - resizeColStartX) / scale;
      const column = columns[resizeCol];
      const ns = offsetColumnSize(column, newWidth, minColumnWidth, maxColumnWidth);
      onColumnResize == null ? void 0 : onColumnResize(column, ns, resizeCol, ns + ((_a2 = column.growOffset) != null ? _a2 : 0));
      lastResizeWidthRef.current = newWidth;

      if ((selectedColumns == null ? void 0 : selectedColumns.first()) === resizeCol) {
        for (const c of selectedColumns) {
          if (c === resizeCol) continue;
          const col = columns[c];
          const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
          onColumnResize == null ? void 0 : onColumnResize(col, s, c, s + ((_b = col.growOffset) != null ? _b : 0));
        }
      }
    }
  }, [dragCol, dragStartX, dragRow, dragStartY, resizeCol, resizeColStartX, columns, minColumnWidth, maxColumnWidth, onColumnResize, selectedColumns, canvasRef]);
  const getMangledCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, forceStrict) => {
    if (dragRow === void 0 || dropRow === void 0) return getCellContent(cell, forceStrict);
    let [col, row] = cell;

    if (row === dropRow) {
      row = dragRow;
    } else {
      if (row > dropRow) row -= 1;
      if (row >= dragRow) row += 1;
    }

    return getCellContent([col, row], forceStrict);
  }, [dragRow, dropRow, getCellContent]);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    onDragStart == null ? void 0 : onDragStart(args);

    if (!args.defaultPrevented()) {
      clearAll();
    }
  }, [clearAll, onDragStart]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_default, {
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    enableGroups: p.enableGroups,
    eventTargetRef: p.eventTargetRef,
    experimental: p.experimental,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    headerIcons: p.headerIcons,
    height: p.height,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isDraggable: p.isDraggable,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDrop: p.onDrop,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    width: p.width,
    getCellContent: getMangledCellContent,
    isResizing: resizeCol !== void 0,
    onHeaderMenuClick: onHeaderMenuClickMangled,
    isDragging: dragColActive,
    onItemHovered: onItemHoveredImpl,
    onDragStart: onDragStartImpl,
    onMouseDown: onMouseDownImpl,
    allowResize: canResize,
    onMouseUp: onMouseUpImpl,
    dragAndDropState: dragOffset,
    onMouseMoveRaw: onMouseMove,
    ref: gridRef
  });
};

var data_grid_dnd_default = DataGridDnd;



function useResizeDetector(initialSize) {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const [size, setSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    width: initialSize == null ? void 0 : initialSize[0],
    height: initialSize == null ? void 0 : initialSize[1]
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    const resizeCallback = entries => {
      for (const entry of entries) {
        const {
          width,
          height
        } = entry && entry.contentRect || {};
        setSize(cv => cv.width === width && cv.height === height ? cv : {
          width,
          height
        });
      }
    };

    const resizeObserver = new window.ResizeObserver(resizeCallback);

    if (ref.current) {
      resizeObserver.observe(ref.current, void 0);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [ref.current]);
  return {
    ref,
    ...size
  };
}

var _exp8 = () => p => p.isSafari ? "scroll" : "auto";

var ScrollRegionStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "ScrollRegionStyle",
  class: "s1jz82f8",
  vars: {
    "s1jz82f8-0": [_exp8()]
  }
});

function eatEvent(e) {
  e.stopPropagation();
}

function useTouchUpDelayed(delay) {
  const [hasTouches, setHasTouches] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const cbTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  useEventListener("touchstart", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    window.clearTimeout(cbTimer.current);
    setHasTouches(true);
  }, []), window, true, false);
  useEventListener("touchend", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(e => {
    if (e.touches.length === 0) {
      cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);
    }
  }, [delay]), window, true, false);
  return hasTouches;
}

var InfiniteScroller = p => {
  var _a, _b, _c, _d;

  const {
    children,
    clientHeight,
    scrollHeight,
    scrollWidth,
    update,
    draggable,
    className,
    preventDiagonalScrolling = false,
    paddingBottom = 0,
    paddingRight = 0,
    rightElement,
    rightElementProps,
    scrollRef,
    scrollToEnd,
    initialSize,
    minimap
  } = p;
  const padders = [];
  const rightElementSticky = (_a = rightElementProps == null ? void 0 : rightElementProps.sticky) != null ? _a : false;
  const rightElementFill = (_b = rightElementProps == null ? void 0 : rightElementProps.fill) != null ? _b : false;
  const offsetY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const lastScrollY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const scroller = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const dpr = window.devicePixelRatio;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const el = scroller.current;
    if (el === null || scrollToEnd !== true) return;
    el.scrollLeft = el.scrollWidth - el.clientWidth;
  }, [scrollToEnd]);
  const lastScrollPosition = react__WEBPACK_IMPORTED_MODULE_0__.useRef({
    scrollLeft: 0,
    scrollTop: 0,
    lockDirection: void 0
  });
  const rightWrapRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const hasTouches = useTouchUpDelayed(200);
  const [isIdle, setIsIdle] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
  const idleTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === void 0) return;
    const el = scroller.current;
    if (el === null) return;
    const [lx, ly] = lastScrollPosition.current.lockDirection;

    if (lx !== void 0) {
      el.scrollLeft = lx;
    } else if (ly !== void 0) {
      el.scrollTop = ly;
    }

    lastScrollPosition.current.lockDirection = void 0;
  }, [hasTouches, isIdle]);
  const onScroll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2, _c2, _d2;

    const el = scroller.current;
    if (el === null) return;
    let scrollTop = el.scrollTop;
    let scrollLeft = el.scrollLeft;
    const lastScrollTop = lastScrollPosition.current.scrollTop;
    const lastScrollLeft = lastScrollPosition.current.scrollLeft;
    const dx = scrollLeft - lastScrollLeft;
    const dy = scrollTop - lastScrollTop;

    if (hasTouches && dx !== 0 && dy !== 0 && (Math.abs(dx) > 3 || Math.abs(dy) > 3) && preventDiagonalScrolling && lastScrollPosition.current.lockDirection === void 0) {
      lastScrollPosition.current.lockDirection = Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, void 0] : [void 0, lastScrollTop];
    }

    const lock = lastScrollPosition.current.lockDirection;
    scrollLeft = (_a2 = lock == null ? void 0 : lock[0]) != null ? _a2 : scrollLeft;
    scrollTop = (_b2 = lock == null ? void 0 : lock[1]) != null ? _b2 : scrollTop;
    lastScrollPosition.current.scrollLeft = scrollLeft;
    lastScrollPosition.current.scrollTop = scrollTop;
    const newY = scrollTop;
    const delta = lastScrollY.current - newY;
    const scrollableHeight = el.scrollHeight - el.clientHeight;
    lastScrollY.current = newY;

    if (scrollableHeight > 0 && (Math.abs(delta) > 2e3 || newY === 0 || newY === scrollableHeight) && scrollHeight > el.scrollHeight + 5) {
      const prog = newY / scrollableHeight;
      const recomputed = (scrollHeight - el.clientHeight) * prog;
      offsetY.current = recomputed - newY;
    }

    if (lock !== void 0) {
      window.clearTimeout(idleTimer.current);
      setIsIdle(false);
      idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);
    }

    update({
      x: scrollLeft,
      y: newY + offsetY.current,
      width: el.clientWidth - paddingRight,
      height: el.clientHeight - paddingBottom,
      paddingRight: (_d2 = (_c2 = rightWrapRef.current) == null ? void 0 : _c2.clientWidth) != null ? _d2 : 0
    });
  }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);
  const onScrollRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onScroll);
  onScrollRef.current = onScroll;
  const lastProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const didFirstScroll = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (didFirstScroll.current) onScroll();else didFirstScroll.current = true;
  }, [onScroll, paddingBottom, paddingRight]);
  const setRefs = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(instance => {
    scroller.current = instance;

    if (scrollRef !== void 0) {
      scrollRef.current = instance;
    }
  }, [scrollRef]);
  let key = 0;
  let h = 0;
  padders.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: key++,
    style: {
      width: scrollWidth,
      height: 0
    }
  }));

  while (h < scrollHeight) {
    const toAdd = Math.min(5e6, scrollHeight - h);
    padders.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: key++,
      style: {
        width: 0,
        height: toAdd
      }
    }));
    h += toAdd;
  }

  const {
    ref,
    width,
    height
  } = useResizeDetector(initialSize);

  if (((_c = lastProps.current) == null ? void 0 : _c.height) !== height || ((_d = lastProps.current) == null ? void 0 : _d.width) !== width) {
    window.setTimeout(() => onScrollRef.current(), 0);
    lastProps.current = {
      width,
      height
    };
  }

  if ((width != null ? width : 0) === 0 || (height != null ? height : 0) === 0) return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollRegionStyle, {
    isSafari: browserIsSafari.value
  }, minimap, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-underlay"
  }, children), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: setRefs,
    style: lastProps.current,
    draggable,
    onDragStart: e => {
      if (!draggable) {
        e.stopPropagation();
        e.preventDefault();
      }
    },
    className: "dvn-scroller " + (className != null ? className : ""),
    onScroll
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-scroll-inner" + (rightElement === void 0 ? " hidden" : "")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-stack"
  }, padders), rightElement !== void 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, !rightElementFill && react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-spacer"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: rightWrapRef,
    onMouseDown: eatEvent,
    onMouseUp: eatEvent,
    onMouseMove: eatEvent,
    style: {
      height,
      maxHeight: clientHeight - Math.ceil(dpr % 1),
      position: "sticky",
      top: 0,
      paddingLeft: 1,
      marginBottom: -40,
      marginRight: paddingRight,
      flexGrow: rightElementFill ? 1 : void 0,
      right: rightElementSticky ? paddingRight != null ? paddingRight : 0 : void 0,
      pointerEvents: "auto"
    }
  }, rightElement))))));
};


var MinimapStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "MinimapStyle",
  class: "m15w2ly5"
});

var GridScroller = p => {
  var _a, _b, _c;

  const {
    columns,
    rows,
    rowHeight,
    headerHeight,
    groupHeaderHeight,
    enableGroups,
    freezeColumns,
    experimental,
    clientSize,
    className,
    onVisibleRegionChanged,
    scrollToEnd,
    scrollRef,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    overscrollX,
    overscrollY,
    showMinimap = false,
    initialSize,
    smoothScrollX = false,
    smoothScrollY = false,
    isDraggable
  } = p;
  const {
    paddingRight,
    paddingBottom
  } = experimental != null ? experimental : {};
  const [clientWidth, clientHeight] = clientSize;
  const last = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastX = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastY = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastSize = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const width = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let r = Math.max(0, overscrollX != null ? overscrollX : 0);

    for (const c of columns) {
      r += c.width;
    }

    return r;
  }, [columns, overscrollX]);
  let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;

  if (typeof rowHeight === "number") {
    height += rows * rowHeight;
  } else {
    for (let r = 0; r < rows; r++) {
      height += rowHeight(r);
    }
  }

  if (overscrollY !== void 0) {
    height += overscrollY;
  }

  const lastArgs = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const processArgs = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2, _c2;

    if (lastArgs.current === void 0) return;
    const args = { ...lastArgs.current
    };
    let x = 0;
    let tx = args.x < 0 ? -args.x : 0;
    let cellRight = 0;
    let cellX = 0;
    args.x = args.x < 0 ? 0 : args.x;
    let stickyColWidth = 0;

    for (let i = 0; i < freezeColumns; i++) {
      stickyColWidth += columns[i].width;
    }

    for (const c of columns) {
      const cx = x - stickyColWidth;

      if (args.x >= cx + c.width) {
        x += c.width;
        cellX++;
        cellRight++;
      } else if (args.x > cx) {
        x += c.width;

        if (smoothScrollX) {
          tx += cx - args.x;
        } else {
          cellX++;
        }

        cellRight++;
      } else if (args.x + args.width > cx) {
        x += c.width;
        cellRight++;
      } else {
        break;
      }
    }

    let ty = 0;
    let cellY = 0;
    let cellBottom = 0;

    if (typeof rowHeight === "number") {
      if (smoothScrollY) {
        cellY = Math.floor(args.y / rowHeight);
        ty = cellY * rowHeight - args.y;
      } else {
        cellY = Math.ceil(args.y / rowHeight);
      }

      cellBottom = Math.ceil(args.height / rowHeight) + cellY;
      if (ty < 0) cellBottom++;
    } else {
      let y = 0;

      for (let row = 0; row < rows; row++) {
        const rh = rowHeight(row);
        const cy = y + (smoothScrollY ? 0 : rh / 2);

        if (args.y >= y + rh) {
          y += rh;
          cellY++;
          cellBottom++;
        } else if (args.y > cy) {
          y += rh;

          if (smoothScrollY) {
            ty += cy - args.y;
          } else {
            cellY++;
          }

          cellBottom++;
        } else if (args.y + args.height > rh / 2 + y) {
          y += rh;
          cellBottom++;
        } else {
          break;
        }
      }
    }

    const rect = {
      x: cellX,
      y: cellY,
      width: cellRight - cellX,
      height: cellBottom - cellY
    };
    const oldRect = last.current;

    if (oldRect === void 0 || oldRect.y !== rect.y || oldRect.x !== rect.x || oldRect.height !== rect.height || oldRect.width !== rect.width || lastX.current !== tx || lastY.current !== ty || args.width !== ((_a2 = lastSize.current) == null ? void 0 : _a2[0]) || args.height !== ((_b2 = lastSize.current) == null ? void 0 : _b2[1])) {
      onVisibleRegionChanged == null ? void 0 : onVisibleRegionChanged({
        x: cellX,
        y: cellY,
        width: cellRight - cellX,
        height: cellBottom - cellY
      }, args.width, args.height, (_c2 = args.paddingRight) != null ? _c2 : 0, tx, ty);
      last.current = rect;
      lastX.current = tx;
      lastY.current = ty;
      lastSize.current = [args.width, args.height];
    }
  }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);
  const onScrollUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    lastArgs.current = args;
    processArgs();
  }, [processArgs]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    processArgs();
  }, [processArgs]);
  const scroller = (_a = scrollRef == null ? void 0 : scrollRef.current) != null ? _a : void 0;
  const aspect = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(width / height, 2 / 3, 1.5);
  const maxSize = 200;
  const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);
  const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;
  const hRatio = w / width;
  const vRatio = h / height;
  const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);
  const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);
  const left = ((_b = scroller == null ? void 0 : scroller.scrollLeft) != null ? _b : 0) / (width - clientWidth) * (w - vWidth);
  const top = ((_c = scroller == null ? void 0 : scroller.scrollTop) != null ? _c : 0) / (height - clientHeight) * (h - vHeight);
  const minimap = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!showMinimap || vWidth === 0 || vHeight === 0) return void 0;

    const handleMouse = e => {
      if (scroller === void 0) return;
      const bounds = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - bounds.x - vWidth / 2;
      const y = e.clientY - bounds.y - vHeight / 2;
      const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));
      const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));
      scroller.scrollTo({
        left: newScrollLeft,
        top: newScrollTop,
        behavior: e.type === "mousemove" ? "auto" : "smooth"
      });
    };

    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MinimapStyle, {
      style: {
        width: w,
        height: h
      },
      "data-testid": "minimap-container",
      onMouseMove: e => {
        if (e.buttons !== 1) return;
        handleMouse(e);
      },
      onClick: handleMouse
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "header"
    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "locationMarker",
      onDragStart: e => e.preventDefault(),
      style: {
        left,
        top,
        width: vWidth,
        height: vHeight,
        borderRadius: Math.min(vWidth, vHeight * 0.2, 9)
      }
    }));
  }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(InfiniteScroller, {
    scrollRef,
    minimap,
    className,
    preventDiagonalScrolling,
    draggable: isDraggable === true || typeof isDraggable === "string",
    scrollWidth: width + (paddingRight != null ? paddingRight : 0),
    scrollHeight: height + (paddingBottom != null ? paddingBottom : 0),
    clientHeight,
    rightElement,
    paddingBottom,
    paddingRight,
    rightElementProps,
    update: onScrollUpdate,
    initialSize,
    scrollToEnd
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_dnd_default, {
    eventTargetRef: scrollRef,
    width: clientWidth,
    height: clientHeight,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY
  }));
};

var scrolling_data_grid_default = GridScroller;

var _exp9 = () => p => p.showSearch ? 0 : 400;

var SearchWrapper = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "SearchWrapper",
  class: "sxep88s",
  vars: {
    "sxep88s-0": [_exp9(), "px"]
  }
});
var upArrow = react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 244l144-144 144 144M256 120v292"
}));
var downArrow = react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 268l144 144 144-144M256 392V100"
}));
var closeX = react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "32",
  d: "M368 368L144 144M368 144L144 368"
}));
var targetSearchTimeMS = 10;

var DataGridSearch = p => {
  const {
    canvasRef,
    cellYOffset,
    rows,
    columns,
    searchInputRef,
    getCellsForSelection,
    onSearchResultsChanged,
    showSearch = false,
    onSearchClose
  } = p;
  const [searchID] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => "search-box-" + Math.round(Math.random() * 1e3));
  const [searchString, setSearchString] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
  const [searchStatus, setSearchStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const searchStatusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(searchStatus);
  searchStatusRef.current = searchStatus;
  const abortControllerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new AbortController());
  const searchHandle = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [searchResults, setSearchResults] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  const cancelSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (searchHandle.current !== void 0) {
      window.cancelAnimationFrame(searchHandle.current);
      searchHandle.current = void 0;
      abortControllerRef.current.abort();
    }
  }, []);
  const cellYOffsetRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cellYOffset);
  cellYOffsetRef.current = cellYOffset;
  const beginSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(str => {
    const regex = new RegExp(str.replace(/([$()*+.?[\\\]^{|}-])/g, "\\$1"), "i");
    let startY = cellYOffsetRef.current;
    let searchStride = Math.min(10, rows);
    let rowsSearched = 0;
    setSearchStatus(void 0);
    setSearchResults([]);
    const runningResult = [];

    const tick = async () => {
      var _a, _b;

      if (getCellsForSelection === void 0) return;
      const tStart = performance.now();
      const rowsLeft = rows - rowsSearched;
      let data = getCellsForSelection({
        x: 0,
        y: startY,
        width: columns.length,
        height: Math.min(searchStride, rowsLeft, rows - startY)
      }, abortControllerRef.current.signal);

      if (typeof data === "function") {
        data = await data();
      }

      let added = false;

      for (const [row, d] of data.entries()) {
        for (const [col, cell] of d.entries()) {
          let testString;

          switch (cell.kind) {
            case GridCellKind.Text:
            case GridCellKind.Number:
              testString = cell.displayData;
              break;

            case GridCellKind.Uri:
            case GridCellKind.Markdown:
              testString = cell.data;
              break;

            case GridCellKind.Boolean:
              testString = typeof cell.data === "boolean" ? cell.data.toString() : void 0;
              break;

            case GridCellKind.Image:
            case GridCellKind.Bubble:
              testString = cell.data.join("\u{1F433}");
              break;

            case GridCellKind.Custom:
              testString = cell.copyData;
              break;
          }

          if (testString !== void 0 && regex.test(testString)) {
            runningResult.push([col, row + startY]);
            added = true;
          }
        }
      }

      const tEnd = performance.now();

      if (added) {
        setSearchResults([...runningResult]);
      }

      rowsSearched += data.length;
      assert(rowsSearched <= rows);
      const selectedIndex = (_b = (_a = searchStatusRef.current) == null ? void 0 : _a.selectedIndex) != null ? _b : -1;
      setSearchStatus({
        results: runningResult.length,
        rowsSearched,
        selectedIndex
      });
      onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(runningResult, selectedIndex);

      if (startY + searchStride >= rows) {
        startY = 0;
      } else {
        startY += searchStride;
      }

      const tElapsed = tEnd - tStart;
      const rounded = Math.max(tElapsed, 1);
      const scalar = targetSearchTimeMS / rounded;
      searchStride = Math.ceil(searchStride * scalar);

      if (rowsSearched < rows && runningResult.length < 1e3) {
        searchHandle.current = window.requestAnimationFrame(tick);
      }
    };

    cancelSearch();
    searchHandle.current = window.requestAnimationFrame(tick);
  }, [cancelSearch, columns.length, getCellsForSelection, onSearchResultsChanged, rows]);
  const onClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a;

    onSearchClose == null ? void 0 : onSearchClose();
    setSearchStatus(void 0);
    setSearchResults([]);
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged([], -1);
    cancelSearch();
    (_a = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a.focus();
  }, [cancelSearch, canvasRef, onSearchClose, onSearchResultsChanged]);
  const onSearchChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    setSearchString(event.target.value);

    if (event.target.value === "") {
      setSearchStatus(void 0);
      setSearchResults([]);
      cancelSearch();
    } else {
      beginSearch(event.target.value);
    }
  }, [beginSearch, cancelSearch]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (showSearch && searchInputRef.current !== null) {
      setSearchString("");
      searchInputRef.current.focus({
        preventScroll: true
      });
    }
  }, [showSearch, searchInputRef]);
  const onNext = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a;

    (_a = ev == null ? void 0 : ev.stopPropagation) == null ? void 0 : _a.call(ev);
    if (searchStatus === void 0) return;
    const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;
    setSearchStatus({ ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [searchStatus, onSearchResultsChanged, searchResults]);
  const onPrev = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a;

    (_a = ev == null ? void 0 : ev.stopPropagation) == null ? void 0 : _a.call(ev);
    if (searchStatus === void 0) return;
    let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;
    if (newIndex < 0) newIndex += searchStatus.results;
    setSearchStatus({ ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [onSearchResultsChanged, searchResults, searchStatus]);
  const onSearchKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    if ((event.ctrlKey || event.metaKey) && event.nativeEvent.code === "KeyF" || event.key === "Escape") {
      onClose();
      event.stopPropagation();
      event.preventDefault();
    } else if (event.key === "Enter") {
      if (event.shiftKey) {
        onPrev();
      } else {
        onNext();
      }
    }
  }, [onClose, onNext, onPrev]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => {
      cancelSearch();
    };
  }, [cancelSearch]);
  const searchbox = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a, _b, _c;

    let resultString;

    if (searchStatus !== void 0) {
      resultString = searchStatus.results >= 1e3 ? `over 1000` : `${searchStatus.results} result${searchStatus.results !== 1 ? "s" : ""}`;

      if (searchStatus.selectedIndex >= 0) {
        resultString = `${searchStatus.selectedIndex + 1} of ${resultString}`;
      }
    }

    const cancelEvent = ev => {
      ev.stopPropagation();
    };

    const rowsSearchedProgress = Math.floor(((_a = searchStatus == null ? void 0 : searchStatus.rowsSearched) != null ? _a : 0) / rows * 100);
    const progressStyle = {
      width: `${rowsSearchedProgress}%`
    };
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SearchWrapper, {
      showSearch,
      onMouseDown: cancelEvent,
      onMouseMove: cancelEvent,
      onMouseUp: cancelEvent,
      onClick: cancelEvent
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-bar-inner"
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      id: searchID,
      "aria-hidden": !showSearch,
      "data-testid": "search-input",
      ref: searchInputRef,
      onChange: onSearchChange,
      value: searchString,
      tabIndex: showSearch ? void 0 : -1,
      onKeyDownCapture: onSearchKeyDown
    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Previous Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? void 0 : -1,
      onClick: onPrev,
      disabled: ((_b = searchStatus == null ? void 0 : searchStatus.results) != null ? _b : 0) === 0
    }, upArrow), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Next Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? void 0 : -1,
      onClick: onNext,
      disabled: ((_c = searchStatus == null ? void 0 : searchStatus.results) != null ? _c : 0) === 0
    }, downArrow), onSearchClose !== void 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Close Search",
      "aria-hidden": !showSearch,
      "data-testid": "search-close-button",
      tabIndex: showSearch ? void 0 : -1,
      onClick: onClose
    }, closeX)), searchStatus !== void 0 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-status"
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      "data-testid": "search-result-area"
    }, resultString)), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-progress",
      style: progressStyle
    })) : react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-status"
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
      htmlFor: searchID
    }, "Type to search")));
  }, [onClose, onNext, onPrev, onSearchChange, onSearchClose, onSearchKeyDown, rows, searchStatus, searchString, showSearch, searchID, searchInputRef]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(scrolling_data_grid_default, {
    prelightCells: searchResults,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    className: p.className,
    clientSize: p.clientSize,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    initialSize: p.initialSize,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    onVisibleRegionChanged: p.onVisibleRegionChanged,
    overscrollX: p.overscrollX,
    overscrollY: p.overscrollY,
    preventDiagonalScrolling: p.preventDiagonalScrolling,
    rightElement: p.rightElement,
    rightElementProps: p.rightElementProps,
    rowHeight: p.rowHeight,
    rows: p.rows,
    scrollRef: p.scrollRef,
    selection: p.selection,
    showMinimap: p.showMinimap,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    scrollToEnd: p.scrollToEnd
  }), searchbox);
};

var data_grid_search_default = DataGridSearch;


var _exp10 = () => p => Math.max(16, p.targetHeight - 10);

var RenameInput = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("input")({
  name: "RenameInput",
  class: "r1kzy40b",
  vars: {
    "r1kzy40b-0": [_exp10(), "px"]
  }
});

var GroupRename = p => {
  const {
    bounds,
    group,
    onClose,
    canvasBounds,
    onFinish
  } = p;
  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(group);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClickOutsideContainer, {
    style: {
      position: "absolute",
      left: bounds.x - canvasBounds.left + 1,
      top: bounds.y - canvasBounds.top,
      width: bounds.width - 2,
      height: bounds.height
    },
    className: "c1sqdbw3",
    onClickOutside: onClose
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenameInput, {
    targetHeight: bounds.height,
    "data-testid": "group-rename-input",
    value,
    onBlur: onClose,
    onFocus: e => e.target.setSelectionRange(0, value.length),
    onChange: e => setValue(e.target.value),
    onKeyDown: e => {
      if (e.key === "Enter") {
        onFinish(value);
      } else if (e.key === "Escape") {
        onClose();
      }
    },
    autoFocus: true
  }));
};


var defaultSize = 150;

function measureCell(ctx, cell, theme, getCellRenderer) {
  var _a, _b;

  if (cell.kind === GridCellKind.Custom) return defaultSize;
  const r = getCellRenderer(cell);
  return (_b = (_a = r == null ? void 0 : r.measure) == null ? void 0 : _a.call(r, ctx, cell, theme)) != null ? _b : defaultSize;
}

function measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, removeOutliers, getCellRenderer) {
  let sizes = [];

  if (selectedData !== void 0) {
    sizes.push(...selectedData.map(row => row[colIndex]).map(cell => measureCell(ctx, cell, theme, getCellRenderer)));
  }

  if (sizes.length > 5 && removeOutliers) {
    const average = sizes.reduce((a, b) => a + b) / sizes.length;
    sizes = sizes.filter(a => a < average * 2);
  }

  sizes.push(ctx.measureText(c.title).width + 16 + (c.icon === void 0 ? 0 : 28));
  const biggest = Math.max(...sizes);
  const final = Math.max(Math.ceil(minColumnWidth), Math.min(Math.floor(maxColumnWidth), Math.ceil(biggest)));
  return { ...c,
    width: final
  };
}

function useColumnSizer(columns, rows, getCellsForSelection, clientWidth, minColumnWidth, maxColumnWidth, theme, getCellRenderer, abortController) {
  const rowsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(rows);
  const getCellsForSelectionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(getCellsForSelection);
  const themeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(theme);
  rowsRef.current = rows;
  getCellsForSelectionRef.current = getCellsForSelection;
  themeRef.current = theme;
  const [ctx] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    if (typeof window === "undefined") return null;
    const offscreen = document.createElement("canvas");
    offscreen.style["display"] = "none";
    offscreen.style["opacity"] = "0";
    offscreen.style["position"] = "fixed";
    document.documentElement.append(offscreen);
    return offscreen.getContext("2d", {
      alpha: false
    });
  });
  const memoMap = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});
  const lastColumns = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [selectedData, setSelectionData] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const getCells = getCellsForSelectionRef.current;
    if (getCells === void 0 || columns.every(isSizedGridColumn)) return;
    let computeRows = Math.max(1, 10 - Math.floor(columns.length / 1e4));
    let tailRows = 0;

    if (computeRows < rowsRef.current && computeRows > 1) {
      computeRows--;
      tailRows = 1;
    }

    const computeArea = {
      x: 0,
      y: 0,
      width: columns.length,
      height: Math.min(rowsRef.current, computeRows)
    };
    const tailComputeArea = {
      x: 0,
      y: rowsRef.current - 1,
      width: columns.length,
      height: 1
    };

    const fn = async () => {
      const getResult = getCells(computeArea, abortController.signal);
      const tailGetResult = tailRows > 0 ? getCells(tailComputeArea, abortController.signal) : void 0;
      let toSet;

      if (typeof getResult === "object") {
        toSet = getResult;
      } else {
        toSet = await resolveCellsThunk(getResult);
      }

      if (tailGetResult !== void 0) {
        if (typeof tailGetResult === "object") {
          toSet = [...toSet, ...tailGetResult];
        } else {
          toSet = [...toSet, ...(await resolveCellsThunk(tailGetResult))];
        }
      }

      lastColumns.current = columns;
      setSelectionData(toSet);
    };

    void fn();
  }, [abortController.signal, columns]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a;

    const getRaw = () => {
      if (columns.every(isSizedGridColumn)) {
        return columns;
      }

      if (ctx === null) {
        return columns.map(c => {
          if (isSizedGridColumn(c)) return c;
          return { ...c,
            width: defaultSize
          };
        });
      }

      ctx.font = `${themeRef.current.baseFontStyle} ${themeRef.current.fontFamily}`;
      return columns.map((c, colIndex) => {
        if (isSizedGridColumn(c)) return c;

        if (memoMap.current[c.id] !== void 0) {
          return { ...c,
            width: memoMap.current[c.id]
          };
        }

        if (selectedData === void 0 || lastColumns.current !== columns || c.id === void 0) {
          return { ...c,
            width: defaultSize
          };
        }

        const r = measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, true, getCellRenderer);
        memoMap.current[c.id] = r.width;
        return r;
      });
    };

    let result = getRaw();
    let totalWidth = 0;
    let totalGrow = 0;
    const distribute = [];

    for (const [i, c] of result.entries()) {
      totalWidth += c.width;

      if (c.grow !== void 0 && c.grow > 0) {
        totalGrow += c.grow;
        distribute.push(i);
      }
    }

    if (totalWidth < clientWidth && distribute.length > 0) {
      const writeable = [...result];
      const extra = clientWidth - totalWidth;
      let remaining = extra;

      for (let di = 0; di < distribute.length; di++) {
        const i = distribute[di];
        const weighted = ((_a = result[i].grow) != null ? _a : 0) / totalGrow;
        const toAdd = di === distribute.length - 1 ? remaining : Math.min(remaining, Math.floor(extra * weighted));
        writeable[i] = { ...result[i],
          growOffset: toAdd,
          width: result[i].width + toAdd
        };
        remaining -= toAdd;
      }

      result = writeable;
    }

    return result;
  }, [clientWidth, columns, ctx, selectedData, theme, minColumnWidth, maxColumnWidth, getCellRenderer]);
}

function checkKey(key, args) {
  if (key === void 0) return false;

  if (key.length > 1 && key.startsWith("_")) {
    const keycode = Number.parseInt(key.slice(1));
    if (keycode !== args.keyCode) return false;
  } else {
    if (key !== args.key) return false;
  }

  return true;
}

function isHotkey(hotkey, args) {
  if (hotkey.length === 0) return false;
  let wantCtrl = false;
  let wantShift = false;
  let wantAlt = false;
  let wantMeta = false;
  const split = hotkey.split("+");
  const key = split.pop();
  if (!checkKey(key, args)) return false;

  for (const accel of split) {
    switch (accel) {
      case "ctrl":
        wantCtrl = true;
        break;

      case "shift":
        wantShift = true;
        break;

      case "alt":
        wantAlt = true;
        break;

      case "meta":
        wantMeta = true;
        break;

      case "primary":
        if (browserIsOSX.value) {
          wantMeta = true;
        } else {
          wantCtrl = true;
        }

        break;
    }
  }

  return args.altKey === wantAlt && args.ctrlKey === wantCtrl && args.shiftKey === wantShift && args.metaKey === wantMeta;
}



function useSelectionBehavior(gridSelection, setGridSelection, rangeBehavior, columnBehavior, rowBehavior, rangeSelect) {
  const setCurrent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((value, expand, append, trigger) => {
    var _a, _b;

    if ((rangeSelect === "cell" || rangeSelect === "multi-cell") && value !== void 0) {
      value = { ...value,
        range: {
          x: value.cell[0],
          y: value.cell[1],
          width: 1,
          height: 1
        }
      };
    }

    const rangeMixable = rangeBehavior === "mixed" && (append || trigger === "drag");
    const allowColumnCoSelect = columnBehavior === "mixed" && rangeMixable;
    const allowRowCoSelect = rowBehavior === "mixed" && rangeMixable;
    let newVal = {
      current: value === void 0 ? void 0 : { ...value,
        rangeStack: trigger === "drag" ? (_b = (_a = gridSelection.current) == null ? void 0 : _a.rangeStack) != null ? _b : [] : []
      },
      columns: allowColumnCoSelect ? gridSelection.columns : CompactSelection.empty(),
      rows: allowRowCoSelect ? gridSelection.rows : CompactSelection.empty()
    };
    const addLastRange = append && (rangeSelect === "multi-rect" || rangeSelect === "multi-cell");

    if (addLastRange && newVal.current !== void 0 && gridSelection.current !== void 0) {
      newVal = { ...newVal,
        current: { ...newVal.current,
          rangeStack: [...gridSelection.current.rangeStack, gridSelection.current.range]
        }
      };
    }

    setGridSelection(newVal, expand);
  }, [columnBehavior, gridSelection, rangeBehavior, rangeSelect, rowBehavior, setGridSelection]);
  const setSelectedRows = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newRows, append, allowMixed) => {
    newRows = newRows != null ? newRows : gridSelection.rows;

    if (append !== void 0) {
      newRows = newRows.add(append);
    }

    let newVal;

    if (rowBehavior === "exclusive" && newRows.length > 0) {
      newVal = {
        current: void 0,
        columns: CompactSelection.empty(),
        rows: newRows
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const columnMixed = allowMixed && columnBehavior === "mixed";
      const current = !rangeMixed ? void 0 : gridSelection.current;
      newVal = {
        current,
        columns: columnMixed ? gridSelection.columns : CompactSelection.empty(),
        rows: newRows
      };
    }

    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  const setSelectedColumns = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCols, append, allowMixed) => {
    newCols = newCols != null ? newCols : gridSelection.columns;

    if (append !== void 0) {
      newCols = newCols.add(append);
    }

    let newVal;

    if (columnBehavior === "exclusive" && newCols.length > 0) {
      newVal = {
        current: void 0,
        rows: CompactSelection.empty(),
        columns: newCols
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const rowMixed = allowMixed && rowBehavior === "mixed";
      const current = !rangeMixed ? void 0 : gridSelection.current;
      newVal = {
        current,
        rows: rowMixed ? gridSelection.rows : CompactSelection.empty(),
        columns: newCols
      };
    }

    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  return [setCurrent, setSelectedRows, setSelectedColumns];
}



function useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortController, rows) {
  const getCellsForSelectionDirectWhenValid = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(rect => {
    var _a;

    if (getCellsForSelectionIn === true) {
      const result = [];

      for (let y = rect.y; y < rect.y + rect.height; y++) {
        const row = [];

        for (let x = rect.x; x < rect.x + rect.width; x++) {
          if (x < 0 || y >= rows) {
            row.push({
              kind: GridCellKind.Loading,
              allowOverlay: false
            });
          } else {
            row.push(getCellContent([x, y]));
          }
        }

        result.push(row);
      }

      return result;
    }

    return (_a = getCellsForSelectionIn == null ? void 0 : getCellsForSelectionIn(rect, abortController.signal)) != null ? _a : [];
  }, [abortController.signal, getCellContent, getCellsForSelectionIn, rows]);
  const getCellsForSelectionDirect = getCellsForSelectionIn !== void 0 ? getCellsForSelectionDirectWhenValid : void 0;
  const getCellsForSelectionMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(rect => {
    if (getCellsForSelectionDirect === void 0) return [];
    const newRect = { ...rect,
      x: rect.x - rowMarkerOffset
    };

    if (newRect.x < 0) {
      newRect.x = 0;
      newRect.width--;
      const r = getCellsForSelectionDirect(newRect, abortController.signal);

      if (typeof r === "function") {
        return async () => (await r()).map(row => [{
          kind: GridCellKind.Loading,
          allowOverlay: false
        }, ...row]);
      }

      return r.map(row => [{
        kind: GridCellKind.Loading,
        allowOverlay: false
      }, ...row]);
    }

    return getCellsForSelectionDirect(newRect, abortController.signal);
  }, [abortController.signal, getCellsForSelectionDirect, rowMarkerOffset]);
  const getCellsForSelection = getCellsForSelectionIn !== void 0 ? getCellsForSelectionMangled : void 0;
  return [getCellsForSelection, getCellsForSelectionDirect];
}

function expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortController) {
  var _a, _b;

  const origVal = newVal;
  if (spanRangeBehavior === "allowPartial" || newVal.current === void 0) return newVal;

  if (getCellsForSelection !== void 0) {
    let isFilled = false;

    do {
      if ((newVal == null ? void 0 : newVal.current) === void 0) break;
      const r = (_a = newVal.current) == null ? void 0 : _a.range;
      const cells = [];

      if (r.width > 2) {
        const leftCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);

        if (typeof leftCells === "function") {
          return origVal;
        }

        cells.push(...leftCells);
        const rightCells = getCellsForSelection({
          x: r.x + r.width - 1,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);

        if (typeof rightCells === "function") {
          return origVal;
        }

        cells.push(...rightCells);
      } else {
        const rCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: r.width,
          height: r.height
        }, abortController.signal);

        if (typeof rCells === "function") {
          return origVal;
        }

        cells.push(...rCells);
      }

      let left = r.x - rowMarkerOffset;
      let right = r.x + r.width - 1 - rowMarkerOffset;

      for (const row of cells) {
        for (const cell of row) {
          if (cell.span === void 0) continue;
          left = Math.min(cell.span[0], left);
          right = Math.max(cell.span[1], right);
        }
      }

      if (left === r.x - rowMarkerOffset && right === r.x + r.width - 1 - rowMarkerOffset) {
        isFilled = true;
      } else {
        newVal = {
          current: {
            cell: (_b = newVal.current.cell) != null ? _b : [0, 0],
            range: {
              x: left + rowMarkerOffset,
              y: r.y,
              width: right - left + 1,
              height: r.height
            },
            rangeStack: newVal.current.rangeStack
          },
          columns: newVal.columns,
          rows: newVal.rows
        };
      }
    } while (!isFilled);
  }

  return newVal;
}

function descape(s) {
  if (s.startsWith('"') && s.endsWith('"')) {
    s = s.slice(1, -1).replace(/""/g, '"');
  }

  return s;
}

function unquote(str) {
  var State;

  (function (State2) {
    State2[State2["None"] = 0] = "None";
    State2[State2["inString"] = 1] = "inString";
    State2[State2["inStringPostQuote"] = 2] = "inStringPostQuote";
  })(State || (State = {}));

  const result = [];
  let current = [];
  let start = 0;
  let state = 0;
  str = str.replace(/\r\n/g, "\n");
  let index = 0;

  for (const char of str) {
    switch (state) {
      case 0:
        if (char === "	" || char === "\n") {
          current.push(str.slice(start, index));
          start = index + 1;

          if (char === "\n") {
            result.push(current);
            current = [];
          }
        } else if (char === `"`) {
          state = 1;
        }

        break;

      case 1:
        if (char === `"`) {
          state = 2;
        }

        break;

      case 2:
        if (char === '"') {
          state = 1;
        } else if (char === "	" || char === "\n") {
          current.push(descape(str.slice(start, index)));
          start = index + 1;

          if (char === "\n") {
            result.push(current);
            current = [];
          }

          state = 0;
        } else {
          state = 0;
        }

        break;
    }

    index++;
  }

  if (start < str.length) {
    current.push(descape(str.slice(start, str.length)));
  }

  result.push(current);
  return result;
}

function decodeHTML(tableEl) {
  var _a, _b;

  const walkEl = [tableEl];
  const result = [];
  let current;

  while (walkEl.length > 0) {
    const el = walkEl.pop();
    if (el === void 0) break;

    if (el instanceof HTMLTableElement || el.nodeName === "TBODY") {
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableRowElement) {
      if (current !== void 0) {
        result.push(current);
      }

      current = [];
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableCellElement) {
      current == null ? void 0 : current.push((_b = (_a = el.innerText) != null ? _a : el.textContent) != null ? _b : "");
    }
  }

  if (current !== void 0) {
    result.push(current);
  }

  return result;
}

function escape(str) {
  if (/[\t\n",]/.test(str)) {
    str = `"${str.replace(/"/g, '""')}"`;
  }

  return str;
}

var formatBoolean = val => {
  switch (val) {
    case true:
      return "TRUE";

    case false:
      return "FALSE";

    case BooleanIndeterminate:
      return "INDETERMINATE";

    case BooleanEmpty:
      return "";

    default:
      assertNever(val);
  }
};

function formatCell(cell, index, raw, columnIndexes) {
  var _a, _b;

  const colIndex = columnIndexes[index];
  if (cell.span !== void 0 && cell.span[0] !== colIndex) return "";

  if (cell.copyData !== void 0) {
    return escape(cell.copyData);
  }

  switch (cell.kind) {
    case GridCellKind.Text:
    case GridCellKind.Number:
      return escape(raw ? (_b = (_a = cell.data) == null ? void 0 : _a.toString()) != null ? _b : "" : cell.displayData);

    case GridCellKind.Markdown:
    case GridCellKind.RowID:
    case GridCellKind.Uri:
      return escape(cell.data);

    case GridCellKind.Image:
    case GridCellKind.Bubble:
      if (cell.data.length === 0) return "";
      return cell.data.reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);

    case GridCellKind.Boolean:
      return formatBoolean(cell.data);

    case GridCellKind.Loading:
      return raw ? "" : "#LOADING";

    case GridCellKind.Protected:
      return raw ? "" : "************";

    case GridCellKind.Drilldown:
      if (cell.data.length === 0) return "";
      return cell.data.map(i => i.text).reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);

    case GridCellKind.Custom:
      return escape(cell.copyData);

    default:
      assertNever(cell);
  }
}

function formatForCopy(cells, columnIndexes) {
  return cells.map(row => row.map((a, b) => formatCell(a, b, false, columnIndexes)).join("	")).join("\n");
}

function copyToClipboard(cells, columnIndexes, e) {
  var _a, _b, _c, _d;

  const str = formatForCopy(cells, columnIndexes);

  if (((_a = window.navigator.clipboard) == null ? void 0 : _a.write) !== void 0 || e !== void 0) {
    const rootEl = document.createElement("tbody");

    for (const row of cells) {
      const rowEl = document.createElement("tr");

      for (const [i, cell] of row.entries()) {
        const cellEl = document.createElement("td");

        if (cell.kind === GridCellKind.Uri) {
          const link = document.createElement("a");
          link.href = cell.data;
          link.innerText = cell.data;
          cellEl.append(link);
        } else {
          cellEl.innerText = formatCell(cell, i, true, columnIndexes);
        }

        rowEl.append(cellEl);
      }

      rootEl.append(rowEl);
    }

    if (((_b = window.navigator.clipboard) == null ? void 0 : _b.write) !== void 0) {
      void window.navigator.clipboard.write([new ClipboardItem({
        "text/plain": new Blob([str], {
          type: "text/plain"
        }),
        "text/html": new Blob([`<table>${rootEl.outerHTML}</table>`], {
          type: "text/html"
        })
      })]);
    } else if (e !== void 0 && (e == null ? void 0 : e.clipboardData) !== null) {
      try {
        e.clipboardData.setData("text/plain", str);
        e.clipboardData.setData("text/html", `<table>${rootEl.outerHTML}</table>`);
      } catch (e2) {
        void ((_c = window.navigator.clipboard) == null ? void 0 : _c.writeText(str));
      }
    }
  } else {
    void ((_d = window.navigator.clipboard) == null ? void 0 : _d.writeText(str));
  }

  e == null ? void 0 : e.preventDefault();
}



function toCss(x) {
  if (typeof x === "string") return x;
  return `${x}px`;
}

var _exp11 = () => p => p.innerWidth;

var _exp22 = () => p => p.innerHeight;

var Wrapper = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "Wrapper",
  class: "wzg2m5k",
  vars: {
    "wzg2m5k-0": [_exp11()],
    "wzg2m5k-1": [_exp22()]
  }
});

var DataEditorContainer = p => {
  const {
    inWidth,
    inHeight,
    children,
    ...rest
  } = p;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, {
    innerHeight: toCss(inHeight),
    innerWidth: toCss(inWidth),
    ...rest
  }, children);
};

function toggleBoolean(data) {
  return data !== true;
}

var defaultCellMaxSize = 20;
var booleanCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "false";
  },
  kind: GridCellKind.Boolean,
  needsHover: true,
  useLabel: false,
  needsHoverPosition: true,
  measure: () => 50,
  draw: a => {
    var _a;

    return drawBoolean(a, a.cell.data, booleanCellIsEditable(a.cell), (_a = a.cell.maxSize) != null ? _a : defaultCellMaxSize);
  },
  onDelete: c => ({ ...c,
    data: false
  }),
  onClick: e => {
    var _a;

    const {
      cell,
      posX: x,
      posY: y,
      bounds
    } = e;
    const maxWidth = (_a = cell.maxSize) != null ? _a : defaultCellMaxSize;

    if (booleanCellIsEditable(cell) && Math.abs(x - bounds.width / 2) <= Math.min(maxWidth / 2, bounds.height / 3.4) && Math.abs(y - bounds.height / 2) <= Math.min(maxWidth / 2, bounds.height / 3.4)) {
      return { ...cell,
        data: toggleBoolean(cell.data)
      };
    }

    return void 0;
  },
  onPaste: (toPaste, cell) => {
    let newVal = BooleanEmpty;

    if (toPaste.toLowerCase() === "true") {
      newVal = true;
    } else if (toPaste.toLowerCase() === "false") {
      newVal = false;
    } else if (toPaste.toLowerCase() === "indeterminate") {
      newVal = BooleanIndeterminate;
    }

    return newVal === cell.data ? void 0 : { ...cell,
      data: newVal
    };
  }
};

var maxPxPerMs = 2;
var msToFullSpeed = 1300;

function useAutoscroll(scrollDirection, scrollRef) {
  const speedScalar = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const [xDir, yDir] = scrollDirection != null ? scrollDirection : [0, 0];
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (xDir === 0 && yDir === 0) {
      speedScalar.current = 0;
      return;
    }

    let lastTime = 0;

    const scrollFn = curTime => {
      var _a;

      if (lastTime === 0) {
        lastTime = curTime;
      } else {
        const step = curTime - lastTime;
        speedScalar.current = Math.min(1, speedScalar.current + step / msToFullSpeed);
        const motion = speedScalar.current ** 1.618 * step * maxPxPerMs;
        (_a = scrollRef.current) == null ? void 0 : _a.scrollBy(xDir * motion, yDir * motion);
        lastTime = curTime;
      }

      t = window.requestAnimationFrame(scrollFn);
    };

    let t = window.requestAnimationFrame(scrollFn);
    return () => window.cancelAnimationFrame(t);
  }, [scrollRef, xDir, yDir]);
}



var BubblesOverlayEditorStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "BubblesOverlayEditorStyle",
  class: "b1bqsp5z"
});

var BubblesOverlayEditor = p => {
  const {
    bubbles
  } = p;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(BubblesOverlayEditorStyle, null, bubbles.map((b, i) => react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: i,
    className: "boe-bubble"
  }, b)), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};

var bubbles_overlay_editor_default = BubblesOverlayEditor;
var bubbleCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Bubble,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data).width + acc + 20, 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => drawBubbles(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(bubbles_overlay_editor_default, {
      bubbles: value.data
    });
  },
  onPaste: () => void 0
};


var DrilldownOverlayEditorStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "DrilldownOverlayEditorStyle",
  class: "df2kt4a"
});

var DrilldownOverlayEditor = p => {
  const {
    drilldowns
  } = p;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(DrilldownOverlayEditorStyle, null, drilldowns.map((d, i) => react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: i,
    className: "doe-bubble"
  }, d.img !== void 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
    src: d.img
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, d.text))));
};

var drilldown_overlay_editor_default = DrilldownOverlayEditor;
var drilldownCellRenderer = {
  getAccessibilityString: c => c.data.map(d => d.text).join(", "),
  kind: GridCellKind.Drilldown,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data.text).width + acc + 20 + (data.img !== void 0 ? 18 : 0), 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => drawDrilldownCell(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(drilldown_overlay_editor_default, {
      drilldowns: value.data
    });
  },
  onPaste: () => void 0
};


var ImageOverlayEditorStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "ImageOverlayEditorStyle",
  class: "i1eozt10"
});


var ImageOverlayEditor = p => {
  const {
    urls,
    canWrite,
    onEditClick,
    renderImage
  } = p;
  const filtered = urls.filter(u => u !== "");

  if (filtered.length === 0) {
    return null;
  }

  const allowMove = filtered.length > 1;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImageOverlayEditorStyle, {
    "data-testid": "GDG-default-image-overlay-editor"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_responsive_carousel__WEBPACK_IMPORTED_MODULE_12__/* .Carousel */ .lr, {
    showArrows: allowMove,
    showThumbs: false,
    swipeable: allowMove,
    emulateTouch: allowMove,
    infiniteLoop: allowMove
  }, filtered.map(url => {
    var _a;

    const innerContent = (_a = renderImage == null ? void 0 : renderImage(url)) != null ? _a : react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
      draggable: false,
      src: url
    });
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "centering-container",
      key: url
    }, innerContent);
  })), canWrite && onEditClick && react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    className: "edit-icon",
    onClick: onEditClick
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null)));
};

var imageCellRenderer = {
  getAccessibilityString: c => c.data.join(", "),
  kind: GridCellKind.Image,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  draw: a => {
    var _a;

    return drawImage(a, (_a = a.cell.displayData) != null ? _a : a.cell.data, a.cell.rounding, a.cell.contentAlign);
  },
  measure: (_ctx, cell) => cell.data.length * 50,
  onDelete: c => ({ ...c,
    data: []
  }),
  provideEditor: () => p => {
    const {
      value,
      onFinishedEditing,
      imageEditorOverride
    } = p;
    const ImageEditor = imageEditorOverride != null ? imageEditorOverride : ImageOverlayEditor;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImageEditor, {
      urls: value.data,
      canWrite: value.allowAdd,
      onCancel: onFinishedEditing,
      onChange: newImage => {
        onFinishedEditing({ ...value,
          data: [newImage]
        });
      }
    });
  },
  onPaste: (toPaste, cell) => {
    toPaste = toPaste.trim();
    const fragments = toPaste.split(",");
    const uris = fragments.map(f => {
      try {
        new URL(f);
        return f;
      } catch (e) {
        return void 0;
      }
    }).filter(x => x !== void 0);
    if (uris.length === cell.data.length && uris.every((u, i) => u === cell.data[i])) return void 0;
    return { ...cell,
      data: uris
    };
  }
};
var loadingCellRenderer = {
  getAccessibilityString: () => "",
  kind: GridCellKind.Loading,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: () => 120,
  draw: () => void 0,
  onPaste: () => void 0
};




var MarkdownContainer = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "MarkdownContainer",
  class: "mlbeo71"
});
var MarkdownDiv = class extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor() {
    super(...arguments);
    this.targetElement = null;

    this.containerRefHook = element => {
      this.targetElement = element;
      this.renderMarkdownIntoDiv();
    };
  }

  renderMarkdownIntoDiv() {
    const {
      targetElement,
      props
    } = this;
    if (targetElement === null) return;
    const {
      contents,
      createNode
    } = props;
    const innerHTML = (0,marked__WEBPACK_IMPORTED_MODULE_13__/* .marked */ .TU)(contents);
    const childRange = document.createRange();
    childRange.selectNodeContents(targetElement);
    childRange.deleteContents();
    let newChild = createNode == null ? void 0 : createNode(innerHTML);

    if (newChild === void 0) {
      const childDoc = document.createElement("template");
      childDoc.innerHTML = innerHTML;
      newChild = childDoc.content;
    }

    targetElement.append(newChild);
    const tags = targetElement.getElementsByTagName("a");

    for (const tag of tags) {
      tag.target = "_blank";
      tag.rel = "noreferrer noopener";
    }
  }

  render() {
    this.renderMarkdownIntoDiv();
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownContainer, {
      ref: this.containerRefHook
    });
  }

};

var InputBox = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("textarea")({
  name: "InputBox",
  class: "ijuk0po"
});
var ShadowBox = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "ShadowBox",
  class: "saq3p5l"
});
var GrowingEntryStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "GrowingEntryStyle",
  class: "gf8vzix"
});

var GrowingEntry = props => {
  const {
    placeholder,
    value,
    onKeyDown,
    highlight,
    altNewline,
    validatedSelection,
    ...rest
  } = props;
  const {
    onChange,
    className
  } = rest;
  const inputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const useText = value != null ? value : "";
  assert(onChange !== void 0, "GrowingEntry must be a controlled input area");
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const ta = inputRef.current;
    if (ta === null) return;
    if (ta.disabled) return;
    const length = useText.toString().length;
    ta.focus();
    ta.setSelectionRange(highlight ? 0 : length, length);
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    var _a;

    if (validatedSelection !== void 0) {
      const range2 = typeof validatedSelection === "number" ? [validatedSelection, null] : validatedSelection;
      (_a = inputRef.current) == null ? void 0 : _a.setSelectionRange(range2[0], range2[1]);
    }
  }, [validatedSelection]);
  const onKeyDownInner = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(e => {
    if (e.key === "Enter" && e.shiftKey && altNewline === true) {
      return;
    }

    onKeyDown == null ? void 0 : onKeyDown(e);
  }, [altNewline, onKeyDown]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntryStyle, {
    className: "gdg-growing-entry"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(ShadowBox, {
    className
  }, useText + "\n"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(InputBox, { ...rest,
    className: (className != null ? className : "") + " gdg-input",
    ref: inputRef,
    onKeyDown: onKeyDownInner,
    value: useText,
    placeholder,
    dir: "auto"
  }));
};

var _exp12 = () => p => p.targetWidth;

var MarkdownOverlayEditorStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "MarkdownOverlayEditorStyle",
  class: "mdwzdl1",
  vars: {
    "mdwzdl1-0": [_exp12(), "px"]
  }
});

var MarkdownOverlayEditor = p => {
  const {
    value,
    onChange,
    forceEditMode,
    createNode,
    targetRect,
    onFinish,
    validatedSelection
  } = p;
  const markdown = value.data;
  const readonly = value.readonly === true;
  const [editMode, setEditMode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(markdown === "" || forceEditMode);
  const onEditClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setEditMode(e => !e);
  }, []);
  const addLeftPad = markdown ? "ml-6" : "";

  if (editMode) {
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditorStyle, {
      targetWidth: targetRect.width - 20
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      autoFocus: true,
      highlight: false,
      validatedSelection,
      value: markdown,
      onKeyDown: e => {
        if (e.key === "Enter") e.stopPropagation();
      },
      onChange
    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: `edit-icon checkmark-hover ${addLeftPad}`,
      onClick: () => onFinish(value)
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Checkmark, null)));
  }

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditorStyle, {
    targetWidth: targetRect.width
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownDiv, {
    contents: markdown,
    createNode
  }), !readonly && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "spacer"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: `edit-icon edit-hover ${addLeftPad}`,
    onClick: onEditClick
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null))), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "md-edit-textarea gdg-input",
    autoFocus: true
  }));
};

var markdownCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Markdown,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: prepTextCell,
  measure: (ctx, cell, t) => {
    const firstLine = cell.data.split("\n")[0];
    return ctx.measureText(firstLine).width + 2 * t.cellHorizontalPadding;
  },
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      onChange,
      value,
      target,
      onFinishedEditing,
      markdownDivCreateNode,
      forceEditMode,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditor, {
      onFinish: onFinishedEditing,
      targetRect: target,
      value,
      validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      }),
      forceEditMode,
      createNode: markdownDivCreateNode
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : { ...cell,
    data: toPaste
  }
};
var markerCellRenderer = {
  getAccessibilityString: c => c.row.toString(),
  kind: InnerGridCellKind.Marker,
  needsHover: true,
  needsHoverPosition: false,
  drawPrep: prepMarkerRowCell,
  measure: () => 44,
  draw: a => drawMarkerRowCell(a, a.cell.row, a.cell.checked, a.cell.markerKind, a.cell.drawHandle),
  onClick: e => {
    const {
      bounds,
      cell,
      posX: x,
      posY: y
    } = e;
    const {
      width,
      height
    } = bounds;
    const centerX = cell.drawHandle ? 7 + (width - 7) / 2 : width / 2;
    const centerY = height / 2;

    if (Math.abs(x - centerX) <= 10 && Math.abs(y - centerY) <= 10) {
      return { ...cell,
        checked: !cell.checked
      };
    }

    return void 0;
  },
  onPaste: () => void 0
};
var newRowCellRenderer = {
  getAccessibilityString: () => "",
  kind: InnerGridCellKind.NewRow,
  needsHover: true,
  needsHoverPosition: false,
  measure: () => 200,
  draw: a => drawNewRowCell(a, a.cell.hint, a.cell.icon),
  onPaste: () => void 0
};

var NumberOverlayEditor = react__WEBPACK_IMPORTED_MODULE_0__.lazy(async () => await Promise.all(/* import() */[__webpack_require__.e(333), __webpack_require__.e(258)]).then(__webpack_require__.bind(__webpack_require__, "./packages/core/dist/js/number-overlay-editor-IQSP2NXN.js")));
var numberCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Number,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: prepTextCell,
  draw: a => drawTextCell(a, a.cell.displayData, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.displayData).width + 16,
  onDelete: c => ({ ...c,
    data: void 0
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
      fallback: null
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(NumberOverlayEditor, {
      highlight: isHighlighted,
      disabled: value.readonly === true,
      value: value.data,
      fixedDecimals: value.fixedDecimals,
      allowNegative: value.allowNegative,
      validatedSelection,
      onChange: x => {
        var _a;

        return onChange({ ...value,
          data: Number.isNaN((_a = x.floatValue) != null ? _a : 0) ? 0 : x.floatValue
        });
      }
    }));
  },
  onPaste: (toPaste, cell) => {
    const newNumber = Number.parseFloat(toPaste);
    if (Number.isNaN(newNumber) || cell.data === newNumber) return void 0;
    return { ...cell,
      data: newNumber
    };
  }
};
var protectedCellRenderer = {
  getAccessibilityString: () => "",
  measure: () => 108,
  kind: GridCellKind.Protected,
  needsHover: false,
  needsHoverPosition: false,
  draw: drawProtectedCell,
  onPaste: () => void 0
};

var rowIDCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.RowID,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: (a, b) => prepTextCell(a, b, a.theme.textLight),
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly !== false,
      value: value.data,
      validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: () => void 0
};

var textCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Text,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: prepTextCell,
  useLabel: true,
  draw: a => (drawTextCell(a, a.cell.displayData, a.cell.contentAlign, a.cell.allowWrapping, a.hyperWrapping), true),
  measure: (ctx, cell, t) => {
    const lines = cell.displayData.split("\n").slice(0, cell.allowWrapping === true ? void 0 : 1);
    return Math.max(...lines.map(l => ctx.measureText(l).width + 2 * t.cellHorizontalPadding));
  },
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly === true,
      altNewline: true,
      value: value.data,
      validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : { ...cell,
    data: toPaste
  }
};


var UriOverlayEditorStyle = (0,_chunk_UM7QR3LO_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "UriOverlayEditorStyle",
  class: "uf0sjo8"
});

var UriOverlayEditor = p => {
  const {
    uri,
    onChange,
    forceEditMode,
    readonly,
    validatedSelection,
    preview
  } = p;
  const [editMode, setEditMode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(uri === "" || forceEditMode);
  const onEditClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setEditMode(true);
  }, []);

  if (editMode) {
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      validatedSelection,
      highlight: true,
      autoFocus: true,
      value: uri,
      onChange
    });
  }

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(UriOverlayEditorStyle, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "link-area",
    href: uri,
    target: "_blank",
    rel: "noopener noreferrer"
  }, preview), !readonly && react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "edit-icon",
    onClick: onEditClick
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null)), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};

var uri_overlay_editor_default = UriOverlayEditor;
var uriCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Uri,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: prepTextCell,
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell, theme) => ctx.measureText(cell.data).width + theme.cellHorizontalPadding * 2,
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    var _a;

    const {
      onChange,
      value,
      forceEditMode,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(uri_overlay_editor_default, {
      forceEditMode,
      uri: value.data,
      preview: (_a = value.displayData) != null ? _a : value.data,
      validatedSelection,
      readonly: value.readonly === true,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : { ...cell,
    data: toPaste
  }
};
var CellRenderers = {
  [InnerGridCellKind.Marker]: markerCellRenderer,
  [InnerGridCellKind.NewRow]: newRowCellRenderer,
  [GridCellKind.Boolean]: booleanCellRenderer,
  [GridCellKind.Bubble]: bubbleCellRenderer,
  [GridCellKind.Drilldown]: drilldownCellRenderer,
  [GridCellKind.Image]: imageCellRenderer,
  [GridCellKind.Loading]: loadingCellRenderer,
  [GridCellKind.Markdown]: markdownCellRenderer,
  [GridCellKind.Number]: numberCellRenderer,
  [GridCellKind.Protected]: protectedCellRenderer,
  [GridCellKind.RowID]: rowIDCellRenderer,
  [GridCellKind.Text]: textCellRenderer,
  [GridCellKind.Uri]: uriCellRenderer
};
var idCounter = 0;

function getSpanStops(cells) {
  return lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__(cells).filter(c => c.span !== void 0).map(c => {
    var _a, _b, _c, _d;

    return lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(((_b = (_a = c.span) == null ? void 0 : _a[0]) != null ? _b : 0) + 1, ((_d = (_c = c.span) == null ? void 0 : _c[1]) != null ? _d : 0) + 1);
  })));
}

function shiftSelection(input, offset) {
  if (input === void 0 || offset === 0 || input.columns.length === 0 && input.current === void 0) return input;
  return {
    current: input.current === void 0 ? void 0 : {
      cell: [input.current.cell[0] + offset, input.current.cell[1]],
      range: { ...input.current.range,
        x: input.current.range.x + offset
      },
      rangeStack: input.current.rangeStack.map(r => ({ ...r,
        x: r.x + offset
      }))
    },
    rows: input.rows,
    columns: input.columns.offset(offset)
  };
}

var keybindingDefaults = {
  selectAll: true,
  selectRow: true,
  selectColumn: true,
  downFill: false,
  rightFill: false,
  pageUp: false,
  pageDown: false,
  clear: true,
  copy: true,
  paste: true,
  search: false,
  first: true,
  last: true
};
var loadingCell2 = {
  kind: GridCellKind.Loading,
  allowOverlay: false
};
var emptyGridSelection = {
  columns: CompactSelection.empty(),
  rows: CompactSelection.empty(),
  current: void 0
};

var DataEditorImpl = (p, forwardedRef) => {
  var _a, _b, _c, _d, _e;

  const [gridSelectionInner, setGridSelectionInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(emptyGridSelection);
  const [overlay, setOverlay] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const searchInputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const canvasRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const [mouseState, setMouseState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const scrollRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const lastSent = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const {
    rowMarkers = "none",
    rowMarkerWidth: rowMarkerWidthRaw,
    imageEditorOverride,
    getRowThemeOverride,
    markdownDivCreateNode,
    width,
    height,
    columns: columnsIn,
    rows,
    getCellContent,
    onCellClicked,
    onCellActivated,
    onFinishedEditing,
    coercePasteValue,
    drawHeader: drawHeaderIn,
    onHeaderClicked,
    spanRangeBehavior = "default",
    onGroupHeaderClicked,
    onCellContextMenu,
    className,
    onHeaderContextMenu,
    getCellsForSelection: getCellsForSelectionIn,
    onGroupHeaderContextMenu,
    onGroupHeaderRenamed,
    onCellEdited,
    onCellsEdited,
    onKeyDown: onKeyDownIn,
    onKeyUp: onKeyUpIn,
    keybindings: keybindingsIn,
    onRowAppended,
    onColumnMoved,
    validateCell: validateCellIn,
    highlightRegions: highlightRegionsIn,
    drawCell: drawCell2,
    rangeSelect = "rect",
    columnSelect = "multi",
    rowSelect = "multi",
    rangeSelectionBlending = "exclusive",
    columnSelectionBlending = "exclusive",
    rowSelectionBlending = "exclusive",
    onDelete: onDeleteIn,
    onDragStart,
    onMouseMove,
    onPaste,
    copyHeaders = false,
    freezeColumns = 0,
    rowSelectionMode = "auto",
    rowMarkerStartIndex = 1,
    rowMarkerTheme,
    onHeaderMenuClick,
    getGroupDetails,
    onSearchClose: onSearchCloseIn,
    onItemHovered,
    onSelectionCleared,
    showSearch: showSearchIn,
    onVisibleRegionChanged,
    gridSelection: gridSelectionOuter,
    onGridSelectionChange,
    minColumnWidth: minColumnWidthIn = 50,
    maxColumnWidth: maxColumnWidthIn = 500,
    maxColumnAutoWidth: maxColumnAutoWidthIn,
    provideEditor,
    trailingRowOptions,
    scrollOffsetX,
    scrollOffsetY,
    verticalBorder,
    onDragOverCell,
    onDrop,
    onColumnResize: onColumnResizeIn,
    onColumnResizeEnd: onColumnResizeEndIn,
    onColumnResizeStart: onColumnResizeStartIn,
    customRenderers: additionalRenderers,
    fillHandle,
    drawFocusRing: drawFocusRing2,
    experimental,
    fixedShadowX,
    fixedShadowY,
    headerIcons,
    imageWindowLoader,
    initialSize,
    isDraggable,
    onDragLeave,
    onRowMoved,
    overscrollX: overscrollXIn,
    overscrollY: overscrollYIn,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    showMinimap,
    smoothScrollX,
    smoothScrollY,
    scrollToEnd,
    scaleToRem = false,
    rowHeight: rowHeightIn = 34,
    headerHeight: headerHeightIn = 36,
    groupHeaderHeight: groupHeaderHeightIn = headerHeightIn,
    theme: themeIn
  } = p;
  const minColumnWidth = Math.max(minColumnWidthIn, 20);
  const maxColumnWidth = Math.max(maxColumnWidthIn, minColumnWidth);
  const maxColumnAutoWidth = Math.max(maxColumnAutoWidthIn != null ? maxColumnAutoWidthIn : maxColumnWidth, minColumnWidth);
  const docStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (typeof window === "undefined") return {
      fontSize: "16px"
    };
    return window.getComputedStyle(document.documentElement);
  }, []);
  const fontSizeStr = docStyle.fontSize;
  const remSize = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => Number.parseFloat(fontSizeStr), [fontSizeStr]);
  const [rowHeight, headerHeight, groupHeaderHeight, theme, overscrollX, overscrollY] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a2, _b2, _c2;

    if (!scaleToRem || remSize === 16) return [rowHeightIn, headerHeightIn, groupHeaderHeightIn, themeIn, overscrollXIn, overscrollYIn];
    const scaler = remSize / 16;
    const rh = rowHeightIn;
    const bt = getDataEditorTheme();
    return [typeof rh === "number" ? rh * scaler : n => Math.ceil(rh(n) * scaler), Math.ceil(headerHeightIn * scaler), Math.ceil(groupHeaderHeightIn * scaler), { ...themeIn,
      headerIconSize: ((_a2 = themeIn == null ? void 0 : themeIn.headerIconSize) != null ? _a2 : bt.headerIconSize) * scaler,
      cellHorizontalPadding: ((_b2 = themeIn == null ? void 0 : themeIn.cellHorizontalPadding) != null ? _b2 : bt.cellHorizontalPadding) * scaler,
      cellVerticalPadding: ((_c2 = themeIn == null ? void 0 : themeIn.cellVerticalPadding) != null ? _c2 : bt.cellVerticalPadding) * scaler
    }, Math.ceil((overscrollXIn != null ? overscrollXIn : 0) * scaler), Math.ceil((overscrollYIn != null ? overscrollYIn : 0) * scaler)];
  }, [groupHeaderHeightIn, headerHeightIn, overscrollXIn, overscrollYIn, remSize, rowHeightIn, scaleToRem, themeIn]);
  const keybindings = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return keybindingsIn === void 0 ? keybindingDefaults : { ...keybindingDefaults,
      ...keybindingsIn
    };
  }, [keybindingsIn]);
  const rowMarkerWidth = rowMarkerWidthRaw != null ? rowMarkerWidthRaw : rows > 1e4 ? 48 : rows > 1e3 ? 44 : rows > 100 ? 36 : 32;
  const hasRowMarkers = rowMarkers !== "none";
  const rowMarkerOffset = hasRowMarkers ? 1 : 0;
  const showTrailingBlankRow = onRowAppended !== void 0;
  const lastRowSticky = (trailingRowOptions == null ? void 0 : trailingRowOptions.sticky) === true;
  const [showSearchInner, setShowSearchInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const showSearch = showSearchIn != null ? showSearchIn : showSearchInner;
  const onSearchClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (onSearchCloseIn !== void 0) {
      onSearchCloseIn();
    } else {
      setShowSearchInner(false);
    }
  }, [onSearchCloseIn]);
  const gridSelectionOuterMangled = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return gridSelectionOuter === void 0 ? void 0 : shiftSelection(gridSelectionOuter, rowMarkerOffset);
  }, [gridSelectionOuter, rowMarkerOffset]);
  const gridSelection = gridSelectionOuterMangled != null ? gridSelectionOuterMangled : gridSelectionInner;
  const abortControllerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new AbortController());
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => {
      abortControllerRef == null ? void 0 : abortControllerRef.current.abort();
    };
  }, []);
  const [getCellsForSelection, getCellsForSeletionDirect] = useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortControllerRef.current, rows);
  const validateCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newValue, prevValue) => {
    if (validateCellIn === void 0) return true;
    const item = [cell[0] - rowMarkerOffset, cell[1]];
    return validateCellIn == null ? void 0 : validateCellIn(item, newValue, prevValue);
  }, [rowMarkerOffset, validateCellIn]);
  const expectedExternalGridSelection = react__WEBPACK_IMPORTED_MODULE_0__.useRef(gridSelectionOuter);
  const setGridSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal, expand) => {
    if (expand) {
      newVal = expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortControllerRef.current);
    }

    if (onGridSelectionChange !== void 0) {
      expectedExternalGridSelection.current = shiftSelection(newVal, -rowMarkerOffset);
      onGridSelectionChange(expectedExternalGridSelection.current);
    } else {
      setGridSelectionInner(newVal);
    }
  }, [onGridSelectionChange, getCellsForSelection, rowMarkerOffset, spanRangeBehavior]);
  const onColumnResize = whenDefined(onColumnResizeIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeIn == null ? void 0 : onColumnResizeIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeEnd = whenDefined(onColumnResizeEndIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeEndIn == null ? void 0 : onColumnResizeEndIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeEndIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeStart = whenDefined(onColumnResizeStartIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeStartIn == null ? void 0 : onColumnResizeStartIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeStartIn, rowMarkerOffset, columnsIn]));
  const drawHeader2 = whenDefined(drawHeaderIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2;

    return (_a2 = drawHeaderIn == null ? void 0 : drawHeaderIn({ ...args,
      columnIndex: args.columnIndex - rowMarkerOffset
    })) != null ? _a2 : false;
  }, [drawHeaderIn, rowMarkerOffset]));
  const onDelete = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(sel => {
    if (onDeleteIn !== void 0) {
      const result = onDeleteIn(shiftSelection(sel, -rowMarkerOffset));

      if (typeof result === "boolean") {
        return result;
      }

      return shiftSelection(result, rowMarkerOffset);
    }

    return true;
  }, [onDeleteIn, rowMarkerOffset]);
  const [setCurrent, setSelectedRows, setSelectedColumns] = useSelectionBehavior(gridSelection, setGridSelection, rangeSelectionBlending, columnSelectionBlending, rowSelectionBlending, rangeSelect);
  const mergedTheme = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return { ...getDataEditorTheme(),
      ...theme
    };
  }, [theme]);
  const [clientSize, setClientSize] = react__WEBPACK_IMPORTED_MODULE_0__.useState([10, 10, 0]);
  const getCellRenderer = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    if (cell.kind !== GridCellKind.Custom) {
      return CellRenderers[cell.kind];
    }

    return additionalRenderers == null ? void 0 : additionalRenderers.find(x => x.isMatch(cell));
  }, [additionalRenderers]);
  const columns = useColumnSizer(columnsIn, rows, getCellsForSeletionDirect, clientSize[0] - (rowMarkerOffset === 0 ? 0 : rowMarkerWidth) - clientSize[2], minColumnWidth, maxColumnAutoWidth, mergedTheme, getCellRenderer, abortControllerRef.current);
  const enableGroups = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return columns.some(c => c.group !== void 0);
  }, [columns]);
  const totalHeaderHeight = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;
  const numSelectedRows = gridSelection.rows.length;
  const rowMarkerHeader = rowMarkers === "none" ? "" : numSelectedRows === 0 ? headerCellUnheckedMarker : numSelectedRows === rows ? headerCellCheckedMarker : headerCellIndeterminateMarker;
  const mangledCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (rowMarkers === "none") return columns;
    return [{
      title: rowMarkerHeader,
      width: rowMarkerWidth,
      icon: void 0,
      hasMenu: false,
      style: "normal",
      themeOverride: rowMarkerTheme
    }, ...columns];
  }, [columns, rowMarkerWidth, rowMarkers, rowMarkerHeader, rowMarkerTheme]);
  const [visibleRegionY, visibleRegionTy] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [scrollOffsetY !== void 0 && typeof rowHeight === "number" ? Math.floor(scrollOffsetY / rowHeight) : 0, scrollOffsetY !== void 0 && typeof rowHeight === "number" ? -(scrollOffsetY % rowHeight) : 0];
  }, [scrollOffsetY, rowHeight]);
  const visibleRegionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({
    height: 1,
    width: 1,
    x: 0,
    y: 0
  });
  const visibleRegionInput = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a2, _b2;

    return {
      x: visibleRegionRef.current.x,
      y: visibleRegionY,
      width: (_a2 = visibleRegionRef.current.width) != null ? _a2 : 1,
      height: (_b2 = visibleRegionRef.current.height) != null ? _b2 : 1,
      ty: visibleRegionTy
    };
  }, [visibleRegionTy, visibleRegionY]);
  const hasJustScrolled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const [visibleRegion, setVisibleRegion, empty2] = useStateWithReactiveInput(visibleRegionInput);
  const vScrollReady = ((_a = visibleRegion.height) != null ? _a : 1) > 1;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (scrollOffsetY !== void 0 && scrollRef.current !== null && vScrollReady) {
      if (scrollRef.current.scrollTop === scrollOffsetY) return;
      scrollRef.current.scrollTop = scrollOffsetY;

      if (scrollRef.current.scrollTop !== scrollOffsetY) {
        empty2();
      }

      hasJustScrolled.current = true;
    }
  }, [scrollOffsetY, vScrollReady, empty2]);
  const hScrollReady = ((_b = visibleRegion.width) != null ? _b : 1) > 1;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (scrollOffsetX !== void 0 && scrollRef.current !== null && hScrollReady) {
      if (scrollRef.current.scrollLeft === scrollOffsetX) return;
      scrollRef.current.scrollLeft = scrollOffsetX;

      if (scrollRef.current.scrollLeft !== scrollOffsetX) {
        empty2();
      }

      hasJustScrolled.current = true;
    }
  }, [scrollOffsetX, hScrollReady, empty2]);
  const cellXOffset = visibleRegion.x + rowMarkerOffset;
  const cellYOffset = visibleRegion.y;
  const gridRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const focus = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(immediate => {
    var _a2;

    if (immediate === true) {
      (_a2 = gridRef.current) == null ? void 0 : _a2.focus();
    } else {
      window.requestAnimationFrame(() => {
        var _a3;

        (_a3 = gridRef.current) == null ? void 0 : _a3.focus();
      });
    }
  }, []);
  const mangledRows = showTrailingBlankRow ? rows + 1 : rows;
  const mangledOnCellsEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(items => {
    const mangledItems = rowMarkerOffset === 0 ? items : items.map(x => ({ ...x,
      location: [x.location[0] - rowMarkerOffset, x.location[1]]
    }));
    const r = onCellsEdited == null ? void 0 : onCellsEdited(mangledItems);

    if (r !== true) {
      for (const i of mangledItems) onCellEdited == null ? void 0 : onCellEdited(i.location, i.value);
    }

    return r;
  }, [onCellEdited, onCellsEdited, rowMarkerOffset]);
  const highlightRegions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (highlightRegionsIn === void 0) return void 0;
    if (rowMarkerOffset === 0) return highlightRegionsIn;
    return highlightRegionsIn.map(r => {
      const maxWidth = mangledCols.length - r.range.x - rowMarkerOffset;
      if (maxWidth <= 0) return void 0;
      return {
        color: r.color,
        range: { ...r.range,
          x: r.range.x + rowMarkerOffset,
          width: Math.min(maxWidth, r.range.width)
        },
        style: r.style
      };
    }).filter(x => x !== void 0);
  }, [highlightRegionsIn, mangledCols.length, rowMarkerOffset]);
  const mangledColsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(mangledCols);
  mangledColsRef.current = mangledCols;
  const getMangledCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (_ref) {
    let [col, row] = _ref;
    let forceStrict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j;

    const isTrailing = showTrailingBlankRow && row === mangledRows - 1;
    const isRowMarkerCol = col === 0 && hasRowMarkers;

    if (isRowMarkerCol) {
      if (isTrailing) {
        return loadingCell2;
      }

      return {
        kind: InnerGridCellKind.Marker,
        allowOverlay: false,
        checked: (gridSelection == null ? void 0 : gridSelection.rows.hasIndex(row)) === true,
        markerKind: rowMarkers === "clickable-number" ? "number" : rowMarkers,
        row: rowMarkerStartIndex + row,
        drawHandle: onRowMoved !== void 0
      };
    } else if (isTrailing) {
      const isFirst = col === rowMarkerOffset;
      const maybeFirstColumnHint = isFirst ? (_a2 = trailingRowOptions == null ? void 0 : trailingRowOptions.hint) != null ? _a2 : "" : "";
      const c = mangledColsRef.current[col];

      if (((_b2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _b2.disabled) === true) {
        return loadingCell2;
      } else {
        const hint = (_d2 = (_c2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _c2.hint) != null ? _d2 : maybeFirstColumnHint;
        const icon = (_f = (_e2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _e2.addIcon) != null ? _f : trailingRowOptions == null ? void 0 : trailingRowOptions.addIcon;
        return {
          kind: InnerGridCellKind.NewRow,
          hint,
          allowOverlay: false,
          icon
        };
      }
    } else {
      const outerCol = col - rowMarkerOffset;

      if (forceStrict || (experimental == null ? void 0 : experimental.strict) === true) {
        const vr = visibleRegionRef.current;
        const isOutsideMainArea = vr.x > outerCol || outerCol > vr.x + vr.width || vr.y > row || row > vr.y + vr.height;
        const isSelected = outerCol === ((_h = (_g = vr.extras) == null ? void 0 : _g.selected) == null ? void 0 : _h[0]) && row === ((_i = vr.extras) == null ? void 0 : _i.selected[1]);
        const isOutsideFreezeArea = ((_j = vr.extras) == null ? void 0 : _j.freezeRegion) === void 0 || vr.extras.freezeRegion.x > outerCol || outerCol > vr.extras.freezeRegion.x + vr.extras.freezeRegion.width || vr.extras.freezeRegion.y > row || row > vr.extras.freezeRegion.y + vr.extras.freezeRegion.height;

        if (isOutsideMainArea && !isSelected && isOutsideFreezeArea) {
          return {
            kind: GridCellKind.Loading,
            allowOverlay: false
          };
        }
      }

      let result = getCellContent([outerCol, row]);

      if (rowMarkerOffset !== 0 && result.span !== void 0) {
        result = { ...result,
          span: [result.span[0] + rowMarkerOffset, result.span[1] + rowMarkerOffset]
        };
      }

      return result;
    }
  }, [showTrailingBlankRow, mangledRows, hasRowMarkers, gridSelection == null ? void 0 : gridSelection.rows, onRowMoved, rowMarkers, rowMarkerOffset, trailingRowOptions == null ? void 0 : trailingRowOptions.hint, trailingRowOptions == null ? void 0 : trailingRowOptions.addIcon, experimental == null ? void 0 : experimental.strict, getCellContent, rowMarkerStartIndex]);
  const mangledGetGroupDetails = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(group => {
    var _a2, _b2;

    let result = (_a2 = getGroupDetails == null ? void 0 : getGroupDetails(group)) != null ? _a2 : {
      name: group
    };

    if (onGroupHeaderRenamed !== void 0 && group !== "") {
      result = {
        icon: result.icon,
        name: result.name,
        overrideTheme: result.overrideTheme,
        actions: [...((_b2 = result.actions) != null ? _b2 : []), {
          title: "Rename",
          icon: "renameIcon",
          onClick: e => setRenameGroup({
            group: result.name,
            bounds: e.bounds
          })
        }]
      };
    }

    return result;
  }, [getGroupDetails, onGroupHeaderRenamed]);
  const setOverlaySimple = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(val => {
    var _a2;

    const [col, row] = val.cell;
    const column = mangledCols[col];
    const groupTheme = (column == null ? void 0 : column.group) !== void 0 ? (_a2 = mangledGetGroupDetails(column.group)) == null ? void 0 : _a2.overrideTheme : void 0;
    const colTheme = column == null ? void 0 : column.themeOverride;
    const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
    setOverlay({ ...val,
      theme: { ...mergedTheme,
        ...groupTheme,
        ...colTheme,
        ...rowTheme,
        ...val.content.themeOverride
      }
    });
  }, [getRowThemeOverride, mangledCols, mangledGetGroupDetails, mergedTheme]);
  const reselect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((bounds, fromKeyboard, initialValue) => {
    var _a2;

    if (gridSelection.current === void 0) return;
    const [col, row] = gridSelection.current.cell;
    const c = getMangledCellContent([col, row]);

    if (c.kind !== GridCellKind.Boolean && c.allowOverlay) {
      let content = c;

      if (initialValue !== void 0) {
        switch (content.kind) {
          case GridCellKind.Number:
            {
              const d = maybe(() => initialValue === "-" ? -0 : Number.parseFloat(initialValue), 0);
              content = { ...content,
                data: Number.isNaN(d) ? 0 : d
              };
              break;
            }

          case GridCellKind.Text:
          case GridCellKind.Markdown:
          case GridCellKind.Uri:
            content = { ...content,
              data: initialValue
            };
            break;
        }
      }

      setOverlaySimple({
        target: bounds,
        content,
        initialValue,
        cell: [col, row],
        highlight: initialValue === void 0,
        forceEditMode: initialValue !== void 0
      });
    } else if (c.kind === GridCellKind.Boolean && fromKeyboard && c.readonly !== true) {
      mangledOnCellsEdited([{
        location: gridSelection.current.cell,
        value: { ...c,
          data: toggleBoolean(c.data)
        }
      }]);
      (_a2 = gridRef.current) == null ? void 0 : _a2.damage([{
        cell: gridSelection.current.cell
      }]);
    }
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited, setOverlaySimple]);
  const focusOnRowFromTrailingBlankRow = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row) => {
    var _a2;

    const bounds = (_a2 = gridRef.current) == null ? void 0 : _a2.getBounds(col, row);

    if (bounds === void 0 || scrollRef.current === null) {
      return;
    }

    const content = getMangledCellContent([col, row]);

    if (!content.allowOverlay) {
      return;
    }

    setOverlaySimple({
      target: bounds,
      content,
      initialValue: void 0,
      highlight: true,
      cell: [col, row],
      forceEditMode: true
    });
  }, [getMangledCellContent, setOverlaySimple]);
  const scrollTo = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (col, row) {
    let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "both";
    let paddingX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let paddingY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : void 0;

    var _a2;

    if (scrollRef.current !== null) {
      const grid = gridRef.current;
      const canvas = canvasRef.current;
      const trueCol = typeof col !== "number" ? col.unit === "cell" ? col.amount : void 0 : col;
      const trueRow = typeof row !== "number" ? row.unit === "cell" ? row.amount : void 0 : row;
      const desiredX = typeof col !== "number" && col.unit === "px" ? col.amount : void 0;
      const desiredY = typeof row !== "number" && row.unit === "px" ? row.amount : void 0;

      if (grid !== null && canvas !== null) {
        let targetRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        let scrollX = 0;
        let scrollY = 0;

        if (trueCol !== void 0 || trueRow !== void 0) {
          targetRect = (_a2 = grid.getBounds((trueCol != null ? trueCol : 0) + rowMarkerOffset, trueRow != null ? trueRow : 0)) != null ? _a2 : targetRect;
          if (targetRect.width === 0 || targetRect.height === 0) return;
        }

        const scrollBounds = canvas.getBoundingClientRect();
        const scale = scrollBounds.width / canvas.offsetWidth;

        if (desiredX !== void 0) {
          targetRect = { ...targetRect,
            x: desiredX - scrollBounds.left - scrollRef.current.scrollLeft,
            width: 1
          };
        }

        if (desiredY !== void 0) {
          targetRect = { ...targetRect,
            y: desiredY + scrollBounds.top - scrollRef.current.scrollTop,
            height: 1
          };
        }

        if (targetRect !== void 0) {
          const bounds = {
            x: targetRect.x - paddingX,
            y: targetRect.y - paddingY,
            width: targetRect.width + 2 * paddingX,
            height: targetRect.height + 2 * paddingY
          };
          let frozenWidth = 0;

          for (let i = 0; i < freezeColumns; i++) {
            frozenWidth += columns[i].width;
          }

          let trailingRowHeight = 0;

          if (lastRowSticky) {
            trailingRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows);
          }

          let sLeft = frozenWidth * scale + scrollBounds.left + rowMarkerOffset * rowMarkerWidth * scale;
          let sRight = scrollBounds.right;
          let sTop = scrollBounds.top + totalHeaderHeight * scale;
          let sBottom = scrollBounds.bottom - trailingRowHeight * scale;
          const minx = targetRect.width + paddingX * 2;

          switch (options == null ? void 0 : options.hAlign) {
            case "start":
              sRight = sLeft + minx;
              break;

            case "end":
              sLeft = sRight - minx;
              break;

            case "center":
              sLeft = Math.floor((sLeft + sRight) / 2) - minx / 2;
              sRight = sLeft + minx;
              break;
          }

          const miny = targetRect.height + paddingY * 2;

          switch (options == null ? void 0 : options.vAlign) {
            case "start":
              sBottom = sTop + miny;
              break;

            case "end":
              sTop = sBottom - miny;
              break;

            case "center":
              sTop = Math.floor((sTop + sBottom) / 2) - miny / 2;
              sBottom = sTop + miny;
              break;
          }

          if (sLeft > bounds.x) {
            scrollX = bounds.x - sLeft;
          } else if (sRight < bounds.x + bounds.width) {
            scrollX = bounds.x + bounds.width - sRight;
          }

          if (sTop > bounds.y) {
            scrollY = bounds.y - sTop;
          } else if (sBottom < bounds.y + bounds.height) {
            scrollY = bounds.y + bounds.height - sBottom;
          }

          if (dir === "vertical" || col < freezeColumns) {
            scrollX = 0;
          } else if (dir === "horizontal") {
            scrollY = 0;
          }

          if (scrollX !== 0 || scrollY !== 0) {
            if (scale !== 1) {
              scrollX /= scale;
              scrollY /= scale;
            }

            scrollRef.current.scrollTo(scrollX + scrollRef.current.scrollLeft, scrollY + scrollRef.current.scrollTop);
          }
        }
      }
    }
  }, [rowMarkerOffset, rowMarkerWidth, totalHeaderHeight, lastRowSticky, freezeColumns, columns, rowHeight, rows]);
  const focusCallback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusOnRowFromTrailingBlankRow);
  const getCellContentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(getCellContent);
  const rowsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(rows);
  focusCallback.current = focusOnRowFromTrailingBlankRow;
  getCellContentRef.current = getCellContent;
  rowsRef.current = rows;
  const appendRow = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async function (col) {
    let openOverlay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var _a2;

    const c = mangledCols[col];

    if (((_a2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _a2.disabled) === true) {
      return;
    }

    const appendResult = onRowAppended == null ? void 0 : onRowAppended();
    let r = void 0;
    let bottom = true;

    if (appendResult !== void 0) {
      r = await appendResult;
      if (r === "top") bottom = false;
      if (typeof r === "number") bottom = false;
    }

    let backoff = 0;

    const doFocus = () => {
      if (rowsRef.current <= rows) {
        if (backoff < 500) {
          window.setTimeout(doFocus, backoff);
        }

        backoff = 50 + backoff * 2;
        return;
      }

      const row = typeof r === "number" ? r : bottom ? rows : 0;
      scrollTo(col - rowMarkerOffset, row);
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, false, false, "edit");
      const cell = getCellContentRef.current([col - rowMarkerOffset, row]);

      if (cell.allowOverlay && isReadWriteCell(cell) && cell.readonly !== true && openOverlay) {
        window.setTimeout(() => {
          focusCallback.current(col, row);
        }, 0);
      }
    };

    doFocus();
  }, [mangledCols, onRowAppended, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const getCustomNewRowTargetColumn = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(col => {
    var _a2, _b2, _c2;

    const customTargetColumn = (_c2 = (_b2 = (_a2 = columns[col]) == null ? void 0 : _a2.trailingRowOptions) == null ? void 0 : _b2.targetColumn) != null ? _c2 : trailingRowOptions == null ? void 0 : trailingRowOptions.targetColumn;

    if (typeof customTargetColumn === "number") {
      const customTargetOffset = hasRowMarkers ? 1 : 0;
      return customTargetColumn + customTargetOffset;
    }

    if (typeof customTargetColumn === "object") {
      const maybeIndex = columnsIn.indexOf(customTargetColumn);

      if (maybeIndex >= 0) {
        const customTargetOffset = hasRowMarkers ? 1 : 0;
        return maybeIndex + customTargetOffset;
      }
    }

    return void 0;
  }, [columns, columnsIn, hasRowMarkers, trailingRowOptions == null ? void 0 : trailingRowOptions.targetColumn]);
  const lastSelectedRowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastSelectedColRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const themeForCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, pos) => {
    var _a2;

    const [col, row] = pos;
    return { ...mergedTheme,
      ...((_a2 = mangledCols[col]) == null ? void 0 : _a2.themeOverride),
      ...(getRowThemeOverride == null ? void 0 : getRowThemeOverride(row)),
      ...cell.themeOverride
    };
  }, [getRowThemeOverride, mangledCols, mergedTheme]);
  const handleSelect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b2, _c2, _d2;

    const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;
    const isMultiRow = isMultiKey && rowSelect === "multi";
    const isMultiCol = isMultiKey && columnSelect === "multi";
    const [col, row] = args.location;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const [cellCol, cellRow] = (_b2 = (_a2 = gridSelection.current) == null ? void 0 : _a2.cell) != null ? _b2 : [];

    if (args.kind === "cell") {
      lastSelectedColRef.current = void 0;
      lastMouseSelectLocation.current = [col, row];

      if (col === 0 && hasRowMarkers) {
        if (showTrailingBlankRow === true && row === rows || rowMarkers === "number" || rowSelect === "none") return;
        const markerCell = getMangledCellContent(args.location);

        if (markerCell.kind !== InnerGridCellKind.Marker) {
          return;
        }

        if (onRowMoved !== void 0) {
          const renderer = getCellRenderer(markerCell);
          assert((renderer == null ? void 0 : renderer.kind) === InnerGridCellKind.Marker);
          const postClick = (_c2 = renderer == null ? void 0 : renderer.onClick) == null ? void 0 : _c2.call(renderer, { ...args,
            cell: markerCell,
            posX: args.localEventX,
            posY: args.localEventY,
            bounds: args.bounds,
            theme: themeForCell(markerCell, args.location),
            preventDefault: () => void 0
          });
          if (postClick === void 0 || postClick.checked === markerCell.checked) return;
        }

        setOverlay(void 0);
        focus();
        const isSelected = selectedRows.hasIndex(row);
        const lastHighlighted = lastSelectedRowRef.current;

        if (rowSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastHighlighted !== void 0 && selectedRows.hasIndex(lastHighlighted)) {
          const newSlice = [Math.min(lastHighlighted, row), Math.max(lastHighlighted, row) + 1];

          if (isMultiRow || rowSelectionMode === "multi") {
            setSelectedRows(void 0, newSlice, true);
          } else {
            setSelectedRows(CompactSelection.fromSingleSelection(newSlice), void 0, isMultiRow);
          }
        } else if (isMultiRow || args.isTouch || rowSelectionMode === "multi") {
          if (isSelected) {
            setSelectedRows(selectedRows.remove(row), void 0, true);
          } else {
            setSelectedRows(void 0, row, true);
            lastSelectedRowRef.current = row;
          }
        } else if (isSelected && selectedRows.length === 1) {
          setSelectedRows(CompactSelection.empty(), void 0, isMultiKey);
        } else {
          setSelectedRows(CompactSelection.fromSingleSelection(row), void 0, isMultiKey);
          lastSelectedRowRef.current = row;
        }
      } else if (col >= rowMarkerOffset && showTrailingBlankRow && row === rows) {
        const customTargetColumn = getCustomNewRowTargetColumn(col);
        void appendRow(customTargetColumn != null ? customTargetColumn : col);
      } else {
        if (cellCol !== col || cellRow !== row) {
          const cell = getMangledCellContent(args.location);
          const renderer = getCellRenderer(cell);

          if ((renderer == null ? void 0 : renderer.onSelect) !== void 0) {
            let prevented = false;
            renderer.onSelect({ ...args,
              cell,
              posX: args.localEventX,
              posY: args.localEventY,
              bounds: args.bounds,
              preventDefault: () => prevented = true,
              theme: themeForCell(cell, args.location)
            });

            if (prevented) {
              return;
            }
          }

          const isLastStickyRow = lastRowSticky && row === rows;
          const startedFromLastSticky = lastRowSticky && gridSelection !== void 0 && ((_d2 = gridSelection.current) == null ? void 0 : _d2.cell[1]) === rows;

          if ((args.shiftKey || args.isLongTouch === true) && cellCol !== void 0 && cellRow !== void 0 && gridSelection.current !== void 0 && !startedFromLastSticky) {
            if (isLastStickyRow) {
              return;
            }

            const left = Math.min(col, cellCol);
            const right = Math.max(col, cellCol);
            const top = Math.min(row, cellRow);
            const bottom = Math.max(row, cellRow);
            setCurrent({ ...gridSelection.current,
              range: {
                x: left,
                y: top,
                width: right - left + 1,
                height: bottom - top + 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = void 0;
            focus();
          } else {
            setCurrent({
              cell: [col, row],
              range: {
                x: col,
                y: row,
                width: 1,
                height: 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = void 0;
            setOverlay(void 0);
            focus();
          }
        }
      }
    } else if (args.kind === "header") {
      lastMouseSelectLocation.current = [col, row];
      setOverlay(void 0);

      if (hasRowMarkers && col === 0) {
        lastSelectedRowRef.current = void 0;
        lastSelectedColRef.current = void 0;

        if (rowSelect === "multi") {
          if (selectedRows.length !== rows) {
            setSelectedRows(CompactSelection.fromSingleSelection([0, rows]), void 0, isMultiKey);
          } else {
            setSelectedRows(CompactSelection.empty(), void 0, isMultiKey);
          }

          focus();
        }
      } else {
        const lastCol = lastSelectedColRef.current;

        if (columnSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastCol !== void 0 && selectedColumns.hasIndex(lastCol)) {
          const newSlice = [Math.min(lastCol, col), Math.max(lastCol, col) + 1];

          if (isMultiCol) {
            setSelectedColumns(void 0, newSlice, isMultiKey);
          } else {
            setSelectedColumns(CompactSelection.fromSingleSelection(newSlice), void 0, isMultiKey);
          }
        } else if (isMultiCol) {
          if (selectedColumns.hasIndex(col)) {
            setSelectedColumns(selectedColumns.remove(col), void 0, isMultiKey);
          } else {
            setSelectedColumns(void 0, col, isMultiKey);
          }

          lastSelectedColRef.current = col;
        } else if (columnSelect !== "none") {
          setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, isMultiKey);
          lastSelectedColRef.current = col;
        }

        lastSelectedRowRef.current = void 0;
        focus();
      }
    } else if (args.kind === groupHeaderKind) {
      lastMouseSelectLocation.current = [col, row];
    } else if (args.kind === outOfBoundsKind) {
      setGridSelection(emptyGridSelection, false);
      setOverlay(void 0);
      focus();
      onSelectionCleared == null ? void 0 : onSelectionCleared();
      lastSelectedRowRef.current = void 0;
      lastSelectedColRef.current = void 0;
    }
  }, [appendRow, columnSelect, focus, getCellRenderer, getCustomNewRowTargetColumn, getMangledCellContent, gridSelection, hasRowMarkers, lastRowSticky, onSelectionCleared, onRowMoved, rowMarkerOffset, rowMarkers, rowSelect, rowSelectionMode, rows, setCurrent, setGridSelection, setSelectedColumns, setSelectedRows, showTrailingBlankRow, themeForCell]);
  const lastMouseSelectLocation = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const touchDownArgs = react__WEBPACK_IMPORTED_MODULE_0__.useRef(visibleRegion);
  const mouseDownData = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b2;

    isPrevented.current = false;
    touchDownArgs.current = visibleRegionRef.current;

    if (args.button !== 0) {
      mouseDownData.current = void 0;
      return;
    }

    const time = performance.now();
    const wasDoubleClick = time - ((_b2 = (_a2 = mouseDownData.current) == null ? void 0 : _a2.time) != null ? _b2 : -1e3) < 250;
    mouseDownData.current = {
      wasDoubleClick,
      time,
      location: args.location
    };
    const fh = args.kind === "cell" && args.isFillHandle;
    if (!fh && args.kind !== "cell" && args.isEdge) return;
    setMouseState({
      previousSelection: gridSelection,
      fillHandle: fh
    });
    lastMouseSelectLocation.current = void 0;

    if (!args.isTouch) {
      handleSelect(args);
    }
  }, [gridSelection, handleSelect]);
  const [renameGroup, setRenameGroup] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const handleGroupHeaderSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (args.kind !== groupHeaderKind || columnSelect !== "multi") {
      return;
    }

    const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;
    const [col] = args.location;
    const selectedColumns = gridSelection.columns;
    if (col < rowMarkerOffset) return;
    const needle = mangledCols[col];
    let start = col;
    let end = col;

    for (let i = col - 1; i >= rowMarkerOffset; i--) {
      if (!isGroupEqual(needle.group, mangledCols[i].group)) break;
      start--;
    }

    for (let i = col + 1; i < mangledCols.length; i++) {
      if (!isGroupEqual(needle.group, mangledCols[i].group)) break;
      end++;
    }

    focus();

    if (isMultiKey) {
      if (selectedColumns.hasAll([start, end + 1])) {
        let newVal = selectedColumns;

        for (let index = start; index <= end; index++) {
          newVal = newVal.remove(index);
        }

        setSelectedColumns(newVal, void 0, isMultiKey);
      } else {
        setSelectedColumns(void 0, [start, end + 1], isMultiKey);
      }
    } else {
      setSelectedColumns(CompactSelection.fromSingleSelection([start, end + 1]), void 0, isMultiKey);
    }
  }, [columnSelect, focus, gridSelection.columns, mangledCols, rowMarkerOffset, setSelectedColumns]);
  const fillDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(reverse => {
    var _a2;

    if (gridSelection.current === void 0) return;
    const v = [];
    const r = gridSelection.current.range;

    for (let x = 0; x < r.width; x++) {
      const fillCol = x + r.x;
      const fillVal = getMangledCellContent([fillCol, reverse ? r.y + r.height - 1 : r.y]);
      if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;

      for (let y = 1; y < r.height; y++) {
        const fillRow = reverse ? r.y + r.height - (y + 1) : y + r.y;
        const target = [fillCol, fillRow];
        v.push({
          location: target,
          value: { ...fillVal
          }
        });
      }
    }

    mangledOnCellsEdited(v);
    (_a2 = gridRef.current) == null ? void 0 : _a2.damage(v.map(c => ({
      cell: c.location
    })));
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited]);
  const isPrevented = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const normalSizeColumn = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async function (col) {
    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var _a2;

    if ((((_a2 = mouseDownData.current) == null ? void 0 : _a2.wasDoubleClick) === true || force) && getCellsForSelection !== void 0 && onColumnResize !== void 0) {
      const start = visibleRegionRef.current.y;
      const end = visibleRegionRef.current.height;
      let cells = getCellsForSelection({
        x: col,
        y: start,
        width: 1,
        height: Math.min(end, rows - start)
      }, abortControllerRef.current.signal);

      if (typeof cells !== "object") {
        cells = await cells();
      }

      const inputCol = columns[col - rowMarkerOffset];
      const offscreen = document.createElement("canvas");
      const ctx = offscreen.getContext("2d", {
        alpha: false
      });

      if (ctx !== null) {
        ctx.font = `${mergedTheme.baseFontStyle} ${mergedTheme.fontFamily}`;
        const newCol = measureColumn(ctx, mergedTheme, inputCol, 0, cells, minColumnWidth, maxColumnWidth, false, getCellRenderer);
        onColumnResize == null ? void 0 : onColumnResize(inputCol, newCol.width, col, newCol.width);
      }
    }
  }, [columns, getCellsForSelection, maxColumnWidth, mergedTheme, minColumnWidth, onColumnResize, rowMarkerOffset, rows, getCellRenderer]);
  const [scrollDir, setScrollDir] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const onMouseUp = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, isOutside) => {
    var _a2, _b2, _c2;

    const mouse = mouseState;
    setMouseState(void 0);
    setScrollDir(void 0);
    if (isOutside) return;

    if ((mouse == null ? void 0 : mouse.fillHandle) === true && gridSelection.current !== void 0) {
      fillDown(gridSelection.current.cell[1] !== gridSelection.current.range.y);
      return;
    }

    const [col, row] = args.location;
    const [lastMouseDownCol, lastMouseDownRow] = (_a2 = lastMouseSelectLocation.current) != null ? _a2 : [];

    const preventDefault = () => {
      isPrevented.current = true;
    };

    const handleMaybeClick = a => {
      var _a3, _b3, _c3;

      if (a.isTouch || lastMouseDownCol === col && lastMouseDownRow === row) {
        onCellClicked == null ? void 0 : onCellClicked([col - rowMarkerOffset, row], { ...a,
          preventDefault
        });
      }

      if (!isPrevented.current) {
        const c = getMangledCellContent(args.location);
        const r = getCellRenderer(c);

        if (r !== void 0 && r.onClick !== void 0) {
          const newVal = r.onClick({ ...a,
            cell: c,
            posX: a.localEventX,
            posY: a.localEventY,
            bounds: a.bounds,
            theme: themeForCell(c, args.location),
            preventDefault
          });

          if (newVal !== void 0 && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {
            mangledOnCellsEdited([{
              location: a.location,
              value: newVal
            }]);
            (_a3 = gridRef.current) == null ? void 0 : _a3.damage([{
              cell: a.location
            }]);
          }
        }

        if (!isPrevented.current && ((_c3 = (_b3 = mouse == null ? void 0 : mouse.previousSelection) == null ? void 0 : _b3.current) == null ? void 0 : _c3.cell) !== void 0 && gridSelection.current !== void 0) {
          const [selectedCol, selectedRow] = gridSelection.current.cell;
          const [prevCol, prevRow] = mouse.previousSelection.current.cell;

          if (col === selectedCol && col === prevCol && row === selectedRow && row === prevRow) {
            onCellActivated == null ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
            reselect(a.bounds, false);
            return true;
          }
        }
      }

      return false;
    };

    const clickLocation = args.location[0] - rowMarkerOffset;

    if (args.isTouch) {
      const vr = visibleRegionRef.current;
      const touchVr = touchDownArgs.current;

      if (vr.x !== touchVr.x || vr.y !== touchVr.y) {
        return;
      }

      if (args.isLongTouch === true) {
        if (args.kind === "cell" && ((_b2 = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _b2.cell[0]) === col && ((_c2 = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _c2.cell[1]) === row) {
          onCellContextMenu == null ? void 0 : onCellContextMenu([clickLocation, args.location[1]], { ...args,
            preventDefault
          });
          return;
        } else if (args.kind === "header" && gridSelection.columns.hasIndex(col)) {
          onHeaderContextMenu == null ? void 0 : onHeaderContextMenu(clickLocation, { ...args,
            preventDefault
          });
          return;
        } else if (args.kind === groupHeaderKind) {
          if (clickLocation < 0) {
            return;
          }

          onGroupHeaderContextMenu == null ? void 0 : onGroupHeaderContextMenu(clickLocation, { ...args,
            preventDefault
          });
          return;
        }
      }

      if (args.kind === "cell") {
        if (!handleMaybeClick(args)) {
          handleSelect(args);
        }
      } else if (args.kind === groupHeaderKind) {
        onGroupHeaderClicked == null ? void 0 : onGroupHeaderClicked(clickLocation, { ...args,
          preventDefault
        });
      } else {
        if (args.kind === headerKind) {
          onHeaderClicked == null ? void 0 : onHeaderClicked(clickLocation, { ...args,
            preventDefault
          });
        }

        handleSelect(args);
      }

      return;
    }

    if (args.kind === "header") {
      if (clickLocation < 0) {
        return;
      }

      if (args.isEdge) {
        void normalSizeColumn(col);
      } else if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onHeaderClicked == null ? void 0 : onHeaderClicked(clickLocation, { ...args,
          preventDefault
        });
      }
    }

    if (args.kind === groupHeaderKind) {
      if (clickLocation < 0) {
        return;
      }

      if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onGroupHeaderClicked == null ? void 0 : onGroupHeaderClicked(clickLocation, { ...args,
          preventDefault
        });

        if (!isPrevented.current) {
          handleGroupHeaderSelection(args);
        }
      }
    }

    if (args.kind === "cell" && args.button === 0) {
      handleMaybeClick(args);
    }

    lastMouseSelectLocation.current = void 0;
  }, [mouseState, rowMarkerOffset, gridSelection, onCellClicked, fillDown, getMangledCellContent, getCellRenderer, themeForCell, mangledOnCellsEdited, onCellActivated, reselect, onCellContextMenu, onHeaderContextMenu, onGroupHeaderContextMenu, handleSelect, onGroupHeaderClicked, normalSizeColumn, onHeaderClicked, handleGroupHeaderSelection]);
  const onMouseMoveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const a = { ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    };
    onMouseMove == null ? void 0 : onMouseMove(a);
    setScrollDir(cv => {
      var _a2, _b2;

      if (args.scrollEdge[0] === (cv == null ? void 0 : cv[0]) && args.scrollEdge[1] === cv[1]) return cv;
      return mouseState === void 0 || ((_b2 = (_a2 = mouseDownData.current) == null ? void 0 : _a2.location[0]) != null ? _b2 : 0) < rowMarkerOffset ? void 0 : args.scrollEdge;
    });
  }, [mouseState, onMouseMove, rowMarkerOffset]);
  useAutoscroll(scrollDir, scrollRef);
  const onHeaderMenuClickInner = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, screenPosition) => {
    onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col - rowMarkerOffset, screenPosition);
  }, [onHeaderMenuClick, rowMarkerOffset]);
  const currentCell = (_c = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _c.cell;
  const onVisibleRegionChangedImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((region, clientWidth, clientHeight, rightElWidth, tx, ty) => {
    hasJustScrolled.current = false;
    let selected = currentCell;

    if (selected !== void 0) {
      selected = [selected[0] - rowMarkerOffset, selected[1]];
    }

    const newRegion = {
      x: region.x - rowMarkerOffset,
      y: region.y,
      width: region.width,
      height: showTrailingBlankRow && region.y + region.height >= rows ? region.height - 1 : region.height,
      tx,
      ty,
      extras: {
        selected,
        freezeRegion: freezeColumns === 0 ? void 0 : {
          x: 0,
          y: region.y,
          width: freezeColumns,
          height: region.height
        }
      }
    };
    visibleRegionRef.current = newRegion;
    setVisibleRegion(newRegion);
    setClientSize([clientWidth, clientHeight, rightElWidth]);
    onVisibleRegionChanged == null ? void 0 : onVisibleRegionChanged(newRegion, newRegion.tx, newRegion.ty, newRegion.extras);
  }, [currentCell, rowMarkerOffset, showTrailingBlankRow, rows, freezeColumns, setVisibleRegion, onVisibleRegionChanged]);
  const onColumnMovedImpl = whenDefined(onColumnMoved, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((startIndex, endIndex) => {
    onColumnMoved == null ? void 0 : onColumnMoved(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);

    if (columnSelect !== "none") {
      setSelectedColumns(CompactSelection.fromSingleSelection(endIndex), void 0, true);
    }
  }, [columnSelect, onColumnMoved, rowMarkerOffset, setSelectedColumns]));
  const isActivelyDragging = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (args.location[0] === 0 && rowMarkerOffset > 0) {
      args.preventDefault();
      return;
    }

    onDragStart == null ? void 0 : onDragStart({ ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });

    if (!args.defaultPrevented()) {
      isActivelyDragging.current = true;
    }

    setMouseState(void 0);
  }, [onDragStart, rowMarkerOffset]);
  const onDragEnd = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    isActivelyDragging.current = false;
  }, []);
  const onItemHoveredImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2;

    if (mouseState !== void 0 && ((_a2 = mouseDownData.current) == null ? void 0 : _a2.location[0]) === 0 && args.location[0] === 0 && rowMarkerOffset === 1 && rowSelect === "multi" && mouseState.previousSelection && !mouseState.previousSelection.rows.hasIndex(mouseDownData.current.location[1]) && gridSelection.rows.hasIndex(mouseDownData.current.location[1])) {
      const start = Math.min(mouseDownData.current.location[1], args.location[1]);
      const end = Math.max(mouseDownData.current.location[1], args.location[1]) + 1;
      setSelectedRows(CompactSelection.fromSingleSelection([start, end]), void 0, false);
    }

    if (mouseState !== void 0 && gridSelection.current !== void 0 && !isActivelyDragging.current && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
      const [selectedCol, selectedRow] = gridSelection.current.cell;
      let [col, row] = args.location;

      if (row < 0) {
        row = visibleRegionRef.current.y;
      }

      const startedFromLastStickyRow = lastRowSticky && selectedRow === rows;
      if (startedFromLastStickyRow) return;
      const landedOnLastStickyRow = lastRowSticky && row === rows;

      if (landedOnLastStickyRow) {
        if (args.kind === outOfBoundsKind) row--;else return;
      }

      col = Math.max(col, rowMarkerOffset);
      const deltaX = col - selectedCol;
      const deltaY = row - selectedRow;
      const newRange = {
        x: deltaX >= 0 ? selectedCol : col,
        y: deltaY >= 0 ? selectedRow : row,
        width: Math.abs(deltaX) + 1,
        height: Math.abs(deltaY) + 1
      };
      setCurrent({ ...gridSelection.current,
        range: newRange
      }, true, false, "drag");
    }

    onItemHovered == null ? void 0 : onItemHovered({ ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });
  }, [mouseState, rowMarkerOffset, rowSelect, gridSelection, rangeSelect, onItemHovered, setSelectedRows, lastRowSticky, rows, setCurrent]);
  const adjustSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(direction2 => {
    if (gridSelection.current === void 0) return;
    const [x, y] = direction2;
    const [col, row] = gridSelection.current.cell;
    const old = gridSelection.current.range;
    let left = old.x;
    let right = old.x + old.width;
    let top = old.y;
    let bottom = old.y + old.height;

    if (y !== 0) {
      switch (y) {
        case 2:
          {
            bottom = rows;
            top = row;
            scrollTo(0, bottom, "vertical");
            break;
          }

        case -2:
          {
            top = 0;
            bottom = row + 1;
            scrollTo(0, top, "vertical");
            break;
          }

        case 1:
          {
            if (top < row) {
              top++;
              scrollTo(0, top, "vertical");
            } else {
              bottom = Math.min(rows, bottom + 1);
              scrollTo(0, bottom, "vertical");
            }

            break;
          }

        case -1:
          {
            if (bottom > row + 1) {
              bottom--;
              scrollTo(0, bottom, "vertical");
            } else {
              top = Math.max(0, top - 1);
              scrollTo(0, top, "vertical");
            }

            break;
          }

        default:
          {
            assertNever(y);
          }
      }
    }

    if (x !== 0) {
      if (x === 2) {
        right = mangledCols.length;
        left = col;
        scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
      } else if (x === -2) {
        left = rowMarkerOffset;
        right = col + 1;
        scrollTo(left - rowMarkerOffset, 0, "horizontal");
      } else {
        let disallowed = [];

        if (getCellsForSelection !== void 0) {
          const cells = getCellsForSelection({
            x: left,
            y: top,
            width: right - left - rowMarkerOffset,
            height: bottom - top
          }, abortControllerRef.current.signal);

          if (typeof cells === "object") {
            disallowed = getSpanStops(cells);
          }
        }

        if (x === 1) {
          let done = false;

          if (left < col) {
            if (disallowed.length > 0) {
              const target = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(left + 1, col + 1).find(n => !disallowed.includes(n - rowMarkerOffset));

              if (target !== void 0) {
                left = target;
                done = true;
              }
            } else {
              left++;
              done = true;
            }

            if (done) scrollTo(left, 0, "horizontal");
          }

          if (!done) {
            right = Math.min(mangledCols.length, right + 1);
            scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
          }
        } else if (x === -1) {
          let done = false;

          if (right > col + 1) {
            if (disallowed.length > 0) {
              const target = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(right - 1, col, -1).find(n => !disallowed.includes(n - rowMarkerOffset));

              if (target !== void 0) {
                right = target;
                done = true;
              }
            } else {
              right--;
              done = true;
            }

            if (done) scrollTo(right - rowMarkerOffset, 0, "horizontal");
          }

          if (!done) {
            left = Math.max(rowMarkerOffset, left - 1);
            scrollTo(left - rowMarkerOffset, 0, "horizontal");
          }
        } else {
          assertNever(x);
        }
      }
    }

    setCurrent({
      cell: gridSelection.current.cell,
      range: {
        x: left,
        y: top,
        width: right - left,
        height: bottom - top
      }
    }, true, false, "keyboard-select");
  }, [getCellsForSelection, gridSelection, mangledCols.length, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const updateSelectedCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row, fromEditingTrailingRow, freeMove) => {
    const rowMax = mangledRows - (fromEditingTrailingRow ? 0 : 1);
    col = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(col, rowMarkerOffset, columns.length - 1 + rowMarkerOffset);
    row = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(row, 0, rowMax);
    if (col === (currentCell == null ? void 0 : currentCell[0]) && row === (currentCell == null ? void 0 : currentCell[1])) return false;

    if (freeMove && gridSelection.current !== void 0) {
      const newStack = [...gridSelection.current.rangeStack];

      if (gridSelection.current.range.width > 1 || gridSelection.current.range.height > 1) {
        newStack.push(gridSelection.current.range);
      }

      setGridSelection({ ...gridSelection,
        current: {
          cell: [col, row],
          range: {
            x: col,
            y: row,
            width: 1,
            height: 1
          },
          rangeStack: newStack
        }
      }, true);
    } else {
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-nav");
    }

    if (lastSent.current !== void 0 && lastSent.current[0] === col && lastSent.current[1] === row) {
      lastSent.current = void 0;
    }

    scrollTo(col - rowMarkerOffset, row);
    return true;
  }, [mangledRows, rowMarkerOffset, columns.length, currentCell, gridSelection, scrollTo, setGridSelection, setCurrent]);
  const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newValue, movement) => {
    if ((overlay == null ? void 0 : overlay.cell) !== void 0 && newValue !== void 0 && isEditableGridCell(newValue)) {
      mangledOnCellsEdited([{
        location: overlay.cell,
        value: newValue
      }]);
      window.requestAnimationFrame(() => {
        var _a2;

        (_a2 = gridRef.current) == null ? void 0 : _a2.damage([{
          cell: overlay.cell
        }]);
      });
    }

    focus(true);
    setOverlay(void 0);
    const [movX, movY] = movement;

    if (gridSelection.current !== void 0 && (movX !== 0 || movY !== 0)) {
      const isEditingTrailingRow = gridSelection.current.cell[1] === mangledRows - 1 && newValue !== void 0;
      updateSelectedCell(lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(gridSelection.current.cell[0] + movX, 0, mangledCols.length - 1), lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(gridSelection.current.cell[1] + movY, 0, mangledRows - 1), isEditingTrailingRow, false);
    }

    onFinishedEditing == null ? void 0 : onFinishedEditing(newValue, movement);
  }, [overlay == null ? void 0 : overlay.cell, focus, gridSelection, onFinishedEditing, mangledOnCellsEdited, mangledRows, updateSelectedCell, mangledCols.length]);
  const overlayID = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return `gdg-overlay-${idCounter++}`;
  }, []);
  const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const fn = async () => {
      var _a2, _b2, _c2, _d2, _e2;

      let cancelled = false;

      if (onKeyDownIn !== void 0) {
        onKeyDownIn({ ...event,
          cancel: () => {
            cancelled = true;
          }
        });
      }

      if (cancelled) return;

      const cancel = () => {
        event.stopPropagation();
        event.preventDefault();
      };

      const overlayOpen = overlay !== void 0;
      const {
        altKey,
        shiftKey,
        metaKey,
        ctrlKey,
        key,
        bounds
      } = event;
      const isOSX = browserIsOSX.value;
      const isPrimaryKey = isOSX ? metaKey : ctrlKey;
      const isDeleteKey = key === "Delete" || isOSX && key === "Backspace";
      const vr = visibleRegionRef.current;
      const selectedColumns = gridSelection.columns;
      const selectedRows = gridSelection.rows;

      if (key === "Escape") {
        if (overlayOpen) {
          setOverlay(void 0);
        } else if (keybindings.clear) {
          setGridSelection(emptyGridSelection, false);
          onSelectionCleared == null ? void 0 : onSelectionCleared();
        }

        return;
      } else if (isHotkey("primary+a", event) && keybindings.selectAll) {
        if (!overlayOpen) {
          setGridSelection({
            columns: CompactSelection.empty(),
            rows: CompactSelection.empty(),
            current: {
              cell: (_b2 = (_a2 = gridSelection.current) == null ? void 0 : _a2.cell) != null ? _b2 : [rowMarkerOffset, 0],
              range: {
                x: rowMarkerOffset,
                y: 0,
                width: columnsIn.length,
                height: rows
              },
              rangeStack: []
            }
          }, false);
        } else {
          const el = document.getElementById(overlayID);

          if (el !== null) {
            const s = window.getSelection();
            const r = document.createRange();
            r.selectNodeContents(el);
            s == null ? void 0 : s.removeAllRanges();
            s == null ? void 0 : s.addRange(r);
          }
        }

        cancel();
        return;
      } else if (isHotkey("primary+f", event) && keybindings.search) {
        cancel();
        (_c2 = searchInputRef == null ? void 0 : searchInputRef.current) == null ? void 0 : _c2.focus({
          preventScroll: true
        });
        setShowSearchInner(true);
      }

      function deleteRange(r) {
        var _a3, _b3, _c3, _d3;

        focus();
        const editList = [];

        for (let x = r.x; x < r.x + r.width; x++) {
          for (let y = r.y; y < r.y + r.height; y++) {
            const cellValue = getCellContent([x - rowMarkerOffset, y]);
            if (!cellValue.allowOverlay && cellValue.kind !== GridCellKind.Boolean) continue;
            let newVal = void 0;

            if (cellValue.kind === GridCellKind.Custom) {
              const toDelete = getCellRenderer(cellValue);
              const editor = (_a3 = toDelete == null ? void 0 : toDelete.provideEditor) == null ? void 0 : _a3.call(toDelete, cellValue);

              if ((toDelete == null ? void 0 : toDelete.onDelete) !== void 0) {
                newVal = toDelete.onDelete(cellValue);
              } else if (isObjectEditorCallbackResult(editor)) {
                newVal = (_b3 = editor == null ? void 0 : editor.deletedValue) == null ? void 0 : _b3.call(editor, cellValue);
              }
            } else if (isEditableGridCell(cellValue) && cellValue.allowOverlay || cellValue.kind === GridCellKind.Boolean) {
              const toDelete = getCellRenderer(cellValue);
              newVal = (_c3 = toDelete == null ? void 0 : toDelete.onDelete) == null ? void 0 : _c3.call(toDelete, cellValue);
            }

            if (newVal !== void 0 && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {
              editList.push({
                location: [x, y],
                value: newVal
              });
            }
          }
        }

        mangledOnCellsEdited(editList);
        (_d3 = gridRef.current) == null ? void 0 : _d3.damage(editList.map(x => ({
          cell: x.location
        })));
      }

      if (isDeleteKey) {
        const callbackResult = (_d2 = onDelete == null ? void 0 : onDelete(gridSelection)) != null ? _d2 : true;
        cancel();

        if (callbackResult !== false) {
          const toDelete = callbackResult === true ? gridSelection : callbackResult;

          if (toDelete.current !== void 0) {
            deleteRange(toDelete.current.range);

            for (const r of toDelete.current.rangeStack) {
              deleteRange(r);
            }
          }

          for (const r of toDelete.rows) {
            deleteRange({
              x: rowMarkerOffset,
              y: r,
              width: mangledCols.length - rowMarkerOffset,
              height: 1
            });
          }

          for (const col2 of toDelete.columns) {
            deleteRange({
              x: col2,
              y: 0,
              width: 1,
              height: rows
            });
          }
        }

        return;
      }

      if (gridSelection.current === void 0) return;
      let [col, row] = gridSelection.current.cell;
      let freeMove = false;

      if (keybindings.selectColumn && isHotkey("ctrl+ ", event) && columnSelect !== "none") {
        if (selectedColumns.hasIndex(col)) {
          setSelectedColumns(selectedColumns.remove(col), void 0, true);
        } else {
          if (columnSelect === "single") {
            setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, true);
          } else {
            setSelectedColumns(void 0, col, true);
          }
        }
      } else if (keybindings.selectRow && isHotkey("shift+ ", event) && rowSelect !== "none") {
        if (selectedRows.hasIndex(row)) {
          setSelectedRows(selectedRows.remove(row), void 0, true);
        } else {
          if (rowSelect === "single") {
            setSelectedRows(CompactSelection.fromSingleSelection(row), void 0, true);
          } else {
            setSelectedRows(void 0, row, true);
          }
        }
      } else if ((isHotkey("Enter", event) || isHotkey(" ", event) || isHotkey("shift+Enter", event)) && bounds !== void 0) {
        if (overlayOpen) {
          setOverlay(void 0);

          if (isHotkey("Enter", event)) {
            row++;
          } else if (isHotkey("shift+Enter", event)) {
            row--;
          }
        } else if (row === rows && showTrailingBlankRow) {
          window.setTimeout(() => {
            const customTargetColumn = getCustomNewRowTargetColumn(col);
            void appendRow(customTargetColumn != null ? customTargetColumn : col);
          }, 0);
        } else {
          onCellActivated == null ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
          reselect(bounds, true);
          cancel();
        }
      } else if (keybindings.downFill && isHotkey("primary+_68", event) && gridSelection.current.range.height > 1) {
        fillDown(false);
        cancel();
      } else if (keybindings.rightFill && isHotkey("primary+_82", event) && gridSelection.current.range.width > 1) {
        const editList = [];
        const r = gridSelection.current.range;

        for (let y = 0; y < r.height; y++) {
          const fillRow = y + r.y;
          const fillVal = getMangledCellContent([r.x, fillRow]);
          if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;

          for (let x = 1; x < r.width; x++) {
            const fillCol = x + r.x;
            const target = [fillCol, fillRow];
            editList.push({
              location: target,
              value: { ...fillVal
              }
            });
          }
        }

        mangledOnCellsEdited(editList);
        (_e2 = gridRef.current) == null ? void 0 : _e2.damage(editList.map(c => ({
          cell: c.location
        })));
        cancel();
      } else if (keybindings.pageDown && isHotkey("PageDown", event)) {
        row += Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.pageUp && isHotkey("PageUp", event)) {
        row -= Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.first && isHotkey("primary+Home", event)) {
        setOverlay(void 0);
        row = 0;
        col = 0;
      } else if (keybindings.last && isHotkey("primary+End", event)) {
        setOverlay(void 0);
        row = Number.MAX_SAFE_INTEGER;
        col = Number.MAX_SAFE_INTEGER;
      } else if (keybindings.first && isHotkey("primary+shift+Home", event)) {
        setOverlay(void 0);
        adjustSelection([-2, -2]);
      } else if (keybindings.last && isHotkey("primary+shift+End", event)) {
        setOverlay(void 0);
        adjustSelection([2, 2]);
      } else if (key === "ArrowDown") {
        if (ctrlKey && altKey) {
          return;
        }

        setOverlay(void 0);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, isPrimaryKey && !altKey ? 2 : 1]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }

          if (isPrimaryKey && !altKey) {
            row = rows - 1;
          } else {
            row += 1;
          }
        }
      } else if (key === "ArrowUp" || key === "Home") {
        const asPrimary = key === "Home" || isPrimaryKey;
        setOverlay(void 0);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, asPrimary && !altKey ? -2 : -1]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }

          row += asPrimary && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "ArrowRight" || key === "End") {
        const asPrimary = key === "End" || isPrimaryKey;
        setOverlay(void 0);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([asPrimary && !altKey ? 2 : 1, 0]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }

          col += asPrimary && !altKey ? Number.MAX_SAFE_INTEGER : 1;
        }
      } else if (key === "ArrowLeft") {
        setOverlay(void 0);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([isPrimaryKey && !altKey ? -2 : -1, 0]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }

          col += isPrimaryKey && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "Tab") {
        setOverlay(void 0);

        if (shiftKey) {
          col--;
        } else {
          col++;
        }
      } else if (!metaKey && !ctrlKey && gridSelection.current !== void 0 && key.length === 1 && /[ -~]/g.test(key) && bounds !== void 0 && isReadWriteCell(getCellContent([col - rowMarkerOffset, Math.max(0, row - 1)]))) {
        if ((!lastRowSticky || row !== rows) && (vr.y > row || row > vr.y + vr.height || vr.x > col || col > vr.x + vr.width)) {
          return;
        }

        reselect(bounds, true, key);
        cancel();
      }

      const moved = updateSelectedCell(col, row, false, freeMove);

      if (moved) {
        cancel();
      }
    };

    void fn();
  }, [onKeyDownIn, overlay, gridSelection, keybindings.selectAll, keybindings.search, keybindings.selectColumn, keybindings.selectRow, keybindings.downFill, keybindings.rightFill, keybindings.pageDown, keybindings.pageUp, keybindings.first, keybindings.last, keybindings.clear, columnSelect, rowSelect, getCellContent, rowMarkerOffset, updateSelectedCell, setGridSelection, onSelectionCleared, columnsIn.length, rows, overlayID, focus, mangledOnCellsEdited, getCellRenderer, onDelete, mangledCols.length, setSelectedColumns, setSelectedRows, showTrailingBlankRow, getCustomNewRowTargetColumn, appendRow, onCellActivated, reselect, fillDown, getMangledCellContent, adjustSelection, rangeSelect, lastRowSticky]);
  const onContextMenu = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, preventDefault) => {
    const adjustedCol = args.location[0] - rowMarkerOffset;

    if (args.kind === "header") {
      onHeaderContextMenu == null ? void 0 : onHeaderContextMenu(adjustedCol, { ...args,
        preventDefault
      });
    }

    if (args.kind === groupHeaderKind) {
      if (adjustedCol < 0) {
        return;
      }

      onGroupHeaderContextMenu == null ? void 0 : onGroupHeaderContextMenu(adjustedCol, { ...args,
        preventDefault
      });
    }

    if (args.kind === "cell") {
      const [col, row] = args.location;
      onCellContextMenu == null ? void 0 : onCellContextMenu([adjustedCol, row], { ...args,
        preventDefault
      });

      if (!gridSelectionHasItem(gridSelection, args.location)) {
        updateSelectedCell(col, row, false, false);
      }
    }
  }, [gridSelection, onCellContextMenu, onGroupHeaderContextMenu, onHeaderContextMenu, rowMarkerOffset, updateSelectedCell]);
  const onPasteInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async e => {
    var _a2, _b2, _c2, _d2, _e2, _f, _g;

    if (!keybindings.paste) return;

    function pasteToCell(inner, target2, toPaste) {
      var _a3, _b3;

      if (!isInnerOnlyCell(inner) && isReadWriteCell(inner) && inner.readonly !== true) {
        const coerced = coercePasteValue == null ? void 0 : coercePasteValue(toPaste, inner);

        if (coerced !== void 0 && isEditableGridCell(coerced)) {
          if (coerced.kind !== inner.kind) {
            console.warn("Coercion should not change cell kind.");
          }

          return {
            location: target2,
            value: coerced
          };
        }

        const r = getCellRenderer(inner);
        if (r === void 0) return void 0;

        if (r.kind === GridCellKind.Custom) {
          assert(inner.kind === GridCellKind.Custom);
          const newVal = (_a3 = r.onPaste) == null ? void 0 : _a3.call(r, toPaste, inner);
          if (newVal === void 0) return void 0;
          return {
            location: target2,
            value: { ...inner,
              data: newVal
            }
          };
        } else {
          const newVal = (_b3 = r.onPaste) == null ? void 0 : _b3.call(r, toPaste, inner);
          if (newVal === void 0) return void 0;
          assert(newVal.kind === inner.kind);
          return {
            location: target2,
            value: newVal
          };
        }
      }

      return void 0;
    }

    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const focused = ((_a2 = scrollRef.current) == null ? void 0 : _a2.contains(document.activeElement)) === true || ((_b2 = canvasRef.current) == null ? void 0 : _b2.contains(document.activeElement)) === true;
    let target = (_c2 = gridSelection.current) == null ? void 0 : _c2.cell;

    if (target === void 0 && selectedColumns.length === 1) {
      target = [(_d2 = selectedColumns.first()) != null ? _d2 : 0, 0];
    }

    if (target === void 0 && selectedRows.length === 1) {
      target = [rowMarkerOffset, (_e2 = selectedRows.first()) != null ? _e2 : 0];
    }

    if (focused && target !== void 0) {
      let data;
      let text;
      const textPlain = "text/plain";
      const textHtml = "text/html";

      if (navigator.clipboard.read !== void 0) {
        const clipboardContent = await navigator.clipboard.read();

        for (const item of clipboardContent) {
          if (item.types.includes(textHtml)) {
            const htmlBlob = await item.getType(textHtml);
            const html = await htmlBlob.text();
            const fragment = document.createElement("html");
            fragment.innerHTML = html;
            const el = fragment.querySelector("table");

            if (el !== null) {
              data = decodeHTML(el);
              break;
            }
          }

          if (item.types.includes(textPlain)) {
            text = await (await item.getType(textPlain)).text();
          }
        }
      } else if (navigator.clipboard.readText !== void 0) {
        text = await navigator.clipboard.readText();
      } else if (e !== void 0 && (e == null ? void 0 : e.clipboardData) !== null) {
        if (e.clipboardData.types.includes(textHtml)) {
          const html = e.clipboardData.getData(textHtml);
          const fragment = document.createElement("html");
          fragment.innerHTML = html;
          const el = fragment.querySelector("table");

          if (el !== null) {
            data = decodeHTML(el);
          }
        }

        if (data === void 0 && e.clipboardData.types.includes(textPlain)) {
          text = e.clipboardData.getData(textPlain);
        }
      } else {
        return;
      }

      const [gridCol, gridRow] = target;
      const editList = [];

      do {
        if (onPaste === void 0) {
          const cellData = getMangledCellContent(target);
          const newVal = pasteToCell(cellData, target, (_f = text != null ? text : data == null ? void 0 : data.map(r => r.join("	")).join("	")) != null ? _f : "");

          if (newVal !== void 0) {
            editList.push(newVal);
          }

          break;
        }

        if (data === void 0) {
          if (text === void 0) return;
          data = unquote(text);
        }

        if (onPaste === false || typeof onPaste === "function" && (onPaste == null ? void 0 : onPaste([target[0] - rowMarkerOffset, target[1]], data)) !== true) {
          return;
        }

        for (const [row, dataRow] of data.entries()) {
          if (row + gridRow >= rows) break;

          for (const [col, dataItem] of dataRow.entries()) {
            const index = [col + gridCol, row + gridRow];
            const cellData = getMangledCellContent(index);
            const newVal = pasteToCell(cellData, index, dataItem);

            if (newVal !== void 0) {
              editList.push(newVal);
            }
          }
        }
      } while (false);

      mangledOnCellsEdited(editList);
      (_g = gridRef.current) == null ? void 0 : _g.damage(editList.map(c => ({
        cell: c.location
      })));
    }
  }, [coercePasteValue, getCellRenderer, getMangledCellContent, gridSelection, keybindings.paste, mangledOnCellsEdited, onPaste, rowMarkerOffset, rows]);
  useEventListener("paste", onPasteInternal, window, false, true);
  const onCopy = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (e, ignoreFocus) => {
    var _a2, _b2;

    if (!keybindings.copy) return;
    const focused = ignoreFocus === true || ((_a2 = scrollRef.current) == null ? void 0 : _a2.contains(document.activeElement)) === true || ((_b2 = canvasRef.current) == null ? void 0 : _b2.contains(document.activeElement)) === true;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;

    const copyToClipboardWithHeaders = (cells, columnIndexes) => {
      if (!copyHeaders) {
        copyToClipboard(cells, columnIndexes, e);
      } else {
        const headers = columnIndexes.map(index => ({
          kind: GridCellKind.Text,
          data: columnsIn[index].title,
          displayData: columnsIn[index].title,
          allowOverlay: false
        }));
        copyToClipboard([headers, ...cells], columnIndexes, e);
      }
    };

    if (focused && getCellsForSelection !== void 0) {
      if (gridSelection.current !== void 0) {
        let thunk = getCellsForSelection(gridSelection.current.range, abortControllerRef.current.signal);

        if (typeof thunk !== "object") {
          thunk = await thunk();
        }

        copyToClipboardWithHeaders(thunk, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(gridSelection.current.range.x - rowMarkerOffset, gridSelection.current.range.x + gridSelection.current.range.width - rowMarkerOffset));
      } else if (selectedRows !== void 0 && selectedRows.length > 0) {
        const toCopy = [...selectedRows];
        const cells = toCopy.map(rowIndex => {
          const thunk = getCellsForSelection({
            x: rowMarkerOffset,
            y: rowIndex,
            width: columnsIn.length - rowMarkerOffset,
            height: 1
          }, abortControllerRef.current.signal);

          if (typeof thunk === "object") {
            return thunk[0];
          }

          return thunk().then(v => v[0]);
        });

        if (cells.some(x => x instanceof Promise)) {
          const settled = await Promise.all(cells);
          copyToClipboardWithHeaders(settled, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(columnsIn.length));
        } else {
          copyToClipboardWithHeaders(cells, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(columnsIn.length));
        }
      } else if (selectedColumns.length > 0) {
        const results = [];
        const cols = [];

        for (const col of selectedColumns) {
          let thunk = getCellsForSelection({
            x: col,
            y: 0,
            width: 1,
            height: rows
          }, abortControllerRef.current.signal);

          if (typeof thunk !== "object") {
            thunk = await thunk();
          }

          results.push(thunk);
          cols.push(col - rowMarkerOffset);
        }

        if (results.length === 1) {
          copyToClipboardWithHeaders(results[0], cols);
        } else {
          const toCopy = results.reduce((pv, cv) => pv.map((row, index) => [...row, ...cv[index]]));
          copyToClipboardWithHeaders(toCopy, cols);
        }
      }
    }
  }, [columnsIn, getCellsForSelection, gridSelection, keybindings.copy, rowMarkerOffset, rows, copyHeaders]);
  useEventListener("copy", onCopy, window, false, false);
  const onSearchResultsChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((results, navIndex) => {
    if (results.length === 0 || navIndex === -1) return;
    const [col, row] = results[navIndex];

    if (lastSent.current !== void 0 && lastSent.current[0] === col && lastSent.current[1] === row) {
      return;
    }

    lastSent.current = [col, row];
    updateSelectedCell(col, row, false, false);
  }, [updateSelectedCell]);
  const [outCol, outRow] = (_e = (_d = gridSelectionOuter == null ? void 0 : gridSelectionOuter.current) == null ? void 0 : _d.cell) != null ? _e : [];
  const scrollToRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(scrollTo);
  scrollToRef.current = scrollTo;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    var _a2, _b2, _c2, _d2;

    if (!hasJustScrolled.current && outCol !== void 0 && outRow !== void 0 && (outCol !== ((_b2 = (_a2 = expectedExternalGridSelection.current) == null ? void 0 : _a2.current) == null ? void 0 : _b2.cell[0]) || outRow !== ((_d2 = (_c2 = expectedExternalGridSelection.current) == null ? void 0 : _c2.current) == null ? void 0 : _d2.cell[1]))) {
      scrollToRef.current(outCol, outRow);
    }

    hasJustScrolled.current = false;
  }, [outCol, outRow]);
  const selectionOutOfBounds = gridSelection.current !== void 0 && (gridSelection.current.cell[0] >= columnsIn.length || gridSelection.current.cell[1] >= mangledRows);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (selectionOutOfBounds) {
      setGridSelection(emptyGridSelection, false);
    }
  }, [selectionOutOfBounds, setGridSelection]);
  const disabledRows = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (showTrailingBlankRow === true && (trailingRowOptions == null ? void 0 : trailingRowOptions.tint) === true) {
      return CompactSelection.fromSingleSelection(mangledRows - 1);
    }

    return CompactSelection.empty();
  }, [mangledRows, showTrailingBlankRow, trailingRowOptions == null ? void 0 : trailingRowOptions.tint]);
  const mangledVerticalBorder = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(col => {
    var _a2;

    return typeof verticalBorder === "boolean" ? verticalBorder : (_a2 = verticalBorder == null ? void 0 : verticalBorder(col - rowMarkerOffset)) != null ? _a2 : true;
  }, [rowMarkerOffset, verticalBorder]);
  const renameGroupNode = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (renameGroup === void 0 || canvasRef.current === null) return null;
    const {
      bounds,
      group
    } = renameGroup;
    const canvasBounds = canvasRef.current.getBoundingClientRect();
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GroupRename, {
      bounds,
      group,
      canvasBounds,
      onClose: () => setRenameGroup(void 0),
      onFinish: newVal => {
        setRenameGroup(void 0);
        onGroupHeaderRenamed == null ? void 0 : onGroupHeaderRenamed(group, newVal);
      }
    });
  }, [onGroupHeaderRenamed, renameGroup]);
  const mangledFreezeColumns = Math.min(mangledCols.length, freezeColumns + (hasRowMarkers ? 1 : 0));
  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardedRef, () => ({
    appendRow: col => appendRow(col + rowMarkerOffset),
    updateCells: damageList => {
      var _a2;

      if (rowMarkerOffset !== 0) {
        damageList = damageList.map(x => ({
          cell: [x.cell[0] + rowMarkerOffset, x.cell[1]]
        }));
      }

      return (_a2 = gridRef.current) == null ? void 0 : _a2.damage(damageList);
    },
    getBounds: (col, row) => {
      var _a2;

      return (_a2 = gridRef.current) == null ? void 0 : _a2.getBounds(col + rowMarkerOffset, row);
    },
    focus: () => {
      var _a2;

      return (_a2 = gridRef.current) == null ? void 0 : _a2.focus();
    },
    emit: async e => {
      switch (e) {
        case "delete":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: false,
            key: "Delete",
            keyCode: 46,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;

        case "fill-right":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: true,
            key: "r",
            keyCode: 82,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;

        case "fill-down":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: true,
            key: "d",
            keyCode: 68,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;

        case "copy":
          await onCopy(void 0, true);
          break;

        case "paste":
          await onPasteInternal();
          break;
      }
    },
    scrollTo,
    remeasureColumns: cols => {
      for (const col of cols) {
        void normalSizeColumn(col + rowMarkerOffset, true);
      }
    }
  }), [appendRow, normalSizeColumn, onCopy, onKeyDown, onPasteInternal, rowMarkerOffset, scrollTo]);
  const [selCol, selRow] = currentCell != null ? currentCell : [];
  const onCellFocused = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;

    if (row === -1) {
      if (columnSelect !== "none") {
        setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, false);
        focus();
      }

      return;
    }

    if (selCol === col && selRow === row) return;
    setCurrent({
      cell,
      range: {
        x: col,
        y: row,
        width: 1,
        height: 1
      }
    }, true, false, "keyboard-nav");
    scrollTo(col, row);
  }, [columnSelect, focus, scrollTo, selCol, selRow, setCurrent, setSelectedColumns]);
  const [isFocused, setIsFocused] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const setIsFocusedDebounced = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__(val => {
    setIsFocused(val);
  }, 5));
  const onCanvasFocused = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setIsFocusedDebounced.current(true);

    if (gridSelection.current === void 0 && gridSelection.columns.length === 0 && gridSelection.rows.length === 0 && mouseState === void 0) {
      setCurrent({
        cell: [rowMarkerOffset, cellYOffset],
        range: {
          x: rowMarkerOffset,
          y: cellYOffset,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-select");
    }
  }, [cellYOffset, gridSelection, mouseState, rowMarkerOffset, setCurrent]);
  const onFocusOut = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setIsFocusedDebounced.current(false);
  }, []);
  const [idealWidth, idealHeight] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a2;

    let h;
    const scrollbarWidth = (_a2 = experimental == null ? void 0 : experimental.scrollbarWidthOverride) != null ? _a2 : getScrollBarWidth();
    const rowsCountWithTrailingRow = rows + (showTrailingBlankRow ? 1 : 0);

    if (typeof rowHeight === "number") {
      h = totalHeaderHeight + rowsCountWithTrailingRow * rowHeight;
    } else {
      let avg = 0;
      const toAverage = Math.min(rowsCountWithTrailingRow, 10);

      for (let i = 0; i < toAverage; i++) {
        avg += rowHeight(i);
      }

      avg = Math.floor(avg / toAverage);
      h = totalHeaderHeight + rowsCountWithTrailingRow * avg;
    }

    h += scrollbarWidth;
    const w = mangledCols.reduce((acc, x) => x.width + acc, 0) + scrollbarWidth;
    return [`${Math.min(1e5, w)}px`, `${Math.min(1e5, h)}px`];
  }, [mangledCols, experimental == null ? void 0 : experimental.scrollbarWidthOverride, rowHeight, rows, showTrailingBlankRow, totalHeaderHeight]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThemeContext.Provider, {
    value: mergedTheme
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataEditorContainer, {
    style: makeCSSStyle(mergedTheme),
    className,
    inWidth: width != null ? width : idealWidth,
    inHeight: height != null ? height : idealHeight
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_search_default, {
    fillHandle,
    drawFocusRing: drawFocusRing2,
    experimental,
    fixedShadowX,
    fixedShadowY,
    getRowThemeOverride,
    headerIcons,
    imageWindowLoader,
    initialSize,
    isDraggable,
    onDragLeave,
    onRowMoved,
    overscrollX,
    overscrollY,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    showMinimap,
    smoothScrollX,
    smoothScrollY,
    className,
    enableGroups,
    onCanvasFocused,
    onCanvasBlur: onFocusOut,
    canvasRef,
    onContextMenu,
    theme: mergedTheme,
    cellXOffset,
    cellYOffset,
    accessibilityHeight: visibleRegion.height,
    onDragEnd,
    columns: mangledCols,
    drawCustomCell: drawCell2,
    drawHeader: drawHeader2,
    disabledRows,
    freezeColumns: mangledFreezeColumns,
    lockColumns: rowMarkerOffset,
    firstColAccessible: rowMarkerOffset === 0,
    getCellContent: getMangledCellContent,
    minColumnWidth,
    maxColumnWidth,
    searchInputRef,
    showSearch,
    onSearchClose,
    highlightRegions,
    getCellsForSelection,
    getGroupDetails: mangledGetGroupDetails,
    headerHeight,
    isFocused,
    groupHeaderHeight: enableGroups ? groupHeaderHeight : 0,
    trailingRowType: !showTrailingBlankRow ? "none" : (trailingRowOptions == null ? void 0 : trailingRowOptions.sticky) === true ? "sticky" : "appended",
    onColumnResize,
    onColumnResizeEnd,
    onColumnResizeStart,
    onCellFocused,
    onColumnMoved: onColumnMovedImpl,
    onDragStart: onDragStartImpl,
    onHeaderMenuClick: onHeaderMenuClickInner,
    onItemHovered: onItemHoveredImpl,
    isFilling: (mouseState == null ? void 0 : mouseState.fillHandle) === true,
    onMouseMove: onMouseMoveImpl,
    onKeyDown,
    onKeyUp: onKeyUpIn,
    onMouseDown,
    onMouseUp,
    onDragOverCell,
    onDrop,
    onSearchResultsChanged,
    onVisibleRegionChanged: onVisibleRegionChangedImpl,
    clientSize: [clientSize[0], clientSize[1]],
    rowHeight,
    rows: mangledRows,
    scrollRef,
    selection: gridSelection,
    translateX: visibleRegion.tx,
    translateY: visibleRegion.ty,
    verticalBorder: mangledVerticalBorder,
    gridRef,
    getCellRenderer,
    scrollToEnd
  }), renameGroupNode, overlay !== void 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_overlay_editor_default, { ...overlay,
    validateCell,
    id: overlayID,
    getCellRenderer,
    className: (experimental == null ? void 0 : experimental.isSubGrid) === true ? "click-outside-ignore" : void 0,
    provideEditor,
    imageEditorOverride,
    onFinishEditing,
    markdownDivCreateNode
  })));
};

var DataEditor = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataEditorImpl);


function inflate(input) {
  return { ...input,
    kind: GridCellKind.Custom
  };
}

function useCustomCells(cells) {
  return {
    customRenderers: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => cells.map(inflate), [cells])
  };
}



/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, [80], () => (__webpack_exec__("./node_modules/@storybook/core-client/dist/esm/globals/polyfills.js"), __webpack_exec__("./node_modules/@storybook/core-client/dist/esm/globals/globals.js"), __webpack_exec__("./storybook-init-framework-entry.js"), __webpack_exec__("./node_modules/@storybook/react/dist/esm/client/docs/config-generated-config-entry.js"), __webpack_exec__("./node_modules/@storybook/react/dist/esm/client/preview/config-generated-config-entry.js"), __webpack_exec__("./.storybook/preview.js-generated-config-entry.js"), __webpack_exec__("./generated-stories-entry.cjs")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);
//# sourceMappingURL=main.7e155fc4.iframe.bundle.js.map